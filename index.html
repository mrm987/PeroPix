<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PeroPix</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        :root {
            /* Background - Deep Navy */
            --bg: #0C1219;
            --bg-light: #141C26;
            --bg-lighter: #1C2530;
            /* Accent - Navy Blue */
            --accent: #4A7AB8;
            --accent-hover: #5B98D4;
            --accent-dim: #2D4A6F;
            /* Accent - Gold (CTA, 강조) */
            --accent-gold: #F5B942;
            --accent-gold-hover: #FFD06A;
            --accent-gold-dim: #9A7A35;
            /* Text */
            --text: #FFFFFF;
            --text-dim: #7A8BA0;
            /* Border */
            --border: #243044;
            /* Semantic */
            --success: #4CAF82;
            --error: #E57373;
            --warning: #F5B942;

            /* Spacing System - 일관된 간격 */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 12px;
            --space-lg: 16px;
            --space-xl: 20px;
            --space-2xl: 24px;

            /* Border Radius - 통일 */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 14px;
            --radius-xl: 18px;

            /* Shadow - 깊이감 */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.25);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.3);

            /* Transition */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.2s ease;
        }

        /* Global Scrollbar Styles */
        *::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        *::-webkit-scrollbar-track {
            background: transparent;
        }
        *::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: var(--radius-sm);
        }
        *::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        /* Firefox scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
        }
        
        /* Layout */
        .app {
            display: flex;
            height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width, 540px);
            min-width: 360px;
            max-width: 800px;
            background: var(--bg-light);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
        }

        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.active {
            opacity: 1;
            background: var(--accent-gold-dim);
        }
        
        .sidebar-header {
            padding: var(--space-lg) var(--space-xl);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-light);
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            letter-spacing: -0.02em;
        }
        .logo img {
            width: 32px;
            height: 32px;
            border-radius: var(--radius-sm);
        }

        .settings-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            cursor: pointer;
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-btn:hover {
            background: var(--bg);
            border-color: var(--accent);
            color: var(--text);
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }


        .sidebar-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
        }
        
        /* Sections */
        .section {
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-lg);
            border-bottom: 1px solid var(--border);
        }

        .section:last-child,
        .sidebar-content > .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: var(--space-md);
            padding: var(--space-sm) var(--space-md);
            margin-left: calc(var(--space-md) * -1);
            margin-right: calc(var(--space-md) * -1);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: var(--transition-fast);
            user-select: none;
        }
        .section-title:hover {
            background: var(--bg-lighter);
            color: var(--accent-hover);
        }

        .section-title .collapse-toggle {
            font-size: 0.65rem;
            opacity: 0.6;
            transition: transform var(--transition-fast);
        }

        .section-title:hover .collapse-toggle {
            opacity: 1;
        }
        
        .section-title .section-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: none;
            letter-spacing: 0;
            color: var(--text);
            cursor: pointer;
        }
        
        .section-title .section-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            cursor: pointer;
        }

        .subsection {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .subsection:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .subsection-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .subsection-title .section-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text);
            cursor: pointer;
        }

        .subsection-title .section-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            cursor: pointer;
        }

        /* Form */
        label {
            display: block;
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: var(--space-xs);
            color: var(--text-dim);
        }

        label.prompt-label {
            color: var(--text);
            font-weight: 600;
        }

        input, select, textarea {
            width: 100%;
            padding: var(--space-md) var(--space-md);
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text);
            font-size: 0.875rem;
            margin-bottom: var(--space-md);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }

        input:hover, select:hover, textarea:hover {
            border-color: var(--accent-dim);
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(74, 122, 184, 0.15);
        }

        textarea {
            resize: vertical;
            min-height: 80px;
            line-height: 1.5;
            font-family: inherit;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Range Slider with Fill */
        .range-wrap {
            position: relative;
            width: 100%;
            height: 16px;
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        .range-wrap .range-bg {
            position: absolute;
            left: 0;
            right: 0;
            height: 6px;
            background: #243044;
            border-radius: 3px;
            pointer-events: none;
        }
        .range-wrap .range-fill {
            position: absolute;
            left: 0;
            height: 6px;
            background: #4A7AB8;
            border-radius: 3px;
            pointer-events: none;
            width: 0%;
        }
        .range-wrap input[type="range"] {
            position: relative;
            width: 100%;
            height: 16px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent !important;
            cursor: pointer;
            padding: 0;
            margin: 0;
            border: none;
            z-index: 2;
        }
        .range-wrap input[type="range"]::-webkit-slider-runnable-track {
            background: transparent;
            height: 6px;
        }
        .range-wrap input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4A7AB8;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            margin-top: -5px;
        }
        .range-wrap input[type="range"]::-moz-range-track {
            background: transparent;
            height: 6px;
        }
        .range-wrap input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4A7AB8;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .range-wrap input[type="range"]:focus {
            outline: none;
        }
        /* 래퍼 없는 기존 슬라이더용 */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #243044;
            border-radius: 3px;
            cursor: pointer;
            padding: 0;
            margin: 8px 0;
            border: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4A7AB8;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            margin-top: -5px;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4A7AB8;
            cursor: pointer;
            border: none;
        }
        input[type="range"]:focus {
            outline: none;
        }

        /* Prompt Weight Highlighting */
        .prompt-highlight-container {
            position: relative;
            width: 100%;
            display: flex;
        }

        .prompt-highlight-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: var(--space-md) var(--space-md);
            margin: 0;
            border: 1px solid transparent;
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.5;
            letter-spacing: normal;
            white-space: pre-wrap;
            word-wrap: break-word;
            box-sizing: border-box;
            overflow-wrap: break-word;
            word-break: break-word;
            overflow: hidden;
            pointer-events: none;
            z-index: 1;
            color: var(--text);
            background: var(--bg);
        }

        .prompt-highlight-overlay::-webkit-scrollbar {
            display: none;
        }

        .prompt-highlight-container textarea {
            position: relative;
            z-index: 2;
            width: 100%;
            background: transparent !important;
            color: var(--text) !important;
            caret-color: var(--text);
            margin: 0 !important;
            padding: var(--space-md) var(--space-md);
            border: 1px solid var(--border) !important;
            border-radius: var(--radius-sm) !important;
            font-size: 0.875rem;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.5;
            letter-spacing: normal;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            -webkit-text-fill-color: transparent;
            text-fill-color: transparent;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .prompt-highlight-container textarea::selection {
            background: rgba(74, 122, 184, 0.3);
            -webkit-text-fill-color: var(--text);
            text-fill-color: var(--text);
        }

        /* Character prompt의 overlay는 bg-light 사용 */
        .character-item .prompt-highlight-overlay {
            background: var(--bg-light);
        }

        .prompt-highlight-overlay span {
            border-radius: 3px;
        }

        /* 번역 모드 */
        .translate-mode-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            margin-right: 4px;
        }
        .translate-mode-btn:hover {
            background: var(--bg-light);
            border-color: var(--text-dim);
        }
        .translate-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .prompt-highlight-overlay.translate-mode {
            pointer-events: auto;
            z-index: 3;
        }
        .prompt-highlight-container.translate-mode textarea {
            pointer-events: none;
        }
        .prompt-highlight-overlay.translate-mode span.tag-segment {
            cursor: help;
            transition: background-color 0.15s;
        }
        .prompt-highlight-overlay.translate-mode span.tag-segment:hover {
            outline: 1px solid var(--accent);
            outline-offset: 1px;
        }

        .translate-tooltip {
            position: fixed;
            z-index: 10000;
            background: var(--bg);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.85rem;
            color: var(--text);
            box-shadow: var(--shadow-lg);
            max-width: 300px;
            word-wrap: break-word;
            display: none;
            pointer-events: none;
        }

        .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        
        .size-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .size-preset {
            flex: 1;
        }

        .size-inputs {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .size-inputs input {
            flex: 1;
            min-width: 0;
            text-align: center;
            padding: 10px 8px;
        }

        .size-x {
            color: var(--text-dim);
            font-size: 0.85rem;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: var(--space-xs);
            margin-bottom: var(--space-lg);
            background: var(--bg);
            padding: var(--space-xs);
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
        }

        .tab {
            flex: 1;
            padding: var(--space-md) var(--space-lg);
            background: transparent;
            border: none;
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            font-size: 0.85rem;
            transition: var(--transition-fast);
        }

        .tab:hover:not(.active) {
            background: var(--bg-lighter);
            color: var(--text);
        }

        .tab.active {
            background: var(--accent);
            color: white;
            box-shadow: var(--shadow-sm);
        }
        
        .provider-section { display: none; }
        .provider-section.active { 
            display: block;
            padding-bottom: 16px;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }
        .provider-section .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        /* Checkbox */
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .checkbox-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin: 0;
            accent-color: var(--accent);
        }
        
        .checkbox-row label {
            margin: 0;
            color: var(--text);
            font-size: 0.9rem;
        }
        
        /* Characters */
        .characters-section {
            margin: 12px 0;
        }
        
        .characters-header {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 8px;
            padding: 8px 10px;
            margin: 0 -10px 8px -10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .characters-header:hover {
            background: var(--bg-lighter);
        }

        .characters-header label {
            font-size: 0.85rem;
            flex: 1;
        }

        .characters-header label.prompt-label {
            color: var(--text);
        }
        
        .add-char-btn {
            background: var(--accent);
            border: none;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .add-char-btn:hover {
            background: var(--accent-hover);
        }
        
        .add-char-btn:disabled {
            background: var(--bg-lighter);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .characters-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .character-item {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            transition: var(--transition-fast);
        }

        .character-item:hover {
            border-color: var(--accent-dim);
        }

        .character-item-header {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-xs) 0;
        }

        .character-item .char-num {
            color: var(--accent-gold);
            font-size: 0.75rem;
            font-weight: 700;
            font-family: 'SF Mono', 'Consolas', monospace;
            background: rgba(245, 185, 66, 0.1);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            min-width: 28px;
            text-align: center;
        }
        
        .character-item .prompt-preset-dropdown {
            margin-left: auto;
        }

        .character-item .prompt-preset-btn {
            padding: 2px 6px;
            font-size: 0.7rem;
        }

        .character-item textarea {
            background: var(--bg-light);
            margin-bottom: 0;
            min-height: 50px;
        }

        .character-item .delete-char-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: var(--space-xs) var(--space-sm);
            font-size: 1rem;
            opacity: 0.4;
            transition: var(--transition-fast);
            border-radius: var(--radius-sm);
        }

        .character-item .delete-char-btn:hover {
            opacity: 1;
            color: var(--error);
            background: rgba(229, 115, 115, 0.1);
        }

        .char-enable-toggle {
            width: 14px;
            height: 14px;
            margin: 0 4px 0 0;
            cursor: pointer;
            accent-color: var(--accent);
            vertical-align: middle;
        }

        .character-item.disabled {
            opacity: 0.5;
        }

        .character-item.disabled textarea {
            background: var(--bg-tertiary);
            color: var(--text-dim);
        }

        /* 캐릭터 드래그 핸들 (슬롯 드래그와 동일 스타일) */
        .char-drag {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: grab;
            padding: 2px 4px;
            font-size: 0.9rem;
            line-height: 1;
            border-radius: 4px;
        }

        .char-drag:hover {
            background: var(--bg);
            color: var(--text);
        }

        .char-drag:active {
            cursor: grabbing;
        }

        .character-item.dragging {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            opacity: 0.9;
        }

        .char-placeholder {
            background: var(--bg-lighter);
            border: 2px dashed var(--border);
            border-radius: 6px;
            margin: 3px 0;
        }

        /* Prompt Preset Dropdown */
        .prompt-label-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            padding: 8px 10px;
            margin: 0 -10px 4px -10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .prompt-label-row:hover {
            background: var(--bg-lighter);
        }

        .prompt-label-left {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mode-toggle {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            line-height: 1;
        }

        .mode-toggle:hover {
            border-color: var(--accent);
            background: var(--bg);
        }

        .mode-toggle.furry {
            background: var(--bg);
            border-color: var(--accent);
        }

        /* Collapsible prompts */
        .collapse-toggle {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        .collapse-toggle:hover {
            color: var(--text);
        }
        .collapse-toggle.collapsed {
            transform: rotate(-90deg);
        }
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
        }
        .collapsible-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            margin: 0;
            padding: 0;
        }
        /* Characters 섹션만 드롭다운이 밖으로 나올 수 있도록 */
        #charactersContent:not(.collapsed) {
            overflow: visible;
        }

        /* 설정 적용 시 강조 효과 */
        .setting-highlight {
            animation: settingHighlight 1.5s ease-out;
        }
        @keyframes settingHighlight {
            0% {
                background-color: rgba(74, 222, 128, 0.4);
                box-shadow: 0 0 8px rgba(74, 222, 128, 0.6);
            }
            100% {
                background-color: transparent;
                box-shadow: none;
            }
        }
        /* 섹션 타이틀 강조 */
        .section-title.setting-highlight {
            border-radius: 4px;
        }

        .prompt-preset-dropdown {
            position: relative;
        }
        
        .prompt-preset-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .prompt-preset-btn:hover {
            background: var(--bg-light);
            border-color: var(--text-dim);
        }
        
        .prompt-preset-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: var(--space-xs);
            min-width: 200px;
            max-width: 280px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            z-index: 100;
            overflow: hidden;
        }
        
        .prompt-preset-menu.show {
            display: block;
        }
        
        .prompt-preset-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .prompt-preset-item {
            padding: var(--space-sm) var(--space-md);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: background var(--transition-fast);
        }

        .prompt-preset-item:hover {
            background: var(--bg-lighter);
        }

        .prompt-preset-item:last-child {
            border-bottom: none;
        }

        .prompt-preset-item-name {
            font-size: 0.85rem;
            color: var(--text);
            margin-bottom: var(--space-xs);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .prompt-preset-item-actions {
            display: flex;
            gap: var(--space-xs);
        }
        
        .prompt-preset-item-actions button {
            flex: 1;
            padding: 3px 8px;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            background: var(--bg);
            color: var(--text);
        }
        
        .prompt-preset-item-actions button:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .prompt-preset-item-actions .delete-btn {
            flex: 0;
            padding: 3px 6px;
            color: var(--text-dim);
        }
        
        .prompt-preset-item-actions .delete-btn:hover {
            background: var(--error);
            border-color: var(--error);
            color: white;
        }
        
        .prompt-preset-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
        }
        
        .prompt-preset-save-btn {
            width: 100%;
            padding: 6px 10px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        .prompt-preset-save-btn:hover {
            background: var(--bg);
            border-color: var(--text-dim);
        }
        
        .prompt-preset-empty {
            padding: 12px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        /* Tag Autocomplete Dropdown */
        .tag-autocomplete-dropdown {
            position: fixed;
            display: none;
            min-width: 250px;
            max-width: 450px;
            max-height: 300px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .tag-autocomplete-dropdown.show {
            display: block;
        }

        .tag-autocomplete-item {
            padding: 6px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid var(--border-dim);
            transition: background 0.15s;
        }

        .tag-autocomplete-item:last-child {
            border-bottom: none;
        }

        .tag-autocomplete-item:hover,
        .tag-autocomplete-item.selected {
            background: var(--bg);
        }

        .tag-autocomplete-item-name {
            flex: 1;
            font-size: 0.85rem;
            color: var(--text);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tag-autocomplete-item-count {
            flex-shrink: 0;
            width: 42px;
            font-size: 0.7rem;
            font-family: monospace;
            color: var(--text-dim);
            text-align: right;
        }

        .tag-autocomplete-item-badge {
            flex-shrink: 0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 600;
            text-align: center;
            line-height: 1;
        }

        .tag-autocomplete-item-badge.general {
            background: var(--bg-tertiary);
            color: var(--text-dim);
        }

        .tag-autocomplete-item-badge.artist {
            background: #4a3520;
            color: #f4a261;
        }

        .tag-autocomplete-item-badge.character {
            background: #1f4037;
            color: #70e1a8;
        }

        .tag-autocomplete-item-badge.copyright {
            background: #3d2f5b;
            color: #b794f4;
        }

        .tag-autocomplete-item-badge.meta {
            background: #2d3748;
            color: #90cdf4;
        }

        .tag-autocomplete-empty {
            padding: 12px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        .tag-autocomplete-loading {
            padding: 12px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            margin-right: var(--space-md);
            vertical-align: middle;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            transition: background-color var(--transition-normal), border-color var(--transition-normal);
            border-radius: 24px;
            border: 1px solid var(--border);
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: var(--text-dim);
            transition: transform var(--transition-normal), background-color var(--transition-normal);
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent-gold);
            border-color: var(--accent-gold);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
            background-color: #fff;
        }

        .toggle-switch input:focus + .toggle-slider {
            box-shadow: 0 0 0 2px var(--accent-gold-dim);
        }

        /* 폴더 열기 아이콘 버튼 (작은 크기) */
        .folder-btn {
            padding: 4px 8px !important;
            margin: 0 !important;
            font-size: 0.9rem !important;
            line-height: 1;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
        }
        .folder-btn:hover {
            background: var(--bg-lighter);
        }
        
        /* LoRA */
        .lora-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .lora-header label {
            flex: 1;
            margin-bottom: 0;
        }
        
        .lora-add-btn {
            padding: 4px 10px;
            font-size: 0.8rem;
            background: var(--accent-gold);
            color: var(--bg-dark);
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .lora-add-btn:hover {
            background: var(--accent-gold-hover);
        }
        
        .lora-list {
            max-height: 150px;
            overflow-y: auto;
        }
        
        .lora-slot {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: var(--bg);
            border-radius: 6px;
            margin-bottom: 4px;
        }
        
        .lora-slot select {
            flex: 1;
            min-width: 0;
            padding: 4px 6px;
            font-size: 0.8rem;
        }
        
        .lora-slot input[type="number"] {
            width: 50px;
            padding: 4px 6px;
            margin: 0;
            font-size: 0.8rem;
        }
        
        .lora-slot .lora-remove-btn {
            padding: 2px 6px;
            font-size: 0.75rem;
            background: transparent;
            color: var(--text-dim);
            border: none;
            cursor: pointer;
            opacity: 0.6;
        }
        
        .lora-slot .lora-remove-btn:hover {
            opacity: 1;
            color: #ff6b6b;
        }
        
        .lora-empty {
            color: var(--text-dim);
            font-size: 0.85rem;
            padding: 8px;
            text-align: center;
        }

        /* Vibe Transfer */
        .vibe-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .vibe-item {
            background: var(--bg);
            border-radius: 8px;
            padding: 10px;
        }

        .vibe-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .vibe-item-header img {
            width: 48px;
            height: 48px;
            object-fit: cover;
            border-radius: 6px;
        }

        .vibe-item-header .vibe-info {
            flex: 1;
            font-size: 0.8rem;
            color: var(--text-dim);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .vibe-item-header .remove-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255,100,100,0.2);
            color: var(--error);
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }

        .vibe-item-header .remove-btn:hover {
            background: rgba(255,100,100,0.4);
        }

        .nai-vibe-placeholder {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
        }

        .vibe-cached-badge {
            color: #4ade80;
            font-size: 0.7rem;
            margin-left: 4px;
        }

        .vibe-sliders {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .vibe-slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
        }

        .vibe-slider-row label {
            width: 70px;
            color: var(--text-dim);
        }

        .vibe-slider-row input[type="range"] {
            flex: 1;
        }

        .vibe-slider-row .value {
            width: 35px;
            text-align: right;
            color: var(--text);
        }

        /* Character Reference */
        .char-ref-preview {
            position: relative;
            margin-bottom: 8px;
            text-align: center;
        }

        .char-ref-preview img {
            max-width: 100%;
            max-height: 150px;
            border-radius: 8px;
            object-fit: contain;
        }

        .char-ref-preview .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(0,0,0,0.7);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }

        .char-ref-preview .remove-btn:hover {
            background: rgba(255,100,100,0.8);
        }

        /* Anlas Info - Single line */
        .anlas-info {
            display: flex;
            align-items: center;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: var(--space-sm);
            gap: var(--space-sm);
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: var(--space-sm) var(--space-md);
        }

        .anlas-info .anlas-icon { font-size: 0.8rem; }
        .anlas-info #anlasBalance { font-weight: 600; color: var(--text); }
        .anlas-info .anlas-separator { opacity: 0.3; margin: 0 var(--space-xs); }
        .anlas-info .anlas-cost-label { opacity: 0.7; }
        .anlas-info #anlasCost { color: var(--accent-gold); font-weight: 600; }

        .anlas-refresh {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 0.7rem;
            padding: 0 2px;
            opacity: 0.6;
        }
        .anlas-refresh:hover { opacity: 1; color: var(--text); }

        .free-tag {
            background: #22c55e;
            color: white;
            font-size: 0.75rem;
            font-weight: 700;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 4px;
        }

        /* Button */
        .btn {
            width: 100%;
            padding: var(--space-md) var(--space-lg);
            background: var(--accent);
            border: none;
            border-radius: var(--radius-md);
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
        }

        .btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        .btn:disabled {
            background: var(--bg-lighter);
            color: var(--text-dim);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Queue button - Gold accent */
        #generateBtn {
            background: var(--accent-gold);
            color: var(--bg);
            font-size: 0.95rem;
            padding: var(--space-lg);
        }

        #generateBtn:hover {
            background: var(--accent-gold-hover);
        }

        .btn-secondary {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
        }

        .btn-secondary:hover {
            background: var(--bg-lighter);
            border-color: var(--text-dim);
            transform: none;
            box-shadow: none;
        }

        .btn-success {
            background: #22c55e;
        }
        .btn-success:hover { background: #16a34a; }

        /* Enhance Modal Resolution Buttons */
        .enhance-res-btn {
            flex: 1;
            padding: 8px 12px;
            font-size: 0.85rem;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            transition: var(--transition-fast);
        }
        .enhance-res-btn:hover {
            background: var(--bg);
            border-color: var(--accent);
            color: var(--text);
        }
        .enhance-res-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        .enhance-res-btn.active:hover {
            background: var(--accent-hover);
        }

        /* Inline button row (for vibe buttons, etc.) */
        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .btn-row .btn {
            width: auto;
            margin-top: 0;
            padding: 10px 16px;
        }
        .btn-row .btn-icon {
            padding: 10px 12px;
            flex-shrink: 0;
        }
        
        /* Main Area */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Mode Header (공통) */
        .mode-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            color: var(--text-dim);
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        /* Slots Toolbar */
        .slots-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) var(--space-lg);
            border-bottom: 1px solid var(--border);
            background: var(--bg);
            flex-shrink: 0;
            gap: var(--space-md);
            min-height: 48px;
            box-sizing: border-box;
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
            min-height: 32px;
        }

        .toolbar-label {
            color: var(--text-muted);
            font-size: 0.8rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .add-slot-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .add-slot-btn:hover {
            background: var(--accent-hover);
        }

        /* 슬롯 사이즈 프리셋 */
        .slot-size-presets {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0 4px;
        }

        .slot-size-preset-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: monospace;
            min-width: 50px;
            text-align: center;
            transition: all 0.2s;
        }

        .slot-size-preset-btn:hover {
            background: var(--bg-light);
            border-color: var(--accent-gold);
        }

        .slot-size-preset-btn.active {
            color: var(--accent-gold);
            font-weight: bold;
        }

        .header-btn.icon-only {
            padding: 6px 8px;
            font-size: 1rem;
        }
        
        .header-btn {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            padding: var(--space-sm) var(--space-md);
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-fast);
            white-space: nowrap;
        }

        .header-btn:hover {
            background: var(--bg-light);
            border-color: var(--accent-dim);
            color: var(--text);
        }

        .header-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        /* 검열중 탭 버튼 - 골드 색상 */
        #censorTabProcessing {
            border-color: var(--accent-gold-dim);
            color: var(--accent-gold);
        }
        #censorTabProcessing:hover {
            background: var(--accent-gold-dim);
            border-color: var(--accent-gold);
            color: white;
        }
        #censorTabProcessing.active {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: #1a1a1a;
        }

        .header-btn.icon-only {
            padding: var(--space-sm) var(--space-sm);
            font-size: 1rem;
        }
        
        /* Preset Dropdown */
        .preset-dropdown {
            position: relative;
        }
        
        .preset-btn {
            min-width: 120px;
        }
        
        .preset-btn .preset-name {
            flex: 1;
            text-align: left;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .preset-btn .dropdown-arrow {
            font-size: 0.6rem;
            margin-left: 4px;
        }
        
        .preset-menu {
            display: none;
            position: fixed;
            min-width: 220px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            z-index: 99999;
            overflow: hidden;
        }
        
        .preset-menu.show {
            display: block;
        }
        
        .preset-list {
            max-height: 250px;
            overflow-y: auto;
        }
        
        .preset-item {
            display: flex;
            align-items: center;
            padding: var(--space-sm) var(--space-md);
            cursor: pointer;
            transition: background var(--transition-fast);
            gap: var(--space-sm);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .preset-item:last-child {
            border-bottom: none;
        }

        .preset-item:hover {
            background: var(--bg-lighter);
        }
        
        .preset-item.selected {
            background: var(--accent);
            color: white;
        }
        
        .preset-item .check {
            width: 16px;
            font-size: 0.8rem;
        }
        
        .preset-item .label {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .preset-item .edit-btn,
        .preset-item .delete-btn {
            background: none;
            border: none;
            padding: 2px 4px;
            cursor: pointer;
            opacity: 0.5;
            font-size: 0.85rem;
            border-radius: 4px;
        }
        
        .preset-item .edit-btn:hover,
        .preset-item .delete-btn:hover {
            opacity: 1;
            background: var(--bg);
        }
        
        .preset-item.selected .edit-btn:hover,
        .preset-item.selected .delete-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .preset-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .preset-action-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.85rem;
            cursor: pointer;
            text-align: left;
            transition: all 0.15s;
        }
        
        .preset-action-btn:hover {
            background: var(--bg);
            border-color: var(--text-dim);
        }
        
        .preset-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        /* Output Folder Dropdown */
        .folder-dropdown {
            position: relative;
        }

        .folder-btn {
            min-width: 100px;
        }

        .folder-btn .folder-name {
            flex: 1;
            text-align: left;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .folder-btn .dropdown-arrow {
            font-size: 0.6rem;
            margin-left: 4px;
        }

        .folder-menu {
            display: none;
            position: fixed;
            min-width: 180px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            z-index: 99999;
            overflow: hidden;
        }

        .folder-menu.show {
            display: block;
        }

        .folder-list {
            max-height: 250px;
            overflow-y: auto;
        }

        .folder-item {
            display: flex;
            align-items: center;
            padding: var(--space-sm) var(--space-md);
            cursor: pointer;
            transition: background var(--transition-fast);
            gap: var(--space-sm);
            font-size: 0.85rem;
            color: var(--text);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .folder-item:last-child {
            border-bottom: none;
        }

        .folder-item:hover {
            background: var(--bg-lighter);
        }

        .folder-item.active {
            background: var(--accent);
            color: white;
        }

        .folder-item.root-folder {
            font-weight: 500;
            border-bottom: 1px solid var(--border);
        }

        .folder-item.subfolder {
            padding-left: 24px;
        }

        .folder-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
        }

        .folder-action-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.85rem;
            cursor: pointer;
            text-align: left;
            transition: all 0.15s;
        }

        .folder-action-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .slots-container-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .slots-container-wrapper::before,
        .slots-container-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 40px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .slots-container-wrapper::before {
            left: 0;
            background: linear-gradient(to right, var(--bg) 0%, transparent 100%);
        }
        
        .slots-container-wrapper::after {
            right: 0;
            background: linear-gradient(to left, var(--bg) 0%, transparent 100%);
        }
        
        .slots-container-wrapper.can-scroll-left::before {
            opacity: 1;
        }
        
        .slots-container-wrapper.can-scroll-right::after {
            opacity: 1;
        }
        
        .slots-container {
            height: 100%;
            display: flex;
            gap: 16px;
            padding: 16px;
            overflow-x: auto;
            overflow-y: hidden;
            align-items: stretch;
            user-select: none;
        }
        
        .slot {
            width: var(--slot-width, 280px);
            min-width: 150px;
            max-width: 1200px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            overflow: visible;  /* 리사이즈 핸들이 바깥에 표시되도록 */
            flex-shrink: 0;
            transition: box-shadow 0.2s;
            position: relative;
        }

        /* 슬롯 리사이즈 핸들 (오른쪽만) */
        .slot-resize-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
            right: -8px;
            border-radius: 0 10px 10px 0;
        }

        .slot-resize-handle:hover,
        .slot-resize-handle.active {
            opacity: 1;
            background: var(--accent-gold-dim);
        }

        body.resizing-slot {
            cursor: ew-resize !important;
            user-select: none !important;
        }

        body.resizing-slot * {
            cursor: ew-resize !important;
        }
        
        /* input, textarea는 선택 가능 */
        .slot input, .slot textarea {
            user-select: text;
        }
        
        .slot.dragging {
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            opacity: 0.9;
        }
        
        .slot-placeholder {
            background: var(--bg-lighter);
            border: 2px dashed var(--border);
            border-radius: 10px;
            flex-shrink: 0;
        }
        
        .slot-prompt {
            flex-shrink: 0;
            border-bottom: 1px solid var(--border);
        }
        
        .slot-prompt-header {
            display: flex;
            align-items: center;
            background: var(--bg-lighter);
            padding: 6px 8px;
            gap: 6px;
        }
        
        .slot-number {
            font-size: 0.75rem;
            color: var(--accent-gold);
            font-weight: bold;
            font-family: monospace;
            background: var(--bg);
            padding: 4px 6px;
            border-radius: 4px;
            flex-shrink: 0;
            line-height: 1;
            display: flex;
            align-items: center;
        }
        
        .slot-prompt-header input {
            flex: 1;
            background: transparent;
            border: none;
            padding: 4px;
            margin: 0;
            font-size: 0.85rem;
            color: var(--text);
            min-width: 0;
        }
        
        .slot-prompt-header input::placeholder {
            color: var(--text-dim);
        }
        
        .slot-prompt-header input:focus {
            outline: none;
        }
        
        .slot-drag {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: grab;
            padding: 2px 4px;
            font-size: 0.9rem;
            line-height: 1;
            border-radius: 4px;
        }
        
        .slot-drag:hover {
            background: var(--bg);
            color: var(--text);
        }
        
        .slot-drag:active {
            cursor: grabbing;
        }
        
        .slot-delete {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 1.1rem;
            line-height: 1;
            border-radius: 4px;
        }
        
        .slot-delete:hover {
            background: var(--error);
            color: white;
        }

        .slot-lock {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.9rem;
            line-height: 1;
            border-radius: 4px;
            opacity: 0.5;
        }
        .slot-lock:hover {
            opacity: 1;
        }
        .slot-lock.locked {
            color: var(--warning);
            opacity: 1;
        }
        .slot.locked {
            opacity: 0.6;
        }
        .slot.locked .slot-prompt-header {
            background: rgba(234, 179, 8, 0.15);
        }

        .slot-prompt textarea {
            width: 100%;
            border: none;
            background: var(--bg-light);
            padding: 10px;
            margin: 0;
            min-height: 70px;
            resize: vertical;
            font-size: 0.85rem;
            color: var(--text);
        }

        .slot-prompt textarea:focus {
            outline: none;
        }

        /* 슬롯 내 프롬프트 하이라이팅 동기화 */
        .slot-prompt .prompt-highlight-container textarea {
            padding: 10px;
            font-size: 0.85rem;
            border: none !important;
        }

        .slot-prompt .prompt-highlight-overlay {
            padding: 10px;
            font-size: 0.85rem;
            border: none;
            background: var(--bg-light);
        }

        /* 슬롯 프롬프트 번역 모드 */
        .slot-prompt .prompt-highlight-container.translate-mode textarea {
            pointer-events: none;
        }
        .slot-prompt .prompt-highlight-overlay.translate-mode {
            pointer-events: auto;
            z-index: 3;
        }

        .slot-images {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .slot-image-card {
            position: relative;
            background: var(--bg);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            transition: border-color 0.2s;
            flex-shrink: 0;
        }
        
        .slot-image-card:hover {
            border-color: var(--accent);
        }
        
        .slot-image-card img {
            width: 100%;
            height: auto;
            cursor: pointer;
            display: block;
            user-select: none;
            -webkit-user-drag: none;
        }
        
        .slot-image-card .info {
            padding: 6px 8px;
            font-size: 0.7rem;
        }
        
        .slot-image-card .filename {
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .slot-image-card .seed {
            color: var(--text-dim);
            margin-top: 2px;
        }
        
        .slot-empty {
            color: var(--text-dim);
            font-size: 0.8rem;
            text-align: center;
            padding: 20px 10px;
        }
        
        .progress-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-lighter);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s;
        }
        
        .status-text {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        
        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-dim);
            text-align: center;
        }
        
        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        
        .empty-state p {
            font-size: 1.1rem;
            margin-bottom: 8px;
        }
        
        .empty-state small {
            opacity: 0.7;
        }
        
        /* Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .lightbox.active { display: flex; }
        
        .lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
        }
        
        .lightbox .close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 2.5rem;
            color: white;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .lightbox .close:hover { opacity: 1; }

        /* Drop Overlay */
        .drop-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(59, 130, 246, 0.15);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            border: 4px dashed var(--accent);
            pointer-events: none;
        }
        .drop-overlay.active { display: flex; }
        .drop-overlay-content {
            background: var(--bg-light);
            padding: 40px 60px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        .drop-overlay-content .icon { font-size: 48px; margin-bottom: 16px; }
        .drop-overlay-content h3 { margin: 0 0 8px 0; font-size: 1.5rem; }
        .drop-overlay-content p { margin: 0; color: var(--text-dim); }

        /* Drop Confirm Modal */
        .drop-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .drop-modal.active { display: flex; }
        .drop-modal-content {
            background: var(--bg-light);
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
        }
        .drop-modal-content h3 { margin: 0 0 16px 0; }
        .drop-modal-content .preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        .drop-modal-content .metadata {
            background: var(--bg);
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            margin-bottom: 16px;
            max-height: 200px;
            overflow-y: auto;
        }
        .drop-modal-content .metadata div { margin-bottom: 4px; }
        .drop-modal-content .buttons { display: flex; gap: 12px; justify-content: flex-end; }
        .drop-modal-content .checkbox-row { display: flex; align-items: center; justify-content: center; gap: 6px; margin-top: 16px; color: var(--text-dim); font-size: 13px; cursor: pointer; }
        .drop-modal-content .checkbox-row input { margin: 0; }
        .drop-modal-content .buttons .btn {
            width: auto;
            flex: 1;
            padding: 10px 16px;
        }

        /* Drop Modal Buttons - Multi-row layout */
        #dropModalButtons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            margin-top: 16px;
        }
        #dropModalButtons .btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }
        #dropModalButtons .btn-row .btn {
            flex: 1;
            min-width: 0;
            padding: 12px 8px;
            font-size: 13px;
            white-space: nowrap;
        }
        #dropModalButtons .btn-row-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 4px;
            width: 100%;
        }
        #dropModalButtons .btn-row-actions .btn {
            flex: 0 1 auto;
            min-width: 100px;
            padding: 12px 20px;
        }

        /* Mask Editor Modal */
        .mask-editor-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .mask-editor-modal.active { display: flex; }
        .mask-editor-container {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 20px;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .mask-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .mask-editor-header h3 { margin: 0; }
        .mask-editor-canvas-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
        }
        .mask-editor-canvas-wrapper canvas {
            max-width: 100%;
            max-height: 70vh;
        }
        #maskEditorMaskCanvas {
            position: absolute;
            top: 0; left: 0;
            opacity: 0.5;
            pointer-events: none;
        }
        .mask-editor-toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .mask-editor-toolbar .tool-group {
            display: flex;
            gap: 4px;
            background: var(--bg);
            padding: 4px;
            border-radius: 8px;
        }
        .mask-editor-toolbar .tool-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
        }
        .mask-editor-toolbar .tool-btn:hover { background: var(--border); }
        .mask-editor-toolbar .tool-btn.active { background: var(--primary); color: white; }
        .mask-editor-toolbar .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .mask-editor-toolbar .slider-group label {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        .mask-editor-toolbar .slider-group input[type="range"] {
            width: 100px;
        }
        .mask-editor-footer {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        .mask-editor-footer .btn { padding: 10px 20px; }

        /* Censor Mode Container - New Design */
        .censor-container {
            position: relative;
            display: flex;
            flex-direction: column;
            flex: 1 1 0;
            min-height: 0;
            background: var(--bg);
        }
        
        /* 썸네일 가로 슬라이드 */
        .censor-thumbnails-wrapper {
            background: var(--bg-light);
            border-bottom: 1px solid var(--border);
            padding: 16px;
            overflow: hidden;
        }
        .censor-thumbnails {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 8px 0;
            scroll-behavior: smooth;
        }
        .censor-thumbnail {
            position: relative;
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .censor-thumbnail:hover { border-color: var(--text-dim); }
        .censor-thumbnail.active {
            border-width: 3px;
            border-color: var(--accent-gold);
        }
        .censor-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        /* 썸네일 삭제 버튼 (검열 전 탭에서만) */
        .censor-thumbnail .thumb-delete-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            color: #fff;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
        }
        .censor-thumbnail:hover .thumb-delete-btn {
            opacity: 1;
        }
        .censor-thumbnail .thumb-delete-btn:hover {
            background: var(--error);
        }
        /* 추가 버튼 (썸네일 리스트 끝) */
        .censor-add-btn {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            border-radius: 6px;
            border: 2px dashed var(--border);
            background: var(--bg-lighter);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.2s;
            color: var(--text-dim);
        }
        .censor-add-btn:hover {
            border-color: var(--accent-gold);
            background: rgba(245, 185, 66, 0.1);
            color: var(--accent-gold);
        }
        .censor-add-btn .add-icon {
            font-size: 24px;
            line-height: 1;
        }
        .censor-add-btn .add-text {
            font-size: 10px;
        }
        .censor-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            color: var(--text-dim);
            font-size: 0.9rem;
            padding: 20px;
        }
        
        /* 큰 프리뷰 영역 */
        /* 메인 영역: 프리뷰 + 우측 패널 */
        .censor-main-area {
            flex: 1 1 0;
            display: flex;
            flex-direction: row;
            overflow: hidden;
            min-height: 0;
            align-items: stretch;  /* 자식들이 전체 높이 차지 */
        }

        .censor-preview-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 16px;
            overflow: visible;  /* 회전 핸들이 밖으로 나갈 수 있도록 */
            background: var(--bg);
            position: relative;
            transition: background 0.3s ease;
        }
        /* 검열중 탭일 때 배경 구분 - 골드 강조 */
        .censor-preview-area.processing {
            background: color-mix(in srgb, var(--bg) 75%, var(--accent-gold-dim) 25%);
            border: 1px solid var(--accent-gold-dim);
        }

        /* 우측 사이드 패널 */
        .censor-side-panel {
            width: 200px;
            flex-shrink: 0;
            background: var(--bg-light);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            /* flex row 안에서 align-items: stretch가 기본이므로 height 자동 */
        }
        .censor-side-panel-content {
            flex: 1 1 0;  /* grow, shrink, basis=0으로 남은 공간 채움 */
            overflow-y: auto;
            overflow-x: hidden;
        }
        .censor-side-section {
            padding: 12px;
            border-bottom: 1px solid var(--border);
        }
        .censor-side-section:last-child {
            border-bottom: none;
        }
        .side-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-dim);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* 모델 선택 */
        .censor-side-model select {
            width: 100%;
            height: 32px;
            padding: 0 8px;
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            font-size: 0.85rem;
        }

        /* 감지 대상 - 세로 리스트 */
        .censor-side-targets .censor-targets {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 252px;
            overflow-y: auto;
        }
        .censor-side-targets .censor-target-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 8px;
            height: 30px;
            background: var(--bg);
            border-radius: 4px;
            border: 1px solid var(--border);
            font-size: 0.8rem;
            box-sizing: border-box;
        }
        .censor-side-targets .censor-target-item input[type="checkbox"] {
            width: 14px;
            height: 14px;
            margin: 0;
            flex-shrink: 0;
        }
        .censor-side-targets .censor-target-item label {
            flex: 1;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .censor-side-targets .censor-target-item .censor-conf-input {
            width: 50px;
            height: 22px;
            padding: 0 4px;
            font-size: 0.75rem;
            text-align: center;
            border: 1px solid var(--border);
            border-radius: 3px;
            background: var(--bg);
            color: var(--text);
            flex-shrink: 0;
            box-sizing: border-box;
            position: relative;
            top: 1px;
        }
        .censor-side-targets .censor-target-item .censor-conf-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* 검열 설정 */
        .censor-side-settings .side-setting-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 10px;
        }
        .censor-side-settings .side-setting-row:last-child {
            margin-bottom: 0;
        }
        .censor-side-settings .side-setting-row label {
            font-size: 0.75rem;
            color: var(--text-dim);
        }
        .censor-side-settings .side-setting-row label span {
            color: var(--primary);
            font-weight: 500;
        }
        .censor-side-settings select {
            width: 100%;
            height: 28px;
            padding: 0 8px;
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            font-size: 0.8rem;
        }
        /* 도구 버튼 */
        .side-tools-grid {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .side-tool-btn {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            text-align: left;
            transition: all 0.15s;
        }
        .side-tool-btn:hover {
            border-color: var(--primary);
            background: var(--bg-light);
        }
        .side-tool-btn.active {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
        }

        /* 단축키 가이드 */
        .side-shortcuts-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .shortcut-row {
            font-size: 0.75rem;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .shortcut-row kbd {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 1px 4px;
            font-size: 0.7rem;
            font-family: monospace;
        }

        /* 액션 버튼 영역 - 항상 하단에 고정 (sidebar-footer와 동일) */
        .censor-side-actions {
            flex-shrink: 0;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-top: 1px solid var(--border);
            background: var(--bg-light);
        }
        .censor-side-actions .btn {
            width: 100%;
            padding: 10px 12px;
            font-size: 0.85rem;
            border-radius: 6px;
        }
        .censor-side-actions .btn-secondary {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
        }
        .censor-side-actions .btn-secondary:hover {
            background: var(--bg-light);
        }
        .censor-preview-container {
            position: relative;
            display: inline-block;
            overflow: visible;  /* 회전 핸들이 밖으로 나갈 수 있도록 */
        }
        .censor-preview-container canvas {
            display: block;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .censor-preview-hint {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            color: rgba(255, 255, 255, 0.9);
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 0.9rem;
            z-index: 100;
            pointer-events: none;
            white-space: nowrap;
        }
        .censor-preview-hint strong {
            color: var(--accent-gold);
        }
        #censorPreviewCanvas {
            position: relative;
        }
        #censorOverlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            cursor: default;
            z-index: 10;
        }
        .censor-preview-empty {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            text-align: center;
            padding: 40px;
            pointer-events: none;
        }
        .censor-preview-empty .icon { font-size: 3rem; margin-bottom: 12px; opacity: 0.5; }
        .censor-preview-empty p { font-size: 1rem; }
        
        /* 드롭존 스타일 (프리뷰 영역 내부) */
        .censor-dropzone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            border: 2px dashed var(--border);
            border-radius: var(--radius-md);
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-normal);
            background: var(--bg-lighter);
            z-index: 10;
        }
        .censor-dropzone:hover,
        .censor-dropzone.drag-over {
            border-color: var(--accent-gold);
            background: rgba(245, 185, 66, 0.1);
        }
        .censor-dropzone .dropzone-content {
            pointer-events: none;
        }
        .censor-dropzone .dropzone-icon {
            font-size: 3rem;
            margin-bottom: 12px;
            opacity: 0.7;
        }
        .censor-dropzone p {
            color: var(--text);
            font-size: 1rem;
            margin-bottom: 4px;
        }
        .censor-dropzone small {
            color: var(--text-dim);
            font-size: 0.85rem;
        }
        
        /* 드롭 오버레이 (전체 영역 드래그 시) */
        .censor-container.drag-over::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(245, 185, 66, 0.1);
            border: 3px dashed var(--accent-gold);
            border-radius: var(--radius-md);
            z-index: 1000;
            pointer-events: none;
        }
        .censor-container.drag-over::after {
            content: '이미지를 여기에 드롭하세요';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: var(--accent-gold);
            padding: 16px 32px;
            border-radius: 8px;
            font-size: 1.1rem;
            z-index: 1001;
            pointer-events: none;
        }
        
        /* 스캔 로딩 인디케이터 */
        .censor-scan-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 15;
            background: rgba(0, 0, 0, 0.75);
            padding: 16px 24px;
            border-radius: 8px;
        }
        .censor-scan-loading.active { display: flex; }
        .scan-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid var(--text-dim);
            border-top-color: var(--accent-gold);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* 이미지 네비게이션 화살표 */
        .censor-nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: none; /* 초기에는 숨김 */
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.2s ease;
            backdrop-filter: blur(8px);
        }
        .censor-nav-arrow:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.7);
            transform: translateY(-50%) scale(1.1);
        }
        .censor-nav-arrow:active {
            transform: translateY(-50%) scale(0.95);
        }
        .censor-nav-arrow:disabled {
            opacity: 0.2;
            cursor: not-allowed;
        }
        .censor-nav-left {
            left: 24px;
        }
        .censor-nav-right {
            right: 24px;
        }

        /* 이미지 번호 표시 */
        .censor-image-counter {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 16px;
            border-radius: 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            font-weight: 500;
            backdrop-filter: blur(8px);
            pointer-events: none;
            user-select: none;
            display: none; /* 초기에는 숨김 */
        }

        /* 단축키 안내 */
        .censor-shortcuts-guide {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            align-items: center;
            padding: 8px 0;
            color: var(--text-dim);
            font-size: 0.9rem;
        }
        .shortcut-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .censor-shortcuts-guide kbd {
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            color: var(--text);
        }
        
        /* 하단 옵션 패널 - 고정 높이 */
        .censor-options-panel {
            background: var(--bg-light);
            border-top: 1px solid var(--border);
            padding: 0;
            height: 150px;
            flex-shrink: 0;
            display: flex;
            align-items: stretch;
        }
        .censor-options-before, .censor-options-processing, .censor-options-after {
            display: flex;
            align-items: stretch;
            width: 100%;
            height: 100%;
        }
        
        /* 좌측 컨텐츠 영역 */
        .censor-panel-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 16px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        /* 구분선 */
        .censor-panel-divider {
            width: 1px;
            background: var(--border);
            flex-shrink: 0;
        }
        
        /* 우측 액션 영역 (고정) */
        .censor-panel-right {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            padding: 12px 20px;
            min-width: 160px;
        }
        .censor-panel-right .btn-lg {
            width: 100%;
            padding: 12px 16px;
            font-size: 0.95rem;
            font-weight: 500;
        }
        
        /* 검열 전 탭 - 모델 선택 행 */
        .censor-model-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .censor-model-row > label,
        .censor-model-row select {
            font-size: 0.85rem;
            height: 32px;
            line-height: 32px;
            box-sizing: border-box;
        }
        .censor-model-row > label {
            color: var(--text-dim);
            white-space: nowrap;
            min-width: 60px;
        }
        .censor-model-row select {
            padding: 0 10px;
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            min-width: 180px;
        }
        
        /* 검열 전 탭 - 감지 대상 행 */
        .censor-targets-row {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            flex: 1;
        }
        .censor-targets-row > label {
            font-size: 0.85rem;
            color: var(--text-dim);
            white-space: nowrap;
            min-width: 60px;
            height: 28px;
            line-height: 28px;
        }
        
        .censor-target-loading {
            color: var(--text-dim);
            font-size: 0.85rem;
            font-style: italic;
        }
        
        /* 검열 방식 선택 */
        .censor-method-select {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 6px;
            width: 100%;
        }
        .censor-method-select label {
            font-size: 0.8rem;
            color: var(--text-dim);
            white-space: nowrap;
            height: 16px;
            line-height: 16px;
        }
        .censor-method-select select {
            height: 32px;
            padding: 0 10px;
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            width: 100%;
            line-height: 30px;
        }

        /* 이미지 네비게이션 */
        .censor-nav-info {
            display: flex;
            align-items: center;
            gap: 10px;
            height: 32px;
        }
        .censor-nav-info .nav-label,
        .nav-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            white-space: nowrap;
            height: 32px;
            line-height: 32px;
        }
        .censor-nav-info .nav-buttons {
            display: flex;
            align-items: center;
            gap: 0;
            height: 32px;
        }
        .censor-nav-info .nav-btn,
        .nav-btn {
            height: 32px;
            padding: 0 12px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            line-height: 30px;
            transition: all 0.15s;
        }
        .censor-nav-info .nav-btn:hover,
        .nav-btn:hover {
            border-color: var(--primary);
            background: var(--bg-light);
        }
        .censor-nav-info .nav-btn:disabled,
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .nav-progress {
            font-size: 0.9rem;
            color: var(--text);
            height: 32px;
            line-height: 32px;
            min-width: 50px;
            text-align: center;
            font-family: monospace;
        }
        
        /* 검열중 탭 - 도구 버튼 */
        .censor-proc-tools {
            display: flex;
            gap: 6px;
            height: 32px;
        }
        .censor-proc-tools .tool-btn {
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            height: 32px;
            line-height: 18px;
        }
        .censor-proc-tools .tool-btn:hover {
            border-color: var(--primary);
        }
        .censor-proc-tools .tool-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        /* 검열중 탭 - 방식 선택 */
        .censor-proc-method {
            display: flex;
            align-items: center;
            gap: 10px;
            height: 32px;
        }
        .censor-proc-method .method-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            white-space: nowrap;
            height: 32px;
            line-height: 32px;
        }
        .censor-proc-method select {
            height: 32px;
            padding: 0 10px;
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            line-height: 32px;
            vertical-align: middle;
        }
        
        /* 검열중 탭 - 팁 */
        .censor-proc-tip {
            color: var(--text-dim);
            font-size: 0.8rem;
            height: 32px;
            line-height: 32px;
        }
        
        /* 검열 후 탭 - 액션 (deprecated) */
        .censor-after-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* 편집 모달 (더 이상 사용 안함 - 검열후 탭에서 직접 편집) */
        .censor-edit-modal {
            display: none !important;
        }
        .censor-edit-modal.show {
            display: none !important;
        }
        .censor-edit-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--bg-light);
            border-bottom: 1px solid var(--border);
        }
        .censor-edit-modal-header h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--text);
        }
        .censor-edit-modal-close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 4px 8px;
        }
        .censor-edit-modal-close:hover {
            color: var(--text);
        }
        .censor-edit-modal-body {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
        }
        .censor-edit-modal-canvas-container {
            position: relative;
            display: inline-block;
        }
        .censor-edit-modal-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--bg-light);
            border-top: 1px solid var(--border);
            gap: 16px;
        }
        .censor-edit-modal-tools {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .censor-edit-modal-tools .tool-btn {
            padding: 8px 14px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .censor-edit-modal-tools .tool-btn:hover {
            border-color: var(--primary);
        }
        .censor-edit-modal-tools .tool-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .censor-edit-modal-actions {
            display: flex;
            gap: 8px;
        }
        
        /* 감지 박스 스타일 */
        .censor-box {
            position: absolute;
            border: 2px dashed rgba(255, 0, 0, 0.8);
            background: rgba(255, 0, 0, 0.1);
            cursor: move;
        }
        .censor-box.selected {
            border: 2px solid var(--primary);
            background: rgba(0, 122, 255, 0.1);
        }
        .censor-box .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border: 1px solid var(--primary);
        }
        .censor-box .resize-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .censor-box .resize-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .censor-box .resize-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .censor-box .resize-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }

        /* Censor Quick Editor Modal */
        .censor-editor-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .censor-editor-modal.active { display: flex; }
        .censor-editor-container {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 20px;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .censor-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .censor-editor-header .header-left,
        .censor-editor-header .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .censor-editor-header h3 { margin: 0; }
        .censor-editor-header .image-counter {
            font-size: 0.9rem;
            color: var(--text-dim);
            padding: 4px 12px;
            background: var(--bg);
            border-radius: 4px;
        }
        .censor-editor-header .nav-btn {
            padding: 8px 16px;
            border: none;
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
        }
        .censor-editor-header .nav-btn:hover { background: var(--border); }
        .censor-editor-toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .censor-editor-toolbar .tool-group {
            display: flex;
            gap: 4px;
            background: var(--bg);
            padding: 4px;
            border-radius: 8px;
        }
        .censor-editor-toolbar .tool-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .censor-editor-toolbar .tool-btn:hover { background: var(--border); }
        .censor-editor-toolbar .tool-btn.active { background: var(--primary); color: white; }
        .censor-editor-toolbar .tool-btn.fill-btn {
            width: 36px;
            padding: 8px;
            text-align: center;
        }
        .censor-editor-toolbar .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .censor-editor-toolbar .slider-group label {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        .censor-editor-toolbar .slider-group input[type="range"] {
            width: 100px;
        }
        .censor-editor-canvas-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
        }
        .censor-editor-canvas-wrapper canvas {
            max-width: 100%;
            max-height: 70vh;
        }
        .censor-editor-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .censor-editor-footer .footer-left,
        .censor-editor-footer .footer-right {
            display: flex;
            gap: 8px;
        }
        .censor-editor-footer .btn { padding: 10px 16px; }
        .btn-warning {
            background: #FF9800 !important;
            color: white !important;
        }
        .btn-warning:hover {
            background: #F57C00 !important;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: var(--bg);
            border-radius: var(--radius-lg);
            padding: var(--space-xs);
            gap: var(--space-xs);
            border: 1px solid var(--border);
        }
        .mode-btn {
            padding: var(--space-md) var(--space-xl);
            border: none;
            background: transparent;
            color: var(--text-dim);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        .mode-btn:hover:not(.active) {
            color: var(--text);
            background: var(--bg-lighter);
        }
        .mode-btn.active {
            background: var(--accent);
            color: white;
            box-shadow: var(--shadow-md);
        }

        /* Gallery */
        .gallery-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            overflow: hidden;
        }
        /* Gallery Toolbar */
        .gallery-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-sm) var(--space-lg);
            border-bottom: 1px solid var(--border);
            background: var(--bg);
            flex-shrink: 0;
            gap: var(--space-md);
        }

        /* Gallery Subfolders Row */
        .gallery-subfolders {
            display: flex;
            gap: var(--space-sm);
            flex-wrap: wrap;
        }

        .folder-separator {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 4px;
            align-self: center;
        }
        .folder-separator.double {
            width: 4px;
            background: linear-gradient(90deg, var(--border) 0%, var(--border) 40%, transparent 40%, transparent 60%, var(--border) 60%, var(--border) 100%);
            margin: 0 8px;
        }
        .folder-tab.vibe-folder {
            background: var(--bg-light);
            border-color: var(--accent-gold);
        }
        .folder-tab.vibe-folder:hover {
            background: var(--bg-lighter);
        }
        .folder-tab.vibe-folder.active {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: black;
        }

        .folder-tab {
            padding: 6px 12px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .folder-tab:hover {
            background: var(--bg-lighter);
        }
        .folder-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        .folder-tab.root-folder {
            font-weight: 500;
        }
        .folder-tab.drag-over {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: black;
        }

        .add-folder-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }
        .add-folder-btn:hover {
            background: var(--accent-hover);
        }
        .gallery-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
        }
        .gallery-folder-btn {
            padding: 6px 10px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }
        .gallery-folder-btn:hover {
            background: var(--bg-lighter);
            border-color: var(--accent-gold);
        }
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 20px;
            width: 100%;
            align-items: start;
            align-content: start;
            padding-bottom: 8px;
        }
        .gallery-item {
            background: var(--bg-light);
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            overflow: hidden;
            transition: transform var(--transition-normal), box-shadow var(--transition-normal), border-color var(--transition-normal);
            cursor: pointer;
            height: fit-content;
            position: relative;
            max-width: 520px;
        }
        .gallery-item:hover {
            transform: translateY(-2px);
            z-index: 1;
            box-shadow: var(--shadow-lg);
            border-color: var(--accent-dim);
        }
        .gallery-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .gallery-item img {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            display: block;
        }
        .gallery-item-info {
            padding: 12px;
        }
        .gallery-item-info .filename-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }
        .gallery-item-info .filename {
            font-size: 0.85rem;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }
        .gallery-item-info .filename-input {
            flex: 1;
            min-width: 0;
            font-size: 0.85rem;
            padding: 2px 6px;
            border: 1px solid var(--accent-gold);
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
        }
        .gallery-item-info .rename-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .gallery-item-info .rename-btn:hover {
            opacity: 1;
        }
        .gallery-item-info .seed {
            font-size: 0.75rem;
            color: var(--text-dim);
        }
        .gallery-item-actions {
            display: flex;
            gap: 8px;
            padding: 8px 12px 12px;
        }
        .gallery-item-actions button {
            flex: 1;
            padding: 6px 8px;
            font-size: 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
        }
        .gallery-item-actions button:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }
        .gallery-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            min-height: 300px;
            color: var(--text-dim);
            text-align: center;
        }
        .gallery-empty .icon { font-size: 64px; margin-bottom: 16px; opacity: 0.5; }
        .gallery-empty p { margin: 0 0 8px 0; font-size: 1.1rem; }
        .gallery-empty small { opacity: 0.7; }

        /* Slot image save button */
        .slot-image-card .save-gallery-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 14px;
        }
        .slot-image-card:hover .save-gallery-btn { opacity: 1; }
        .slot-image-card .save-gallery-btn:hover { background: rgba(0,0,0,0.9); opacity: 1; }
        .slot-image-card .save-gallery-btn.saved { color: gold; opacity: 1; }

        /* Info row layout */
        .slot-image-card .info-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .slot-image-card .info-row .filename {
            flex: 1;
            min-width: 0;
        }

        /* Load settings button */
        .slot-image-card .load-settings-btn,
        .slot-image-card .inpaint-btn,
        .slot-image-card .enhance-btn,
        .slot-image-card .clear-card-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        .slot-image-card .load-settings-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .slot-image-card .inpaint-btn:hover {
            background: #9b59b6;
            color: white;
        }
        .slot-image-card .enhance-btn:hover {
            background: #e67e22;
            color: white;
        }
        .slot-image-card .clear-card-btn:hover {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }
        .slot-image-card .delete-file-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        .slot-image-card .delete-file-btn:hover {
            background: #c0392b;
            color: white;
            border-color: #c0392b;
        }

        /* Settings Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 900;
            justify-content: center;
            align-items: center;
        }
        
        .modal.active { display: flex; }
        
        .modal-content {
            background: var(--bg-light);
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-header h2 {
            font-size: 1.25rem;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .input-group {
            margin-bottom: 16px;
        }
        
        .input-group label {
            margin-bottom: 6px;
        }
        
        .input-group small {
            display: block;
            margin-top: -8px;
            margin-bottom: 12px;
            color: var(--text-dim);
            font-size: 0.8rem;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .status-badge.success {
            background: rgba(34, 197, 94, 0.2);
            color: var(--success);
        }
        
        .status-badge.warning {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }
        
        /* Local Environment */
        .local-env-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border-radius: 6px;
            margin-top: 6px;
        }
        
        .local-env-status .status-icon {
            font-size: 1.2rem;
        }
        
        .local-env-status.installed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }
        
        .local-env-status.not-installed {
            background: rgba(245, 158, 11, 0.15);
            color: var(--warning);
        }
        
        .local-env-status.installing {
            background: rgba(111, 41, 222, 0.15);
            color: var(--accent);
        }
        
        .local-env-status.error {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }
        
        .local-env-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }
        
        .local-env-progress-bar {
            flex: 1;
            height: 8px;
            background: var(--bg-lighter);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .local-env-progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .local-env-progress-text {
            font-size: 0.8rem;
            color: var(--text-dim);
            min-width: 40px;
        }
        
        #localEnvActions .btn {
            margin-right: 8px;
        }
        
        #localEnvActions .btn-danger {
            background: rgba(239, 68, 68, 0.2);
            color: var(--error);
        }
        
        #localEnvActions .btn-danger:hover {
            background: rgba(239, 68, 68, 0.3);
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            padding: 12px 24px;
            border-radius: 8px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1100;
        }
        
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .toast.success { border-color: var(--success); }
        .toast.error { border-color: var(--error); }
        .toast.warning { border-color: var(--warning); }
    </style>
</head>
<body>
    <div class="app">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="logo"><img src="assets/icon.png" alt="" style="width: 42px; height: 42px;"> PeroPix</div>
                <button class="settings-btn" onclick="openSettings()">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                </button>
            </div>
            
            <div class="sidebar-content">
                <!-- Provider Tabs -->
                <div class="section">
                    <div class="tabs">
                        <div class="tab active" data-provider="nai">NAI</div>
                        <div class="tab" data-provider="local">Local</div>
                    </div>
                </div>
                
                <!-- Prompts -->
                <div class="section">
                    <div class="prompt-label-row">
                        <div class="prompt-label-left">
                            <button type="button" class="collapse-toggle" data-target="basePromptContent" title="접기/펼치기">▼</button>
                            <button type="button" id="modeToggle" class="mode-toggle" title="아니메 모드">🌸</button>
                            <label for="basePrompt" class="prompt-label">Base Prompt</label>
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <button type="button" class="translate-mode-btn" onclick="toggleTranslateMode()" title="번역 모드 (태그에 호버하면 번역 표시)">🌐</button>
                            <div class="prompt-preset-dropdown" data-category="base">
                                <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">🔖 ▼</button>
                                <div class="prompt-preset-menu">
                                    <div class="prompt-preset-list"></div>
                                    <div class="prompt-preset-actions">
                                        <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="basePromptContent" class="collapsible-content">
                        <textarea id="basePrompt" placeholder="1girl, solo, masterpiece..."></textarea>
                    </div>

                    <!-- Characters -->
                    <div class="characters-section">
                        <div class="characters-header">
                            <button type="button" class="collapse-toggle" data-target="charactersContent" title="접기/펼치기">▼</button>
                            <label class="prompt-label">Characters</label>
                            <button type="button" class="add-char-btn" id="addCharBtn" title="캐릭터 추가">+</button>
                        </div>
                        <div id="charactersContent" class="collapsible-content">
                            <div class="characters-list" id="charactersList">
                                <!-- 캐릭터들이 여기에 추가됨 -->
                            </div>
                        </div>
                    </div>

                    <div class="prompt-label-row">
                        <div class="prompt-label-left">
                            <button type="button" class="collapse-toggle" data-target="negativePromptContent" title="접기/펼치기">▼</button>
                            <label for="negativePrompt" class="prompt-label">Negative Prompt</label>
                        </div>
                        <div class="prompt-preset-dropdown" data-category="negative">
                            <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">🔖 ▼</button>
                            <div class="prompt-preset-menu">
                                <div class="prompt-preset-list"></div>
                                <div class="prompt-preset-actions">
                                    <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="negativePromptContent" class="collapsible-content">
                        <textarea id="negativePrompt" rows="2" placeholder="lowres, bad quality..."></textarea>
                    </div>
                </div>
                
                <!-- NAI Settings -->
                <div class="provider-section active" data-provider="nai">
                    <div class="section">
                        <div class="section-title">
                            <button type="button" class="collapse-toggle" data-target="naiSettingsContent" title="접기/펼치기">▼</button>
                            <span>NAI Settings</span>
                        </div>
                        <div id="naiSettingsContent" class="collapsible-content">
                            <label>Model</label>
                            <select id="naiModel">
                                <option value="nai-diffusion-4-5-full">V4.5 Full</option>
                                <option value="nai-diffusion-4-curated-preview">V4 Curated</option>
                                <option value="nai-diffusion-3">V3</option>
                            </select>

                            <div class="row">
                                <div>
                                    <label>Undesired Content Preset</label>
                                    <select id="ucPreset">
                                        <option value="Heavy">Heavy</option>
                                        <option value="Light">Light</option>
                                        <option value="Human Focus">Human Focus</option>
                                        <option value="Furry Focus">Furry Focus</option>
                                        <option value="None">None</option>
                                    </select>
                                </div>
                                <div>
                                    <label>SMEA</label>
                                    <select id="smea">
                                        <option value="none">None</option>
                                        <option value="SMEA">SMEA</option>
                                        <option value="SMEA+DYN">SMEA+DYN</option>
                                    </select>
                                </div>
                            </div>

                            <div class="checkbox-row">
                                <input type="checkbox" id="qualityTags" checked>
                                <label for="qualityTags">Add Quality Tags</label>
                            </div>
                        </div>
                    </div>

                    <!-- Vibe / Character Reference -->
                    <div class="section">
                        <div class="section-title">
                            <button type="button" class="collapse-toggle" data-target="vibeCharRefContent" title="접기/펼치기">▼</button>
                            <span>Vibe / Character Ref</span>
                            <small style="font-weight: normal; text-transform: none; letter-spacing: 0; opacity: 0.7;">(택1)</small>
                        </div>
                        <div id="vibeCharRefContent" class="collapsible-content">
                            <!-- Vibe Transfer -->
                            <div class="subsection">
                                <div class="subsection-title">
                                    <span>Vibe Transfer</span>
                                    <label class="section-toggle">
                                        <input type="checkbox" id="enableVibeTransfer">
                                        <span>Active</span>
                                    </label>
                                </div>

                                <div id="vibeTransferSettings" style="display: none;">
                                    <small style="color: var(--text-dim); display: block; margin-bottom: 8px;">
                                        최대 16개 이미지. 강도 합계가 1.0 이하가 되도록 권장.
                                    </small>

                                    <div id="vibeCacheInfo" style="display: none; font-size: 12px; margin-bottom: 8px; padding: 4px 8px; background: rgba(0,0,0,0.2); border-radius: 4px;"></div>

                                    <div id="vibeList" class="vibe-list"></div>

                                    <div class="btn-row">
                                        <button type="button" class="btn btn-secondary" id="addVibeBtn" style="flex: 1;">
                                            + 바이브 추가
                                        </button>
                                        <button type="button" class="btn btn-secondary btn-icon" id="openVibeFolderBtn" title="바이브 캐시 폴더 열기">
                                            📁
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Character Reference (V4.5 only) -->
                            <div class="subsection" id="charRefSection">
                                <div class="subsection-title">
                                    <span>Character Reference</span>
                                    <label class="section-toggle">
                                        <input type="checkbox" id="enableCharRef">
                                        <span>Active</span>
                                    </label>
                                </div>

                                <div id="charRefSettings" style="display: none;">
                                    <small style="color: var(--text-dim); display: block; margin-bottom: 8px;">
                                        V4.5 전용. Vibe Transfer와 동시 사용 불가.
                                    </small>

                                    <div id="charRefPreview" class="char-ref-preview" style="display: none;">
                                        <img id="charRefImage" src="" alt="Character Reference">
                                        <button type="button" class="remove-btn" id="removeCharRefBtn">×</button>
                                    </div>

                                    <button type="button" class="btn btn-secondary" id="uploadCharRefBtn" style="width: 100%;">
                                        이미지 선택
                                    </button>
                                    <input type="file" id="charRefInput" accept="image/*" style="display: none;">

                                    <div class="row" style="margin-top: 12px;">
                                        <div style="flex: 1;">
                                            <label>Fidelity</label>
                                            <input type="range" id="charRefFidelity" value="0.5" min="0" max="1" step="0.05" style="width: 100%;">
                                            <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim);">
                                                <span>유연</span>
                                                <span id="charRefFidelityValue">0.5</span>
                                                <span>정밀</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="checkbox-row" style="margin-top: 8px;">
                                        <input type="checkbox" id="charRefStyleAware" checked>
                                        <label for="charRefStyleAware">Style Aware (스타일도 복사)</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Local Settings -->
                <div class="provider-section" data-provider="local">
                    <div class="section">
                        <div class="section-title">
                            <button type="button" class="collapse-toggle" data-target="localSettingsContent" title="접기/펼치기">▼</button>
                            <span>Local Settings</span>
                        </div>
                        <div id="localSettingsContent" class="collapsible-content">
                            <div class="lora-header">
                                <label>Model</label>
                                <button type="button" class="folder-btn" id="openCheckpointsFolderBtn" title="체크포인트 폴더 열기">📁</button>
                            </div>
                            <select id="localModel" style="width: 100%; margin-bottom: 12px;">
                                <option value="">-- Select Model --</option>
                            </select>

                            <div class="lora-header">
                                <label>LoRAs</label>
                                <button type="button" class="lora-add-btn" id="addLoraSlotBtn" title="LoRA 슬롯 추가">+ Add</button>
                                <button type="button" class="folder-btn" id="openLorasFolderBtn" title="LoRA 폴더 열기">📁</button>
                            </div>
                            <div class="lora-list" id="loraList">
                                <div class="lora-empty">+ 버튼으로 LoRA 추가</div>
                            </div>
                        </div>
                    </div>

                    <div class="section">
                        <div class="section-title">
                            <button type="button" class="collapse-toggle" data-target="upscaleContent" title="접기/펼치기">▼</button>
                            <span>Hires.fix</span>
                            <label class="section-toggle">
                                <input type="checkbox" id="enableUpscale">
                                <span>Active</span>
                            </label>
                        </div>
                        <div id="upscaleContent" class="collapsible-content">
                            <div id="upscaleSettings">
                                <label>Upscale Model</label>
                                <select id="upscaleModel">
                                    <option value="">-- Select Model --</option>
                                </select>
                                <small>Place .pth files in models/upscale_models/</small>

                                <div class="row" style="margin-top: 8px;">
                                    <div>
                                        <label>Final Scale</label>
                                        <input type="number" id="downscaleRatio" value="0.7" step="0.05" min="0.3" max="1.0">
                                        <small>×2 upscale × ratio</small>
                                    </div>
                                    <div>
                                        <label>Alignment</label>
                                        <select id="sizeAlignment">
                                            <option value="none">None</option>
                                            <option value="8">8px</option>
                                            <option value="64" selected>64px</option>
                                        </select>
                                    </div>
                                </div>

                                <div class="row">
                                    <div>
                                        <label>Steps</label>
                                        <input type="number" id="upscaleSteps" value="15" min="5" max="50">
                                    </div>
                                    <div>
                                        <label>CFG</label>
                                        <input type="number" id="upscaleCfg" value="5.0" step="0.1" min="1" max="20">
                                    </div>
                                </div>

                                <div class="row">
                                    <div style="flex: 1;">
                                        <label>Denoise</label>
                                        <input type="range" id="upscaleDenoise" value="0.5" min="0.1" max="1.0" step="0.05" style="width: 100%;">
                                        <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim);">
                                            <span>0.1</span>
                                            <span id="upscaleDenoiseValue">0.5</span>
                                            <span>1.0</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- LUT (Color Grading) -->
                <div class="section" id="lutSection">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="lutContent" title="접기/펼치기">▼</button>
                        <span>LUT</span>
                        <label class="section-toggle">
                            <input type="checkbox" id="enableLut">
                            <span>Active</span>
                        </label>
                    </div>
                    <div id="lutContent" class="collapsible-content">
                        <div id="lutSettings" style="display: none;">
                            <label>LUT File</label>
                            <select id="lutFile">
                                <option value="">-- Select LUT --</option>
                            </select>
                            <small>Place .cube files in models/luts/</small>

                            <div class="row" style="margin-top: 8px;">
                                <div style="flex: 1;">
                                    <label>Intensity</label>
                                    <input type="range" id="lutIntensity" value="1.0" min="0.0" max="1.0" step="0.05" style="width: 100%;">
                                    <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim);">
                                        <span>0</span>
                                        <span id="lutIntensityValue">1.0</span>
                                        <span>1</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Base Image (Inpaint/Img2Img) -->
                <div class="section" id="baseImageSection">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="baseImageContent" title="접기/펼치기">▼</button>
                        <span>Base Image</span>
                        <button type="button" class="btn btn-secondary" id="clearBaseImage" style="margin-left: auto; padding: 4px 8px; font-size: 0.8rem; display: none;">✕ Clear</button>
                    </div>
                    <div id="baseImageContent" class="collapsible-content">
                        <!-- 이미지가 없을 때: 파일 선택 버튼 -->
                        <div id="baseImageDropZone" style="text-align: center; padding: 12px;">
                            <button type="button" class="btn" id="baseImageSelectBtn" style="width: 100%;">📷 이미지 선택</button>
                            <div style="color: var(--text-dim); font-size: 0.75rem; margin-top: 6px;">
                                또는 슬롯/갤러리에서 🎨 Inpaint / ✨ Enhance 사용
                            </div>
                            <input type="file" id="baseImageFileInput" accept="image/*" style="display: none;">
                        </div>
                        <!-- 이미지가 있을 때: 프리뷰 및 설정 -->
                        <div id="baseImageSettings" style="display: none;">
                            <div style="display: flex; gap: 12px; align-items: flex-start;">
                                <div id="baseImagePreview" style="flex: 0 0 120px; height: 120px; background: var(--bg); border-radius: 8px; overflow: hidden; display: flex; align-items: center; justify-content: center; position: relative;">
                                    <img id="baseImageImg" src="" style="max-width: 100%; max-height: 100%; object-fit: contain;">
                                    <div id="baseImageMaskOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.5; pointer-events: none;"></div>
                                </div>
                                <div style="flex: 1;">
                                    <div class="row" style="margin-bottom: 8px;">
                                        <div style="flex: 1;">
                                            <label>Mode</label>
                                            <select id="baseImageMode">
                                                <option value="img2img">Img2Img</option>
                                                <option value="inpaint">Inpaint</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div style="margin-bottom: 8px;">
                                        <label><span id="baseImageStrengthLabel">Strength</span>: <span id="baseImageStrengthValue">0.7</span></label>
                                        <input type="range" id="baseImageStrength" min="0" max="1" step="0.05" value="0.7" style="width: 100%;">
                                    </div>
                                    <div id="baseImageNoiseContainer">
                                        <label>Noise: <span id="baseImageNoiseValue">0</span></label>
                                        <input type="range" id="baseImageNoise" min="0" max="1" step="0.05" value="0" style="width: 100%;">
                                    </div>
                                    <button type="button" class="btn" id="editMaskBtn" style="margin-top: 8px; width: 100%; display: none;">🎨 마스크 수정</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Generation Settings -->
                <div class="section">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="generationContent" title="접기/펼치기">▼</button>
                        <span>Generation</span>
                    </div>
                    <div id="generationContent" class="collapsible-content">
                        <div class="row">
                            <div>
                                <label>Size</label>
                                <select id="sizePreset">
                                    <optgroup label="Landscape">
                                        <option value="1536x640">1536 × 640</option>
                                        <option value="1344x768">1344 × 768</option>
                                        <option value="1216x832">1216 × 832</option>
                                        <option value="1152x896">1152 × 896</option>
                                    </optgroup>
                                    <optgroup label="Square">
                                        <option value="1024x1024">1024 × 1024</option>
                                    </optgroup>
                                    <optgroup label="Portrait">
                                        <option value="896x1152">896 × 1152</option>
                                        <option value="832x1216" selected>832 × 1216</option>
                                        <option value="768x1344">768 × 1344</option>
                                        <option value="640x1536">640 × 1536</option>
                                    </optgroup>
                                    <option value="custom">Custom</option>
                                </select>
                            </div>
                            <div>
                                <label>W × H</label>
                                <div class="size-inputs">
                                    <input type="number" id="width" value="832" step="64">
                                    <span class="size-x">×</span>
                                    <input type="number" id="height" value="1216" step="64">
                                </div>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Steps</label>
                                <input type="number" id="steps" value="28">
                            </div>
                            <div>
                                <label id="cfgLabel">CFG</label>
                                <input type="number" id="cfg" value="5.0" step="0.1">
                            </div>
                        </div>

                        <!-- NAI Advanced Settings -->
                        <div id="naiAdvancedSettings" class="provider-section" data-provider="nai">
                            <div class="row">
                                <div style="flex: 1;">
                                    <label style="display: flex; justify-content: space-between; align-items: center;">
                                        <span>Prompt Guidance Rescale</span>
                                        <span id="cfgRescaleValue" style="font-weight: 500;">0</span>
                                    </label>
                                    <input type="range" id="cfgRescale" value="0" min="0" max="1" step="0.02" style="width: 100%;">
                                </div>
                            </div>
                            <div class="checkbox-row">
                                <input type="checkbox" id="varietyPlus">
                                <label for="varietyPlus">Variety+</label>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Sampler</label>
                                <select id="sampler">
                                    <option value="k_euler_ancestral">Euler Ancestral</option>
                                    <option value="k_euler">Euler</option>
                                    <option value="k_dpmpp_2s_ancestral">DPM++ 2S Ancestral</option>
                                    <option value="k_dpmpp_2m_sde">DPM++ 2M SDE</option>
                                    <option value="k_dpmpp_2m">DPM++ 2M</option>
                                    <option value="k_dpmpp_sde">DPM++ SDE</option>
                                </select>
                            </div>
                            <div>
                                <label>Scheduler</label>
                                <select id="scheduler">
                                    <option value="karras">Karras</option>
                                    <option value="exponential">Exponential</option>
                                    <option value="polyexponential">Polyexponential</option>
                                </select>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Seed</label>
                                <input type="number" id="seed" value="-1">
                            </div>
                        </div>

                        <div class="checkbox-row">
                            <input type="checkbox" id="randomSeed">
                            <label for="randomSeed">매 슬롯마다 랜덤 시드</label>
                        </div>
                        <div class="checkbox-row">
                            <input type="checkbox" id="lockSeed">
                            <label for="lockSeed">시드 고정</label>
                        </div>
                    </div>
                </div>

                <!-- Save Options -->
                <div class="section">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="saveOptionsContent" title="접기/펼치기">▼</button>
                        <span>Save Options</span>
                    </div>
                    <div id="saveOptionsContent" class="collapsible-content">
                        <div class="row">
                            <div>
                                <label>Format</label>
                                <select id="saveFormat">
                                    <option value="png" selected>PNG</option>
                                    <option value="jpg">JPG</option>
                                    <option value="webp">WebP</option>
                                </select>
                            </div>
                            <div>
                                <label>JPG Quality</label>
                                <input type="number" id="jpgQuality" value="95" min="1" max="100" step="1">
                            </div>
                        </div>
                        <div class="checkbox-row">
                            <input type="checkbox" id="stripMetadata">
                            <label for="stripMetadata">메타데이터 제거</label>
                        </div>
                        <small style="color: var(--text-dim);">체크 시 이미지에서 생성 정보가 제거됩니다</small>
                    </div>
                </div>
            </div>

            <div class="sidebar-footer">
                <!-- Anlas Info (NAI only) - Single line -->
                <div id="anlasInfo" class="anlas-info" style="display: none;">
                    <span class="anlas-icon">💎</span>
                    <span id="anlasBalance">--</span>
                    <button type="button" class="anlas-refresh" id="refreshAnlasBtn" title="새로고침">↻</button>
                    <span class="anlas-separator">│</span>
                    <span class="anlas-cost-label">-</span>
                    <span id="anlasCost">0</span>
                    <span id="anlasFreeTag" class="free-tag" style="display: none;">FREE</span>
                </div>

                <div class="status-text" id="statusText" style="text-align: left; margin-bottom: 4px;">준비</div>
                <div class="progress-bar" style="margin-bottom: 12px;">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <div style="display: flex; margin-bottom: 8px; align-items: center; gap: 8px;">
                    <div style="flex: 1;">
                        <button class="btn" id="generateBtn">Queue (0)</button>
                    </div>
                    <span style="color: var(--text-dim); font-size: 0.9rem;">×</span>
                    <div style="width: 60px;">
                        <input type="number" id="repeatCount" value="1" min="1" style="margin: 0; height: 100%; text-align: center;" title="반복 횟수">
                    </div>
                </div>
                <div class="row" style="gap: 6px;">
                    <button class="btn btn-secondary" id="cancelCurrentBtn" title="현재 작업 취소 (진행중인 이미지 완료 후)">Cancel</button>
                    <button class="btn btn-secondary" id="clearQueueBtn" title="대기열 비우기">Clear Q</button>
                </div>
            </div>
            <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>
        </aside>

        <!-- Main -->
        <main class="main">
            <!-- 모드 토글 (공통) -->
            <div class="mode-header">
                <div class="mode-toggle">
                    <button type="button" class="mode-btn active" id="slotModeBtn">🎰 슬롯 모드</button>
                    <button type="button" class="mode-btn" id="galleryModeBtn">🖼️ 갤러리</button>
                    <button type="button" class="mode-btn" id="censorModeBtn">🔍 자동검열</button>
                </div>
            </div>

            <!-- 슬롯 모드 툴바 -->
            <div class="slots-toolbar" id="slotsToolbar">
                <div class="toolbar-left">
                    <button type="button" class="add-slot-btn" id="addSlotBtn" title="슬롯 추가">+🎰</button>
                    <div class="slot-size-presets">
                        <button type="button" class="slot-size-preset-btn" id="slotSizePreset1" title="좌클릭: 프리셋 1 적용 | 우클릭: 현재 크기 저장">150</button>
                        <button type="button" class="slot-size-preset-btn" id="slotSizePreset2" title="좌클릭: 프리셋 2 적용 | 우클릭: 현재 크기 저장">675</button>
                        <button type="button" class="slot-size-preset-btn" id="slotSizePreset3" title="좌클릭: 프리셋 3 적용 | 우클릭: 현재 크기 저장">1200</button>
                    </div>
                    <button type="button" class="header-btn" id="clearImagesBtn" title="미리보기 이미지 지우기 (파일은 삭제되지 않음)">
                        <span>🧹</span>
                        <span>Clear</span>
                    </button>
                    <div class="preset-dropdown" id="presetDropdown">
                        <button type="button" class="header-btn preset-btn" id="presetBtn">
                            <span>🔖</span>
                            <span class="preset-name" id="presetName">Slot Set</span>
                            <span class="dropdown-arrow">▼</span>
                        </button>
                        <div class="preset-menu" id="presetMenu">
                            <div class="preset-list" id="presetList">
                                <!-- 프리셋 목록 -->
                            </div>
                            <div class="preset-actions">
                                <button type="button" class="preset-action-btn" id="newPresetBtn">+ New Set</button>
                                <button type="button" class="preset-action-btn" id="savePresetBtn">💾 Save</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="header-btn" id="syncScrollBtn" title="전체 슬롯 스크롤 동기화">
                        <span>🔗</span>
                        <span>Sync</span>
                    </button>
                    <button type="button" class="header-btn" id="saveImageSetBtn" title="현재 슬롯 이미지들을 폴더에 저장">
                        <span>💾</span>
                        <span>세트 저장</span>
                    </button>
                </div>
                <div class="toolbar-right">
                    <span class="toolbar-label">Save to:</span>
                    <div class="folder-dropdown" id="outputFolderDropdown">
                        <button type="button" class="header-btn folder-btn" id="outputFolderBtn">
                            <span class="folder-icon">📁</span>
                            <span class="folder-name" id="outputFolderName">output</span>
                            <span class="dropdown-arrow">▼</span>
                        </button>
                        <div class="folder-menu" id="outputFolderMenu">
                            <div class="folder-list" id="outputFolderList">
                                <!-- 폴더 목록 -->
                            </div>
                            <div class="folder-actions">
                                <button type="button" class="folder-action-btn" id="newOutputFolderBtn">+ 새 폴더</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="header-btn icon-only" id="openOutputFolderBtn" title="출력 폴더 열기">📂</button>
                </div>
            </div>

            <div class="slots-container-wrapper" id="slotsWrapper">
                <div class="slots-container" id="slotsContainer">
                    <!-- 슬롯들이 가로로 배치됨 -->
                </div>
            </div>

            <!-- 갤러리 모드 -->
            <div class="gallery-container" id="galleryContainer" style="display: none;">
                <div class="gallery-toolbar">
                    <div class="toolbar-left">
                        <button type="button" class="folder-tab vibe-folder" id="vibeCacheBtn" data-folder="vibe">🎨 vibe</button>
                        <span class="folder-separator double"></span>
                        <button type="button" class="folder-tab root-folder active" id="galleryRootBtn" data-folder="">📂 gallery</button>
                        <span class="folder-separator"></span>
                        <button type="button" class="add-folder-btn" id="addFolderBtn" title="새 폴더 추가">+📁</button>
                        <div class="gallery-subfolders" id="gallerySubfolders">
                            <!-- 하위 폴더 탭들이 여기에 추가됨 -->
                        </div>
                    </div>
                    <div class="toolbar-right">
                        <button type="button" class="header-btn icon-only" id="openGalleryFolderBtn" title="갤러리 폴더 열기">📂</button>
                    </div>
                </div>
                <div class="gallery-content">
                    <div class="gallery-grid" id="galleryGrid">
                        <!-- 갤러리 이미지들 -->
                    </div>
                    <div class="gallery-empty" id="galleryEmpty">
                        <div class="icon">🖼️</div>
                        <p>갤러리가 비어있습니다</p>
                        <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                    </div>
                </div>
            </div>

            <!-- 검열 모드 -->
            <div class="censor-container" id="censorContainer" style="display: none;">
                <!-- 툴바 (슬롯모드와 동일한 스타일) -->
                <div class="slots-toolbar" id="censorToolbar">
                    <div class="toolbar-left">
                        <button type="button" class="header-btn active" id="censorTabBefore">📥 검열 전</button>
                        <button type="button" class="header-btn" id="censorTabProcessing" style="display: none;">⚙️ 검열중</button>
                        <button type="button" class="header-btn" id="censorTabAfter">📤 검열 후</button>
                    </div>
                    <div class="toolbar-right">
                        <!-- 검열 전: 이미지 초기화 버튼 -->
                        <button type="button" class="header-btn" id="censorClearImagesBtn" style="display: none;" title="드롭된 이미지 초기화">
                            🧹 Clear
                        </button>
                        <!-- 저장 폴더 드롭다운 (모든 탭에서 표시) -->
                        <div class="folder-dropdown" id="censorFolderAfter">
                            <button type="button" class="header-btn folder-btn" id="censorCensoredFolderBtn">
                                <span class="folder-icon">📁</span>
                                <span class="folder-name" id="censorCensoredFolderName">censored</span>
                                <span class="dropdown-arrow">▼</span>
                            </button>
                            <div class="folder-menu" id="censorCensoredFolderMenu">
                                <div class="folder-list" id="censorCensoredFolderList">
                                    <!-- 폴더 목록 -->
                                </div>
                                <div class="folder-actions">
                                    <button type="button" class="folder-action-btn" id="censorAddCensoredBtn">+ 새 폴더</button>
                                </div>
                            </div>
                        </div>
                        <button type="button" class="header-btn icon-only" id="censorOpenFolderBtn" title="폴더 열기">📂</button>
                    </div>
                </div>
                
                <!-- 썸네일 가로 슬라이드 -->
                <div class="censor-thumbnails-wrapper" id="censorThumbnailsWrapper">
                    <div class="censor-thumbnails" id="censorThumbnails">
                        <!-- 썸네일들이 여기에 렌더링됨 -->
                    </div>
                </div>
                
                <!-- 메인 영역 (프리뷰 + 우측 패널) -->
                <div class="censor-main-area">
                    <!-- 좌측: 프리뷰 영역 -->
                    <div class="censor-preview-area">
                        <!-- 좌측 네비게이션 화살표 -->
                        <button class="censor-nav-arrow censor-nav-left" id="censorNavLeft" title="이전 이미지 (휠 위)">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="15 18 9 12 15 6"></polyline>
                            </svg>
                        </button>

                        <div class="censor-preview-container" id="censorPreviewContainer">
                            <!-- 검열전 탭 안내 문구 -->
                            <div class="censor-preview-hint" id="censorPreviewHint" style="display: none;">
                                검열 부위 미리보기입니다. 실제 검열은 <strong>전체 검열</strong> 버튼을 눌러주세요.
                            </div>
                            <canvas id="censorPreviewCanvas"></canvas>
                        </div>
                        <!-- 오버레이 캔버스: preview-area 전체를 덮음 (핸들 조작용) -->
                        <canvas id="censorOverlayCanvas"></canvas>

                        <!-- 우측 네비게이션 화살표 -->
                        <button class="censor-nav-arrow censor-nav-right" id="censorNavRight" title="다음 이미지 (휠 아래)">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                        </button>

                        <!-- 이미지 번호 표시 -->
                        <div class="censor-image-counter" id="censorImageCounter">0 / 0</div>

                        <!-- 드롭존 (이미지 없을 때 프리뷰 영역에 표시) -->
                        <div class="censor-dropzone" id="censorDropzone">
                            <div class="dropzone-content">
                                <div class="dropzone-icon">📁</div>
                                <p>검열할 이미지를 여기에 드롭하세요</p>
                                <small>또는 클릭하여 파일 선택</small>
                            </div>
                            <input type="file" id="censorFileInput" multiple accept="image/*" style="display: none;">
                        </div>
                        <!-- 검열중/후 탭 이미지 없음 표시 -->
                        <div class="censor-preview-empty" id="censorPreviewEmpty" style="display: none;">
                            <div class="icon">🖼️</div>
                            <p>표시할 이미지가 없습니다</p>
                        </div>
                        <div class="censor-scan-loading" id="censorScanLoading">
                            <div class="scan-spinner"></div>
                            <span>검열 영역 스캔 중...</span>
                        </div>
                    </div>

                    <!-- 우측 패널 -->
                    <div class="censor-side-panel" id="censorSidePanel">
                        <!-- 스크롤 가능한 콘텐츠 영역 -->
                        <div class="censor-side-panel-content">
                        <!-- 검열전 탭: 모델/감지대상 섹션 -->
                        <div class="censor-side-section censor-side-model" id="censorSideModel">
                            <div class="side-section-title">📦 모델</div>
                            <select id="censorModel">
                                <option value="">모델 선택...</option>
                            </select>
                        </div>

                        <div class="censor-side-section censor-side-targets" id="censorSideTargets">
                            <div class="side-section-title">🎯 감지 대상</div>
                            <div class="censor-targets" id="censorTargets">
                                <div class="censor-target-loading">모델을 선택하세요</div>
                            </div>
                        </div>

                        <!-- 공통: 검열 설정 -->
                        <div class="censor-side-section censor-side-settings">
                            <div class="side-section-title">⚙️ 검열 설정</div>
                            <div class="side-setting-row">
                                <label>방식</label>
                                <select id="censorMethod">
                                    <option value="steam" selected>☁️ 스팀</option>
                                    <option value="black">검정</option>
                                    <option value="white">흰색</option>
                                    <option value="mosaic">모자이크</option>
                                    <option value="blur">블러</option>
                                </select>
                            </div>
                            <div class="side-setting-row">
                                <label style="display: flex; justify-content: space-between; align-items: center;">
                                    <span>확장</span>
                                    <span id="censorExpandValue" style="font-weight: 500;">0</span>
                                </label>
                                <input type="range" id="censorExpandPixels" min="0" max="50" value="0" style="width: 100%;">
                            </div>
                            <div class="side-setting-row">
                                <label style="display: flex; justify-content: space-between; align-items: center;">
                                    <span>부드럽게</span>
                                    <span id="censorFeatherValue" style="font-weight: 500;">0</span>
                                </label>
                                <input type="range" id="censorFeather" min="0" max="50" value="0" style="width: 100%;">
                            </div>
                        </div>

                        <!-- 검열중/후 탭: 도구 섹션 -->
                        <div class="censor-side-section censor-side-tools" id="censorSideTools" style="display: none;">
                            <div class="side-section-title">🔧 도구</div>
                            <div class="side-tools-grid">
                                <button type="button" class="side-tool-btn active" id="procToolSelect">↔ 선택</button>
                                <button type="button" class="side-tool-btn" id="procToolAdd">+ 추가</button>
                                <button type="button" class="side-tool-btn" id="procToolDelete">🗑️ 삭제</button>
                            </div>
                        </div>

                        <!-- 검열후 탭: 도구 섹션 (별도 ID) -->
                        <div class="censor-side-section censor-side-tools-after" id="censorSideToolsAfter" style="display: none;">
                            <div class="side-section-title">🔧 도구</div>
                            <div class="side-tools-grid">
                                <button type="button" class="side-tool-btn active" id="afterToolSelect">↔ 선택</button>
                                <button type="button" class="side-tool-btn" id="afterToolAdd">+ 추가</button>
                                <button type="button" class="side-tool-btn" id="afterToolDelete">🗑️ 삭제</button>
                            </div>
                        </div>

                        <!-- 단축키 가이드 (검열중/후) -->
                        <div class="censor-side-section censor-side-shortcuts" id="censorSideShortcuts" style="display: none;">
                            <div class="side-section-title">📋 단축키</div>
                            <div class="side-shortcuts-list">
                                <div class="shortcut-row"><kbd>1</kbd><kbd>2</kbd><kbd>3</kbd> 모드</div>
                                <div class="shortcut-row"><kbd>휠</kbd> 이미지 전환</div>
                                <div class="shortcut-row"><kbd>우클릭</kbd> 삭제</div>
                            </div>
                        </div>
                        </div><!-- /.censor-side-panel-content -->

                        <!-- 액션 버튼 - content 밖에서 하단 고정 -->
                        <div class="censor-side-actions">
                            <!-- 검열전: 전체 검열 -->
                            <button type="button" class="btn btn-primary" id="censorRunAllBtn">🔍 전체 검열</button>
                            <!-- 검열중: 완료/취소 -->
                            <button type="button" class="btn btn-success" id="censorCompleteBtn" style="display: none;">✓ 검열 완료</button>
                            <button type="button" class="btn btn-secondary" id="censorCancelBtn" style="display: none;">취소</button>
                            <!-- 검열후: 저장 -->
                            <button type="button" class="btn btn-success" id="censorAfterSaveBtn" style="display: none;" disabled>💾 저장</button>
                        </div>
                    </div>
                </div>

                <!-- 하단 옵션 패널 (숨김 - 기존 호환용, 추후 제거) -->
                <div class="censor-options-panel" id="censorOptionsPanel" style="display: none;">
                    <div class="censor-options-before" id="censorOptionsBefore"></div>
                    <div class="censor-options-processing" id="censorOptionsProcessing" style="display: none;"></div>
                    <div class="censor-options-after" id="censorOptionsAfter" style="display: none;"></div>
                </div>
            </div>
            
            <!-- 검열 편집 모달 -->
            <div class="censor-edit-modal" id="censorEditModal">
                <div class="censor-edit-modal-header">
                    <h3>🔍 검열 편집</h3>
                    <button type="button" class="censor-edit-modal-close" id="censorEditModalClose">&times;</button>
                </div>
                <div class="censor-edit-modal-body">
                    <div class="censor-edit-modal-canvas-container">
                        <canvas id="censorEditCanvas"></canvas>
                        <canvas id="censorEditOverlay"></canvas>
                    </div>
                </div>
                <div class="censor-edit-modal-footer">
                    <div class="censor-edit-modal-tools">
                        <button type="button" class="tool-btn active" id="editToolSelect">↔ 선택</button>
                        <button type="button" class="tool-btn" id="editToolAdd">+ 추가</button>
                        <button type="button" class="tool-btn" id="editToolDelete">🗑️ 삭제</button>
                        <span style="color: var(--border); margin: 0 8px;">|</span>
                        <div class="censor-method-select">
                            <label>방식:</label>
                            <select id="editCensorMethod">
                                <option value="steam" selected>☁️ 스팀</option>
                                <option value="black">□ 검정</option>
                                <option value="white">■ 흰색</option>
                                <option value="mosaic">▦ 모자이크</option>
                                <option value="blur">◐ 블러</option>
                            </select>
                        </div>
                    </div>
                    <div class="censor-edit-modal-actions">
                        <button type="button" class="btn" id="censorEditCancelBtn">취소</button>
                        <button type="button" class="btn btn-primary" id="censorEditSaveBtn">💾 저장 (덮어쓰기)</button>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <span class="close">&times;</span>
        <img src="" alt="">
    </div>

    <!-- Drop Overlay -->
    <div class="drop-overlay" id="dropOverlay">
        <div class="drop-overlay-content">
            <div class="icon">📥</div>
            <h3>이미지 드롭</h3>
            <p>바이브 또는 생성 이미지를 드롭하세요</p>
        </div>
    </div>

    <!-- Drop Confirm Modal -->
    <div class="drop-modal" id="dropModal">
        <div class="drop-modal-content">
            <h3 id="dropModalTitle">이미지 가져오기</h3>
            <img id="dropModalPreview" class="preview" src="" alt="">
            <div id="dropModalMetadata" class="metadata"></div>
            <div id="dropModalButtons">
                <!-- 이미지 용도 선택 버튼 그룹 -->
                <div class="btn-row" id="dropModalImageOptions" style="display: none;">
                    <button type="button" class="btn" id="dropModalAsVibe">바이브 추가</button>
                    <button type="button" class="btn" id="dropModalAsCharRef">캐릭터 레퍼런스</button>
                    <button type="button" class="btn" id="dropModalAsBaseImage">베이스 이미지</button>
                </div>
                <!-- 메타데이터 적용 버튼 그룹 -->
                <div class="btn-row" id="dropModalMetaOptions" style="display: none;">
                    <button type="button" class="btn" id="dropModalPromptOnly">프롬프트만</button>
                    <button type="button" class="btn" id="dropModalSeedOnly">시드만</button>
                    <button type="button" class="btn btn-primary" id="dropModalConfirm">전체 적용</button>
                </div>
                <!-- 취소 버튼 (일반 이미지용) -->
                <div class="btn-row-actions" id="dropModalPlainActions" style="display: none;">
                    <button type="button" class="btn btn-secondary" id="dropModalCancel">취소</button>
                </div>
                <!-- 취소 버튼 (메타데이터 있는 이미지용) -->
                <div class="btn-row-actions" id="dropModalMetaActions" style="display: none;">
                    <button type="button" class="btn btn-secondary" id="dropModalCancelMeta">취소</button>
                </div>
                <!-- 바이브 파일용 버튼 -->
                <div class="btn-row-actions" id="dropModalVibeActions" style="display: none;">
                    <button type="button" class="btn btn-secondary" id="dropModalCancelVibe">취소</button>
                    <button type="button" class="btn btn-primary" id="dropModalAddVibe">바이브에 추가</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Generic Confirm Modal -->
    <div class="drop-modal" id="confirmModal">
        <div class="drop-modal-content" style="max-width: 400px;">
            <h3 id="confirmModalTitle">확인</h3>
            <div id="confirmModalMessage" class="metadata" style="margin: 16px 0;"></div>
            <div class="buttons">
                <button type="button" class="btn btn-secondary" id="confirmModalCancel">취소</button>
                <button type="button" class="btn" id="confirmModalOk">확인</button>
            </div>
            <label id="confirmModalCheckboxWrapper" class="checkbox-row" style="display: none;">
                <input type="checkbox" id="confirmModalCheckbox">
                <span id="confirmModalCheckboxLabel">앞으로 묻지 않음</span>
            </label>
        </div>
    </div>

    <!-- Input Prompt Modal -->
    <div class="drop-modal" id="inputModal">
        <div class="drop-modal-content" style="max-width: 400px;">
            <h3 id="inputModalTitle">입력</h3>
            <div id="inputModalMessage" style="margin: 12px 0; color: var(--text-dim);"></div>
            <input type="text" id="inputModalInput" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-light); color: var(--text); margin-bottom: 16px;">
            <div class="buttons">
                <button type="button" class="btn btn-secondary" id="inputModalCancel">취소</button>
                <button type="button" class="btn" id="inputModalOk">확인</button>
            </div>
        </div>
    </div>

    <!-- Enhance Modal (NAI) -->
    <div class="drop-modal" id="enhanceModal">
        <div class="drop-modal-content" style="max-width: 500px;">
            <h3>✨ Enhance</h3>
            <div style="display: flex; gap: 16px; margin-bottom: 16px;">
                <div id="enhanceModalPreview" style="flex: 0 0 150px; height: 150px; background: var(--bg); border-radius: 8px; overflow: hidden; display: flex; align-items: center; justify-content: center;">
                    <img id="enhanceModalImg" src="" style="max-width: 100%; max-height: 100%; object-fit: contain;">
                </div>
                <div style="flex: 1;">
                    <div style="margin-bottom: 12px;">
                        <label>Resolution</label>
                        <div style="display: flex; gap: 8px; margin-top: 4px;">
                            <button type="button" class="btn enhance-res-btn active" data-scale="1">Normal (1x)</button>
                            <button type="button" class="btn enhance-res-btn" data-scale="1.5">Large (1.5x)</button>
                        </div>
                        <div id="enhanceResInfo" style="font-size: 0.8rem; color: var(--text-dim); margin-top: 4px;"></div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label>Magnitude: <span id="enhanceModalMagnitude">3</span></label>
                        <input type="range" id="enhanceModalMagnitudeSlider" min="1" max="5" step="1" value="3" style="width: 100%;">
                        <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: var(--text-dim);">
                            <span>Low (원본 유지)</span>
                            <span>High (변형 많음)</span>
                        </div>
                    </div>
                    <div id="enhanceModalCost" style="font-size: 0.9rem; padding: 8px; background: var(--bg); border-radius: 6px; text-align: center;">
                        Cost: <span id="enhanceModalAnlas">0</span> Anlas
                    </div>
                </div>
            </div>
            <div class="buttons">
                <button type="button" class="btn btn-secondary" id="enhanceModalCancel">취소</button>
                <button type="button" class="btn btn-primary" id="enhanceModalConfirm">✨ Enhance 실행</button>
            </div>
        </div>
    </div>

    <!-- Mask Editor Modal -->
    <div class="mask-editor-modal" id="maskEditorModal">
        <div class="mask-editor-container">
            <div class="mask-editor-header">
                <h3>🎨 Inpaint Mask Editor</h3>
                <button class="btn btn-secondary" id="maskEditorClose" style="padding: 6px 12px;">✕</button>
            </div>
            <div class="mask-editor-toolbar">
                <div class="tool-group">
                    <button class="tool-btn active" id="maskToolBrush" title="브러시 (마스크 그리기)">🖌️ Brush</button>
                    <button class="tool-btn" id="maskToolEraser" title="지우개">◼ Eraser</button>
                </div>
                <div class="slider-group">
                    <label>Size:</label>
                    <input type="range" id="maskBrushSize" min="5" max="100" value="30">
                    <span id="maskBrushSizeValue">30</span>
                </div>
                <div class="tool-group" style="margin-left: auto;">
                    <button class="tool-btn" id="maskToolClear" title="전체 지우기">🗑️ Clear</button>
                    <button class="tool-btn" id="maskToolInvert" title="마스크 반전">🔄 Invert</button>
                </div>
            </div>
            <div class="mask-editor-canvas-wrapper">
                <canvas id="maskEditorImageCanvas"></canvas>
                <canvas id="maskEditorMaskCanvas"></canvas>
                <canvas id="maskEditorDrawCanvas" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
            </div>
            <div class="mask-editor-toolbar">
                <div class="slider-group">
                    <label>Strength:</label>
                    <input type="range" id="maskEditorStrength" min="0" max="1" step="0.05" value="0.7">
                    <span id="maskEditorStrengthValue">0.7</span>
                </div>
            </div>
            <div class="mask-editor-footer">
                <button class="btn btn-secondary" id="maskEditorCancel">취소</button>
                <button class="btn btn-primary" id="maskEditorApply">✓ 베이스 이미지로 등록</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="modal-close" onclick="closeSettings()">&times;</button>
            </div>
            
            <div class="input-group">
                <label>NAI API Token</label>
                <input type="password" id="naiToken" placeholder="NAI 토큰 입력">
                <small>Get from novelai.net → Account → API</small>
            </div>
            
            <div class="input-group">
                <label>Status</label>
                <span class="status-badge" id="naiStatus">Checking...</span>
            </div>
            
            <div class="input-group">
                <label>Checkpoints Directory</label>
                <input type="text" id="checkpointsDir" placeholder="./models/checkpoints">
            </div>
            
            <div class="input-group">
                <label>LoRA Directory</label>
                <input type="text" id="loraDir" placeholder="./models/loras">
            </div>

            <div style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 16px;">
                <label class="toggle-switch" style="flex-shrink: 0; margin-top: 2px;">
                    <input type="checkbox" id="tagAutocompleteToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
                <div style="flex: 1; min-width: 0;">
                    <div style="font-weight: 600; margin-bottom: 4px;">태그 자동 완성</div>
                    <small style="color: var(--text-dim); display: block; line-height: 1.4;">
                        댄부루 태그 데이터베이스 기반 자동완성 제안 (Base/Negative/Character 프롬프트)
                    </small>
                </div>
            </div>

            <div style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 16px;">
                <label class="toggle-switch" style="flex-shrink: 0; margin-top: 2px;">
                    <input type="checkbox" id="promptHighlightToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
                <div style="flex: 1; min-width: 0;">
                    <div style="font-weight: 600; margin-bottom: 4px;">프롬프트 가중치 강조</div>
                    <small style="color: var(--text-dim); display: block; line-height: 1.4;">
                        가중치 문법 색상 표시 (NAI: {강화} [약화], Local: (강화) [약화])
                    </small>
                </div>
            </div>

            <hr style="border: none; border-top: 1px solid var(--border); margin: 16px 0;">
            
            <div class="input-group">
                <label>Local Generation Environment</label>
                <div id="localEnvStatus" class="local-env-status">
                    <span class="status-text">Checking...</span>
                </div>
                <div id="localEnvActions" style="margin-top: 8px;">
                    <!-- 동적으로 버튼 추가됨 -->
                </div>
                <div id="localEnvProgress" class="local-env-progress" style="display: none;">
                    <div class="local-env-progress-bar">
                        <div class="local-env-progress-fill" id="localEnvProgressFill"></div>
                    </div>
                    <span class="local-env-progress-text" id="localEnvProgressText">0%</span>
                </div>
                <small style="display: block; margin-top: 12px; color: var(--text-dim);">Python + PyTorch CUDA (~5GB, 3-5분)</small>
            </div>

            <hr style="border: none; border-top: 1px solid var(--border); margin: 16px 0;">

            <!-- App Info -->
            <div class="input-group">
                <label>App Info</label>
                <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                    <span id="appVersionDisplay" style="color: var(--text-dim);">v1.0.0</span>
                    <button class="btn btn-sm" onclick="checkForUpdates()" id="checkUpdateBtn">Check for Updates</button>
                    <a href="https://discord.gg/Cv4hUFM2Z2" target="_blank" class="btn btn-sm" title="Bug reports & suggestions" style="display: inline-flex; align-items: center; gap: 6px; background: #5865F2; border-color: #5865F2; text-decoration: none;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028 14.09 14.09 0 0 0 1.226-1.994.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z"/></svg>
                        최신 버전 / 버그 / 건의
                    </a>
                </div>
                <div id="updateStatus" style="margin-top: 8px; display: none;"></div>
            </div>

            <button class="btn" onclick="saveSettings()" style="margin-top: 16px;">Save Settings</button>
        </div>
    </div>
    
    <!-- Local Install Modal -->
    <div class="modal" id="localInstallModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2>⚙️ 환경 설치</h2>
                <button class="modal-close" id="localInstallModalClose" onclick="closeLocalInstallModal()">&times;</button>
            </div>
            
            <p style="color: var(--text-dim); margin-bottom: 16px;">
                로컬 생성/검열 기능을 위해 Python 환경과 PyTorch를 설치해야 합니다. (최초 1회)
            </p>
            
            <div class="input-group">
                <div id="installModalStatus" class="local-env-status">
                    <span class="status-text">확인 중...</span>
                </div>
                <div id="installModalProgress" class="local-env-progress" style="display: none;">
                    <div class="local-env-progress-bar">
                        <div class="local-env-progress-fill" id="installModalProgressFill"></div>
                    </div>
                    <span class="local-env-progress-text" id="installModalProgressText">0%</span>
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn" id="installModalBtn" onclick="installFromModal()" style="flex: 1;">
                    ⬇️ 설치 (~5GB)
                </button>
                <button class="btn" id="installModalCancelBtn" onclick="closeLocalInstallModal()" style="flex: 1; background: var(--surface-light);">
                    취소
                </button>
            </div>
            
            <small style="display: block; margin-top: 12px; color: var(--text-dim);">
                인터넷 속도에 따라 3~5분 정도 소요됩니다.
            </small>
        </div>
    </div>
    
    <!-- Restart Confirmation Modal -->
    <div class="modal" id="restartModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2>🔄 재시작 필요</h2>
            </div>
            
            <p style="color: var(--text); margin-bottom: 8px;">
                재시작이 필요합니다
            </p>
            <p style="color: var(--text-dim); margin-bottom: 16px;">
                재시작 후 GPU(CUDA) 환경 설치가 자동으로 시작됩니다.
            </p>
            
            <div style="display: flex; gap: 8px;">
                <button class="btn" id="restartConfirmBtn" onclick="confirmRestart()" style="flex: 1;">
                    🔄 지금 재시작
                </button>
            </div>
            
            <small style="display: block; margin-top: 12px; color: var(--text-dim);">
                재시작 후 자동으로 연결됩니다.
            </small>
        </div>
    </div>
    
    <!-- NAI Token Modal -->
    <div class="modal" id="naiTokenModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2>🔑 NovelAI API 토큰</h2>
                <button class="modal-close" onclick="closeNaiTokenModal()">&times;</button>
            </div>
            
            <p style="color: var(--text-dim); margin-bottom: 16px;">
                NAI 생성을 사용하려면 API 토큰이 필요합니다.
            </p>
            
            <div class="input-group">
                <label>API 토큰</label>
                <input type="password" id="naiTokenModalInput" placeholder="토큰 붙여넣기">
                <small><a href="https://novelai.net/image" target="_blank" style="color: var(--primary);">novelai.net</a> → Account Settings → Get Persistent API Token</small>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn" id="naiTokenModalBtn" onclick="saveNaiTokenFromModal()" style="flex: 2;">
                    💾 저장
                </button>
                <button class="btn" onclick="closeNaiTokenModal()" style="flex: 1; background: var(--surface-light);">
                    취소
                </button>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
    
    <script>
        console.log('[PeroPix] Script initialized');

        // Range 슬라이더 채움 업데이트
        function updateSliderFill(slider) {
            const min = parseFloat(slider.min) || 0;
            const max = parseFloat(slider.max) || 100;
            const val = parseFloat(slider.value) || 0;
            const percent = ((val - min) / (max - min)) * 100;

            // 래퍼 안의 fill 요소 업데이트
            const wrapper = slider.closest('.range-wrap');
            if (wrapper) {
                const fill = wrapper.querySelector('.range-fill');
                if (fill) {
                    fill.style.width = percent + '%';
                }
            }
        }

        // 슬라이더를 래퍼로 감싸기
        function wrapSlider(slider) {
            // 이미 래핑되어 있으면 스킵
            if (slider.closest('.range-wrap')) return;

            const wrapper = document.createElement('div');
            wrapper.className = 'range-wrap';

            const bg = document.createElement('div');
            bg.className = 'range-bg';

            const fill = document.createElement('div');
            fill.className = 'range-fill';

            slider.parentNode.insertBefore(wrapper, slider);
            wrapper.appendChild(bg);
            wrapper.appendChild(fill);
            wrapper.appendChild(slider);

            // 초기 채움 설정
            updateSliderFill(slider);

            // input 이벤트 리스너
            slider.addEventListener('input', () => updateSliderFill(slider));
        }

        // 모든 range 슬라이더에 자동 채움 적용
        function initAllSliders() {
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                wrapSlider(slider);
            });
        }

        const API_BASE = 'http://127.0.0.1:8765';

        let currentProvider = 'nai';
        let currentIndex = 0;
        let totalImages = 0;
        let resetTimer = null;
        let naiTokenSet = false;  // NAI 토큰 설정 여부

        // WebSocket 연결 관리
        let ws = null;
        let wsClientId = localStorage.getItem('ws_client_id') || null;
        let wsReconnectTimer = null;
        let lastImageSeq = 0;  // 마지막으로 받은 이미지 순번 (재연결 시 동기화용)

        // Elements
        const tabs = document.querySelectorAll('.tab');
        const providerSections = document.querySelectorAll('.provider-section');
        const generateBtn = document.getElementById('generateBtn');
        const cancelCurrentBtn = document.getElementById('cancelCurrentBtn');
        const clearQueueBtn = document.getElementById('clearQueueBtn');
        const progressFill = document.getElementById('progressFill');
        const statusText = document.getElementById('statusText');
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = lightbox.querySelector('img');

        // Lightbox navigation state (for wheel navigation)
        let lightboxCurrentSlot = null;
        let lightboxCurrentCard = null;
        let lightboxCurrentGalleryItem = null;  // 갤러리 모드용
        
        // Slots
        const slotsContainer = document.getElementById('slotsContainer');
        const addSlotBtn = document.getElementById('addSlotBtn');
        let slotCounter = 0;
        
        function updateSlotNumbers() {
            const slots = slotsContainer.querySelectorAll('.slot');
            slots.forEach((slot, index) => {
                slot.querySelector('.slot-number').textContent = String(index + 1).padStart(3, '0');
            });
        }
        
        // 슬롯 너비 관리
        let currentSlotWidth = 280;
        const MIN_SLOT_WIDTH = 150;
        const MAX_SLOT_WIDTH = 1200;

        function setSlotWidth(width) {
            currentSlotWidth = Math.max(MIN_SLOT_WIDTH, Math.min(MAX_SLOT_WIDTH, width));
            document.documentElement.style.setProperty('--slot-width', currentSlotWidth + 'px');
            updateSlotSizePresetButtons();
            autoSaveSettings();
        }

        // 슬롯 사이즈 프리셋
        let slotSizePresets = [150, 675, 1200]; // 초기값: 최소, 중간, 최대

        function loadSlotSizePresets() {
            const saved = localStorage.getItem('slotSizePresets');
            if (saved) {
                try {
                    slotSizePresets = JSON.parse(saved);
                } catch (e) {
                    console.warn('Failed to load slot size presets:', e);
                }
            }
            updateSlotSizePresetButtons();
        }

        function saveSlotSizePresets() {
            localStorage.setItem('slotSizePresets', JSON.stringify(slotSizePresets));
        }

        function updateSlotSizePresetButtons() {
            for (let i = 0; i < 3; i++) {
                const btn = document.getElementById(`slotSizePreset${i + 1}`);
                if (btn) {
                    btn.textContent = slotSizePresets[i];
                    // 활성 프리셋 표시 (현재 슬롯 폭과 일치 시)
                    if (Math.abs(currentSlotWidth - slotSizePresets[i]) < 5) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            }
        }

        // 프리셋 버튼 이벤트 리스너
        (function setupSlotSizePresets() {
            for (let i = 0; i < 3; i++) {
                const btn = document.getElementById(`slotSizePreset${i + 1}`);
                if (!btn) continue;

                // 좌클릭: 프리셋 적용
                btn.addEventListener('click', () => {
                    setSlotWidth(slotSizePresets[i]);
                });

                // 우클릭: 현재 크기 저장
                btn.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    slotSizePresets[i] = currentSlotWidth;
                    saveSlotSizePresets();
                    updateSlotSizePresetButtons();
                });
            }
        })();

        function setupSlotResize(slot) {
            const handle = slot.querySelector('.slot-resize-handle');
            if (!handle) return;

            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = currentSlotWidth;

                document.body.classList.add('resizing-slot');
                handle.classList.add('active');

                function onMouseMove(e) {
                    const deltaX = e.clientX - startX;
                    setSlotWidth(startWidth + deltaX);
                }

                function onMouseUp() {
                    document.body.classList.remove('resizing-slot');
                    handle.classList.remove('active');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // 사이드바 너비 관리
        let currentSidebarWidth = 540;
        const MIN_SIDEBAR_WIDTH = 360;
        const MAX_SIDEBAR_WIDTH = 800;

        function setSidebarWidth(width) {
            currentSidebarWidth = Math.max(MIN_SIDEBAR_WIDTH, Math.min(MAX_SIDEBAR_WIDTH, width));
            document.documentElement.style.setProperty('--sidebar-width', currentSidebarWidth + 'px');
            autoSaveSettings();
        }

        // 사이드바 리사이즈 핸들 설정
        (function setupSidebarResize() {
            const handle = document.getElementById('sidebarResizeHandle');
            if (!handle) return;

            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = currentSidebarWidth;

                document.body.classList.add('resizing-slot');
                handle.classList.add('active');

                let rafId = null;
                function onMouseMove(e) {
                    const deltaX = e.clientX - startX;
                    setSidebarWidth(startWidth + deltaX);
                    // 드래그 중 프롬프트 하이라이트 동기화 (throttled via rAF)
                    if (!rafId) {
                        rafId = requestAnimationFrame(() => {
                            if (typeof updatePromptHighlights === 'function') {
                                updatePromptHighlights();
                            }
                            rafId = null;
                        });
                    }
                }

                function onMouseUp() {
                    document.body.classList.remove('resizing-slot');
                    handle.classList.remove('active');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    // 사이드바 리사이즈 완료 후 프롬프트 하이라이트 동기화
                    if (typeof updatePromptHighlights === 'function') {
                        updatePromptHighlights();
                    }
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        })();

        function createSlot(name = '', content = '') {
            const slotId = slotCounter++;
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.dataset.slotIndex = slotId;
            slot.innerHTML = `
                <div class="slot-resize-handle"></div>
                <div class="slot-prompt">
                    <div class="slot-prompt-header">
                        <span class="slot-number">001</span>
                        <input type="text" placeholder="이름 (선택)" value="${name}" class="slot-name">
                        <button type="button" class="slot-lock" title="락 (생성 제외)" tabindex="-1">🔓</button>
                        <button type="button" class="slot-drag" title="드래그하여 순서 변경" tabindex="-1">☰</button>
                        <button type="button" class="slot-delete" tabindex="-1">×</button>
                    </div>
                    <textarea placeholder="이 슬롯에만 적용할 태그" class="slot-tags">${content}</textarea>
                </div>
                <div class="slot-images">
                    <div class="slot-empty">이미지가 여기에 표시됩니다</div>
                </div>
            `;

            // 리사이즈 핸들 설정
            setupSlotResize(slot);
            
            slot.querySelector('.slot-delete').onclick = () => {
                if (slotsContainer.querySelectorAll('.slot').length > 1) {
                    slot.remove();
                    updateSlotNumbers();
                    updateQueueButton();
                    updateAnlasCost();
                    autoSaveSettings();
                }
            };

            // 락 버튼
            const lockBtn = slot.querySelector('.slot-lock');
            lockBtn.onclick = () => {
                const isLocked = slot.classList.toggle('locked');
                lockBtn.classList.toggle('locked', isLocked);
                lockBtn.textContent = isLocked ? '🔒' : '🔓';
                lockBtn.title = isLocked ? '락 해제' : '락 (생성 제외)';
                updateQueueButton();
                updateAnlasCost();
                autoSaveSettings();
            };

            const tagsTextarea = slot.querySelector('textarea');
            tagsTextarea.oninput = updateQueueButton;

            // 태그 자동완성 설정
            setupTagAutocomplete(tagsTextarea);

            // 프롬프트 하이라이팅 설정
            setupPromptHighlighting(tagsTextarea);

            // 탭 키로 같은 타입 필드 간 이동
            const nameInput = slot.querySelector('.slot-name');
            const tagsInput = slot.querySelector('.slot-tags');
            
            nameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const slots = [...slotsContainer.querySelectorAll('.slot')];
                    const currentIdx = slots.indexOf(slot);
                    const nextIdx = e.shiftKey 
                        ? (currentIdx - 1 + slots.length) % slots.length 
                        : (currentIdx + 1) % slots.length;
                    slots[nextIdx].querySelector('.slot-name').focus();
                }
            });
            
            tagsInput.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const slots = [...slotsContainer.querySelectorAll('.slot')];
                    const currentIdx = slots.indexOf(slot);
                    const nextIdx = e.shiftKey 
                        ? (currentIdx - 1 + slots.length) % slots.length 
                        : (currentIdx + 1) % slots.length;
                    slots[nextIdx].querySelector('.slot-tags').focus();
                }
            });
            
            // 드래그 핸들
            const dragHandle = slot.querySelector('.slot-drag');
            dragHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startSlotDrag(slot, e);
            });
            
            return slot;
        }
        
        // 슬롯 드래그 앤 드롭
        let draggedSlot = null;
        let dragStartX = 0;
        let slotStartX = 0;
        let placeholder = null;
        
        function startSlotDrag(slot, e) {
            draggedSlot = slot;
            dragStartX = e.clientX;
            
            const rect = slot.getBoundingClientRect();
            slotStartX = rect.left;
            
            // 플레이스홀더 생성
            placeholder = document.createElement('div');
            placeholder.className = 'slot-placeholder';
            placeholder.style.width = rect.width + 'px';
            placeholder.style.height = rect.height + 'px';
            
            // 드래그 중 스타일
            slot.classList.add('dragging');
            slot.style.position = 'fixed';
            slot.style.left = rect.left + 'px';
            slot.style.top = rect.top + 'px';
            slot.style.width = rect.width + 'px';
            slot.style.zIndex = '1000';
            
            slot.parentNode.insertBefore(placeholder, slot);
            document.body.appendChild(slot);
            
            document.addEventListener('mousemove', onSlotDrag);
            document.addEventListener('mouseup', endSlotDrag);
        }
        
        function onSlotDrag(e) {
            if (!draggedSlot) return;
            
            const dx = e.clientX - dragStartX;
            draggedSlot.style.left = (slotStartX + dx) + 'px';
            
            // 플레이스홀더 위치 업데이트
            const slots = [...slotsContainer.querySelectorAll('.slot:not(.dragging)')];
            const draggedRect = draggedSlot.getBoundingClientRect();
            const draggedCenter = draggedRect.left + draggedRect.width / 2;
            
            for (let i = 0; i < slots.length; i++) {
                const slotRect = slots[i].getBoundingClientRect();
                const slotCenter = slotRect.left + slotRect.width / 2;
                
                if (draggedCenter < slotCenter) {
                    slotsContainer.insertBefore(placeholder, slots[i]);
                    return;
                }
            }
            slotsContainer.appendChild(placeholder);
        }
        
        function endSlotDrag() {
            if (!draggedSlot) return;
            
            // 플레이스홀더 위치에 슬롯 삽입
            draggedSlot.classList.remove('dragging');
            draggedSlot.style.position = '';
            draggedSlot.style.left = '';
            draggedSlot.style.top = '';
            draggedSlot.style.width = '';
            draggedSlot.style.zIndex = '';
            
            slotsContainer.insertBefore(draggedSlot, placeholder);
            placeholder.remove();
            
            draggedSlot = null;
            placeholder = null;
            
            document.removeEventListener('mousemove', onSlotDrag);
            document.removeEventListener('mouseup', endSlotDrag);

            updateSlotNumbers();
            autoSaveSettings();
        }

        function addSlot(name = '', content = '', locked = false) {
            const slot = createSlot(name, content);
            if (locked) {
                slot.classList.add('locked');
                const lockBtn = slot.querySelector('.slot-lock');
                lockBtn.classList.add('locked');
                lockBtn.textContent = '🔒';
                lockBtn.title = '락 해제';
            }
            slotsContainer.appendChild(slot);
            setupSlotImageScroll(slot);
            updateSlotNumbers();
            updateQueueButton();
            updateAnlasCost();
        }
        
        function getSlotList() {
            const slots = slotsContainer.querySelectorAll('.slot');
            const list = [];

            slots.forEach((slot, index) => {
                // 락된 슬롯은 제외
                if (slot.classList.contains('locked')) return;

                const name = slot.querySelector('.slot-name').value.trim();
                const content = slot.querySelector('.slot-tags').value.trim();
                // 현재 위치 기반 인덱스 사용
                list.push({ name, content, slotIndex: index });
            });

            return list;
        }

        function getUnlockedSlotCount() {
            const slots = slotsContainer.querySelectorAll('.slot:not(.locked)');
            return slots.length;
        }

        // 저장용: 모든 슬롯 정보 (락 상태 포함)
        function getAllSlotList() {
            const slots = slotsContainer.querySelectorAll('.slot');
            const list = [];

            slots.forEach((slot, index) => {
                const name = slot.querySelector('.slot-name').value.trim();
                const content = slot.querySelector('.slot-tags').value.trim();
                const locked = slot.classList.contains('locked');
                list.push({ name, content, locked, slotIndex: index });
            });

            return list;
        }

        function updateQueueButton() {
            const count = getUnlockedSlotCount() || 1;
            generateBtn.textContent = `Queue (${count})`;
        }
        
        function addImageToSlot(slotIndex, data) {
            // slotIndex로 슬롯 찾기
            const slots = slotsContainer.querySelectorAll('.slot');
            const slotsWrapperDisplay = slotsWrapper.style.display;
            console.log(`[addImageToSlot] slotIndex=${slotIndex}, slots.length=${slots.length}, filename=${data.filename}, slotsWrapperDisplay=${slotsWrapperDisplay}`);

            // 슬롯이 없거나 인덱스가 범위를 벗어나면 첫 번째 슬롯에 추가
            let targetSlot;
            if (slotIndex >= slots.length || slotIndex < 0) {
                console.warn(`[addImageToSlot] Invalid slotIndex ${slotIndex}, falling back to slot 0`);
                if (slots.length === 0) {
                    console.error('[addImageToSlot] No slots available!');
                    return;
                }
                targetSlot = slots[0];
            } else {
                targetSlot = slots[slotIndex];
            }

            const imagesContainer = targetSlot.querySelector('.slot-images');

            // 빈 상태 제거
            const empty = imagesContainer.querySelector('.slot-empty');
            if (empty) empty.remove();

            const card = document.createElement('div');
            card.className = 'slot-image-card';

            // image_path가 있으면 URL로, 없으면 base64로 (하위 호환)
            // 캐시 버스터 추가 (삭제된 파일명 재사용 시 캐시 문제 방지)
            const cacheBuster = Date.now();
            const imgSrc = data.image_path
                ? `${API_BASE}/api/outputs/${data.image_path}?t=${cacheBuster}`
                : `data:image/png;base64,${data.image}`;
            card.innerHTML = `
                <img src="${imgSrc}" alt="" draggable="false">
                <button type="button" class="save-gallery-btn" title="갤러리에 저장">☆</button>
                <div class="info">
                    <div class="info-row">
                        <button type="button" class="clear-card-btn" title="미리보기 지우기">🧹</button>
                        <button type="button" class="delete-file-btn" title="파일 삭제">🗑️</button>
                        <div class="filename" title="${data.filename}">${data.filename}</div>
                        <button type="button" class="inpaint-btn" title="Inpaint">🎨</button>
                        <button type="button" class="enhance-btn" title="Enhance (NAI)" style="display: none;">✨</button>
                        <button type="button" class="load-settings-btn" title="전체 설정 불러오기">📋</button>
                    </div>
                    <div class="seed">${data.metadata ? 'Seed: ' + data.seed : '메타데이터 없음'}</div>
                </div>
            `;

            // 이미지 데이터 저장 (갤러리 저장용 + 설정 불러오기용)
            // metadata가 null이면 seed/prompt도 null로 처리 (strip_metadata 옵션)
            const hasMetadata = !!data.metadata;
            card._imageData = {
                image_path: data.image_path || null,
                image: data.image || null,  // 하위 호환
                filename: data.filename,
                seed: hasMetadata ? data.seed : null,
                prompt: hasMetadata ? (data.prompt || '') : null,
                metadata: data.metadata || null  // 전체 설정 메타데이터
            };

            // 갤러리 저장/제거 토글 버튼
            const saveBtn = card.querySelector('.save-gallery-btn');
            saveBtn.onclick = async (e) => {
                e.stopPropagation();

                // 이미 저장된 경우 갤러리에서 제거
                if (saveBtn.classList.contains('saved')) {
                    try {
                        const galleryFilename = card._imageData.galleryFilename || card._imageData.filename;
                        const response = await fetch(`${API_BASE}/api/gallery/${encodeURIComponent(galleryFilename)}`, {
                            method: 'DELETE'
                        });
                        const result = await response.json();
                        if (result.success) {
                            saveBtn.classList.remove('saved');
                            saveBtn.textContent = '☆';
                            card._imageData.galleryFilename = null;
                            showToast('갤러리에서 제거됨', 'success');
                            // 갤러리 캐시 무효화
                            window.galleryInitialized = false;
                            // 갤러리 뷰 새로고침
                            if (currentMode === 'gallery') {
                                loadGallery();
                            }
                        } else {
                            showToast('제거 실패: ' + result.error, 'error');
                        }
                    } catch (err) {
                        showToast('제거 오류: ' + err.message, 'error');
                    }
                    return;
                }

                // 저장되지 않은 경우 갤러리에 저장
                try {
                    // 현재 열린 갤러리 폴더에 저장
                    const response = await fetch(`${API_BASE}/api/gallery/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image: card._imageData.image,  // base64 (하위 호환)
                            image_path: card._imageData.image_path,  // 파일 경로
                            filename: card._imageData.filename,
                            folder: currentGalleryFolder || '',  // 현재 갤러리 폴더
                            metadata: card._imageData.metadata  // 메타데이터 (JPG/WebP 저장 시 필요)
                        })
                    });
                    const result = await response.json();
                    if (result.success) {
                        saveBtn.classList.add('saved');
                        saveBtn.textContent = '★';
                        card._imageData.galleryFilename = result.filename || card._imageData.filename;
                        showToast('갤러리에 저장됨', 'success');
                        // 갤러리 캐시 무효화
                        window.galleryInitialized = false;
                    } else {
                        showToast('저장 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('저장 오류: ' + err.message, 'error');
                }
            };

            // 설정 불러오기 버튼 - dropModal 사용
            const loadSettingsBtn = card.querySelector('.load-settings-btn');
            loadSettingsBtn.onclick = async (e) => {
                e.stopPropagation();
                const metadata = card._imageData.metadata;
                // 이미지 base64 가져오기
                let imageBase64 = card._imageData.image;
                if (!imageBase64 && card._imageData.image_path) {
                    try {
                        const response = await fetch(`${API_BASE}/api/outputs/${card._imageData.image_path}`);
                        const blob = await response.blob();
                        imageBase64 = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result.split(',')[1]);
                            reader.readAsDataURL(blob);
                        });
                    } catch (err) {
                        console.error('이미지 로드 실패:', err);
                    }
                }
                if (imageBase64) {
                    showGalleryDropModal(imageBase64, metadata, card._imageData.image_path || 'output.png');
                } else {
                    showToast('이미지를 불러올 수 없습니다', 'error');
                }
            };

            // Inpaint 버튼
            const inpaintBtn = card.querySelector('.inpaint-btn');
            inpaintBtn.onclick = async (e) => {
                e.stopPropagation();
                // 이미지 base64 가져오기
                let imageBase64 = card._imageData.image;
                if (!imageBase64 && card._imageData.image_path) {
                    // 파일 경로에서 이미지 로드 (outputs API 사용)
                    try {
                        const response = await fetch(`${API_BASE}/api/outputs/${card._imageData.image_path}`);
                        const blob = await response.blob();
                        imageBase64 = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result.split(',')[1]);
                            reader.readAsDataURL(blob);
                        });
                    } catch (err) {
                        showToast('이미지 로드 실패', 'error');
                        return;
                    }
                }
                if (imageBase64) {
                    setBaseImageForInpaint('data:image/png;base64,' + imageBase64);
                } else {
                    showToast('이미지 데이터가 없습니다', 'error');
                }
            };

            // Enhance 버튼 (NAI 전용)
            const enhanceBtn = card.querySelector('.enhance-btn');
            // NAI 모드일 때만 표시
            if (currentProvider === 'nai') {
                enhanceBtn.style.display = 'inline-block';
            }
            enhanceBtn.onclick = async (e) => {
                e.stopPropagation();
                // 이미지 base64 가져오기
                let imageBase64 = card._imageData.image;
                if (!imageBase64 && card._imageData.image_path) {
                    try {
                        const response = await fetch(`${API_BASE}/api/outputs/${card._imageData.image_path}`);
                        const blob = await response.blob();
                        imageBase64 = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result.split(',')[1]);
                            reader.readAsDataURL(blob);
                        });
                    } catch (err) {
                        showToast('이미지 로드 실패', 'error');
                        return;
                    }
                }
                if (imageBase64) {
                    openEnhanceModal('data:image/png;base64,' + imageBase64, card._imageData.metadata);
                } else {
                    showToast('이미지 데이터가 없습니다', 'error');
                }
            };

            // 미리보기 지우기 버튼
            const clearCardBtn = card.querySelector('.clear-card-btn');
            clearCardBtn.onclick = (e) => {
                e.stopPropagation();
                card.remove();
            };

            // 파일 삭제 버튼
            const deleteFileBtn = card.querySelector('.delete-file-btn');
            deleteFileBtn.onclick = async (e) => {
                e.stopPropagation();
                const imagePath = card._imageData?.image_path;
                const filename = card._imageData?.filename;

                if (!imagePath) {
                    showToast('파일 경로 정보가 없습니다', 'error');
                    return;
                }

                const doDelete = async () => {
                    try {
                        const response = await fetch(`${API_BASE}/api/outputs/${encodeURIComponent(imagePath)}`, {
                            method: 'DELETE'
                        });
                        const result = await response.json();

                        if (result.success) {
                            card.remove();
                            showToast('파일이 삭제되었습니다', 'success');
                        } else {
                            showToast('삭제 실패: ' + (result.error || 'Unknown error'), 'error');
                        }
                    } catch (err) {
                        showToast('삭제 오류: ' + err.message, 'error');
                    }
                };

                const skipConfirm = sessionStorage.getItem('skipSlotDeleteConfirm') === 'true';
                if (skipConfirm) {
                    doDelete();
                } else {
                    showConfirmModal(
                        '🗑️ 파일 삭제',
                        `<p>파일을 삭제하시겠습니까?</p><p style="color: var(--text-dim); font-size: 12px; word-break: break-all;">${filename}</p>`,
                        (dontAskAgain) => {
                            if (dontAskAgain) {
                                sessionStorage.setItem('skipSlotDeleteConfirm', 'true');
                            }
                            doDelete();
                        },
                        '삭제',
                        true,
                        '앞으로 묻지 않음'
                    );
                }
            };

            // 드래그와 클릭 구분
            const img = card.querySelector('img');
            let imgMouseDownX = 0;
            let imgMouseDownY = 0;

            img.addEventListener('mousedown', (e) => {
                imgMouseDownX = e.clientX;
                imgMouseDownY = e.clientY;
            });

            img.addEventListener('mouseup', (e) => {
                const dx = Math.abs(e.clientX - imgMouseDownX);
                const dy = Math.abs(e.clientY - imgMouseDownY);
                // 5px 이내면 클릭으로 간주
                if (dx < 5 && dy < 5) {
                    lightboxImg.src = imgSrc;  // URL 또는 base64 사용
                    lightboxCurrentSlot = targetSlot;
                    lightboxCurrentCard = card;
                    lightbox.classList.add('active');
                }
            });

            // 이미지 로드 완료 후 카드 추가 (이미지와 info가 동시에 표시되도록)
            const insertCard = () => {
                imagesContainer.insertBefore(card, imagesContainer.firstChild);
                console.log(`[addImageToSlot] Card inserted for ${data.filename}`);
            };
            img.onload = insertCard;
            img.onerror = insertCard;  // 로드 실패 시에도 카드 표시
        }

        function clearSlotImages() {
            const slots = slotsContainer.querySelectorAll('.slot');
            slots.forEach(slot => {
                const imagesContainer = slot.querySelector('.slot-images');
                imagesContainer.innerHTML = '<div class="slot-empty">이미지가 여기에 표시됩니다</div>';
            });
        }
        
        addSlotBtn.onclick = () => {
            addSlot();
            autoSaveSettings();
        };
        
        // === Preset System ===
        const presetDropdown = document.getElementById('presetDropdown');
        const presetBtn = document.getElementById('presetBtn');
        const presetMenu = document.getElementById('presetMenu');
        const presetList = document.getElementById('presetList');
        const presetNameSpan = document.getElementById('presetName');
        const newPresetBtn = document.getElementById('newPresetBtn');
        const savePresetBtn = document.getElementById('savePresetBtn');
        
        let currentPreset = null; // { filename, name }
        let presets = [];
        
        // 드롭다운 토글 (body에 붙여서 overflow 문제 해결)
        presetBtn.onclick = (e) => {
            e.stopPropagation();
            const isShowing = presetMenu.classList.contains('show');

            if (isShowing) {
                presetMenu.classList.remove('show');
                presetDropdown.appendChild(presetMenu); // 원래 위치로
            } else {
                // body에 붙이고 위치 계산
                document.body.appendChild(presetMenu);
                const btnRect = presetBtn.getBoundingClientRect();
                presetMenu.style.top = (btnRect.bottom + 4) + 'px';
                presetMenu.style.left = btnRect.left + 'px';
                presetMenu.classList.add('show');
                loadPresetList();
            }
        };

        // 외부 클릭 시 닫기
        document.addEventListener('click', (e) => {
            if (!presetDropdown.contains(e.target) && !presetMenu.contains(e.target)) {
                presetMenu.classList.remove('show');
                if (presetMenu.parentElement === document.body) {
                    presetDropdown.appendChild(presetMenu);
                }
            }
        });
        
        // 프리셋 목록 로드
        async function loadPresetList() {
            try {
                const res = await fetch(`${API_BASE}/api/presets`);
                const data = await res.json();
                presets = data.presets;
                renderPresetList();
            } catch (e) {
                console.error('Failed to load presets:', e);
            }
        }
        
        // 프리셋 목록 렌더링
        function renderPresetList() {
            if (presets.length === 0) {
                presetList.innerHTML = '<div class="preset-empty">No presets saved</div>';
                return;
            }
            
            presetList.innerHTML = presets.map(p => `
                <div class="preset-item ${currentPreset?.filename === p.filename ? 'selected' : ''}" data-filename="${p.filename}">
                    <span class="check">${currentPreset?.filename === p.filename ? '✓' : ''}</span>
                    <span class="label">${p.name}</span>
                    <button class="edit-btn" title="이름 변경">✏️</button>
                    <button class="delete-btn" title="삭제">🗑️</button>
                </div>
            `).join('');
            
            // 이벤트 바인딩
            presetList.querySelectorAll('.preset-item').forEach(item => {
                const filename = item.dataset.filename;
                
                item.querySelector('.label').onclick = () => loadPreset(filename);
                
                item.querySelector('.edit-btn').onclick = (e) => {
                    e.stopPropagation();
                    renamePreset(filename);
                };
                
                item.querySelector('.delete-btn').onclick = (e) => {
                    e.stopPropagation();
                    deletePreset(filename);
                };
            });
        }
        
        // 프리셋 로드
        async function loadPreset(filename) {
            try {
                const res = await fetch(`${API_BASE}/api/presets/${filename}`);
                const data = await res.json();
                
                // 현재 슬롯 모두 제거
                slotsContainer.innerHTML = '';
                
                // 프리셋 슬롯들로 교체
                data.slots.forEach(s => {
                    addSlot(s.name, s.content);
                });
                
                // 최소 1개 슬롯
                if (data.slots.length === 0) {
                    addSlot();
                }
                
                // 폴더 적용
                setOutputFolder(data.folder || '');
                
                currentPreset = { filename, name: data.name };
                presetNameSpan.textContent = data.name;
                presetMenu.classList.remove('show');
                
                showToast(`Loaded: ${data.name}`, 'success');
            } catch (e) {
                showToast('프리셋 로드 실패', 'error');
            }
        }
        
        // 새 프리셋 저장
        newPresetBtn.onclick = async () => {
            const name = prompt('프리셋 이름 입력:');
            if (!name) return;
            
            const slots = getSlotList().map(s => ({ name: s.name, content: s.content }));
            const folder = getOutputFolder();

            try {
                const res = await fetch(`${API_BASE}/api/presets`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, slots, folder })
                });
                const data = await res.json();
                
                currentPreset = { filename: data.filename, name: data.name };
                presetNameSpan.textContent = data.name;
                
                loadPresetList();
                showToast(`Saved: ${name}`, 'success');
            } catch (e) {
                showToast('프리셋 저장 실패', 'error');
            }
        };
        
        // 현재 프리셋에 덮어쓰기
        savePresetBtn.onclick = async () => {
            if (!currentPreset) {
                showToast('프리셋이 선택되지 않음', 'warning');
                return;
            }
            
            const slots = getSlotList().map(s => ({ name: s.name, content: s.content }));
            const folder = getOutputFolder();

            try {
                await fetch(`${API_BASE}/api/presets/${currentPreset.filename}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: currentPreset.name, slots, folder })
                });
                
                showToast(`Saved: ${currentPreset.name}`, 'success');
                presetMenu.classList.remove('show');
            } catch (e) {
                showToast('프리셋 저장 실패', 'error');
            }
        };
        
        // 프리셋 이름 변경
        async function renamePreset(filename) {
            const preset = presets.find(p => p.filename === filename);
            if (!preset) return;
            
            const newName = prompt('Enter new name:', preset.name);
            if (!newName || newName === preset.name) return;
            
            try {
                // 기존 데이터 로드
                const res = await fetch(`${API_BASE}/api/presets/${filename}`);
                const data = await res.json();
                
                // 이름만 변경해서 저장 (prefix 유지)
                await fetch(`${API_BASE}/api/presets/${filename}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName, slots: data.slots, prefix: data.prefix || 'Name_' })
                });
                
                if (currentPreset?.filename === filename) {
                    currentPreset.name = newName;
                    presetNameSpan.textContent = newName;
                }
                
                loadPresetList();
                showToast('이름 변경됨', 'success');
            } catch (e) {
                showToast('이름 변경 실패', 'error');
            }
        }
        
        // 프리셋 삭제
        async function deletePreset(filename) {
            const preset = presets.find(p => p.filename === filename);
            if (!preset) return;

            showConfirmModal(
                '🗑️ 프리셋 삭제',
                `<p>"${preset.name}" 프리셋을 삭제하시겠습니까?</p>`,
                async () => {
                    try {
                        await fetch(`${API_BASE}/api/presets/${filename}`, { method: 'DELETE' });

                        if (currentPreset?.filename === filename) {
                            currentPreset = null;
                            presetNameSpan.textContent = 'Slot Set';
                        }

                        loadPresetList();
                        showToast('삭제됨', 'success');
                    } catch (e) {
                        showToast('삭제 실패', 'error');
                    }
                },
                '삭제',
                true
            );
        }

        // ============================================================
        // Output Folder Dropdown
        // ============================================================
        const outputFolderDropdown = document.getElementById('outputFolderDropdown');
        const outputFolderBtn = document.getElementById('outputFolderBtn');
        const outputFolderMenu = document.getElementById('outputFolderMenu');
        const outputFolderList = document.getElementById('outputFolderList');
        const outputFolderName = document.getElementById('outputFolderName');
        const outputFolderIcon = outputFolderBtn.querySelector('.folder-icon');

        let currentOutputFolder = ''; // 빈 문자열 = output 루트

        // 현재 선택된 폴더 반환 (API 호출 시 사용)
        function getOutputFolder() {
            return currentOutputFolder;
        }

        // 폴더 선택 시 UI 업데이트
        function setOutputFolder(folderName) {
            currentOutputFolder = folderName;
            outputFolderName.textContent = folderName || 'output';
            outputFolderIcon.textContent = '📁';
            autoSaveSettings();
        }

        // 폴더 드롭다운 토글
        outputFolderBtn.onclick = (e) => {
            e.stopPropagation();
            const isShowing = outputFolderMenu.classList.contains('show');

            if (isShowing) {
                outputFolderMenu.classList.remove('show');
                outputFolderDropdown.appendChild(outputFolderMenu);
            } else {
                document.body.appendChild(outputFolderMenu);
                const btnRect = outputFolderBtn.getBoundingClientRect();
                outputFolderMenu.style.top = (btnRect.bottom + 4) + 'px';
                outputFolderMenu.style.right = (window.innerWidth - btnRect.right) + 'px';
                outputFolderMenu.style.left = 'auto';
                outputFolderMenu.classList.add('show');
                loadOutputFolderList();
            }
        };

        // 외부 클릭 시 닫기
        document.addEventListener('click', (e) => {
            if (!outputFolderDropdown.contains(e.target) && !outputFolderMenu.contains(e.target)) {
                outputFolderMenu.classList.remove('show');
                if (outputFolderMenu.parentElement === document.body) {
                    outputFolderDropdown.appendChild(outputFolderMenu);
                }
            }
        });

        // 폴더 목록 로드
        async function loadOutputFolderList() {
            try {
                const res = await fetch(`${API_BASE}/api/output-folders`);
                const data = await res.json();
                renderOutputFolderList(data.folders || []);
            } catch (e) {
                console.error('Failed to load output folders:', e);
                renderOutputFolderList([]);
            }
        }

        // 폴더 목록 렌더링
        function renderOutputFolderList(folders) {
            const isRootSelected = currentOutputFolder === '';

            let html = `
                <div class="folder-item root-folder ${isRootSelected ? 'active' : ''}" data-folder="">
                    <span>${isRootSelected ? '📂' : '📁'}</span>
                    <span>output</span>
                </div>
            `;

            folders.forEach(folder => {
                const isSelected = currentOutputFolder === folder.name;
                html += `
                    <div class="folder-item subfolder ${isSelected ? 'active' : ''}" data-folder="${folder.name}">
                        <span>${isSelected ? '📂' : '📁'}</span>
                        <span>${folder.name}</span>
                        <span style="margin-left: auto; opacity: 0.6; font-size: 0.75rem;">${folder.image_count}</span>
                    </div>
                `;
            });

            outputFolderList.innerHTML = html;

            // 폴더 클릭 이벤트
            outputFolderList.querySelectorAll('.folder-item').forEach(item => {
                item.onclick = () => {
                    setOutputFolder(item.dataset.folder);
                    outputFolderMenu.classList.remove('show');
                    outputFolderDropdown.appendChild(outputFolderMenu);
                };
            });
        }

        // 새 폴더 생성
        document.getElementById('newOutputFolderBtn').onclick = () => {
            outputFolderMenu.classList.remove('show');
            outputFolderDropdown.appendChild(outputFolderMenu);

            showInputModal('📁 새 폴더', '폴더 이름을 입력하세요', async (folderName) => {
                try {
                    const response = await fetch(`${API_BASE}/api/output-folders`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: folderName })
                    });
                    const result = await response.json();
                    if (result.success) {
                        setOutputFolder(result.name);
                        showToast(`폴더 생성: ${result.name}`, 'success');
                    } else {
                        showToast(result.error || '폴더 생성 실패', 'error');
                    }
                } catch (err) {
                    showToast('폴더 생성 오류', 'error');
                }
            }, '생성');
        };

        // 세트 저장 버튼 - 현재 슬롯에 표시된 이미지들을 폴더로 저장
        document.getElementById('saveImageSetBtn').onclick = async () => {
            // 모든 슬롯에서 표시된 이미지 경로 수집
            const imagePaths = [];
            slotsContainer.querySelectorAll('.slot').forEach(slot => {
                const imagesContainer = slot.querySelector('.slot-images');
                imagesContainer.querySelectorAll('.slot-image-card').forEach(card => {
                    if (card._imageData && card._imageData.image_path) {
                        imagePaths.push(card._imageData.image_path);
                    }
                });
            });

            if (imagePaths.length === 0) {
                showToast('저장할 이미지가 없습니다', 'warning');
                return;
            }

            try {
                showToast('폴더를 선택하세요...', 'info');
                const response = await fetch(`${API_BASE}/api/save-image-set`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image_paths: imagePaths })
                });
                const result = await response.json();

                if (result.cancelled) {
                    showToast('저장 취소됨', 'warning');
                } else if (result.success) {
                    showToast(`${result.saved_count}개 이미지 저장됨`, 'success');
                } else {
                    showToast(result.error || '저장 실패', 'error');
                }
            } catch (err) {
                showToast('저장 오류: ' + err.message, 'error');
            }
        };

        // Sync scroll 토글
        const syncScrollBtn = document.getElementById('syncScrollBtn');
        let syncScrollEnabled = false;
        let isSyncScrolling = false;
        
        syncScrollBtn.onclick = () => {
            syncScrollEnabled = !syncScrollEnabled;
            syncScrollBtn.classList.toggle('active', syncScrollEnabled);
        };
        
        function setupSlotImageScroll(slot) {
            const imagesContainer = slot.querySelector('.slot-images');
            
            imagesContainer.addEventListener('scroll', () => {
                if (!syncScrollEnabled || isSyncScrolling) return;
                
                isSyncScrolling = true;
                const scrollTop = imagesContainer.scrollTop;
                const scrollRatio = imagesContainer.scrollTop / (imagesContainer.scrollHeight - imagesContainer.clientHeight || 1);
                
                // 다른 모든 슬롯의 이미지 영역도 같이 스크롤
                slotsContainer.querySelectorAll('.slot').forEach(otherSlot => {
                    if (otherSlot === slot) return;
                    const otherImages = otherSlot.querySelector('.slot-images');
                    const maxScroll = otherImages.scrollHeight - otherImages.clientHeight;
                    otherImages.scrollTop = scrollRatio * maxScroll;
                });
                
                setTimeout(() => { isSyncScrolling = false; }, 10);
            });
        }
        
        // 스크롤 그라데이션 업데이트
        const slotsWrapper = document.getElementById('slotsWrapper');
        
        function updateScrollGradients() {
            const { scrollLeft, scrollWidth, clientWidth } = slotsContainer;
            const canScrollLeft = scrollLeft > 5;
            const canScrollRight = scrollLeft < scrollWidth - clientWidth - 5;
            
            slotsWrapper.classList.toggle('can-scroll-left', canScrollLeft);
            slotsWrapper.classList.toggle('can-scroll-right', canScrollRight);
        }
        
        slotsContainer.addEventListener('scroll', updateScrollGradients);
        // 초기화 및 슬롯 추가/삭제 시 업데이트를 위한 observer
        const resizeObserver = new ResizeObserver(updateScrollGradients);
        resizeObserver.observe(slotsContainer);
        
        // 가로 스크롤 드래그 (오버스크롤 바운스 포함)
        let isScrollDragging = false;
        let scrollStartX = 0;
        let scrollLeft = 0;
        let overscrollOffset = 0;
        
        slotsContainer.addEventListener('mousedown', (e) => {
            // 텍스트 입력란, 버튼, 드래그 핸들만 제외
            if (e.target.tagName === 'INPUT' || 
                e.target.tagName === 'TEXTAREA' || 
                e.target.tagName === 'BUTTON' ||
                e.target.classList.contains('slot-drag') ||
                e.target.classList.contains('slot-delete')) {
                return;
            }
            
            isScrollDragging = true;
            scrollStartX = e.pageX - slotsContainer.offsetLeft;
            scrollLeft = slotsContainer.scrollLeft;
            overscrollOffset = 0;
            slotsContainer.style.cursor = 'grabbing';
            slotsContainer.style.transition = 'none';
        });
        
        slotsContainer.addEventListener('mousemove', (e) => {
            if (!isScrollDragging) return;
            e.preventDefault();
            const x = e.pageX - slotsContainer.offsetLeft;
            const walk = (x - scrollStartX) * 1.5;
            
            const maxScroll = slotsContainer.scrollWidth - slotsContainer.clientWidth;
            const newScrollLeft = scrollLeft - walk;
            
            // 스크롤 가능 범위 체크
            if (maxScroll <= 0) {
                // 스크롤 불가 - 오버스크롤 효과만
                overscrollOffset = walk * 0.3; // 저항감 있게
                overscrollOffset = Math.max(-50, Math.min(50, overscrollOffset));
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else if (newScrollLeft < 0) {
                // 왼쪽 끝 넘어감
                slotsContainer.scrollLeft = 0;
                overscrollOffset = -newScrollLeft * 0.3;
                overscrollOffset = Math.min(50, overscrollOffset);
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else if (newScrollLeft > maxScroll) {
                // 오른쪽 끝 넘어감
                slotsContainer.scrollLeft = maxScroll;
                overscrollOffset = -(newScrollLeft - maxScroll) * 0.3;
                overscrollOffset = Math.max(-50, overscrollOffset);
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else {
                // 정상 스크롤
                slotsContainer.scrollLeft = newScrollLeft;
                overscrollOffset = 0;
                slotsContainer.style.transform = '';
            }
        });
        
        function endScrollDrag() {
            if (!isScrollDragging) return;
            isScrollDragging = false;
            slotsContainer.style.cursor = '';
            
            // 오버스크롤 바운스백
            if (overscrollOffset !== 0) {
                slotsContainer.style.transition = 'transform 0.3s ease-out';
                slotsContainer.style.transform = '';
                overscrollOffset = 0;
            }
        }
        
        slotsContainer.addEventListener('mouseup', endScrollDrag);
        slotsContainer.addEventListener('mouseleave', endScrollDrag);
        
        // Tab switching
        let localEnvInstalled = false;  // Local 환경 설치 여부
        
        // Provider별 Generation 설정 저장소
        let naiGenerationSettings = { steps: 28, cfg: 6, sampler: 'k_euler_ancestral', scheduler: 'karras' };
        let localGenerationSettings = { steps: 20, cfg: 7, sampler: 'euler_ancestral', scheduler: 'normal' };
        
        // 현재 provider의 Generation 설정 저장
        function saveCurrentProviderGenerationSettings() {
            const settings = {
                steps: document.getElementById('steps').value,
                cfg: document.getElementById('cfg').value,
                sampler: document.getElementById('sampler').value,
                scheduler: document.getElementById('scheduler').value
            };
            if (currentProvider === 'nai') {
                naiGenerationSettings = settings;
            } else {
                localGenerationSettings = settings;
            }
        }
        
        // 특정 provider의 Generation 설정 복원
        function restoreProviderGenerationSettings(provider) {
            const settings = provider === 'nai' ? naiGenerationSettings : localGenerationSettings;
            document.getElementById('steps').value = settings.steps;
            document.getElementById('cfg').value = settings.cfg;
            // 샘플러/스케줄러는 옵션이 바뀌므로 옵션 업데이트 후 설정
            updateSamplerSchedulerOptions(provider);
            document.getElementById('sampler').value = settings.sampler;
            document.getElementById('scheduler').value = settings.scheduler;
        }
        
        // NAI / Local 샘플러/스케줄러 옵션
        const NAI_SAMPLERS = [
            { value: 'k_euler_ancestral', label: 'Euler Ancestral' },
            { value: 'k_euler', label: 'Euler' },
            { value: 'k_dpmpp_2s_ancestral', label: 'DPM++ 2S Ancestral' },
            { value: 'k_dpmpp_2m_sde', label: 'DPM++ 2M SDE' },
            { value: 'k_dpmpp_2m', label: 'DPM++ 2M' },
            { value: 'k_dpmpp_sde', label: 'DPM++ SDE' },
        ];
        const NAI_SCHEDULERS = [
            { value: 'karras', label: 'Karras' },
            { value: 'exponential', label: 'Exponential' },
            { value: 'polyexponential', label: 'Polyexponential' },
        ];
        const LOCAL_SAMPLERS = [
            { value: 'euler_ancestral', label: 'Euler Ancestral' },
            { value: 'euler', label: 'Euler' },
            { value: 'dpmpp_2m', label: 'DPM++ 2M' },
        ];
        const LOCAL_SCHEDULERS = [
            { value: 'normal', label: 'Normal' },
            { value: 'karras', label: 'Karras' },
            { value: 'exponential', label: 'Exponential' },
            { value: 'sgm_uniform', label: 'SGM Uniform' },
            { value: 'simple', label: 'Simple' },
            { value: 'ddim_uniform', label: 'DDIM Uniform' },
            { value: 'beta', label: 'Beta' },
        ];
        
        function updateSamplerSchedulerOptions(provider) {
            const samplerSelect = document.getElementById('sampler');
            const schedulerSelect = document.getElementById('scheduler');
            
            const samplers = provider === 'nai' ? NAI_SAMPLERS : LOCAL_SAMPLERS;
            const schedulers = provider === 'nai' ? NAI_SCHEDULERS : LOCAL_SCHEDULERS;
            
            // 현재 선택 저장
            const currentSampler = samplerSelect.value;
            const currentScheduler = schedulerSelect.value;
            
            // 옵션 교체
            samplerSelect.innerHTML = samplers.map(s => 
                `<option value="${s.value}">${s.label}</option>`
            ).join('');
            schedulerSelect.innerHTML = schedulers.map(s => 
                `<option value="${s.value}">${s.label}</option>`
            ).join('');
            
            // 기존 선택 복원 시도, 없으면 첫 번째
            if (samplers.some(s => s.value === currentSampler)) {
                samplerSelect.value = currentSampler;
            }
            if (schedulers.some(s => s.value === currentScheduler)) {
                schedulerSelect.value = currentScheduler;
            }
        }
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Local 탭 클릭 시 설치 안 됐으면 팝업
                if (tab.dataset.provider === 'local' && !localEnvInstalled) {
                    showLocalInstallModal();
                    return;
                }
                
                // 같은 탭 클릭 시 무시
                if (tab.dataset.provider === currentProvider) return;

                // 현재 provider의 모든 설정 저장
                const currentSettings = collectCurrentProviderSettings();
                if (currentProvider === 'nai') {
                    naiSettings = currentSettings;
                } else {
                    localSettings = currentSettings;
                }
                // Generation 설정도 동기화
                saveCurrentProviderGenerationSettings();
                
                // Provider 전환
                const newProvider = tab.dataset.provider;
                currentProvider = newProvider;
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                providerSections.forEach(s => {
                    s.classList.toggle('active', s.dataset.provider === currentProvider);
                });
                
                // 새 provider의 전체 설정 복원
                const newSettings = currentProvider === 'nai' ? naiSettings : localSettings;
                applyProviderSettings(newSettings, true);
                
                // Generation 설정도 복원 (샘플러/스케줄러 옵션 포함)
                restoreProviderGenerationSettings(currentProvider);
                
                updateAnlasVisibility();
                updateProviderLabels();
                updateBaseImageNoiseVisibility();
                autoSaveSettings();
            });
        });

        // Provider별 라벨 및 제한값 업데이트
        function updateProviderLabels() {
            const cfgLabel = document.getElementById('cfgLabel');
            const stepsInput = document.getElementById('steps');
            const cfgInput = document.getElementById('cfg');

            if (currentProvider === 'nai') {
                if (cfgLabel) cfgLabel.textContent = 'Prompt Guidance';
                // NAI 제한: steps 최대 50, cfg 최대 10
                if (stepsInput) {
                    stepsInput.max = 50;
                    if (parseInt(stepsInput.value) > 50) stepsInput.value = 50;
                }
                if (cfgInput) {
                    cfgInput.max = 10;
                    if (parseFloat(cfgInput.value) > 10) cfgInput.value = 10;
                }
            } else {
                if (cfgLabel) cfgLabel.textContent = 'CFG';
                // Local: 제한 해제
                if (stepsInput) stepsInput.removeAttribute('max');
                if (cfgInput) cfgInput.removeAttribute('max');
            }
        }

        // NAI 제한값 강제 적용 (입력 이벤트)
        function enforceNaiLimits() {
            const stepsInput = document.getElementById('steps');
            const cfgInput = document.getElementById('cfg');

            if (stepsInput) {
                stepsInput.addEventListener('input', () => {
                    if (currentProvider === 'nai' && parseInt(stepsInput.value) > 50) {
                        stepsInput.value = 50;
                    }
                });
            }
            if (cfgInput) {
                cfgInput.addEventListener('input', () => {
                    if (currentProvider === 'nai' && parseFloat(cfgInput.value) > 10) {
                        cfgInput.value = 10;
                    }
                });
            }
        }
        
        // === Prompt Presets ===
        async function loadPromptPresets(category) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}`);
                const data = await res.json();
                return data.presets;
            } catch (e) {
                console.error('Failed to load prompt presets:', e);
                return [];
            }
        }
        
        async function getPromptPreset(category, filename) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}/${filename}`);
                const data = await res.json();
                return data.content;
            } catch (e) {
                console.error('Failed to get prompt preset:', e);
                return null;
            }
        }
        
        async function savePromptPreset(category, name, content) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, content })
                });
                const data = await res.json();
                showToast(`Saved: ${name}`, 'success');
                return data;
            } catch (e) {
                showToast('저장 실패', 'error');
                return null;
            }
        }
        
        async function deletePromptPreset(category, filename) {
            try {
                await fetch(`${API_BASE}/api/prompts/${category}/${filename}`, { method: 'DELETE' });
                showToast('삭제됨', 'success');
                return true;
            } catch (e) {
                showToast('삭제 실패', 'error');
                return false;
            }
        }
        
        function setupPromptPresetDropdown(dropdown, textarea) {
            const category = dropdown.dataset.category;
            const btn = dropdown.querySelector('.prompt-preset-btn');
            const menu = dropdown.querySelector('.prompt-preset-menu');
            const list = dropdown.querySelector('.prompt-preset-list');
            const saveBtn = dropdown.querySelector('.prompt-preset-save-btn');
            
            btn.onclick = async (e) => {
                e.stopPropagation();
                // 다른 메뉴 닫기
                document.querySelectorAll('.prompt-preset-menu.show').forEach(m => {
                    if (m !== menu) m.classList.remove('show');
                });
                menu.classList.toggle('show');
                
                if (menu.classList.contains('show')) {
                    // 목록 로드
                    const presets = await loadPromptPresets(category);
                    if (presets.length === 0) {
                        list.innerHTML = '<div class="prompt-preset-empty">저장된 프리셋 없음</div>';
                    } else {
                        list.innerHTML = presets.map(p => `
                            <div class="prompt-preset-item" data-filename="${p.filename}">
                                <div class="prompt-preset-item-name" title="${p.name}">${p.name}</div>
                                <div class="prompt-preset-item-actions">
                                    <button class="add-btn">Add</button>
                                    <button class="replace-btn">Replace</button>
                                    <button class="delete-btn">🗑️</button>
                                </div>
                            </div>
                        `).join('');
                        
                        // 이벤트 바인딩
                        list.querySelectorAll('.prompt-preset-item').forEach(item => {
                            const filename = item.dataset.filename;
                            
                            item.querySelector('.add-btn').onclick = async (e) => {
                                e.stopPropagation();
                                const content = await getPromptPreset(category, filename);
                                if (content !== null) {
                                    if (textarea.value.trim()) {
                                        textarea.value = textarea.value.trim() + '\n\n' + content;
                                    } else {
                                        textarea.value = content;
                                    }
                                    menu.classList.remove('show');
                                }
                            };
                            
                            item.querySelector('.replace-btn').onclick = async (e) => {
                                e.stopPropagation();
                                const content = await getPromptPreset(category, filename);
                                if (content !== null) {
                                    textarea.value = content;
                                    // 하이라이팅 업데이트를 위해 input 이벤트 트리거
                                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                                    menu.classList.remove('show');
                                }
                            };
                            
                            item.querySelector('.delete-btn').onclick = async (e) => {
                                e.stopPropagation();
                                showConfirmModal(
                                    '🗑️ 프리셋 삭제',
                                    '<p>이 프리셋을 삭제하시겠습니까?</p>',
                                    async () => {
                                        if (await deletePromptPreset(category, filename)) {
                                            item.remove();
                                            if (list.querySelectorAll('.prompt-preset-item').length === 0) {
                                                list.innerHTML = '<div class="prompt-preset-empty">저장된 프리셋 없음</div>';
                                            }
                                        }
                                    },
                                    '삭제',
                                    true
                                );
                            };
                        });
                    }
                }
            };
            
            saveBtn.onclick = async (e) => {
                e.stopPropagation();
                const content = textarea.value.trim();
                if (!content) {
                    showToast('저장할 내용 없음', 'warning');
                    return;
                }
                const name = prompt('프리셋 이름 입력:');
                if (!name) return;
                
                if (await savePromptPreset(category, name, content)) {
                    menu.classList.remove('show');
                }
            };
        }
        
        // Base/Negative 프롬프트 프리셋 초기화
        document.querySelectorAll('.section > .prompt-label-row .prompt-preset-dropdown').forEach(dropdown => {
            const category = dropdown.dataset.category;
            let textarea;
            if (category === 'base') {
                textarea = document.getElementById('basePrompt');
            } else if (category === 'negative') {
                textarea = document.getElementById('negativePrompt');
            }
            if (textarea) {
                setupPromptPresetDropdown(dropdown, textarea);
            }
        });
        
        // 외부 클릭 시 프롬프트 프리셋 메뉴 닫기
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.prompt-preset-dropdown')) {
                document.querySelectorAll('.prompt-preset-menu.show').forEach(m => m.classList.remove('show'));
            }
        });
        
        // === Characters ===
        const charactersList = document.getElementById('charactersList');
        const addCharBtn = document.getElementById('addCharBtn');
        
        function createCharacterItem(content = '', collapsed = false, enabled = true) {
            const item = document.createElement('div');
            item.className = 'character-item' + (enabled ? '' : ' disabled');

            // 헤더 (접기 + on/off + 번호 + 프리셋 + 삭제)
            const header = document.createElement('div');
            header.className = 'character-item-header';

            // 드래그 핸들
            const dragHandle = document.createElement('button');
            dragHandle.type = 'button';
            dragHandle.className = 'char-drag';
            dragHandle.innerHTML = '☰';
            dragHandle.title = '드래그하여 순서 변경';

            // 접기 버튼
            const collapseBtn = document.createElement('button');
            collapseBtn.type = 'button';
            collapseBtn.className = 'collapse-toggle' + (collapsed ? ' collapsed' : '');
            collapseBtn.textContent = '▼';
            collapseBtn.title = '접기/펼치기';

            // On/Off 토글
            const enableToggle = document.createElement('input');
            enableToggle.type = 'checkbox';
            enableToggle.className = 'char-enable-toggle';
            enableToggle.checked = enabled;
            enableToggle.title = enabled ? '활성화됨 (클릭하여 비활성화)' : '비활성화됨 (클릭하여 활성화)';
            enableToggle.onchange = () => {
                item.classList.toggle('disabled', !enableToggle.checked);
                enableToggle.title = enableToggle.checked ? '활성화됨 (클릭하여 비활성화)' : '비활성화됨 (클릭하여 활성화)';
                autoSaveSettings();
            };

            const charNum = document.createElement('span');
            charNum.className = 'char-num';

            // 프리셋 드롭다운
            const presetDropdown = document.createElement('div');
            presetDropdown.className = 'prompt-preset-dropdown';
            presetDropdown.dataset.category = 'character';
            presetDropdown.innerHTML = `
                <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">🔖 ▼</button>
                <div class="prompt-preset-menu">
                    <div class="prompt-preset-list"></div>
                    <div class="prompt-preset-actions">
                        <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                    </div>
                </div>
            `;

            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'delete-char-btn';
            deleteBtn.textContent = '×';
            deleteBtn.onclick = () => {
                item.remove();
                updateCharacterNumbers();
                autoSaveSettings();
            };

            header.appendChild(dragHandle);
            header.appendChild(collapseBtn);
            header.appendChild(enableToggle);
            header.appendChild(charNum);
            header.appendChild(presetDropdown);
            header.appendChild(deleteBtn);

            // 프롬프트 입력 (접을 수 있는 영역)
            const contentDiv = document.createElement('div');
            contentDiv.className = 'collapsible-content' + (collapsed ? ' collapsed' : '');

            const textarea = document.createElement('textarea');
            textarea.value = content;
            textarea.placeholder = 'Character prompt...';
            textarea.rows = 2;

            // content가 있으면 나중에 input 이벤트 트리거
            if (content) {
                setTimeout(() => {
                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                }, 50);
            }

            contentDiv.appendChild(textarea);

            // 드래그 핸들 이벤트
            dragHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startCharDrag(item, e);
            });

            // 헤더 바 전체 클릭으로 접기/펴기
            header.addEventListener('click', (e) => {
                // 체크박스, 프리셋, 삭제, 드래그 버튼 클릭은 무시
                if (e.target.closest('.char-enable-toggle, .prompt-preset-dropdown, .delete-char-btn, .char-drag')) return;
                collapseBtn.classList.toggle('collapsed');
                contentDiv.classList.toggle('collapsed');
                autoSaveSettings();
            });

            item.appendChild(header);
            item.appendChild(contentDiv);

            // 프리셋 드롭다운 이벤트 연결
            setupPromptPresetDropdown(presetDropdown, textarea);

            // 태그 자동완성 설정
            setupTagAutocomplete(textarea);

            // 프롬프트 가중치 하이라이팅 설정
            setupPromptHighlighting(textarea);

            return item;
        }
        
        function updateCharacterNumbers() {
            const items = charactersList.querySelectorAll('.character-item');
            items.forEach((item, index) => {
                item.querySelector('.char-num').textContent = index + 1;
            });
            // 최대 6개 제한
            updateAddCharBtn();
        }
        
        function updateAddCharBtn() {
            const count = charactersList.querySelectorAll('.character-item').length;
            addCharBtn.disabled = count >= 6;
            addCharBtn.title = count >= 6 ? 'Maximum 6 characters' : 'Add character';
        }
        
        function addCharacter(content = '') {
            const count = charactersList.querySelectorAll('.character-item').length;
            if (count >= 6) {
                showToast('최대 6개의 캐릭터까지 가능', 'warning');
                return;
            }
            // Characters 섹션이 접혀있으면 펼치기
            const charactersContent = document.getElementById('charactersContent');
            if (charactersContent.classList.contains('collapsed')) {
                charactersContent.classList.remove('collapsed');
                // 토글 버튼 상태도 동기화
                const toggleBtn = document.querySelector('[data-target="charactersContent"]');
                if (toggleBtn) {
                    toggleBtn.classList.remove('collapsed');
                    localStorage.setItem('collapse_charactersContent', 'expanded');
                }
            }
            const item = createCharacterItem(content);
            charactersList.appendChild(item);
            updateCharacterNumbers();
            item.querySelector('textarea').focus();
        }
        
        function getCharacterPrompts() {
            const items = charactersList.querySelectorAll('.character-item');
            return Array.from(items)
                .filter(item => item.querySelector('.char-enable-toggle').checked)  // enabled만
                .map(item => item.querySelector('textarea').value)
                .filter(v => v.trim());
        }

        function getCharacterPromptsWithLayout() {
            const items = charactersList.querySelectorAll('.character-item');
            return Array.from(items).map(item => ({
                content: item.querySelector('textarea').value,
                collapsed: item.querySelector('.collapsible-content').classList.contains('collapsed'),
                height: item.querySelector('textarea').style.height || null,
                enabled: item.querySelector('.char-enable-toggle').checked
            }));
        }

        // 캐릭터 드래그 앤 드롭
        let draggedChar = null;
        let dragStartY = 0;
        let charStartY = 0;
        let charPlaceholder = null;

        function startCharDrag(item, e) {
            draggedChar = item;
            dragStartY = e.clientY;

            const rect = item.getBoundingClientRect();
            charStartY = rect.top;

            // 플레이스홀더 생성
            charPlaceholder = document.createElement('div');
            charPlaceholder.className = 'char-placeholder';
            charPlaceholder.style.height = rect.height + 'px';

            // 드래그 중 스타일
            item.classList.add('dragging');
            item.style.position = 'fixed';
            item.style.left = rect.left + 'px';
            item.style.top = rect.top + 'px';
            item.style.width = rect.width + 'px';
            item.style.zIndex = '1000';

            item.parentNode.insertBefore(charPlaceholder, item);
            document.body.appendChild(item);

            // 마우스 이벤트 등록
            document.addEventListener('mousemove', onCharDrag);
            document.addEventListener('mouseup', endCharDrag);
        }

        function onCharDrag(e) {
            if (!draggedChar) return;

            const deltaY = e.clientY - dragStartY;
            draggedChar.style.top = (charStartY + deltaY) + 'px';

            // 다른 캐릭터 아이템들과 위치 비교
            const items = charactersList.querySelectorAll('.character-item:not(.dragging)');
            let targetItem = null;
            let insertBefore = true;

            for (const item of items) {
                const rect = item.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;

                if (e.clientY < midY) {
                    targetItem = item;
                    insertBefore = true;
                    break;
                }
                targetItem = item;
                insertBefore = false;
            }

            // 플레이스홀더 위치 업데이트
            if (targetItem) {
                if (insertBefore) {
                    charactersList.insertBefore(charPlaceholder, targetItem);
                } else {
                    if (targetItem.nextSibling) {
                        charactersList.insertBefore(charPlaceholder, targetItem.nextSibling);
                    } else {
                        charactersList.appendChild(charPlaceholder);
                    }
                }
            }
        }

        function endCharDrag() {
            if (!draggedChar) return;

            // 플레이스홀더 위치에 아이템 삽입
            charactersList.insertBefore(draggedChar, charPlaceholder);
            charPlaceholder.remove();

            // 드래그 스타일 제거
            draggedChar.classList.remove('dragging');
            draggedChar.style.position = '';
            draggedChar.style.left = '';
            draggedChar.style.top = '';
            draggedChar.style.width = '';
            draggedChar.style.zIndex = '';

            // 번호 업데이트 및 저장
            updateCharacterNumbers();
            autoSaveSettings();

            // 이벤트 제거
            document.removeEventListener('mousemove', onCharDrag);
            document.removeEventListener('mouseup', endCharDrag);

            draggedChar = null;
            charPlaceholder = null;
        }

        addCharBtn.onclick = () => {
            addCharacter();
            autoSaveSettings();
        };

        // LoRA 슬롯 시스템
        let availableLoras = [];  // 폴더에서 로드된 LoRA 목록
        let loraSlots = [];       // 현재 활성화된 LoRA 슬롯들 [{ name, scale }]
        
        function renderLoraSlots() {
            const loraList = document.getElementById('loraList');
            if (loraSlots.length === 0) {
                loraList.innerHTML = '<div class="lora-empty">+ 버튼으로 LoRA 추가</div>';
                return;
            }
            
            loraList.innerHTML = loraSlots.map((slot, index) => `
                <div class="lora-slot" data-index="${index}">
                    <select onchange="updateLoraSlot(${index}, 'name', this.value)">
                        <option value="">-- Select LoRA --</option>
                        ${availableLoras.map(l => `<option value="${l}" ${slot.name === l ? 'selected' : ''}>${l}</option>`).join('')}
                    </select>
                    <input type="number" value="${slot.scale}" step="0.1" min="0" max="2" 
                           onchange="updateLoraSlot(${index}, 'scale', this.value)">
                    <button type="button" class="lora-remove-btn" onclick="removeLoraSlot(${index})">✕</button>
                </div>
            `).join('');
        }
        
        function addLoraSlot() {
            loraSlots.push({ name: '', scale: 1.0 });
            renderLoraSlots();
            autoSaveSettings();
        }
        
        function removeLoraSlot(index) {
            loraSlots.splice(index, 1);
            renderLoraSlots();
            autoSaveSettings();
        }
        
        function updateLoraSlot(index, field, value) {
            if (field === 'scale') {
                loraSlots[index].scale = parseFloat(value);
            } else {
                loraSlots[index].name = value;
            }
            autoSaveSettings();
        }
        
        // Load resources
        async function loadResources() {
            try {
                const [modelsRes, lorasRes, upscaleRes, lutsRes, configRes] = await Promise.all([
                    fetch(`${API_BASE}/api/models`),
                    fetch(`${API_BASE}/api/loras`),
                    fetch(`${API_BASE}/api/upscale_models`),
                    fetch(`${API_BASE}/api/luts`),
                    fetch(`${API_BASE}/api/config`)
                ]);

                const { models } = await modelsRes.json();
                const { loras } = await lorasRes.json();
                const upscaleData = await upscaleRes.json();
                const lutsData = await lutsRes.json();
                const config = await configRes.json();

                // Models
                const modelSelect = document.getElementById('localModel');
                modelSelect.innerHTML = '<option value="">-- Select Model --</option>';
                models.forEach(m => {
                    modelSelect.innerHTML += `<option value="${m}">${m}</option>`;
                });

                // LoRAs - 사용 가능한 목록 저장 후 슬롯 렌더링
                availableLoras = loras;
                renderLoraSlots();

                // Upscale Models
                const upscaleSelect = document.getElementById('upscaleModel');
                upscaleSelect.innerHTML = '<option value="">-- Select Model --</option>';
                (upscaleData.models || []).forEach(m => {
                    upscaleSelect.innerHTML += `<option value="${m}">${m}</option>`;
                });

                // LUT Files
                const lutSelect = document.getElementById('lutFile');
                lutSelect.innerHTML = '<option value="">-- Select LUT --</option>';
                (lutsData.luts || []).forEach(l => {
                    lutSelect.innerHTML += `<option value="${l}">${l}</option>`;
                });
                
                // Config
                document.getElementById('checkpointsDir').value = config.checkpoints_dir || '';
                document.getElementById('loraDir').value = config.lora_dir || '';
                updateNaiStatus(config.nai_token_set);
                
            } catch (e) {
                console.error('Failed to load:', e);
                statusText.textContent = '백엔드 실행 안됨!';
                showToast('백엔드 연결 안됨', 'error');
            }
        }
        
        function updateNaiStatus(hasToken) {
            naiTokenSet = hasToken;
            const badge = document.getElementById('naiStatus');
            if (hasToken) {
                badge.textContent = 'Connected';
                badge.className = 'status-badge success';
            } else {
                badge.textContent = 'Token not set';
                badge.className = 'status-badge warning';
            }
        }
        
        // NAI Token Modal
        function showNaiTokenModal() {
            document.getElementById('naiTokenModal').classList.add('active');
            document.getElementById('naiTokenModalInput').focus();
        }
        
        function closeNaiTokenModal() {
            document.getElementById('naiTokenModal').classList.remove('active');
        }
        
        async function saveNaiTokenFromModal() {
            const token = document.getElementById('naiTokenModalInput').value.trim();
            if (!token) {
                showToast('토큰을 입력하세요', 'error');
                return;
            }
            
            const btn = document.getElementById('naiTokenModalBtn');
            btn.textContent = '⏳ 저장 중...';
            btn.disabled = true;
            
            try {
                const res = await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nai_token: token })
                });
                
                console.log('[Token Save] Response status:', res.status);
                const text = await res.text();
                console.log('[Token Save] Response body:', text);
                
                let data;
                try {
                    data = JSON.parse(text);
                } catch (parseErr) {
                    console.error('[Token Save] JSON parse error:', parseErr);
                    showToast('서버 응답 파싱 실패', 'error');
                    return;
                }

                if (res.ok && data.success) {
                    showToast('토큰 저장됨. Anlas 정보를 불러오는 중...', 'success');
                    naiTokenSet = true;
                    closeNaiTokenModal();

                    // Settings 모달의 토큰 필드도 업데이트
                    document.getElementById('naiToken').value = token;

                    // Anlas 정보 갱신 후 UI 업데이트
                    await fetchAnlasBalance();
                    updateNaiStatus(true);
                    
                    showToast('준비 완료. 다시 Queue를 눌러주세요.', 'info');
                } else {
                    console.error('[Token Save] Failed:', data);
                    showToast(data.error || '토큰 저장 실패', 'error');
                }
            } catch (e) {
                console.error('[Token Save Error]', e);
                showToast(`토큰 저장 실패: ${e.message}`, 'error');
            }
            
            btn.textContent = '💾 저장';
            btn.disabled = false;
        }
        
        // 모달 외부 클릭 및 Enter 키
        document.getElementById('naiTokenModal').addEventListener('click', (e) => {
            if (e.target.id === 'naiTokenModal') closeNaiTokenModal();
        });
        document.getElementById('naiTokenModalInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveNaiTokenFromModal();
        });
        
        function getSelectedLoras() {
            // 슬롯에서 선택된 LoRA만 반환 (name이 비어있지 않은 것만)
            return loraSlots.filter(slot => slot.name).map(slot => ({
                name: slot.name,
                scale: slot.scale
            }));
        }
        
        // Generate
        async function addToQueue() {
            // NAI 모드인데 토큰 없으면 팝업
            if (currentProvider === 'nai' && !naiTokenSet) {
                showNaiTokenModal();
                return;
            }
            
            // Complete 후 리셋 타이머 취소
            if (resetTimer) {
                clearTimeout(resetTimer);
                resetTimer = null;
            }
            
            // Complete 상태였다면 새로 시작
            if (totalImages > 0 && totalImages === currentIndex) {
                currentIndex = 0;
                totalImages = 0;
            }
            
            const slotList = getSlotList();
            const repeatCount = parseInt(document.getElementById('repeatCount').value) || 1;

            // 슬롯 모드에서 모든 슬롯이 락되어 있으면 생성 불가
            if (currentMode === 'slot') {
                const allSlots = getAllSlotList();
                if (allSlots.length > 0 && slotList.length === 0) {
                    showToast('모든 슬롯이 잠겨 있어 생성할 수 없습니다', 'warning');
                    return;
                }
            }

            // 모든 슬롯 등록 (빈 슬롯도 포함)
            const promptCount = slotList.length || 1;

            // 백엔드용 데이터 변환
            const promptData = slotList.length > 0
                ? slotList.map(s => ({ name: s.name, content: s.content, slotIndex: s.slotIndex }))
                : [{ name: '', content: '', slotIndex: 0 }];

            console.log(`[Queue] Adding job: slots=${slotList.length}, promptData=`, promptData);
            
            const request = {
                provider: currentProvider,
                base_prompt: document.getElementById('basePrompt').value,
                negative_prompt: document.getElementById('negativePrompt').value,
                character_prompts: getCharacterPrompts(),
                prompt_list: promptData,
                width: parseInt(document.getElementById('width').value),
                height: parseInt(document.getElementById('height').value),
                steps: parseInt(document.getElementById('steps').value),
                cfg: parseFloat(document.getElementById('cfg').value),
                seed: parseInt(document.getElementById('seed').value),
                random_seed_per_image: document.getElementById('randomSeed').checked,
                sampler: document.getElementById('sampler').value,
                scheduler: document.getElementById('scheduler').value,
                output_folder: getOutputFolder(),
            };
            
            if (currentProvider === 'nai') {
                request.nai_model = document.getElementById('naiModel').value;
                request.smea = document.getElementById('smea').value;
                request.uc_preset = document.getElementById('ucPreset').value;
                request.quality_tags = document.getElementById('qualityTags').checked;
                request.furry_mode = furryModeEnabled;
                request.cfg_rescale = parseFloat(document.getElementById('cfgRescale').value);
                request.variety_plus = document.getElementById('varietyPlus').checked;

                // Vibe Transfer
                if (document.getElementById('enableVibeTransfer').checked && vibeList.length > 0) {
                    request.vibe_transfer = vibeList.map(v => ({
                        image: v.image,
                        info_extracted: v.info_extracted,
                        strength: v.strength,
                        name: v.name || 'vibe',
                        encoded: v.encoded,
                        encoded_model: v.encoded_model
                    }));
                }

                // Character Reference (V4.5 only)
                if (document.getElementById('enableCharRef').checked && charRefData) {
                    request.character_reference = {
                        image: charRefData.processedImage || charRefData.image,  // Canvas 처리된 이미지 우선
                        fidelity: parseFloat(document.getElementById('charRefFidelity').value),
                        style_aware: document.getElementById('charRefStyleAware').checked
                    };
                }
            } else {
                request.model = document.getElementById('localModel').value;
                request.loras = getSelectedLoras();
                if (!request.model) {
                    showToast('모델을 선택하세요', 'error');
                    return;
                }
                
                // Upscale settings
                request.enable_upscale = document.getElementById('enableUpscale').checked;
                if (request.enable_upscale) {
                    request.upscale_model = document.getElementById('upscaleModel').value;
                    request.downscale_ratio = parseFloat(document.getElementById('downscaleRatio').value);
                    request.upscale_steps = parseInt(document.getElementById('upscaleSteps').value);
                    request.upscale_cfg = parseFloat(document.getElementById('upscaleCfg').value);
                    request.upscale_denoise = parseFloat(document.getElementById('upscaleDenoise').value);
                    request.size_alignment = document.getElementById('sizeAlignment').value;
                    
                    if (!request.upscale_model) {
                        showToast('업스케일 모델을 선택하세요', 'error');
                        return;
                    }
                }

            }

            // LUT settings (NAI와 Local 모두 지원)
            request.enable_lut = document.getElementById('enableLut').checked;
            if (request.enable_lut) {
                request.lut_file = document.getElementById('lutFile').value;
                request.lut_intensity = parseFloat(document.getElementById('lutIntensity').value);

                if (!request.lut_file) {
                    showToast('LUT 파일을 선택하세요', 'error');
                    return;
                }
            }

            // Save options
            request.save_format = document.getElementById('saveFormat').value;
            request.jpg_quality = parseInt(document.getElementById('jpgQuality').value);
            request.strip_metadata = document.getElementById('stripMetadata').checked;

            // Base Image (img2img / inpaint)
            if (baseImageData.enabled && baseImageData.image) {
                request.base_image = baseImageData.image;
                request.base_mode = baseImageData.mode;
                request.base_strength = baseImageData.strength;
                request.base_noise = baseImageData.noise;
                if (baseImageData.mode === 'inpaint' && baseImageData.mask) {
                    request.base_mask = baseImageData.mask;
                }
            }

            // 시드 고정이 아닐 경우, 다음 큐를 위해 즉시 새 시드로 UI 갱신
            // (빠르게 여러 번 클릭해도 중복 시드 방지)
            if (!document.getElementById('lockSeed').checked) {
                document.getElementById('seed').value = Math.floor(Math.random() * 2147483647);
            }

            // N번 큐에 등록
            for (let i = 0; i < repeatCount; i++) {
                try {
                    await fetch(`${API_BASE}/api/generate/multi`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(request)
                    });
                } catch (e) {
                    showToast(`Error: ${e.message}`, 'error');
                }

                // 매번 새로운 시드
                request.seed = Math.floor(Math.random() * 2147483647);
            }

            showToast(`${repeatCount * promptCount} images queued`, 'success');
        }
        
        function updateProgress() {
            if (totalImages === 0) {
                statusText.textContent = '준비';
                progressFill.style.width = '0%';
            } else {
                statusText.textContent = `${currentIndex}/${totalImages}`;
                progressFill.style.width = `${(currentIndex / totalImages) * 100}%`;
            }
        }
        
        async function cancelCurrent() {
            try {
                const response = await fetch(`${API_BASE}/api/cancel-current`, { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    // 로컬 생성은 즉시 취소, NAI는 현재 이미지 완료 후 취소
                    if (currentProvider === 'local') {
                        showToast('취소 중...', 'warning');
                    } else {
                        showToast('현재 이미지 완료 후 취소됩니다', 'warning');
                    }
                } else {
                    showToast('진행 중인 작업이 없습니다', 'error');
                }
            } catch (e) {
                showToast(`오류: ${e.message}`, 'error');
            }
        }
        
        async function clearQueue() {
            try {
                const response = await fetch(`${API_BASE}/api/clear-queue`, { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    // 대기 이미지 수 제거
                    totalImages -= result.cleared_images;
                    if (totalImages < currentIndex) totalImages = currentIndex;
                    updateProgress();
                    showToast(`Cleared ${result.cleared_images} images`, 'warning');
                }
            } catch (e) {
                showToast(`Error: ${e.message}`, 'error');
            }
        }
        
        // ============================================================
        // WebSocket 연결 및 메시지 처리
        // ============================================================

        function connectWebSocket() {
            if (wsReconnectTimer) {
                clearTimeout(wsReconnectTimer);
                wsReconnectTimer = null;
            }

            if (ws && ws.readyState === WebSocket.OPEN) {
                return;
            }

            const wsUrl = `ws://127.0.0.1:8765/ws${wsClientId ? `?clientId=${wsClientId}` : ''}`;
            console.log('[WS] Connecting...', wsUrl);
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('[WS] Connected');
                // 재연결 시 누락된 이미지 동기화 요청
                if (lastImageSeq > 0) {
                    ws.send(JSON.stringify({ type: 'sync', last_seq: lastImageSeq }));
                }
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                } catch (e) {
                    console.error('[WS] Parse error:', e);
                }
            };

            ws.onclose = (event) => {
                console.log('[WS] Disconnected, reconnecting in 1s...', event.code);
                wsReconnectTimer = setTimeout(connectWebSocket, 1000);
            };

            ws.onerror = (error) => {
                console.error('[WS] Error:', error);
            };
        }

        function updateProgressFromServer(progress) {
            if (progress) {
                currentIndex = progress.completed;
                totalImages = progress.total;
                updateProgress();
            }
        }

        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'connected':
                    // 연결 성공, 클라이언트 ID 저장
                    wsClientId = data.client_id;
                    localStorage.setItem('ws_client_id', wsClientId);
                    console.log('[WS] Client ID:', wsClientId);
                    // 초기 상태 동기화
                    if (data.status) {
                        currentIndex = data.status.completed_images;
                        totalImages = data.status.total_images;
                        updateProgress();
                    }
                    break;

                case 'sync':
                    // 재연결 시 누락된 이미지 수신
                    console.log(`[WS] Sync: received ${data.images?.length || 0} missed images`);
                    if (data.images) {
                        data.images.forEach(img => {
                            addImageToSlot(img.slot_idx, img);
                            if (img.seq) lastImageSeq = Math.max(lastImageSeq, img.seq);
                        });
                    }
                    if (data.status) {
                        currentIndex = data.status.completed_images;
                        totalImages = data.status.total_images;
                        updateProgress();
                    }
                    break;

                case 'job_queued':
                    // 작업이 큐에 추가될 때 즉시 진행률 반영
                    console.log(`[WS] Job queued: ${data.job_id}, images: ${data.job_images}`);
                    updateProgressFromServer(data.progress);
                    break;

                case 'job_start':
                    console.log(`[WS] Job started: ${data.job_id}, total: ${data.job_total}`);
                    updateProgressFromServer(data.progress);
                    break;

                case 'image':
                    console.log(`[WS] Image received: job_id=${data.job_id}, slot_idx=${data.slot_idx}, filename=${data.filename}, seq=${data.seq}`);
                    if (data.seq) lastImageSeq = Math.max(lastImageSeq, data.seq);
                    updateProgressFromServer(data.progress);
                    addImageToSlot(data.slot_idx, data);
                    break;

                case 'job_done':
                    console.log(`[WS] Job done: ${data.job_id}`);
                    updateProgressFromServer(data.progress);

                    // Anlas 잔액 및 비용 갱신 (생성 완료 시)
                    if (currentProvider === 'nai') {
                        fetchAnlasBalance();
                        updateAnlasCost();

                        // V4+ 모델에서 바이브가 사용된 경우, vibeList의 인코딩 상태 갱신
                        // (생성 완료 후 해당 설정으로 캐시됨)
                        const currentModel = document.getElementById('naiModel').value;
                        if (currentModel.includes('diffusion-4') && vibeList.length > 0) {
                            let updated = false;
                            vibeList.forEach(v => {
                                // 현재 모델과 info_extracted가 인코딩된 값과 다르면 갱신
                                const baseModel = currentModel.replace('-inpainting', '');
                                const encodedBaseModel = (v.encoded_model || '').replace('-inpainting', '');
                                const infoMatch = Math.abs((v.info_extracted || 1.0) - (v.encoded_info_extracted || v.info_extracted || 1.0)) <= 0.001;

                                if (encodedBaseModel !== baseModel || !infoMatch) {
                                    v.encoded_model = currentModel;
                                    v.encoded_info_extracted = v.info_extracted || 1.0;
                                    updated = true;
                                }
                            });
                            if (updated) {
                                renderVibeList();
                                saveAppSettings();
                            }
                        }
                    }

                    if (data.progress?.queue_length === 0) {
                        // 모든 작업 완료
                        statusText.textContent = '완료!';
                        progressFill.style.width = '100%';
                        showToast('완료', 'success');
                        lastImageSeq = 0;  // 시퀀스 리셋

                        if (resetTimer) clearTimeout(resetTimer);
                        resetTimer = setTimeout(() => {
                            if (totalImages === currentIndex || totalImages === 0) {
                                currentIndex = 0;
                                totalImages = 0;
                                updateProgress();
                            }
                        }, 2000);
                    }
                    break;

                case 'job_cancelled':
                    console.log(`[WS] Job cancelled: ${data.job_id}, immediate: ${data.immediate}`);
                    updateProgressFromServer(data.progress);
                    // 큐가 비었으면 상태 초기화
                    if (!data.progress || data.progress.total === 0 || data.progress.queue_length === 0) {
                        totalImages = 0;
                        currentIndex = 0;
                        updateProgress();
                    }
                    // 실제로 취소된 이미지가 있을 때만 토스트 표시
                    if (data.cancelled_images > 0) {
                        const msg = data.immediate
                            ? `즉시 취소됨 (${data.cancelled_images}장 취소)`
                            : `작업 취소됨 (${data.cancelled_images}장 취소)`;
                        showToast(msg, 'warning');
                    }
                    break;

                case 'queue_cleared':
                    console.log(`[WS] Queue cleared: ${data.cleared_images} images`);
                    updateProgressFromServer(data.progress);
                    break;

                case 'error':
                    console.error('[WS] Generation error:', data.error);
                    updateProgressFromServer(data.progress);
                    showToast(`Error: ${data.error || 'Generation failed'}`, 'error');
                    break;

                case 'pong':
                    // Heartbeat 응답
                    break;
            }
        }
        
        function clearResults() {
            clearSlotImages();
            statusText.textContent = '준비';
            progressFill.style.width = '0%';
            currentIndex = 0;
            totalImages = 0;
        }
        
        // Lightbox
        lightbox.onclick = (e) => {
            if (e.target === lightbox || e.target.classList.contains('close')) {
                lightbox.classList.remove('active');
                lightboxCurrentSlot = null;
                lightboxCurrentCard = null;
                lightboxCurrentGalleryItem = null;
            }
        };

        // Lightbox wheel navigation (slot mode & gallery mode)
        lightbox.addEventListener('wheel', (e) => {
            if (!lightbox.classList.contains('active')) return;

            // 슬롯 모드
            if (lightboxCurrentSlot && lightboxCurrentCard) {
                e.preventDefault();

                const imagesContainer = lightboxCurrentSlot.querySelector('.slot-images');
                const cards = Array.from(imagesContainer.querySelectorAll('.slot-image-card'));
                if (cards.length <= 1) return;

                const currentIndex = cards.indexOf(lightboxCurrentCard);
                if (currentIndex === -1) return;

                let newIndex;
                if (e.deltaY > 0) {
                    newIndex = currentIndex + 1;
                    if (newIndex >= cards.length) newIndex = 0;
                } else {
                    newIndex = currentIndex - 1;
                    if (newIndex < 0) newIndex = cards.length - 1;
                }

                const newCard = cards[newIndex];
                const newImg = newCard.querySelector('img');
                if (newImg) {
                    lightboxImg.src = newImg.src;
                    lightboxCurrentCard = newCard;
                }
                return;
            }

            // 갤러리/바이브 모드
            if (lightboxCurrentGalleryItem) {
                e.preventDefault();

                const items = Array.from(galleryGrid.querySelectorAll('.gallery-item'));
                if (items.length <= 1) return;

                const currentIndex = items.indexOf(lightboxCurrentGalleryItem);
                if (currentIndex === -1) return;

                let newIndex;
                if (e.deltaY > 0) {
                    newIndex = currentIndex + 1;
                    if (newIndex >= items.length) newIndex = 0;
                } else {
                    newIndex = currentIndex - 1;
                    if (newIndex < 0) newIndex = items.length - 1;
                }

                const newItem = items[newIndex];
                lightboxCurrentGalleryItem = newItem;

                // 바이브 캐시면 썸네일 직접 사용
                if (newItem._isVibe && newItem._thumbnail) {
                    lightboxImg.src = 'data:image/png;base64,' + newItem._thumbnail;
                    return;
                }

                // 갤러리 이미지 로드 (비동기)
                const filename = newItem._filename;
                const folder = newItem._folder || '';
                const folderQuery = folder ? `?folder=${encodeURIComponent(folder)}` : '';
                fetch(`${API_BASE}/api/gallery/${filename}${folderQuery}`)
                    .then(res => res.json())
                    .then(result => {
                        if (result.success) {
                            lightboxImg.src = 'data:image/png;base64,' + result.image;
                        }
                    })
                    .catch(() => {});
            }
        }, { passive: false });

        // Settings
        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
            // Sync tag autocomplete checkbox with current state
            document.getElementById('tagAutocompleteToggle').checked = tagAutocompleteEnabled;
            checkLocalEnvStatus();
            loadAppVersion();
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        // 버전 정보 로드
        async function loadAppVersion() {
            try {
                const res = await fetch(`${API_BASE}/api/version`);
                const data = await res.json();
                document.getElementById('appVersionDisplay').textContent = `v${data.version}`;
            } catch (e) {
                document.getElementById('appVersionDisplay').textContent = 'v1.0.0';
            }
        }

        // 업데이트 확인
        async function checkForUpdates() {
            const btn = document.getElementById('checkUpdateBtn');
            const statusDiv = document.getElementById('updateStatus');

            btn.disabled = true;
            btn.textContent = 'Checking...';
            statusDiv.style.display = 'none';

            try {
                const res = await fetch(`${API_BASE}/api/check-update`);
                const data = await res.json();

                statusDiv.style.display = 'block';

                if (data.error) {
                    statusDiv.innerHTML = `<span style="color: var(--text-dim);">Update check failed: ${data.error}</span>`;
                } else if (data.has_update) {
                    statusDiv.innerHTML = `
                        <div style="padding: 12px; background: var(--bg-lighter); border-radius: var(--radius-sm); border: 1px solid var(--accent);">
                            <div style="font-weight: 600; color: var(--accent); margin-bottom: 8px;">
                                New version available: v${data.latest_version}
                            </div>
                            <a href="${data.release_url}" target="_blank" class="btn btn-sm" style="margin-top: 4px;">Download Update</a>
                        </div>
                    `;
                } else {
                    statusDiv.innerHTML = `<span style="color: var(--success);">You're using the latest version!</span>`;
                }
            } catch (e) {
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = `<span style="color: var(--error);">Failed to check for updates</span>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Check for Updates';
            }
        }

        // 모달 외부 클릭 시 닫기
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') closeSettings();
        });
        document.getElementById('localInstallModal').addEventListener('click', (e) => {
            if (e.target.id === 'localInstallModal') closeLocalInstallModal();
        });
        
        async function saveSettings() {
            const config = {
                nai_token: document.getElementById('naiToken').value || null,
                checkpoints_dir: document.getElementById('checkpointsDir').value || null,
                lora_dir: document.getElementById('loraDir').value || null,
            };

            try {
                const res = await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                const data = await res.json();

                if (res.ok && data.success) {
                    showToast('설정 저장됨', 'success');
                    // NAI 토큰이 입력되었으면 상태 및 Anlas 업데이트
                    const tokenValue = document.getElementById('naiToken').value;
                    if (tokenValue) {
                        updateNaiStatus(true);
                        fetchAnlasBalance();
                    }
                    closeSettings();
                } else {
                    showToast(data.error || '저장 실패', 'error');
                }
            } catch (e) {
                showToast('저장 실패', 'error');
            }
        }
        
        // Local Environment
        let localEnvPollInterval = null;
        
        async function checkLocalEnvStatus() {
            try {
                const res = await fetch(`${API_BASE}/api/local/status`);
                const data = await res.json();
                updateLocalEnvUI(data);
                return data;
            } catch (e) {
                console.error('Failed to check local env status:', e);
                return null;
            }
        }
        
        function updateLocalEnvUI(data) {
            const statusEl = document.getElementById('localEnvStatus');
            const actionsEl = document.getElementById('localEnvActions');
            const progressEl = document.getElementById('localEnvProgress');
            const progressFillEl = document.getElementById('localEnvProgressFill');
            const progressTextEl = document.getElementById('localEnvProgressText');
            
            if (data.installing) {
                statusEl.className = 'local-env-status installing';
                statusEl.innerHTML = `<span class="status-icon">⏳</span><span class="status-text">${data.message || 'Installing...'}</span>`;
                actionsEl.innerHTML = '';
                progressEl.style.display = 'flex';
                progressFillEl.style.width = `${data.progress}%`;
                progressTextEl.textContent = `${data.progress}%`;
                
                // 폴링 시작
                if (!localEnvPollInterval) {
                    localEnvPollInterval = setInterval(checkLocalEnvStatus, 1000);
                }
            } else if (data.error) {
                statusEl.className = 'local-env-status error';
                statusEl.innerHTML = `<span class="status-icon">❌</span><span class="status-text">Error: ${data.error}</span>`;
                actionsEl.innerHTML = `<button class="btn" onclick="installLocalEnv()">Retry Install</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
            } else if (data.installed) {
                statusEl.className = 'local-env-status installed';
                statusEl.innerHTML = `<span class="status-icon">✅</span><span class="status-text">Installed</span>`;
                actionsEl.innerHTML = `<button class="btn btn-danger" onclick="uninstallLocalEnv()">제거</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
                
                // Local 탭 활성화
                enableLocalTab(true);
                
                // 저장된 provider가 local이었으면 자동 전환
                if (window._pendingProvider === 'local') {
                    window._pendingProvider = null;
                    currentProvider = 'local';
                    tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === 'local'));
                    providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === 'local'));
                    // Local의 전체 설정 복원
                    applyProviderSettings(localSettings, true);
                    restoreProviderGenerationSettings('local');
                    updateAnlasVisibility();
                    updateProviderLabels();
                }
            } else {
                statusEl.className = 'local-env-status not-installed';
                statusEl.innerHTML = `<span class="status-icon">⚠️</span><span class="status-text">Not installed</span>`;
                actionsEl.innerHTML = `<button class="btn" onclick="installLocalEnv()">Install Local Engine</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
                
                // Local 탭 비활성화
                enableLocalTab(false);
            }
        }
        
        function stopLocalEnvPolling() {
            if (localEnvPollInterval) {
                clearInterval(localEnvPollInterval);
                localEnvPollInterval = null;
            }
        }
        
        function enableLocalTab(enabled) {
            localEnvInstalled = enabled;
            const localTab = document.querySelector('.tab[data-provider="local"]');
            if (localTab) {
                if (enabled) {
                    localTab.classList.remove('disabled');
                    localTab.style.opacity = '1';
                } else {
                    localTab.classList.add('disabled');
                    localTab.style.opacity = '0.6';
                }
                // pointerEvents는 항상 auto로 - 클릭 감지 필요
                localTab.style.pointerEvents = 'auto';
            }
        }
        
        // Local Install Modal
        let installModalSource = 'local'; // 'local' | 'censor' - 어디서 팝업을 열었는지
        
        function showLocalInstallModal(source = 'local') {
            installModalSource = source;
            document.getElementById('localInstallModal').classList.add('active');
            updateInstallModalStatus();
        }
        
        function closeLocalInstallModal() {
            if (isInstalling) return;
            document.getElementById('localInstallModal').classList.remove('active');
        }
        
        function updateInstallModalStatus() {
            const statusEl = document.getElementById('installModalStatus');
            const progressEl = document.getElementById('installModalProgress');
            const btn = document.getElementById('installModalBtn');
            const closeBtn = document.getElementById('localInstallModalClose');
            const cancelBtn = document.getElementById('installModalCancelBtn');
            
            fetch(`${API_BASE}/api/local/status`)
                .then(res => res.json())
                .then(data => {
                    if (data.installed) {
                        const wasInstalling = isInstalling;  // 방금 설치 완료인지 확인
                        isInstalling = false;
                        if (installPollInterval) {
                            clearInterval(installPollInterval);
                            installPollInterval = null;
                        }
                        statusEl.className = 'local-env-status installed';
                        statusEl.innerHTML = '<span class="status-text">✅ 설치됨</span>';
                        progressEl.style.display = 'none';
                        btn.textContent = '✓ 이미 설치됨';
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        // 모달 닫기/취소 버튼 다시 활성화
                        if (closeBtn) closeBtn.style.display = '';
                        if (cancelBtn) cancelBtn.disabled = false;
                        
                        // 방금 설치가 완료된 경우 → 상태 업데이트 후 재시작 모달 표시
                        if (wasInstalling) {
                            // Local 탭 활성화 (재시작 안 해도 접근 가능하게)
                            localEnvInstalled = true;
                            enableLocalTab(true);

                            setTimeout(() => {
                                closeLocalInstallModal();
                                showRestartModal();
                            }, 500);
                        } else {
                        // 이미 설치된 상태로 모달 열린 경우
                            setTimeout(() => {
                                closeLocalInstallModal();
                                if (installModalSource === 'censor') {
                                    // 검열 모드에서 열었으면 검열 모드로 진입
                                    if (data.censor_ready) {
                                        // ultralytics 설치됨 - 검열 모드 진입
                                        currentMode = 'censor';
                                        censorModeBtn.classList.add('active');
                                        slotModeBtn.classList.remove('active');
                                        galleryModeBtn.classList.remove('active');
                                        document.getElementById('slotsToolbar').style.display = 'none';
                                        document.getElementById('slotsWrapper').style.display = 'none';
                                        document.getElementById('galleryContainer').style.display = 'none';
                                        document.getElementById('censorContainer').style.display = 'flex';
                                        if (typeof initCensorMode === 'function') {
                                            initCensorMode();
                                        }
                                    } else {
                                        // ultralytics 미설치 - 재설치 필요 안내
                                        showToast('검열 기능을 위해 환경 재설치가 필요합니다. Settings > Local에서 제거 후 다시 설치해주세요.', 'error', 5000);
                                    }
                                } else {
                                    // 로컬에서 열었으면 로컬 탭으로 전환
                                    localEnvInstalled = true;
                                    currentProvider = 'local';
                                    tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === 'local'));
                                    providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === 'local'));
                                }
                            }, 500);
                        }
                    } else if (data.installing) {
                        statusEl.className = 'local-env-status installing';
                        statusEl.innerHTML = `<span class="status-text">⏳ ${data.message || '설치 중...'}</span>`;
                        progressEl.style.display = 'flex';
                        document.getElementById('installModalProgressFill').style.width = `${data.progress || 0}%`;
                        document.getElementById('installModalProgressText').textContent = `${data.progress || 0}%`;
                        btn.textContent = '⏳ 설치 중...';
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        // 설치 중에는 닫기/취소 버튼 비활성화
                        if (closeBtn) closeBtn.style.display = 'none';
                        if (cancelBtn) cancelBtn.disabled = true;
                        // 폴링은 interval로 처리됨
                    } else if (data.error) {
                        isInstalling = false;  // 에러 발생
                        stopInstallPolling();  // 폴링 중지
                        statusEl.className = 'local-env-status error';
                        statusEl.innerHTML = `<span class="status-text">❌ ${data.error}</span>`;
                        progressEl.style.display = 'none';
                        btn.textContent = '🔄 다시 시도';
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        // 에러 시 닫기/취소 버튼 다시 활성화
                        if (closeBtn) closeBtn.style.display = '';
                        if (cancelBtn) cancelBtn.disabled = false;
                    } else {
                        // 설치 완료됐지만 installed가 false인 경우 (progress 100)
                        if (data.progress === 100) {
                            isInstalling = false;
                            stopInstallPolling();
                            statusEl.className = 'local-env-status installed';
                            statusEl.innerHTML = '<span class="status-text">✅ 설치 완료</span>';
                            btn.textContent = '✓ 설치 완료';
                            btn.disabled = true;
                            btn.style.opacity = '0.5';
                            progressEl.style.display = 'none';
                            if (closeBtn) closeBtn.style.display = '';
                            if (cancelBtn) cancelBtn.disabled = false;
                        } else if (!isInstalling) {
                            // 설치 중이 아닐 때만 "설치 필요" 표시
                            stopInstallPolling();
                            statusEl.className = 'local-env-status not-installed';
                            statusEl.innerHTML = '<span class="status-text">⚠️ 설치 필요</span>';
                            btn.textContent = '⬇️ 설치 (~5GB)';
                            btn.disabled = false;
                            btn.style.opacity = '1';
                            progressEl.style.display = 'none';
                            if (closeBtn) closeBtn.style.display = '';
                            if (cancelBtn) cancelBtn.disabled = false;
                        }
                        // isInstalling이 true이고 progress < 100이면 폴링 계속 (백엔드가 아직 시작 안함)
                    }
                })
                .catch(() => {
                    statusEl.className = 'local-env-status error';
                    statusEl.innerHTML = '<span class="status-text">❌ 백엔드 연결 안됨</span>';
                    // 에러 시 닫기/취소 버튼 다시 활성화
                    if (closeBtn) closeBtn.style.display = '';
                    if (cancelBtn) cancelBtn.disabled = false;
                });
        }
        
        let isInstalling = false;  // 설치 중 플래그
        let installPollInterval = null;  // 설치 상태 폴링 인터벌
        
        function startInstallPolling() {
            if (installPollInterval) return;
            installPollInterval = setInterval(updateInstallModalStatus, 500);  // 0.5초마다 폴링
        }
        
        function stopInstallPolling() {
            if (installPollInterval) {
                clearInterval(installPollInterval);
                installPollInterval = null;
            }
        }
        
        // === Restart Modal ===
        function showRestartModal() {
            document.getElementById('restartModal').classList.add('active');
        }

        async function autoRestart() {
            // 자동 재시작 - 현재 탭 닫기 (서버가 새 브라우저를 열어줌)
            window.isIntentionalClose = true;  // beforeunload 경고 비활성화
            try {
                await fetch(`${API_BASE}/api/restart`, { method: 'POST' });
            } catch (e) {
                // 서버가 종료되면서 연결이 끊어질 수 있음
            }
            window.close();
        }

        async function confirmRestart() {
            const btn = document.getElementById('restartConfirmBtn');
            btn.textContent = '⏳ 재시작 중...';
            btn.disabled = true;
            btn.style.opacity = '0.5';
            window.isIntentionalClose = true;  // beforeunload 경고 비활성화

            try {
                await fetch(`${API_BASE}/api/restart`, { method: 'POST' });
            } catch (e) {
                // 서버가 종료되면서 연결이 끊어질 수 있음
            }
            window.close();
        }
        
        async function waitForServer(maxAttempts = 30) {
            // 서버가 내려갔다가 다시 올라올 때까지 대기
            // 먼저 서버가 내려가길 기다림 (최대 3초)
            await new Promise(r => setTimeout(r, 1000));
            
            for (let i = 0; i < maxAttempts; i++) {
                try {
                    const res = await fetch(`${API_BASE}/api/health`, { 
                        method: 'GET',
                        signal: AbortSignal.timeout(2000)
                    });
                    if (res.ok) {
                        // 서버가 올라옴
                        return true;
                    }
                } catch (e) {
                    // 아직 서버 안 올라옴
                }
                await new Promise(r => setTimeout(r, 1000));
            }
            return false;
        }
        
        async function installFromModal() {
            const btn = document.getElementById('installModalBtn');
            const closeBtn = document.getElementById('localInstallModalClose');
            const cancelBtn = document.getElementById('installModalCancelBtn');
            const progressEl = document.getElementById('installModalProgress');
            const statusEl = document.getElementById('installModalStatus');
            
            // 즉시 UI 잠금
            isInstalling = true;
            btn.textContent = '⏳ 시작 중...';
            btn.disabled = true;
            btn.style.opacity = '0.5';
            if (closeBtn) closeBtn.style.display = 'none';
            if (cancelBtn) cancelBtn.disabled = true;
            statusEl.className = 'local-env-status installing';
            statusEl.innerHTML = '<span class="status-text">⏳ 설치 준비 중...</span>';
            progressEl.style.display = 'flex';
            document.getElementById('installModalProgressFill').style.width = '0%';
            document.getElementById('installModalProgressText').textContent = '0%';
            
            try {
                const res = await fetch(`${API_BASE}/api/local/install`, { method: 'POST' });
                const data = await res.json();
                if (res.ok) {
                    if (data.status === 'restart_required') {
                        // torch가 이미 로드되어 있어 재시작 필요
                        showToast('재시작 후 CUDA가 설치됩니다', 'info', 5000);
                        closeLocalInstallModal();
                        showRestartModal();
                        isInstalling = false;
                    } else {
                        showToast('설치 시작됨', 'success');
                        startInstallPolling();  // 폴링 시작
                        checkLocalEnvStatus();  // Settings 모달도 업데이트
                    }
                } else {
                    showToast(data.detail || '설치 시작 실패', 'error');
                    // 실패 시 UI 복원
                    isInstalling = false;
                    btn.textContent = '⬇️ 설치 (~5GB)';
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    if (closeBtn) closeBtn.style.display = '';
                    if (cancelBtn) cancelBtn.disabled = false;
                    progressEl.style.display = 'none';
                    statusEl.className = 'local-env-status not-installed';
                    statusEl.innerHTML = '<span class="status-text">⚠️ 설치 필요</span>';
                }
            } catch (e) {
                showToast('설치 시작 실패', 'error');
                // 실패 시 UI 복원
                isInstalling = false;
                btn.textContent = '⬇️ 설치 (~5GB)';
                btn.disabled = false;
                btn.style.opacity = '1';
                if (closeBtn) closeBtn.style.display = '';
                if (cancelBtn) cancelBtn.disabled = false;
                progressEl.style.display = 'none';
                statusEl.className = 'local-env-status not-installed';
                statusEl.innerHTML = '<span class="status-text">⚠️ 설치 필요</span>';
            }
        }
        
        async function installLocalEnv() {
            try {
                const res = await fetch(`${API_BASE}/api/local/install`, { method: 'POST' });
                const data = await res.json();
                if (res.ok) {
                    if (data.status === 'restart_required') {
                        showToast('재시작 후 CUDA가 설치됩니다', 'info', 5000);
                        showRestartModal();
                    } else {
                        showToast('설치 시작됨', 'success');
                        checkLocalEnvStatus();
                    }
                } else {
                    showToast(data.detail || 'Failed to start installation', 'error');
                }
            } catch (e) {
                showToast('설치 시작 실패', 'error');
            }
        }
        
        async function uninstallLocalEnv() {
            showConfirmModal(
                '🗑️ 환경 제거',
                '<p>로컬 생성/검열 환경을 제거하시겠습니까?</p><p style="color: var(--text-dim); font-size: 0.9rem;">약 5GB 디스크 공간이 확보됩니다.</p>',
                async () => {
                    try {
                        showToast('제거 중...', '', 30000);
                        const res = await fetch(`${API_BASE}/api/local/uninstall`, { method: 'DELETE' });
                        const data = await res.json();
                        if (res.ok) {
                            if (data.status === 'partial') {
                                showToast(`일부 제거됨: ${data.message}`, 'warning');
                            } else {
                                showToast('제거 완료', 'success');
                            }
                            checkLocalEnvStatus();
                        } else {
                            showToast('제거 실패: ' + (data.detail || ''), 'error');
                        }
                    } catch (e) {
                        showToast('제거 실패: ' + e.message, 'error');
                    }
                },
                '제거',
                true
            );
        }
        
        // Toast
        let toastTimeout = null;
        function showToast(msg, type = '', duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.className = 'toast show ' + type;
            if (toastTimeout) {
                clearTimeout(toastTimeout);
                toastTimeout = null;
            }
            if (duration > 0) {
                toastTimeout = setTimeout(() => toast.classList.remove('show'), duration);
            }
        }
        function hideToast() {
            const toast = document.getElementById('toast');
            toast.classList.remove('show');
            if (toastTimeout) {
                clearTimeout(toastTimeout);
                toastTimeout = null;
            }
        }

        // Generic Confirm Modal
        function showConfirmModal(title, message, onConfirm, confirmText = '확인', isDanger = false, checkboxLabel = null) {
            const modal = document.getElementById('confirmModal');
            document.getElementById('confirmModalTitle').textContent = title;
            document.getElementById('confirmModalMessage').innerHTML = message;
            const okBtn = document.getElementById('confirmModalOk');
            okBtn.textContent = confirmText;
            okBtn.className = isDanger ? 'btn btn-danger' : 'btn';
            okBtn.style.background = isDanger ? 'var(--error)' : '';

            // 체크박스 설정
            const checkboxWrapper = document.getElementById('confirmModalCheckboxWrapper');
            const checkbox = document.getElementById('confirmModalCheckbox');
            if (checkboxLabel) {
                document.getElementById('confirmModalCheckboxLabel').textContent = checkboxLabel;
                checkboxWrapper.style.display = 'flex';
                checkbox.checked = false;
            } else {
                checkboxWrapper.style.display = 'none';
            }

            // 이벤트 리스너 정리 후 재설정
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            const newCancelBtn = document.getElementById('confirmModalCancel').cloneNode(true);
            document.getElementById('confirmModalCancel').parentNode.replaceChild(newCancelBtn, document.getElementById('confirmModalCancel'));

            newOkBtn.onclick = () => {
                modal.classList.remove('active');
                if (onConfirm) onConfirm(checkbox.checked);
            };
            newCancelBtn.onclick = () => {
                modal.classList.remove('active');
            };

            modal.classList.add('active');
        }

        function showInputModal(title, message, onConfirm, confirmText = '확인', defaultValue = '') {
            const modal = document.getElementById('inputModal');
            document.getElementById('inputModalTitle').textContent = title;
            document.getElementById('inputModalMessage').textContent = message;
            const input = document.getElementById('inputModalInput');
            input.value = defaultValue;

            const okBtn = document.getElementById('inputModalOk');
            okBtn.textContent = confirmText;

            // 이벤트 리스너 정리 후 재설정
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            const newCancelBtn = document.getElementById('inputModalCancel').cloneNode(true);
            document.getElementById('inputModalCancel').parentNode.replaceChild(newCancelBtn, document.getElementById('inputModalCancel'));

            newOkBtn.onclick = () => {
                const value = input.value.trim();
                if (value) {
                    modal.classList.remove('active');
                    if (onConfirm) onConfirm(value);
                }
            };
            newCancelBtn.onclick = () => {
                modal.classList.remove('active');
            };
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    newOkBtn.click();
                } else if (e.key === 'Escape') {
                    modal.classList.remove('active');
                }
            };

            modal.classList.add('active');
            setTimeout(() => input.focus(), 100);
        }

        // NAI 형식 메타데이터를 앱 내부 형식으로 변환
        function normalizeMetadata(meta) {
            if (!meta) return null;

            // 이미 앱 내부 형식이면 그대로 반환
            if (meta.negative_prompt !== undefined || meta.cfg !== undefined || meta.nai_model !== undefined) {
                return meta;
            }

            // 캐릭터 프롬프트 추출 (peropix 또는 NAI 형식)
            let charPrompts = [];
            const ppx = meta.peropix || {};
            if (ppx.character_prompts && ppx.character_prompts.length > 0) {
                charPrompts = ppx.character_prompts;
            } else if (meta.v4_prompt?.caption?.char_captions) {
                charPrompts = meta.v4_prompt.caption.char_captions.map(c => c.char_caption).filter(c => c);
            } else if (meta.characterPrompts) {
                charPrompts = meta.characterPrompts.map(c => c.prompt).filter(c => c);
            }

            // UC Preset: 숫자 → 문자열 변환
            const ucPresetMap = { 0: 'Heavy', 1: 'Light', 2: 'Human Focus', 3: 'None' };
            let ucPreset = ucPresetMap[meta.ucPreset] || meta.ucPreset || 'Heavy';
            let qualityTags = meta.qualityToggle;

            // 순수 NAI 이미지 여부 확인 (peropix 확장이 없으면 순수 NAI)
            const isPureNai = !meta.peropix;

            // 슬롯 프롬프트 (PeroPix v2+ 이미지에서 사용)
            let slotPrompt = ppx.slot_prompt || '';

            // 순수 NAI 이미지면 프롬프트에서 퀄리티 태그/UC 프리셋 태그 제거 (중복 방지)
            let prompt = meta.prompt || '';
            let negativePrompt = meta.uc || '';

            // V4.5 Quality Tags 패턴
            const v45QualityTagsPatterns = [
                ", very aesthetic, masterpiece, no text, -2::upscaled, blurry::,", // Enhance
                ", very aesthetic, masterpiece, no text" // 일반
            ];

            // V4.5 UC 프리셋 정의
            const v45UcPresets = {
                'Heavy': 'nsfw, lowres, artistic error, film grain, scan artifacts, worst quality, bad quality, jpeg artifacts, very displeasing, chromatic aberration, dithering, halftone, screentone, multiple views, logo, too many watermarks, negative space, blank page',
                'Light': 'nsfw, lowres, artistic error, scan artifacts, worst quality, bad quality, jpeg artifacts, multiple views, very displeasing, too many watermarks, negative space, blank page',
                'Furry Focus': 'nsfw, {worst quality}, distracting watermark, unfinished, bad quality, {widescreen}, upscale, {sequence}, {{grandfathered content}}, blurred foreground, chromatic aberration, sketch, everyone, [sketch background], simple, [flat colors], ych (character), outline, multiple scenes, [[horror (theme)]], comic',
                'Human Focus': 'nsfw, lowres, artistic error, film grain, scan artifacts, worst quality, bad quality, jpeg artifacts, very displeasing, chromatic aberration, dithering, halftone, screentone, multiple views, logo, too many watermarks, negative space, blank page, @_@, mismatched pupils, glowing eyes, bad anatomy'
            };

            if (isPureNai) {
                // 순수 NAI 이미지: 프롬프트 끝에서 퀄리티 태그 제거
                let tagRemoved = false;
                for (const pattern of v45QualityTagsPatterns) {
                    if (prompt.endsWith(pattern)) {
                        prompt = prompt.slice(0, -pattern.length);
                        qualityTags = true;
                        tagRemoved = true;
                        break;
                    }
                }
                if (!tagRemoved) {
                    qualityTags = false;
                }

                // UC 프리셋 감지 및 제거
                let foundPreset = false;
                for (const [presetName, presetTags] of Object.entries(v45UcPresets)) {
                    if (negativePrompt.startsWith(presetTags)) {
                        ucPreset = presetName;
                        negativePrompt = negativePrompt.slice(presetTags.length);
                        negativePrompt = negativePrompt.replace(/^,\s*/, '');
                        foundPreset = true;
                        break;
                    }
                }
                if (!foundPreset) {
                    ucPreset = 'None';
                }
            }

            // PeroPix 이미지: base_prompt가 있으면 직접 사용 (v3+)
            // 없으면 기존 로직으로 슬롯 프롬프트 제거 시도 (v2 하위호환)
            if (!isPureNai) {
                if (ppx.base_prompt !== undefined) {
                    // v3+: base_prompt 직접 사용
                    prompt = ppx.base_prompt || '';
                } else if (slotPrompt) {
                    // v2 하위호환: 슬롯 프롬프트 수동 제거
                    // 1) 퀄리티 태그 제거 (끝에 있을 수 있음)
                    for (const pattern of v45QualityTagsPatterns) {
                        if (prompt.endsWith(pattern)) {
                            prompt = prompt.slice(0, -pattern.length);
                            qualityTags = true;
                            break;
                        }
                    }

                    // 2) 슬롯 프롬프트 제거
                    const slotSuffix = ', ' + slotPrompt;
                    if (prompt.endsWith(slotSuffix)) {
                        prompt = prompt.slice(0, -slotSuffix.length);
                    } else if (prompt.endsWith(',' + slotPrompt)) {
                        prompt = prompt.slice(0, -(slotPrompt.length + 1));
                    } else if (prompt.endsWith(slotPrompt)) {
                        prompt = prompt.slice(0, -slotPrompt.length).replace(/,\s*$/, '');
                    }
                }
            }

            // Variety+ 감지 (peropix 확장 또는 NAI skip_cfg_above_sigma)
            let varietyPlus = ppx.variety_plus || false;
            if (!varietyPlus && meta.skip_cfg_above_sigma !== undefined && meta.skip_cfg_above_sigma !== null) {
                varietyPlus = true;
            }

            // Furry Mode 감지 (peropix 확장 또는 프롬프트 시작)
            let furryMode = ppx.furry_mode || false;
            if (!furryMode && meta.prompt && meta.prompt.startsWith('fur dataset,')) {
                furryMode = true;
            }

            // NAI 형식 → 앱 내부 형식 변환
            // 모델명: request_type이 실제 모델명인지 확인 (NAI 내부 타입명 필터)
            let naiModel = '';
            if (meta.request_type && meta.request_type.startsWith('nai-diffusion')) {
                naiModel = meta.request_type;
            } else if (meta.model && meta.model.startsWith('nai-diffusion')) {
                naiModel = meta.model;
            }
            // request_type이 "PromptGenerateRequest" 같은 내부 타입이면 무시

            return {
                prompt: prompt,
                negative_prompt: negativePrompt,
                character_prompts: charPrompts,
                slot_prompt: slotPrompt,
                seed: meta.seed,
                width: meta.width,
                height: meta.height,
                steps: meta.steps,
                cfg: meta.scale,
                sampler: meta.sampler,
                scheduler: meta.noise_schedule || 'karras',
                nai_model: naiModel,
                smea: meta.sm_dyn ? 'SMEA+DYN' : (meta.sm ? 'SMEA' : 'none'),
                uc_preset: ucPreset,
                quality_tags: qualityTags,
                cfg_rescale: meta.cfg_rescale,
                variety_plus: varietyPlus,
                furry_mode: furryMode,
                provider: ppx.provider || 'nai',
                model: ppx.local_model || '',
                vibe_transfer: ppx.vibe_transfer || null,
                // NAI 바이브 데이터 (순수 NAI 이미지용)
                nai_vibes: {
                    images: meta.reference_image_multiple || [],
                    strengths: meta.reference_strength_multiple || [],
                    info_extracted: meta.reference_information_extracted_multiple || []
                },
                // NAI 캐릭터 레퍼런스 사용 여부 (이미지 데이터는 제외됨)
                has_character_reference: !!(meta.director_reference_strength_values?.length > 0)
            };
        }

        // 순수 NAI 이미지 적용 시 경고 팝업
        function showPureNaiWarning(callback) {
            const msg = `⚠️ 순수 NAI 이미지입니다.

[적용되지 않는 항목]
• Character Reference
• Base Image (img2img/inpaint)

계속하시겠습니까?`;
            if (confirm(msg)) {
                callback();
            }
        }

        // 프롬프트만 적용 (시드 포함)
        function applyPromptOnly(metadata) {
            // 프롬프트 (공란이어도 적용)
            if (metadata.prompt !== undefined) {
                const basePrompt = document.getElementById('basePrompt');
                basePrompt.value = metadata.prompt;
                basePrompt.dispatchEvent(new Event('input', { bubbles: true }));
            }
            if (metadata.negative_prompt !== undefined) {
                const negativePrompt = document.getElementById('negativePrompt');
                negativePrompt.value = metadata.negative_prompt;
                negativePrompt.dispatchEvent(new Event('input', { bubbles: true }));
            }

            // 캐릭터 프롬프트 적용
            if (metadata.character_prompts && metadata.character_prompts.length > 0) {
                const charactersList = document.getElementById('charactersList');
                charactersList.innerHTML = '';
                metadata.character_prompts.forEach(cp => {
                    if (cp && cp.trim()) {
                        addCharacter(cp);
                    }
                });
                updateCharacterNumbers();
            }

            // 슬롯 프롬프트 복원 (첫 번째 슬롯에)
            if (metadata.slot_prompt) {
                const slots = document.querySelectorAll('#slotsContainer .slot');
                if (slots.length > 0) {
                    const firstSlotTags = slots[0].querySelector('.slot-tags');
                    if (firstSlotTags) {
                        firstSlotTags.value = metadata.slot_prompt;
                        firstSlotTags.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }
            }

            showToast('프롬프트가 적용되었습니다', 'success');
        }

        // 메타데이터 설정 적용
        function applyMetadataSettings(metadata) {
            // 스크롤 위치 저장 (적용 후 복원용)
            const sidebarContent = document.querySelector('.sidebar-content');
            const savedScrollTop = sidebarContent ? sidebarContent.scrollTop : 0;

            // 요소 강조 함수 (스크롤/펼치기 없음)
            function highlight(elementId) {
                const el = document.getElementById(elementId);
                if (el) {
                    el.classList.remove('setting-highlight');
                    void el.offsetWidth; // reflow 트리거
                    el.classList.add('setting-highlight');
                    setTimeout(() => el.classList.remove('setting-highlight'), 1500);
                }
            }

            // 프롬프트 (공란이어도 적용)
            if (metadata.prompt !== undefined) {
                const basePrompt = document.getElementById('basePrompt');
                basePrompt.value = metadata.prompt;
                // 하이라이팅 업데이트를 위해 input 이벤트 트리거
                basePrompt.dispatchEvent(new Event('input', { bubbles: true }));
                highlight('basePromptContent');
            }
            if (metadata.negative_prompt !== undefined) {
                const negativePrompt = document.getElementById('negativePrompt');
                negativePrompt.value = metadata.negative_prompt;
                // 하이라이팅 업데이트를 위해 input 이벤트 트리거
                negativePrompt.dispatchEvent(new Event('input', { bubbles: true }));
                highlight('negativePromptContent');
            }

            // 캐릭터 프롬프트 적용
            if (metadata.character_prompts && metadata.character_prompts.length > 0) {
                // 기존 캐릭터 슬롯 모두 제거
                const charactersList = document.getElementById('charactersList');
                charactersList.innerHTML = '';
                // 새 캐릭터 프롬프트 추가
                metadata.character_prompts.forEach(cp => {
                    if (cp && cp.trim()) {
                        addCharacter(cp);
                    }
                });
                updateCharacterNumbers();
                highlight('charactersList');
            }

            // 슬롯 프롬프트 복원 (첫 번째 슬롯에)
            if (metadata.slot_prompt) {
                const slots = document.querySelectorAll('#slotsContainer .slot');
                if (slots.length > 0) {
                    const firstSlot = slots[0];
                    const firstSlotTags = firstSlot.querySelector('.slot-tags');
                    if (firstSlotTags) {
                        firstSlotTags.value = metadata.slot_prompt;
                        // 하이라이팅 오버레이 갱신을 위해 input 이벤트 트리거
                        firstSlotTags.dispatchEvent(new Event('input', { bubbles: true }));
                        // 슬롯 전체 강조
                        firstSlot.classList.add('setting-highlight');
                        setTimeout(() => firstSlot.classList.remove('setting-highlight'), 1500);
                    }
                }
            }

            // 크기
            if (metadata.width) {
                document.getElementById('width').value = metadata.width;
                highlight('width');
            }
            if (metadata.height) {
                document.getElementById('height').value = metadata.height;
                highlight('height');
            }
            // 사이즈 프리셋 체크
            const sizeValue = `${metadata.width}x${metadata.height}`;
            const sizePreset = document.getElementById('sizePreset');
            const matchingOption = [...sizePreset.options].find(o => o.value === sizeValue);
            sizePreset.value = matchingOption ? sizeValue : 'custom';

            // 생성 설정
            if (metadata.steps) {
                document.getElementById('steps').value = metadata.steps;
                highlight('steps');
            }
            if (metadata.cfg) {
                document.getElementById('cfg').value = metadata.cfg;
                highlight('cfg');
            }
            if (metadata.seed) {
                document.getElementById('seed').value = metadata.seed;
                highlight('seed');
            }
            if (metadata.sampler) {
                document.getElementById('sampler').value = metadata.sampler;
                highlight('sampler');
            }
            if (metadata.scheduler) {
                document.getElementById('scheduler').value = metadata.scheduler;
                highlight('scheduler');
            }

            // NAI 설정
            if (metadata.nai_model) {
                document.getElementById('naiModel').value = metadata.nai_model;
                highlight('naiModel');
            }
            if (metadata.smea) {
                document.getElementById('smea').value = metadata.smea;
                highlight('smea');
            }
            if (metadata.uc_preset) {
                document.getElementById('ucPreset').value = metadata.uc_preset;
                highlight('ucPreset');
            }
            if (metadata.quality_tags !== undefined) {
                document.getElementById('qualityTags').checked = metadata.quality_tags;
                highlight('qualityTags');
            }
            if (metadata.cfg_rescale !== undefined) {
                const cfgRescaleEl = document.getElementById('cfgRescale');
                cfgRescaleEl.value = metadata.cfg_rescale;
                document.getElementById('cfgRescaleValue').textContent = metadata.cfg_rescale;
                updateSliderFill(cfgRescaleEl);
                highlight('cfgRescale');
            }
            if (metadata.variety_plus !== undefined) {
                document.getElementById('varietyPlus').checked = metadata.variety_plus;
                highlight('varietyPlus');
            }
            if (metadata.furry_mode !== undefined) setFurryMode(metadata.furry_mode);

            // Local 설정
            if (metadata.model) {
                document.getElementById('localModel').value = metadata.model;
                highlight('localModel');
            }

            // Provider 설정
            if (metadata.provider && metadata.provider !== currentProvider) {
                // Provider 변경은 복잡하므로 알림만
                showToast(`원본 Provider: ${metadata.provider}`, 'warning');
            }

            // Vibe Transfer 설정
            let vibesRestored = false;
            let vibeCount = 0;
            if (metadata.vibe_transfer && metadata.vibe_transfer.length > 0) {
                // PeroPix 형식 바이브 - 기존 바이브 클리어 후 로드
                vibeCount = metadata.vibe_transfer.length;
                vibeList = [];  // 기존 바이브 클리어
                renderVibeList();  // 클리어 후 UI도 갱신
                loadVibesFromMetadata(metadata.vibe_transfer).catch(err => {
                    console.error('[Vibe] 바이브 로드 실패:', err);
                });
                vibesRestored = true;
                highlight('vibeTransferSettings');
                // Vibe/CharRef 섹션 펼치기 (스크롤 없이)
                expandAndScrollToSection('vibeCharRefContent', null, true);
            } else if (metadata.nai_vibes && metadata.nai_vibes.images && metadata.nai_vibes.images.length > 0) {
                // NAI 원본 이미지의 바이브 복원 (인코딩 데이터만 있음)
                const naiVibes = metadata.nai_vibes;
                vibeList = [];  // 기존 바이브 클리어

                for (let i = 0; i < naiVibes.images.length; i++) {
                    const encodedData = naiVibes.images[i];
                    const strength = naiVibes.strengths[i] || 0.6;
                    // info_extracted는 배열이 비어있을 수 있음 - 기본값 1.0
                    const infoExtracted = (naiVibes.info_extracted && naiVibes.info_extracted[i] !== undefined)
                        ? naiVibes.info_extracted[i]
                        : 1.0;

                    // 플레이스홀더 이미지 생성 (1x1 투명 PNG)
                    const placeholderImage = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';

                    vibeList.push({
                        image: placeholderImage,
                        strength: strength,
                        info_extracted: infoExtracted,
                        name: `NAI Vibe ${i + 1}`,
                        encoded: encodedData,
                        encoded_model: metadata.nai_model || 'nai-diffusion-4-5-full',
                        encoded_info_extracted: infoExtracted,
                        _isNaiVibe: true  // NAI 바이브 표시용
                    });
                }

                renderVibeList();
                saveAppSettings();
                updateAnlasCost();
                document.getElementById('enableVibeTransfer').checked = true;
                document.getElementById('vibeTransferSettings').style.display = 'block';
                // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                document.getElementById('enableCharRef').checked = false;
                document.getElementById('charRefSettings').style.display = 'none';
                vibesRestored = true;
                highlight('vibeTransferSettings');
                // Vibe/CharRef 섹션 펼치기 (스크롤 없이)
                expandAndScrollToSection('vibeCharRefContent', null, true);
            } else {
                // 바이브 없는 이미지: 기존 바이브 클리어
                if (vibeList.length > 0) {
                    vibeList = [];
                    renderVibeList();
                    document.getElementById('enableVibeTransfer').checked = false;
                    document.getElementById('vibeTransferSettings').style.display = 'none';
                    updateAnlasCost();
                }
            }

            autoSaveSettings();

            // 결과 메시지 - PeroPix 바이브는 loadVibesFromMetadata 내부에서 토스트 표시됨
            if (vibesRestored && metadata.nai_vibes?.images?.length > 0) {
                showToast(`설정 적용됨 (NAI 바이브 ${metadata.nai_vibes.images.length}개 복원)`, 'success');
            } else if (vibesRestored && vibeCount > 0) {
                showToast(`설정 적용됨 (바이브 로딩 중...)`, 'success');
            } else {
                showToast('설정을 불러왔습니다', 'success');
            }

            // 스크롤 위치 복원 (DOM 업데이트 후)
            requestAnimationFrame(() => {
                if (sidebarContent) {
                    sidebarContent.scrollTop = savedScrollTop;
                }
            });
        }

        // 메타데이터에서 바이브 로드 (메타데이터에 직접 저장된 데이터 사용)
        async function loadVibesFromMetadata(vibeInfoList) {
            if (!vibeInfoList || vibeInfoList.length === 0) return;

            try {
                let loadedCount = 0;

                for (const vibeInfo of vibeInfoList) {
                    // 최대 16개까지만
                    if (vibeList.length >= 16) break;

                    // 메타데이터에 직접 저장된 바이브 데이터 사용
                    if (vibeInfo.image) {
                        vibeList.push({
                            image: vibeInfo.image,
                            strength: vibeInfo.strength || 0.6,
                            info_extracted: vibeInfo.info_extracted || 1.0,
                            name: vibeInfo.name || `Vibe ${vibeList.length + 1}`,
                            encoded: vibeInfo.encoded || null,
                            encoded_model: vibeInfo.encoded_model || null,
                            encoded_info_extracted: vibeInfo.info_extracted || 1.0
                        });
                        loadedCount++;
                    }
                }

                if (loadedCount > 0) {
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                    document.getElementById('enableCharRef').checked = false;
                    document.getElementById('charRefSettings').style.display = 'none';
                    showToast(`바이브 ${loadedCount}개 복원됨`, 'success');
                } else {
                    showToast('바이브를 복원할 수 없습니다 (이미지 데이터 없음)', 'warning');
                }
            } catch (err) {
                console.error('[Vibe] 메타데이터에서 로드 실패:', err);
                showToast('바이브 복원 실패', 'error');
            }
        }

        // Event listeners
        generateBtn.onclick = addToQueue;
        cancelCurrentBtn.onclick = cancelCurrent;
        clearQueueBtn.onclick = clearQueue;
        document.getElementById('clearImagesBtn').onclick = clearResults;

        // Anime/Furry Mode Toggle
        let furryModeEnabled = false;
        const modeToggle = document.getElementById('modeToggle');

        function setFurryMode(enabled) {
            furryModeEnabled = enabled;
            if (enabled) {
                modeToggle.textContent = '🐾';
                modeToggle.title = '퍼리 모드';
                modeToggle.classList.add('furry');
            } else {
                modeToggle.textContent = '🌸';
                modeToggle.title = '아니메 모드';
                modeToggle.classList.remove('furry');
            }
            autoSaveSettings();
        }

        modeToggle.onclick = () => {
            setFurryMode(!furryModeEnabled);
        };

        // Collapse toggle for prompts and sections
        document.querySelectorAll('.collapse-toggle').forEach(btn => {
            const targetId = btn.dataset.target;
            const target = document.getElementById(targetId);
            if (!target) return;

            // 토글 함수
            const toggleCollapse = (e) => {
                // 프리셋 드롭다운 버튼, 기타 컨트롤 클릭은 무시
                if (e && e.target.closest('.prompt-preset-dropdown, .add-char-btn, .section-toggle, .mode-toggle, .translate-mode-btn')) return;
                // 이벤트 버블링 방지
                if (e) e.stopPropagation();

                btn.classList.toggle('collapsed');
                target.classList.toggle('collapsed');
                localStorage.setItem(`collapse_${targetId}`, btn.classList.contains('collapsed') ? 'collapsed' : 'expanded');
            };

            // 저장된 상태 복원 또는 기본값 설정
            const savedState = localStorage.getItem(`collapse_${targetId}`);
            if (savedState === 'collapsed') {
                btn.classList.add('collapsed');
                target.classList.add('collapsed');
            } else if (savedState === null) {
                // 첫 실행: basePromptContent만 펼치고 나머지 접기
                if (targetId !== 'basePromptContent') {
                    btn.classList.add('collapsed');
                    target.classList.add('collapsed');
                    localStorage.setItem(`collapse_${targetId}`, 'collapsed');
                }
            }

            // 클릭 가능한 바 찾기 (prompt-label-row가 prompt-label-left보다 우선)
            let clickableBar = btn.closest('.section-title, .characters-header');
            if (!clickableBar) {
                // prompt-label-left 안에 있으면 prompt-label-row를 찾음
                const promptLabelLeft = btn.closest('.prompt-label-left');
                if (promptLabelLeft) {
                    clickableBar = promptLabelLeft.closest('.prompt-label-row');
                }
            }

            // 바 전체에 클릭 이벤트 설정
            if (clickableBar) {
                clickableBar.addEventListener('click', toggleCollapse);
            } else {
                // 바가 없으면 버튼에만 설정
                btn.onclick = toggleCollapse;
            }
        });

        // 폴더 열기 버튼 핸들러
        async function openFolder(folderType, subfolder = '') {
            try {
                const response = await fetch(`${API_BASE}/api/open-folder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder: folderType, subfolder: subfolder })
                });
                const data = await response.json();
                if (data.error) {
                    showToast(`폴더 열기 실패: ${data.error}`, 'error');
                }
            } catch (e) {
                showToast('폴더 열기 실패', 'error');
            }
        }

        document.getElementById('openOutputFolderBtn').onclick = () => {
            openFolder('outputs', getOutputFolder());
        };
        document.getElementById('openVibeFolderBtn').onclick = () => openFolder('vibe_cache');
        document.getElementById('openCheckpointsFolderBtn').onclick = () => openFolder('checkpoints');
        document.getElementById('openLorasFolderBtn').onclick = () => openFolder('loras');
        document.getElementById('addLoraSlotBtn').onclick = addLoraSlot;

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                lightbox.classList.remove('active');
                closeSettings();
            }
            if (e.ctrlKey && e.key === 'Enter') {
                addToQueue();
            }
        });
        
        // 탭 활성화 시 WebSocket 재연결 확인
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                connectWebSocket();
            }
        });
        
        // Size Preset
        const sizePreset = document.getElementById('sizePreset');
        const widthInput = document.getElementById('width');
        const heightInput = document.getElementById('height');
        
        sizePreset.onchange = () => {
            const value = sizePreset.value;
            if (value !== 'custom') {
                const [w, h] = value.split('x').map(Number);
                widthInput.value = w;
                heightInput.value = h;
            }
            updateAnlasCost();
        };
        
        // Width/Height 직접 수정 시 Custom으로 변경
        function checkCustomSize() {
            const w = widthInput.value;
            const h = heightInput.value;
            const currentValue = `${w}x${h}`;
            
            // 프리셋에 있는 값인지 확인
            const options = [...sizePreset.options];
            const match = options.find(opt => opt.value === currentValue);
            
            if (match) {
                sizePreset.value = currentValue;
            } else {
                sizePreset.value = 'custom';
            }
        }
        
        widthInput.onchange = checkCustomSize;
        heightInput.onchange = checkCustomSize;
        
        // Hires.fix (Upscale) 활성화 토글
        document.getElementById('enableUpscale').onchange = function() {
            document.getElementById('upscaleSettings').style.display = this.checked ? 'block' : 'none';
            saveAppSettings();
        };

        // Upscale denoise slider value display
        document.getElementById('upscaleDenoise').oninput = function() {
            document.getElementById('upscaleDenoiseValue').textContent = this.value;
        };

        // LUT 활성화 토글
        document.getElementById('enableLut').onchange = function() {
            document.getElementById('lutSettings').style.display = this.checked ? 'block' : 'none';
            saveAppSettings();
        };

        // LUT intensity slider value display
        document.getElementById('lutIntensity').oninput = function() {
            document.getElementById('lutIntensityValue').textContent = this.value;
        };

        // CFG Rescale slider value display
        document.getElementById('cfgRescale').oninput = function() {
            document.getElementById('cfgRescaleValue').textContent = this.value;
        };

        // ============================================================
        // Vibe Transfer
        // ============================================================
        let vibeList = []; // {image: base64, info_extracted: 1.0, strength: 0.6}

        document.getElementById('enableVibeTransfer').onchange = function() {
            document.getElementById('vibeTransferSettings').style.display = this.checked ? 'block' : 'none';
            // Vibe Transfer와 Character Reference는 동시 사용 불가
            if (this.checked && document.getElementById('enableCharRef').checked) {
                document.getElementById('enableCharRef').checked = false;
                document.getElementById('charRefSettings').style.display = 'none';
            }
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('addVibeBtn').onclick = function() {
            if (vibeList.length >= 16) {
                alert('최대 16개까지만 추가할 수 있습니다.');
                return;
            }
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const base64 = await fileToBase64(file);
                vibeList.push({
                    image: base64,
                    info_extracted: 1.0,
                    strength: 0.6,
                    name: file.name
                });
                renderVibeList();
                saveAppSettings();
                updateAnlasCost();
            };
            input.click();
        };

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    // data:image/png;base64,XXXXX -> XXXXX 만 추출
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function renderVibeList() {
            const container = document.getElementById('vibeList');
            container.innerHTML = '';
            vibeList.forEach((vibe, idx) => {
                const item = document.createElement('div');
                item.className = 'vibe-item';
                // NAI 바이브 (원본 이미지 없음)는 특별 표시
                const isNaiVibe = vibe._isNaiVibe;
                const imgContent = isNaiVibe
                    ? `<div class="nai-vibe-placeholder" title="NAI에서 복원된 바이브 (원본 이미지 없음)">🎨</div>`
                    : `<img src="data:image/png;base64,${vibe.image}" alt="vibe">`;
                const cachedBadge = vibe.encoded ? '<span class="vibe-cached-badge" title="인코딩 캐시됨">✓</span>' : '';
                item.innerHTML = `
                    <div class="vibe-item-header">
                        ${imgContent}
                        <span class="vibe-info">${vibe.name || 'Vibe ' + (idx + 1)}${cachedBadge}</span>
                        <button type="button" class="remove-btn" data-idx="${idx}">×</button>
                    </div>
                    <div class="vibe-sliders">
                        <div class="vibe-slider-row">
                            <label>${isNaiVibe ? 'Reference Strength' : 'Strength'}</label>
                            <input type="range" class="vibe-strength" data-idx="${idx}" value="${vibe.strength}" min="0" max="1" step="0.05">
                            <span class="value">${vibe.strength}</span>
                        </div>
                        ${!isNaiVibe ? `<div class="vibe-slider-row">
                            <label>Info Extract</label>
                            <input type="range" class="vibe-info" data-idx="${idx}" value="${vibe.info_extracted}" min="0.01" max="1" step="0.01">
                            <span class="value">${vibe.info_extracted}</span>
                        </div>` : ''}
                    </div>
                `;
                container.appendChild(item);
            });

            // Event listeners
            container.querySelectorAll('.remove-btn').forEach(btn => {
                btn.onclick = function() {
                    vibeList.splice(parseInt(this.dataset.idx), 1);
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                };
            });
            container.querySelectorAll('.vibe-strength').forEach(slider => {
                slider.oninput = function() {
                    const idx = parseInt(this.dataset.idx);
                    vibeList[idx].strength = parseFloat(this.value);
                    // 래핑된 경우 부모의 부모에서 .value 찾기
                    const row = this.closest('.vibe-slider-row');
                    if (row) row.querySelector('.value').textContent = this.value;
                    saveAppSettings();
                };
            });
            container.querySelectorAll('.vibe-info').forEach(slider => {
                slider.oninput = function() {
                    const idx = parseInt(this.dataset.idx);
                    vibeList[idx].info_extracted = parseFloat(this.value);
                    // 래핑된 경우 부모의 부모에서 .value 찾기
                    const row = this.closest('.vibe-slider-row');
                    if (row) row.querySelector('.value').textContent = this.value;
                    saveAppSettings();
                    updateAnlasCost();  // info_extracted 변경시 캐시 상태 재확인
                };
            });

            // 동적 생성된 슬라이더 래핑 및 채움 초기화
            container.querySelectorAll('input[type="range"]').forEach(slider => {
                wrapSlider(slider);
            });
        }

        // ============================================================
        // Character Reference (V4.5 only)
        // ============================================================
        let charRefData = null; // {image: base64, processedImage: base64, fidelity: 0.5, style_aware: true}

        // Canvas 기반 이미지 처리 (NAIS2/NAI 웹과 동일한 방식)
        async function processCharacterReferenceImage(base64Image) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = function() {
                    const width = img.width;
                    const height = img.height;
                    
                    // 캔버스 크기 선택 (1472x1472, 1536x1024, 1024x1536)
                    let targetW = 1472, targetH = 1472;
                    if (width > height) {
                        targetW = 1536;
                        targetH = 1024;
                    } else if (width < height) {
                        targetW = 1024;
                        targetH = 1536;
                    }
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = targetW;
                    canvas.height = targetH;
                    const ctx = canvas.getContext('2d');
                    
                    // 검은 배경으로 채우기 (letterbox)
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, targetW, targetH);
                    
                    // 비율 유지하면서 리사이즈 계산
                    const scale = Math.min(targetW / width, targetH / height);
                    const w = width * scale;
                    const h = height * scale;
                    const x = (targetW - w) / 2;
                    const y = (targetH - h) / 2;
                    
                    // 이미지 그리기
                    ctx.drawImage(img, x, y, w, h);
                    
                    console.log(`[CharRef] Canvas processed: ${width}x${height} -> ${targetW}x${targetH}`);
                    
                    // JPEG 95% 품질로 출력 (NAIS2와 동일)
                    const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
                    const base64Only = dataUrl.split(',')[1];
                    resolve(base64Only);
                };
                img.onerror = () => reject(new Error('Image load failed'));
                img.src = base64Image.startsWith('data:') ? base64Image : 'data:image/png;base64,' + base64Image;
            });
        }

        document.getElementById('enableCharRef').onchange = function() {
            document.getElementById('charRefSettings').style.display = this.checked ? 'block' : 'none';
            // Vibe Transfer와 Character Reference는 동시 사용 불가
            if (this.checked && document.getElementById('enableVibeTransfer').checked) {
                document.getElementById('enableVibeTransfer').checked = false;
                document.getElementById('vibeTransferSettings').style.display = 'none';
            }
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('uploadCharRefBtn').onclick = function() {
            document.getElementById('charRefInput').click();
        };

        document.getElementById('charRefInput').onchange = async function() {
            const file = this.files[0];
            if (!file) return;
            const base64 = await fileToBase64(file);
            
            // Canvas로 이미지 처리 (NAI 웹/NAIS2와 동일한 방식)
            let processedImage;
            try {
                processedImage = await processCharacterReferenceImage(base64);
                console.log(`[CharRef] Image processed, length: ${processedImage.length}`);
            } catch (e) {
                console.error('[CharRef] Processing failed:', e);
                processedImage = base64; // 실패시 원본 사용
            }
            
            charRefData = {
                image: base64,  // 원본 (프리뷰용)
                processedImage: processedImage,  // 처리된 이미지 (API용)
                fidelity: parseFloat(document.getElementById('charRefFidelity').value),
                style_aware: document.getElementById('charRefStyleAware').checked
            };
            document.getElementById('charRefImage').src = 'data:image/png;base64,' + base64;
            document.getElementById('charRefPreview').style.display = 'block';
            document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('removeCharRefBtn').onclick = function() {
            charRefData = null;
            document.getElementById('charRefPreview').style.display = 'none';
            document.getElementById('uploadCharRefBtn').textContent = '이미지 선택';
            document.getElementById('charRefInput').value = '';
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('charRefFidelity').oninput = function() {
            document.getElementById('charRefFidelityValue').textContent = this.value;
            updateSliderFill(this);
            if (charRefData) {
                charRefData.fidelity = parseFloat(this.value);
                saveAppSettings();
            }
        };

        document.getElementById('charRefStyleAware').onchange = function() {
            if (charRefData) {
                charRefData.style_aware = this.checked;
                saveAppSettings();
            }
        };

        // ============================================================
        // Anlas System
        // ============================================================
        let currentAnlas = null;
        let isOpusTier = false;

        async function fetchAnlasBalance() {
            try {
                const response = await fetch(`${API_BASE}/api/nai/subscription`);
                const data = await response.json();

                if (data.error) {
                    document.getElementById('anlasBalance').textContent = 'Error';
                    return;
                }

                currentAnlas = data.anlas;
                isOpusTier = data.tier >= 3; // Tier 3 = Opus
                console.log('[Anlas] Subscription loaded:', { tier: data.tier, isOpusTier, anlas: currentAnlas });

                document.getElementById('anlasBalance').textContent =
                    currentAnlas !== null ? currentAnlas.toLocaleString() : '--';

                updateAnlasCost();
            } catch (e) {
                console.error('[Anlas] Failed to fetch subscription:', e);
                document.getElementById('anlasBalance').textContent = '--';
            }
        }

        async function updateAnlasCost() {
            if (currentProvider !== 'nai') return;

            const width = parseInt(document.getElementById('width').value) || 832;
            const height = parseInt(document.getElementById('height').value) || 1216;
            const steps = parseInt(document.getElementById('steps').value) || 28;
            const vibeEnabled = document.getElementById('enableVibeTransfer').checked;
            const vibeCount = vibeEnabled ? vibeList.length : 0;
            const hasCharRef = document.getElementById('enableCharRef').checked && charRefData !== null;
            const repeatCount = parseInt(document.getElementById('repeatCount').value) || 1;
            const slotCount = document.querySelectorAll('.slot').length || 1;
            const totalCount = repeatCount * slotCount;
            const naiModel = document.getElementById('naiModel').value;

            // Vibe 데이터 (캐시 체크용)
            const vibes = vibeEnabled ? vibeList.map(v => ({
                image: v.image,
                info_extracted: v.info_extracted,
                encoded: !!v.encoded,  // 이미 인코딩된 바이브인지 여부
                encoded_model: v.encoded_model,  // 인코딩된 모델
                encoded_info_extracted: v.encoded_info_extracted  // 인코딩 시 사용된 info_extracted
            })) : [];

            try {
                const response = await fetch(`${API_BASE}/api/nai/calculate-cost`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        width, height, steps,
                        is_opus: isOpusTier,
                        vibe_count: vibeCount,
                        has_char_ref: hasCharRef,
                        count: totalCount,
                        vibes: vibes,
                        model: naiModel
                    })
                });
                const data = await response.json();
                console.log('[Cost Response]', data);

                if (data.is_free && data.vibe_encoding_cost === 0) {
                    document.getElementById('anlasCost').style.display = 'none';
                    document.getElementById('anlasFreeTag').style.display = 'inline';
                } else {
                    document.getElementById('anlasCost').style.display = 'inline';
                    document.getElementById('anlasFreeTag').style.display = 'none';

                    // Vibe 인코딩 비용 (일회성, 바이브 갯수만큼)
                    if (data.vibe_encoding_cost > 0) {
                        document.getElementById('anlasCost').textContent =
                            `${data.vibe_encoding_cost} (바이브 ${data.uncached_vibes}개)`;
                    }
                    // 일반 생성 비용 (CharRef 등)
                    else {
                        let costText = data.total_cost.toLocaleString();
                        if (slotCount > 1 || repeatCount > 1) {
                            let breakdown = `${data.cost_per_image}`;
                            if (slotCount > 1) breakdown += ` × ${slotCount}슬롯`;
                            if (repeatCount > 1) breakdown += ` × ${repeatCount}회`;
                            costText += ` (${breakdown})`;
                        }
                        document.getElementById('anlasCost').textContent = costText;
                    }
                }

                // Vibe 캐시 상태 표시
                const vibeCacheInfo = document.getElementById('vibeCacheInfo');
                if (vibeCacheInfo && vibes.length > 0) {
                    if (data.cached_vibes > 0 && data.uncached_vibes === 0) {
                        vibeCacheInfo.textContent = `✓ ${data.cached_vibes}개 캐시됨 (무료)`;
                        vibeCacheInfo.style.color = '#4CAF82';
                    } else if (data.uncached_vibes > 0) {
                        vibeCacheInfo.textContent = `${data.uncached_vibes}개 인코딩 필요 (+${data.vibe_encoding_cost} Anlas)`;
                        vibeCacheInfo.style.color = '#F5B942';
                    }
                    vibeCacheInfo.style.display = 'block';
                } else if (vibeCacheInfo) {
                    vibeCacheInfo.style.display = 'none';
                }
            } catch (e) {
                document.getElementById('anlasCost').textContent = '?';
            }
        }

        // Anlas UI 표시/숨김 (provider에 따라)
        function updateAnlasVisibility() {
            const anlasInfo = document.getElementById('anlasInfo');
            if (currentProvider === 'nai') {
                anlasInfo.style.display = 'block';
                fetchAnlasBalance();
            } else {
                anlasInfo.style.display = 'none';
            }
        }

        // Anlas 새로고침 버튼
        document.getElementById('refreshAnlasBtn').onclick = function() {
            this.style.transform = 'rotate(360deg)';
            setTimeout(() => this.style.transform = '', 300);
            fetchAnlasBalance();
        };

        // 설정 변경시 비용 재계산
        ['width', 'height', 'steps', 'repeatCount'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', updateAnlasCost);
            }
        });

        // Vibe/CharRef/모델 변경시 비용 재계산
        document.getElementById('enableVibeTransfer').addEventListener('change', updateAnlasCost);
        document.getElementById('enableCharRef').addEventListener('change', updateAnlasCost);
        document.getElementById('naiModel').addEventListener('change', () => {
            updateAnlasCost();
            updateSmeaVisibility();
        });

        // V4+ 모델에서 SMEA 비활성화
        function updateSmeaVisibility() {
            const model = document.getElementById('naiModel').value;
            const isV4 = model.includes('diffusion-4');
            const smeaSelect = document.getElementById('smea');
            const smeaContainer = smeaSelect.parentElement;

            if (isV4) {
                smeaSelect.value = 'none';
                smeaContainer.style.opacity = '0.5';
                smeaSelect.disabled = true;
                smeaContainer.title = 'V4+ 모델에서는 SMEA를 지원하지 않습니다';
            } else {
                smeaContainer.style.opacity = '1';
                smeaSelect.disabled = false;
                smeaContainer.title = '';
            }
        }
        updateSmeaVisibility(); // 초기 실행

        // ============================================================
        // Prompt Weight Highlighting System
        // ============================================================

        let promptHighlightEnabled = true;

        /**
         * NAI 문법 파싱: {text}, [text], number::text ::
         * @param {string} text - 파싱할 프롬프트 텍스트
         * @returns {Array} - [{text: string, level: number}, ...]
         */
        function parseNAIWeights(text) {
            const result = [];
            let i = 0;
            let currentLevel = 0;
            let levelStack = [];

            while (i < text.length) {
                // 수치 가중치 파싱: number::
                if (text[i].match(/\d/) || text[i] === '-') {
                    const numMatch = text.substring(i).match(/^(-?\d+\.?\d*)::(.*?)::/);
                    if (numMatch) {
                        const weight = parseFloat(numMatch[1]);
                        const content = numMatch[2];

                        // 가중치를 레벨로 변환 (1.0 = 0, 1.5 = +5, 0.5 = -5)
                        let level = Math.round((weight - 1.0) * 10);

                        // 수치 문법은 괄호 포함
                        result.push({ text: `${numMatch[1]}::${content}::`, level });
                        i += numMatch[0].length;
                        continue;
                    }
                }

                // { 강화 괄호
                if (text[i] === '{') {
                    result.push({ text: '{', level: 0 }); // 괄호는 강조 없음
                    levelStack.push(currentLevel);
                    currentLevel++;
                    i++;
                    continue;
                }

                // [ 약화 괄호
                if (text[i] === '[') {
                    result.push({ text: '[', level: 0 }); // 괄호는 강조 없음
                    levelStack.push(currentLevel);
                    currentLevel--;
                    i++;
                    continue;
                }

                // 닫는 괄호 } ]
                if (text[i] === '}' || text[i] === ']') {
                    if (levelStack.length > 0) {
                        currentLevel = levelStack.pop();
                    }
                    result.push({ text: text[i], level: 0 }); // 괄호는 강조 없음
                    i++;
                    continue;
                }

                // 일반 텍스트 수집
                let textChunk = '';
                while (i < text.length && text[i] !== '{' && text[i] !== '[' && text[i] !== '}' && text[i] !== ']') {
                    // 수치 가중치 체크
                    if (text[i].match(/\d/) || text[i] === '-') {
                        const numMatch = text.substring(i).match(/^(-?\d+\.?\d*)::(.*?)::/);
                        if (numMatch) break;
                    }
                    textChunk += text[i];
                    i++;
                }

                if (textChunk) {
                    result.push({ text: textChunk, level: currentLevel });
                }
            }

            return result;
        }

        /**
         * Local (Stable Diffusion) 문법 파싱: (text), [text], (text:number)
         * @param {string} text - 파싱할 프롬프트 텍스트
         * @returns {Array} - [{text: string, level: number}, ...]
         */
        function parseLocalWeights(text) {
            const result = [];
            let i = 0;
            let currentLevel = 0;
            let levelStack = [];

            while (i < text.length) {
                // ( 강화 괄호
                if (text[i] === '(') {
                    // (text:number) 형식 체크
                    const weightMatch = text.substring(i).match(/^\(([^:)]+):(-?\d+\.?\d*)\)/);
                    if (weightMatch) {
                        const content = weightMatch[1];
                        const weight = parseFloat(weightMatch[2]);

                        // 가중치를 레벨로 변환 (1.0 = 0, 1.1 = +1, 0.9 = -1)
                        let level = Math.round((weight - 1.0) * 10);

                        // 수치 문법은 괄호 포함
                        result.push({ text: `(${content}:${weightMatch[2]})`, level });
                        i += weightMatch[0].length;
                        continue;
                    }

                    // 일반 (text) 형식
                    result.push({ text: '(', level: 0 }); // 괄호는 강조 없음
                    levelStack.push(currentLevel);
                    currentLevel++;
                    i++;
                    continue;
                }

                // [ 약화 괄호
                if (text[i] === '[') {
                    result.push({ text: '[', level: 0 }); // 괄호는 강조 없음
                    levelStack.push(currentLevel);
                    currentLevel--;
                    i++;
                    continue;
                }

                // 닫는 괄호 ) ]
                if (text[i] === ')' || text[i] === ']') {
                    if (levelStack.length > 0) {
                        currentLevel = levelStack.pop();
                    }
                    result.push({ text: text[i], level: 0 }); // 괄호는 강조 없음
                    i++;
                    continue;
                }

                // 일반 텍스트 수집
                let textChunk = '';
                while (i < text.length && text[i] !== '(' && text[i] !== '[' && text[i] !== ')' && text[i] !== ']') {
                    textChunk += text[i];
                    i++;
                }

                if (textChunk) {
                    result.push({ text: textChunk, level: currentLevel });
                }
            }

            return result;
        }

        /**
         * 가중치 레벨을 색상으로 변환 (-2 ~ +2 범위로 제한)
         * @param {number} level - 가중치 레벨
         * @returns {string} - CSS 색상 문자열
         */
        function levelToColor(level) {
            // 레벨을 -2 ~ +2 범위로 제한
            const clampedLevel = Math.max(-2, Math.min(2, level));

            if (clampedLevel === 0) {
                return 'transparent';
            }

            const goldColor = '#F5B942'; // --accent-gold
            const blueColor = '#4A7AB8'; // --accent

            if (clampedLevel > 0) {
                // 강화: 골드 (투명도로 강도 표현)
                const opacity = 0.2 + (clampedLevel / 2) * 0.3; // 0.2 ~ 0.5
                return `rgba(245, 185, 66, ${opacity})`;
            } else {
                // 약화: 블루 (투명도로 강도 표현)
                const opacity = 0.2 + (Math.abs(clampedLevel) / 2) * 0.3; // 0.2 ~ 0.5
                return `rgba(74, 122, 184, ${opacity})`;
            }
        }

        // ============================================================
        // 번역 모드 (Translate Mode)
        // ============================================================
        let translateModeEnabled = false;
        const translateCache = new Map(); // 번역 캐시
        const translateUndoStack = []; // 번역 Undo 스택 (textarea별로 저장)
        const MAX_UNDO_STACK = 50; // 최대 Undo 저장 개수

        /**
         * Google Translate 무료 API로 번역
         * @param {string} text - 번역할 텍스트
         * @param {string} sourceLang - 소스 언어 (auto, en, ko)
         * @param {string} targetLang - 타겟 언어 (ko, en)
         * @returns {Promise<string>} - 번역된 텍스트
         */
        async function translateText(text, sourceLang = 'auto', targetLang = 'ko') {
            const cacheKey = `${text}|${sourceLang}|${targetLang}`;
            if (translateCache.has(cacheKey)) {
                return translateCache.get(cacheKey);
            }

            try {
                const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${sourceLang}&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`;
                const response = await fetch(url);
                const data = await response.json();

                // 응답 형식: [[["번역결과","원문",null,null,10]],null,"en",...]
                const translated = data[0].map(item => item[0]).join('');
                translateCache.set(cacheKey, translated);
                return translated;
            } catch (e) {
                console.error('[Translate] Error:', e);
                return text; // 실패 시 원문 반환
            }
        }

        /**
         * 번역 모드 토글
         */
        function toggleTranslateMode() {
            translateModeEnabled = !translateModeEnabled;

            // 버튼 상태 업데이트
            document.querySelectorAll('.translate-mode-btn').forEach(btn => {
                btn.classList.toggle('active', translateModeEnabled);
            });

            // container와 overlay에 클래스 추가/제거
            document.querySelectorAll('.prompt-highlight-container').forEach(container => {
                container.classList.toggle('translate-mode', translateModeEnabled);
            });

            // 하이라이트 다시 렌더링 (hover 이벤트 추가/제거)
            updatePromptHighlights();

            if (translateModeEnabled) {
                showToast('번역 모드 ON - 태그에 마우스를 올리면 번역이 표시됩니다', 'info');
            } else {
                hideTranslateTooltip();
            }
        }

        /**
         * 번역 툴팁 생성/표시
         */
        let translateTooltip = null;
        function showTranslateTooltip(element, translatedText) {
            if (!translateTooltip) {
                translateTooltip = document.createElement('div');
                translateTooltip.className = 'translate-tooltip';
                document.body.appendChild(translateTooltip);
            }

            translateTooltip.textContent = translatedText;
            translateTooltip.style.display = 'block';
            translateTooltip.style.visibility = 'hidden'; // 위치 계산을 위해 숨김

            // 위치 계산
            const rect = element.getBoundingClientRect();
            let top = rect.top - translateTooltip.offsetHeight - 5;
            let left = rect.left;

            // 위로 넘치면 아래에 표시
            if (top < 5) {
                top = rect.bottom + 5;
            }

            // 오른쪽으로 넘치면 조정
            if (left + translateTooltip.offsetWidth > window.innerWidth - 10) {
                left = window.innerWidth - translateTooltip.offsetWidth - 10;
            }

            // 왼쪽으로 넘치면 조정
            if (left < 5) {
                left = 5;
            }

            translateTooltip.style.left = left + 'px';
            translateTooltip.style.top = top + 'px';
            translateTooltip.style.visibility = 'visible';
        }

        function hideTranslateTooltip() {
            if (translateTooltip) {
                translateTooltip.style.display = 'none';
            }
        }

        // ESC 키로 번역 모드 해제
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && translateModeEnabled) {
                toggleTranslateMode();
            }
        });

        // 허공 클릭 시 번역 모드 해제
        document.addEventListener('click', (e) => {
            if (!translateModeEnabled) return;
            // 번역 버튼, 태그 세그먼트, 툴팁 클릭은 무시
            if (e.target.closest('.translate-mode-btn, .tag-segment, .translate-tooltip')) return;
            toggleTranslateMode();
        });

        /**
         * 모든 프롬프트 필드의 하이라이트를 업데이트
         * (프로그래매틱하게 value를 변경한 후 호출)
         */
        function updatePromptHighlights() {
            document.querySelectorAll('.prompt-highlight-overlay').forEach(overlay => {
                const container = overlay.parentElement;
                const textarea = container?.querySelector('textarea');
                if (textarea) {
                    highlightPrompt(textarea, overlay);
                }
            });
        }

        /**
         * 프롬프트 텍스트를 하이라이팅하여 overlay에 렌더링
         * @param {HTMLTextAreaElement} textarea - 프롬프트 textarea
         * @param {HTMLElement} overlay - overlay div
         */
        function highlightPrompt(textarea, overlay) {
            const text = textarea.value;
            if (!text) {
                overlay.innerHTML = '';
                overlay.classList.remove('translate-mode');
                return;
            }

            // 번역 모드 클래스 토글
            overlay.classList.toggle('translate-mode', translateModeEnabled);

            // 하이라이트가 꺼져있으면 일반 텍스트만 표시
            if (!promptHighlightEnabled) {
                let escapedText = text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
                // 텍스트가 줄바꿈으로 끝나면 추가 공간 확보
                if (text.endsWith('\n')) {
                    escapedText += '\u00A0';
                }
                overlay.innerHTML = escapedText;
                overlay.scrollTop = textarea.scrollTop;
                overlay.scrollLeft = textarea.scrollLeft;
                return;
            }

            // 현재 모드에 따라 파서 선택
            const naiTab = document.getElementById('naiTab');
            const localTab = document.getElementById('localTab');
            const isLocalMode = localTab && localTab.classList.contains('active');
            const parseFunction = isLocalMode ? parseLocalWeights : parseNAIWeights;

            // 텍스트 파싱
            const parsed = parseFunction(text);

            // HTML 생성 - 번역 모드일 때는 쉼표 기준 태그 세그먼트로 분리
            let html = '';

            if (translateModeEnabled) {
                // 번역 모드: 쉼표 기준으로 태그 세그먼트 분리
                // 기존 파싱 결과를 유지하면서 쉼표를 기준으로 태그 단위로 묶기
                let currentTag = [];
                let currentTagText = '';

                parsed.forEach((chunk, idx) => {
                    const chunkText = chunk.text;

                    // 쉼표가 포함된 청크 처리
                    if (chunkText.includes(',')) {
                        const parts = chunkText.split(/(?<=,)/); // 쉼표 뒤에서 분리 (쉼표 포함)

                        parts.forEach((part, partIdx) => {
                            if (part.endsWith(',')) {
                                // 쉼표로 끝나면 현재 태그 완료
                                currentTag.push({ text: part, level: chunk.level });
                                currentTagText += part;
                                html += renderTagSegment(currentTag, currentTagText.trim());
                                currentTag = [];
                                currentTagText = '';
                            } else if (part) {
                                // 쉼표 없는 부분은 다음 태그에 포함
                                currentTag.push({ text: part, level: chunk.level });
                                currentTagText += part;
                            }
                        });
                    } else {
                        currentTag.push(chunk);
                        currentTagText += chunkText;
                    }
                });

                // 마지막 태그 처리 (쉼표로 끝나지 않은 경우)
                if (currentTag.length > 0) {
                    html += renderTagSegment(currentTag, currentTagText.trim());
                }
            } else {
                // 기존 하이라이트 모드
                parsed.forEach(chunk => {
                    const color = levelToColor(chunk.level);
                    const escapedText = chunk.text
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#039;');

                    if (color === 'transparent' || !color) {
                        html += escapedText;
                    } else {
                        html += `<span style="background-color: ${color};">${escapedText}</span>`;
                    }
                });
            }

            // 텍스트가 줄바꿈으로 끝나면 추가 공간 확보 (커서 위치 동기화)
            if (text.endsWith('\n')) {
                html += '\u00A0'; // non-breaking space
            }

            overlay.innerHTML = html;

            // 번역 모드일 때 이벤트 바인딩
            if (translateModeEnabled) {
                overlay.querySelectorAll('.tag-segment').forEach(span => {
                    span.addEventListener('mouseenter', handleTagHover);
                    span.addEventListener('mouseleave', hideTranslateTooltip);
                    span.addEventListener('click', handleTagClick);
                });
            }

            // overlay 스크롤을 textarea와 동기화
            overlay.scrollTop = textarea.scrollTop;
            overlay.scrollLeft = textarea.scrollLeft;
        }

        /**
         * 태그 세그먼트를 HTML로 렌더링 (번역 모드용)
         * @param {Array} chunks - 파싱된 청크 배열
         * @param {string} rawTag - 원본 태그 텍스트 (번역용)
         */
        function renderTagSegment(chunks, rawTag) {
            let innerHtml = '';
            chunks.forEach(chunk => {
                const color = levelToColor(chunk.level);
                const escapedText = chunk.text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');

                if (color === 'transparent' || !color) {
                    innerHtml += escapedText;
                } else {
                    innerHtml += `<span style="background-color: ${color};">${escapedText}</span>`;
                }
            });

            // 태그 텍스트에서 괄호와 가중치 제거하여 순수 태그만 추출
            const pureTag = rawTag
                .replace(/[\{\}\[\]]/g, '')  // NAI 괄호 제거
                .replace(/\([^)]*:[^)]*\)/g, (m) => m.replace(/:[^)]*\)/, ')'))  // (tag:1.2) -> (tag)
                .replace(/[()]/g, '')  // 일반 괄호 제거
                .replace(/,\s*$/, '')  // 끝 쉼표 제거
                .trim();

            return `<span class="tag-segment" data-tag="${pureTag.replace(/"/g, '&quot;')}">${innerHtml}</span>`;
        }

        /**
         * 한글 포함 여부 확인
         */
        function containsKorean(text) {
            return /[가-힣ㄱ-ㅎㅏ-ㅣ]/.test(text);
        }

        /**
         * 태그 호버 시 번역 처리
         */
        let lastTranslatedTag = null;  // 마지막 번역 결과 저장
        let lastTranslatedResult = null;

        async function handleTagHover(e) {
            const span = e.target.closest('.tag-segment');
            if (!span) return;

            const tag = span.dataset.tag;
            if (!tag || tag.trim() === '' || tag === ',') return;

            // 로딩 표시
            showTranslateTooltip(span, '번역 중...');

            // 한글이 포함되어 있으면 영어로, 아니면 한글로 번역
            const isKorean = containsKorean(tag);
            const sourceLang = isKorean ? 'ko' : 'en';
            const targetLang = isKorean ? 'en' : 'ko';

            const translated = await translateText(tag, sourceLang, targetLang);

            // 번역 결과 저장 (클릭 시 사용)
            lastTranslatedTag = tag;
            lastTranslatedResult = translated;

            // 여전히 호버 중인지 확인
            if (span.matches(':hover')) {
                showTranslateTooltip(span, translated);
            }
        }

        /**
         * 태그 클릭 시 번역 결과로 교체
         */
        async function handleTagClick(e) {
            const span = e.target.closest('.tag-segment');
            if (!span) return;

            const tag = span.dataset.tag;
            if (!tag || tag.trim() === '' || tag === ',') return;

            // 번역 결과가 없으면 먼저 번역
            let translated = lastTranslatedResult;
            if (lastTranslatedTag !== tag || !translated) {
                const isKorean = containsKorean(tag);
                const sourceLang = isKorean ? 'ko' : 'en';
                const targetLang = isKorean ? 'en' : 'ko';
                translated = await translateText(tag, sourceLang, targetLang);
            }

            // 같은 텍스트면 교체 안함
            if (translated === tag) return;

            // overlay의 부모 container에서 textarea 찾기
            const container = span.closest('.prompt-highlight-container');
            if (!container) return;
            const textarea = container.querySelector('textarea');
            if (!textarea) return;

            // textarea에서 해당 태그를 번역 결과로 교체
            const text = textarea.value;
            const escapedTag = tag.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            // 태그 경계를 고려한 정규식 (쉼표, 시작, 끝, 괄호 등)
            const regex = new RegExp(`(^|,\\s*|[{\\[\\(])${escapedTag}(\\s*,|\\s*$|[}\\]\\)])`, 'g');

            const newText = text.replace(regex, (match, before, after) => {
                return before + translated + after;
            });

            if (newText !== text) {
                // Undo 스택에 이전 상태 저장
                translateUndoStack.push({
                    textarea: textarea,
                    value: text,
                    selectionStart: textarea.selectionStart,
                    selectionEnd: textarea.selectionEnd
                });
                // 스택 크기 제한
                if (translateUndoStack.length > MAX_UNDO_STACK) {
                    translateUndoStack.shift();
                }

                textarea.value = newText;
                textarea.dispatchEvent(new Event('input', { bubbles: true }));
                hideTranslateTooltip();
                showToast(`"${tag}" → "${translated}" (Ctrl+Z로 되돌리기)`, 'success', 2000);
            }
        }

        /**
         * 번역 Undo 처리
         */
        function undoTranslation() {
            if (translateUndoStack.length === 0) return false;

            const lastState = translateUndoStack.pop();
            if (lastState && lastState.textarea) {
                lastState.textarea.value = lastState.value;
                lastState.textarea.selectionStart = lastState.selectionStart;
                lastState.textarea.selectionEnd = lastState.selectionEnd;
                lastState.textarea.dispatchEvent(new Event('input', { bubbles: true }));
                showToast('번역 되돌리기 완료', 'success', 1500);
                return true;
            }
            return false;
        }

        // Ctrl+Z 키 이벤트 핸들러 (번역 모드에서 Undo)
        document.addEventListener('keydown', (e) => {
            if (translateModeEnabled && e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                if (translateUndoStack.length > 0) {
                    e.preventDefault();
                    e.stopPropagation();
                    undoTranslation();
                }
            }
        }, true); // capture phase에서 처리

        /**
         * textarea에 프롬프트 하이라이팅 적용
         * @param {HTMLTextAreaElement} textarea - 대상 textarea
         */
        function setupPromptHighlighting(textarea) {
            if (!textarea) {
                console.warn('[PromptHighlight] setupPromptHighlighting called with null textarea');
                return;
            }

            // 이미 설정된 경우 스킵
            if (textarea.dataset.highlightSetup === 'true') {
                console.log('[PromptHighlight] Already setup for', textarea.id);
                return;
            }
            textarea.dataset.highlightSetup = 'true';

            console.log('[PromptHighlight] Setting up highlighting for', textarea.id);

            // Wrapper 생성
            const wrapper = document.createElement('div');
            wrapper.className = 'prompt-highlight-container';
            // 번역 모드가 이미 켜져 있으면 클래스 추가
            if (translateModeEnabled) {
                wrapper.classList.add('translate-mode');
            }

            // Overlay 생성
            const overlay = document.createElement('div');
            overlay.className = 'prompt-highlight-overlay';

            // textarea를 wrapper로 감싸기
            textarea.parentNode.insertBefore(wrapper, textarea);
            wrapper.appendChild(overlay);
            wrapper.appendChild(textarea);

            console.log('[PromptHighlight] Created wrapper and overlay for', textarea.id);

            // textarea의 계산된 스타일을 overlay에 복사 (폰트 관련)
            function syncStyles() {
                const computed = window.getComputedStyle(textarea);
                overlay.style.padding = computed.padding;
                overlay.style.fontSize = computed.fontSize;
                overlay.style.fontFamily = computed.fontFamily;
                overlay.style.lineHeight = computed.lineHeight;
                overlay.style.letterSpacing = computed.letterSpacing;
                overlay.style.wordSpacing = computed.wordSpacing;

                // 스크롤바 영역 보정: textarea에 스크롤바가 있으면 overlay의 padding-right 증가
                const hasScrollbar = textarea.scrollHeight > textarea.clientHeight;
                if (hasScrollbar) {
                    const paddingRight = parseFloat(computed.paddingRight) || 0;
                    // 스크롤바 너비: border 제외한 전체 너비 - 실제 컨텐츠 영역 너비
                    const scrollbarWidth = textarea.offsetWidth - textarea.clientWidth -
                        (parseFloat(computed.borderLeftWidth) || 0) - (parseFloat(computed.borderRightWidth) || 0);
                    overlay.style.paddingRight = (paddingRight + scrollbarWidth) + 'px';
                } else {
                    overlay.style.paddingRight = computed.paddingRight;
                }
            }

            // 초기 하이라이팅
            syncStyles();
            highlightPrompt(textarea, overlay);

            // 이벤트 리스너
            textarea.addEventListener('input', () => {
                syncStyles();
                highlightPrompt(textarea, overlay);
            });

            textarea.addEventListener('scroll', () => {
                overlay.scrollTop = textarea.scrollTop;
                overlay.scrollLeft = textarea.scrollLeft;
            });

            // 창 크기 변경 시 재렌더링
            const resizeObserver = new ResizeObserver(() => {
                syncStyles();
                highlightPrompt(textarea, overlay);
            });
            resizeObserver.observe(textarea);
        }

        // ============================================================
        // Tag Autocomplete System
        // ============================================================

        let ALL_TAGS = [];
        let TAG_INDEX = {}; // 첫 글자 인덱싱 for O(1) access
        let tagAutocompleteEnabled = true;
        let tagsLoaded = false;

        // Load tag data from JSON
        async function loadTagData() {
            console.log('[TagAutocomplete] Loading tag data from data/tags.json...');
            try {
                const response = await fetch('data/tags.json');
                console.log('[TagAutocomplete] Fetch response:', response.status, response.statusText);

                if (!response.ok) {
                    console.warn('[TagAutocomplete] Tag data not found (HTTP ' + response.status + '). Autocomplete disabled.');
                    tagAutocompleteEnabled = false;
                    return;
                }

                const tags = await response.json();
                ALL_TAGS = tags;
                console.log('[TagAutocomplete] Parsed', ALL_TAGS.length, 'tags from JSON');

                // Build first-letter index for fast lookup
                TAG_INDEX = {};
                tags.forEach(tag => {
                    const firstChar = tag.label[0].toLowerCase();
                    if (!TAG_INDEX[firstChar]) {
                        TAG_INDEX[firstChar] = [];
                    }
                    TAG_INDEX[firstChar].push(tag);

                    // Add lowercase cache
                    tag._lower = tag.label.toLowerCase();
                });

                tagsLoaded = true;
                console.log('[TagAutocomplete] Ready! Loaded', ALL_TAGS.length, 'tags, indexed', Object.keys(TAG_INDEX).length, 'letters');
                console.log('[TagAutocomplete] Enabled:', tagAutocompleteEnabled);
            } catch (error) {
                console.error('[TagAutocomplete] Failed to load tag data:', error);
                tagAutocompleteEnabled = false;
            }
        }

        // Get current word at cursor position
        function getCurrentWord(textarea) {
            const value = textarea.value;
            const cursorPos = textarea.selectionStart;

            // 태그에 유효한 문자: 알파벳, 숫자, 언더스코어, 하이픈, 공백
            const isTagChar = (char) => /[a-zA-Z0-9_\-\s]/.test(char);

            // 커서 위치에서 뒤로 스캔하여 단어 시작점 찾기
            let start = cursorPos;
            while (start > 0) {
                const char = value[start - 1];
                // 콤마, 개행, 괄호, 콜론은 단어 경계
                if (char === ',' || char === '\n' || char === '\r' ||
                    char === '{' || char === '}' || char === '[' || char === ']' ||
                    char === '(' || char === ')' || char === ':') {
                    break;
                }
                if (!isTagChar(char)) {
                    break;
                }
                start--;
            }

            // 커서 위치에서 앞으로 스캔하여 단어 끝점 찾기 (태그 삽입 시 교체 범위용)
            let end = cursorPos;
            while (end < value.length) {
                const char = value[end];
                // 콤마, 개행, 괄호, 콜론은 단어 경계
                if (char === ',' || char === '\n' || char === '\r' ||
                    char === '{' || char === '}' || char === '[' || char === ']' ||
                    char === '(' || char === ')' || char === ':') {
                    break;
                }
                if (!isTagChar(char)) {
                    break;
                }
                end++;
            }

            // 검색용 단어: 커서 앞에 있는 부분만 (현재 입력 중인 부분)
            const beforeCursor = value.substring(start, cursorPos);
            const searchWord = beforeCursor.trim();

            // 전체 단어: 교체 시 사용 (커서 앞뒤 모두)
            const fullWord = value.substring(start, end).trim();

            // 공백 제거한 후 실제 단어의 위치 재계산
            const leadingSpaces = beforeCursor.length - beforeCursor.trimStart().length;

            return {
                word: searchWord,          // 검색용: 커서 앞 부분만
                fullWord: fullWord,        // 전체 단어 (커서 앞뒤)
                rawWord: beforeCursor,     // trim 전 원본 (공백 포함)
                start: start + leadingSpaces,  // 공백 제외한 단어 시작
                end: end,                      // 단어 끝 (교체 범위)
                fullStart: start,              // 공백 포함한 시작
                fullEnd: end,                  // 공백 포함한 끝
                cursorPos
            };
        }

        // Search tags with 2-stage algorithm
        function searchTags(query, maxResults = 15) {
            if (!query || query.length < 2) return [];

            const lowerQuery = query.toLowerCase();
            const firstChar = lowerQuery[0];
            const results = [];

            // Stage 1: Search indexed tags (startsWith)
            if (TAG_INDEX[firstChar]) {
                for (const tag of TAG_INDEX[firstChar]) {
                    if (tag._lower.startsWith(lowerQuery)) {
                        results.push(tag);
                        if (results.length >= maxResults) return results;
                    }
                }
            }

            // Stage 2: If not enough results, search all tags (includes)
            if (results.length < maxResults) {
                for (const tag of ALL_TAGS) {
                    if (results.includes(tag)) continue;
                    if (tag._lower.includes(lowerQuery)) {
                        results.push(tag);
                        if (results.length >= maxResults) break;
                    }
                }
            }

            return results;
        }

        // Format number with K/M suffix
        function formatCount(count) {
            if (count >= 1000000) return (count / 1000000).toFixed(1) + 'M';
            if (count >= 1000) return (count / 1000).toFixed(1) + 'K';
            return count.toString();
        }

        // Create autocomplete dropdown
        function createAutocompleteDropdown() {
            const dropdown = document.createElement('div');
            dropdown.className = 'tag-autocomplete-dropdown';
            dropdown.id = 'tagAutocompleteDropdown';
            document.body.appendChild(dropdown);
            return dropdown;
        }

        // Get or create dropdown
        function getAutocompleteDropdown() {
            let dropdown = document.getElementById('tagAutocompleteDropdown');
            if (!dropdown) {
                dropdown = createAutocompleteDropdown();
            }
            return dropdown;
        }

        // Show autocomplete dropdown
        function showAutocomplete(textarea, results) {
            const dropdown = getAutocompleteDropdown();
            dropdown.innerHTML = '';

            if (results.length === 0) {
                dropdown.innerHTML = '<div class="tag-autocomplete-empty">No matching tags</div>';
                dropdown.classList.add('show');
                return;
            }

            results.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-autocomplete-item';
                if (index === 0) item.classList.add('selected');
                item.dataset.index = index;
                item.dataset.tagValue = tag.value;

                const name = document.createElement('span');
                name.className = 'tag-autocomplete-item-name';
                name.textContent = tag.label;
                name.title = tag.label;  // 마우스 오버 시 전체 태그명 표시

                const badge = document.createElement('span');
                badge.className = `tag-autocomplete-item-badge ${tag.type}`;

                // 카테고리 한글 표시
                const categoryNames = {
                    'general': '일반',
                    'artist': '작가',
                    'character': '캐릭터',
                    'copyright': '작품',
                    'meta': '기타'
                };
                badge.textContent = categoryNames[tag.type] || tag.type;

                const count = document.createElement('span');
                count.className = 'tag-autocomplete-item-count';
                count.textContent = formatCount(tag.count);

                item.appendChild(name);
                item.appendChild(badge);
                item.appendChild(count);

                // Click to insert
                item.addEventListener('click', () => {
                    insertTag(textarea, tag.value);
                    hideAutocomplete();
                });

                dropdown.appendChild(item);
            });

            // Position dropdown near cursor
            positionDropdown(textarea, dropdown);
            dropdown.classList.add('show');

            // Store results for keyboard navigation
            dropdown._currentResults = results;
            dropdown._selectedIndex = 0;
            dropdown._textarea = textarea;
        }

        // Hide autocomplete dropdown
        function hideAutocomplete() {
            const dropdown = getAutocompleteDropdown();
            dropdown.classList.remove('show');
        }

        // Get accurate cursor pixel position (handles word wrap)
        function getCursorPixelPosition(textarea) {
            const cursorPos = textarea.selectionStart;

            // Create a mirror div with exact same styles and content
            const mirror = document.createElement('div');
            const computed = window.getComputedStyle(textarea);

            // Copy all text styles
            mirror.style.position = 'absolute';
            mirror.style.visibility = 'hidden';
            mirror.style.whiteSpace = computed.whiteSpace;
            mirror.style.wordWrap = computed.wordWrap;
            mirror.style.overflowWrap = computed.overflowWrap;
            mirror.style.width = textarea.clientWidth + 'px';
            mirror.style.font = computed.font;
            mirror.style.fontSize = computed.fontSize;
            mirror.style.fontFamily = computed.fontFamily;
            mirror.style.fontWeight = computed.fontWeight;
            mirror.style.lineHeight = computed.lineHeight;
            mirror.style.letterSpacing = computed.letterSpacing;
            mirror.style.padding = computed.padding;
            mirror.style.border = '0';
            mirror.style.boxSizing = computed.boxSizing;

            // Add text before cursor
            const textBefore = textarea.value.substring(0, cursorPos);
            mirror.textContent = textBefore;

            // Create a marker span at cursor position
            const marker = document.createElement('span');
            marker.textContent = '\u200B'; // Zero-width space
            marker.style.display = 'inline';
            mirror.appendChild(marker);

            document.body.appendChild(mirror);

            // Get marker position relative to mirror
            const markerRect = marker.getBoundingClientRect();
            const mirrorRect = mirror.getBoundingClientRect();

            const x = markerRect.left - mirrorRect.left;
            const y = markerRect.top - mirrorRect.top;

            document.body.removeChild(mirror);

            return { x, y };
        }

        // Position dropdown near cursor
        function positionDropdown(textarea, dropdown) {
            const textareaRect = textarea.getBoundingClientRect();
            const cursorPos = getCursorPixelPosition(textarea);

            // Get line height
            const computed = window.getComputedStyle(textarea);
            const lineHeight = parseInt(computed.lineHeight) || parseInt(computed.fontSize) * 1.2;

            // Calculate absolute position
            // Account for textarea scroll
            const scrollTop = textarea.scrollTop;
            const scrollLeft = textarea.scrollLeft;

            // Position dropdown below cursor line
            let left = textareaRect.left + cursorPos.x - scrollLeft;
            let top = textareaRect.top + cursorPos.y - scrollTop + lineHeight + 4;

            // Dropdown dimensions
            const dropdownWidth = Math.min(350, Math.max(250, textareaRect.width - 20));
            const dropdownHeight = 300; // max-height

            // Adjust if goes off-screen horizontally
            if (left + dropdownWidth > window.innerWidth - 10) {
                left = window.innerWidth - dropdownWidth - 10;
            }
            if (left < 10) {
                left = 10;
            }

            // Adjust if goes off-screen vertically
            if (top + dropdownHeight > window.innerHeight - 10) {
                // Position above cursor instead
                top = textareaRect.top + cursorPos.y - scrollTop - dropdownHeight - 4;
            }
            if (top < 10) {
                top = 10;
            }

            dropdown.style.left = left + 'px';
            dropdown.style.top = top + 'px';
            dropdown.style.maxWidth = dropdownWidth + 'px';
        }

        // Insert tag at cursor position (with undo support via execCommand)
        function insertTag(textarea, tagValue) {
            const { start, end, fullStart, fullEnd, word } = getCurrentWord(textarea);
            const value = textarea.value;

            // Transform tag based on provider
            // NAI V4/V4.5: Replace underscores with spaces (except emoticons like ^_^)
            // Local: Keep underscores (Danbooru format)
            let finalTag = tagValue;
            if (currentProvider === 'nai') {
                // Replace underscores with spaces, but preserve emoticons
                finalTag = tagValue.replace(/_/g, (match, offset, string) => {
                    // Check if it's part of an emoticon (preceded/followed by ^ or other emoticon chars)
                    const before = string[offset - 1];
                    const after = string[offset + 1];
                    if ((before === '^' || after === '^') ||
                        (before && after && /[><;:=]/.test(before + after))) {
                        return '_'; // Keep underscore in emoticons
                    }
                    return ' '; // Replace with space
                });
            }

            // Preserve leading spaces between comma and word
            const leadingSpaces = value.substring(fullStart, start);

            // Determine what comes after the tag
            let suffix = ', ';

            // Check if there's already a comma after the current word
            if (fullEnd < value.length && value[fullEnd] === ',') {
                suffix = ''; // Don't add comma if one already exists
                // But ensure space after comma
                if (fullEnd + 1 < value.length && value[fullEnd + 1] !== ' ') {
                    suffix = ' ';
                }
            }

            // Focus textarea and select the text to replace (for undo support)
            textarea.focus();
            textarea.setSelectionRange(fullStart, end);

            // Use execCommand for undo support (Ctrl+Z)
            const insertText = leadingSpaces + finalTag + suffix;
            const success = document.execCommand('insertText', false, insertText);

            if (!success) {
                // Fallback for browsers that don't support execCommand
                const before = value.substring(0, fullStart);
                const after = value.substring(end);
                const newValue = before + insertText + after;
                textarea.value = newValue;
            }

            // Set cursor position after inserted tag and suffix
            const newCursorPos = fullStart + leadingSpaces.length + finalTag.length + suffix.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);

            // Trigger input event for autosave
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
        }

        // Handle keyboard navigation in dropdown
        function handleAutocompleteKeyboard(e, dropdown) {
            if (!dropdown.classList.contains('show')) return false;

            const items = dropdown.querySelectorAll('.tag-autocomplete-item');
            if (items.length === 0) return false;

            let selectedIndex = dropdown._selectedIndex || 0;

            switch(e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, 0);
                    break;
                case 'Enter':
                    e.preventDefault();
                    const selectedItem = items[selectedIndex];
                    if (selectedItem) {
                        const tagValue = selectedItem.dataset.tagValue;
                        // 엔터로 선택 시 잠시 autocomplete 억제
                        window._suppressAutocomplete = true;
                        insertTag(dropdown._textarea, tagValue);
                        hideAutocomplete();
                        setTimeout(() => { window._suppressAutocomplete = false; }, 100);
                    }
                    return true;
                case 'Escape':
                    e.preventDefault();
                    hideAutocomplete();
                    return true;
                default:
                    return false;
            }

            // Update selection
            items.forEach((item, i) => {
                item.classList.toggle('selected', i === selectedIndex);
            });
            dropdown._selectedIndex = selectedIndex;

            // Scroll selected item into view
            items[selectedIndex].scrollIntoView({ block: 'nearest' });

            return true;
        }

        // Setup tag autocomplete for a textarea
        function setupTagAutocomplete(textarea) {
            if (!textarea) {
                console.warn('[TagAutocomplete] setupTagAutocomplete called with null textarea');
                return;
            }
            if (textarea.dataset.autocompleteSetup) {
                console.log('[TagAutocomplete] Textarea already has autocomplete setup:', textarea.id || textarea.className);
                return;
            }
            console.log('[TagAutocomplete] Setting up autocomplete for:', textarea.id || textarea.className);
            textarea.dataset.autocompleteSetup = 'true';

            let inputTimeout = null;
            let lastValue = textarea.value;
            let isDeleting = false;

            // Input event - trigger autocomplete
            textarea.addEventListener('input', (e) => {
                console.log('[TagAutocomplete] Input event - enabled:', tagAutocompleteEnabled, 'loaded:', tagsLoaded);
                if (!tagAutocompleteEnabled || !tagsLoaded) return;

                // 엔터로 태그 선택 직후 억제
                if (window._suppressAutocomplete) {
                    return;
                }

                // 포커스가 없거나 프로그래밍적 이벤트면 무시
                if (document.activeElement !== textarea || !e.isTrusted) {
                    hideAutocomplete();
                    return;
                }

                // Detect if user is deleting (backspace/delete)
                const currentValue = textarea.value;
                isDeleting = currentValue.length < lastValue.length;
                lastValue = currentValue;

                // Don't show autocomplete while deleting
                if (isDeleting) {
                    hideAutocomplete();
                    return;
                }

                // Debounce input
                if (inputTimeout) clearTimeout(inputTimeout);
                inputTimeout = setTimeout(() => {
                    // 연속 스페이스 2개 입력 시 자동완성 종료 체크
                    // (커서 앞 2글자가 모두 스페이스인지 확인)
                    const cursorPos = textarea.selectionStart;
                    if (cursorPos >= 2) {
                        const beforeCursor = textarea.value.substring(cursorPos - 2, cursorPos);
                        if (beforeCursor === '  ') {
                            hideAutocomplete();
                            return;
                        }
                    }

                    const { word } = getCurrentWord(textarea);

                    // 스페이스를 언더바로 치환하여 검색
                    const searchWord = word.replace(/ /g, '_');

                    if (searchWord.length >= 2) {
                        const results = searchTags(searchWord);
                        if (results.length > 0) {
                            showAutocomplete(textarea, results);
                        } else {
                            hideAutocomplete();
                        }
                    } else {
                        hideAutocomplete();
                    }
                }, 50);
            });

            // Keydown event - handle navigation
            textarea.addEventListener('keydown', (e) => {
                if (!tagAutocompleteEnabled || !tagsLoaded) return;

                const dropdown = getAutocompleteDropdown();
                if (handleAutocompleteKeyboard(e, dropdown)) {
                    // Event was handled by autocomplete
                    return;
                }
            });

            // Focus event - update lastValue
            textarea.addEventListener('focus', () => {
                lastValue = textarea.value;
            });

            // Blur event - hide dropdown
            textarea.addEventListener('blur', () => {
                // Delay to allow click on dropdown item
                setTimeout(() => {
                    const dropdown = getAutocompleteDropdown();
                    if (!dropdown.matches(':hover')) {
                        hideAutocomplete();
                    }
                }, 200);
            });
        }

        // Initialize tag autocomplete system
        console.log('[PeroPix] Initializing tag autocomplete system...');
        console.log('[PeroPix] tagAutocompleteEnabled initial value:', tagAutocompleteEnabled);
        loadTagData();

        // ============================================================
        // Settings Persistence (localStorage) - NAI/Local 완전 분리
        // ============================================================
        const SETTINGS_KEY = 'peropix_settings_v2';
        
        // Provider별 설정 저장소
        let naiSettings = {};
        let localSettings = {};
        
        // 현재 provider의 모든 설정을 객체로 수집
        function collectCurrentProviderSettings() {
            return {
                // Prompts
                basePrompt: document.getElementById('basePrompt').value,
                negativePrompt: document.getElementById('negativePrompt').value,
                characterPromptsLayout: getCharacterPromptsWithLayout(),
                
                // Size
                sizePreset: document.getElementById('sizePreset').value,
                width: document.getElementById('width').value,
                height: document.getElementById('height').value,
                
                // Generation
                steps: document.getElementById('steps').value,
                cfg: document.getElementById('cfg').value,
                sampler: document.getElementById('sampler').value,
                scheduler: document.getElementById('scheduler').value,
                seed: document.getElementById('seed').value,
                randomSeed: document.getElementById('randomSeed').checked,
                lockSeed: document.getElementById('lockSeed').checked,
                
                // Save Options
                saveFormat: document.getElementById('saveFormat').value,
                jpgQuality: document.getElementById('jpgQuality').value,
                stripMetadata: document.getElementById('stripMetadata').checked,
                
                // Output
                outputFolder: getOutputFolder(),
                repeatCount: document.getElementById('repeatCount').value,
                
                // Slots & Preset
                slots: getAllSlotList(),
                currentPreset: currentPreset,
                
                // NAI-specific (NAI일 때만 의미있음)
                naiModel: document.getElementById('naiModel').value,
                smea: document.getElementById('smea').value,
                ucPreset: document.getElementById('ucPreset').value,
                qualityTags: document.getElementById('qualityTags').checked,
                furryModeEnabled: furryModeEnabled,
                cfgRescale: document.getElementById('cfgRescale').value,
                varietyPlus: document.getElementById('varietyPlus').checked,
                enableVibeTransfer: document.getElementById('enableVibeTransfer').checked,
                vibeList: vibeList,
                // CharRef: 이미지 데이터는 저장 안 함 (NAI 웹처럼 재실행 시 초기화)
                // enableCharRef, charRefData는 저장하지 않음
                charRefFidelity: document.getElementById('charRefFidelity').value,
                charRefStyleAware: document.getElementById('charRefStyleAware').checked,
                
                // Local-specific (Local일 때만 의미있음)
                localModel: document.getElementById('localModel').value,
                loraSlots: loraSlots,
                enableUpscale: document.getElementById('enableUpscale').checked,
                upscaleModel: document.getElementById('upscaleModel').value,
                downscaleRatio: document.getElementById('downscaleRatio').value,
                sizeAlignment: document.getElementById('sizeAlignment').value,
                upscaleSteps: document.getElementById('upscaleSteps').value,
                upscaleCfg: document.getElementById('upscaleCfg').value,
                upscaleDenoise: document.getElementById('upscaleDenoise').value,

                // LUT settings
                enableLut: document.getElementById('enableLut').checked,
                lutFile: document.getElementById('lutFile').value,
                lutIntensity: document.getElementById('lutIntensity').value,

                // Tag Autocomplete
                tagAutocompleteEnabled: tagAutocompleteEnabled,

                // Prompt Weight Highlighting
                promptHighlightEnabled: promptHighlightEnabled,
            };
        }
        
        // 설정을 UI에 적용
        function applyProviderSettings(settings, isFullRestore = false) {
            if (!settings) return;

            // isFullRestore일 때는 빈 객체도 처리 (탭 전환 시 빈 값으로 초기화)
            const isEmpty = Object.keys(settings).length === 0;

            // Prompts - 빈 객체일 때 기본값으로 초기화
            if (isFullRestore && isEmpty) {
                document.getElementById('basePrompt').value = '';
                document.getElementById('negativePrompt').value = '';
            } else {
                if (settings.basePrompt !== undefined) document.getElementById('basePrompt').value = settings.basePrompt;
                if (settings.negativePrompt !== undefined) document.getElementById('negativePrompt').value = settings.negativePrompt;
            }
            // 프롬프트 하이라이트 업데이트
            updatePromptHighlights();
            
            // Character prompts
            if (settings.characterPromptsLayout && settings.characterPromptsLayout.length > 0) {
                const charactersList = document.getElementById('charactersList');
                charactersList.innerHTML = '';
                settings.characterPromptsLayout.forEach(charData => {
                    const content = charData.content || '';
                    const collapsed = charData.collapsed || false;
                    const height = charData.height || null;
                    const enabled = charData.enabled !== false;
                    if (content.trim() || collapsed) {
                        const item = createCharacterItem(content, collapsed, enabled);
                        if (height) {
                            item.querySelector('textarea').style.height = height;
                        }
                        charactersList.appendChild(item);
                    }
                });
                updateCharacterNumbers();
            } else if (isFullRestore) {
                document.getElementById('charactersList').innerHTML = '';
            }
            
            // Size
            if (isFullRestore && isEmpty) {
                document.getElementById('sizePreset').value = 'custom';
                document.getElementById('width').value = currentProvider === 'nai' ? 832 : 1024;
                document.getElementById('height').value = currentProvider === 'nai' ? 1216 : 1024;
            } else {
                if (settings.sizePreset) document.getElementById('sizePreset').value = settings.sizePreset;
                if (settings.width) document.getElementById('width').value = settings.width;
                if (settings.height) document.getElementById('height').value = settings.height;
            }

            // Generation - 샘플러/스케줄러는 provider에 따라 옵션이 다름
            // (빈 객체일 때는 restoreProviderGenerationSettings에서 처리됨)
            if (!isEmpty && settings.steps) document.getElementById('steps').value = settings.steps;
            if (!isEmpty && settings.cfg) document.getElementById('cfg').value = settings.cfg;
            updateSamplerSchedulerOptions(currentProvider);
            if (settings.sampler) {
                const samplerSelect = document.getElementById('sampler');
                if ([...samplerSelect.options].some(o => o.value === settings.sampler)) {
                    samplerSelect.value = settings.sampler;
                }
            }
            if (settings.scheduler) {
                const schedulerSelect = document.getElementById('scheduler');
                if ([...schedulerSelect.options].some(o => o.value === settings.scheduler)) {
                    schedulerSelect.value = settings.scheduler;
                }
            }
            if (isFullRestore && isEmpty) {
                document.getElementById('seed').value = '';
                document.getElementById('randomSeed').checked = true;
                document.getElementById('lockSeed').checked = false;
            } else {
                if (settings.seed !== undefined) document.getElementById('seed').value = settings.seed;
                if (settings.randomSeed !== undefined) document.getElementById('randomSeed').checked = settings.randomSeed;
                if (settings.lockSeed !== undefined) document.getElementById('lockSeed').checked = settings.lockSeed;
            }

            // Save Options
            if (isFullRestore && isEmpty) {
                document.getElementById('saveFormat').value = 'png';
                document.getElementById('jpgQuality').value = 95;
                document.getElementById('stripMetadata').checked = false;
            } else {
                if (settings.saveFormat) document.getElementById('saveFormat').value = settings.saveFormat;
                if (settings.jpgQuality) document.getElementById('jpgQuality').value = settings.jpgQuality;
                if (settings.stripMetadata !== undefined) document.getElementById('stripMetadata').checked = settings.stripMetadata;
            }

            // Output
            if (isFullRestore && isEmpty) {
                setOutputFolder('');
                document.getElementById('repeatCount').value = 1;
            } else {
                if (settings.outputFolder !== undefined) setOutputFolder(settings.outputFolder);
                if (settings.repeatCount) document.getElementById('repeatCount').value = settings.repeatCount;
            }
            
            // Slots - provider별로 분리됨 (락 상태 포함)
            if (settings.slots && settings.slots.length > 0) {
                slotsContainer.innerHTML = '';
                settings.slots.forEach(slot => {
                    addSlot(slot.name || '', slot.content || '', slot.locked || false);
                });
            } else if (isFullRestore) {
                // 슬롯이 없으면 빈 상태로 (기본 슬롯 1개)
                slotsContainer.innerHTML = '';
                addSlot('', '');
            }
            
            // Preset
            if (settings.currentPreset !== undefined) {
                currentPreset = settings.currentPreset;
                presetNameSpan.textContent = currentPreset?.name || 'Slot Set';
            }
            
            // NAI-specific
            if (currentProvider === 'nai') {
                if (settings.naiModel) document.getElementById('naiModel').value = settings.naiModel;
                if (settings.smea) document.getElementById('smea').value = settings.smea;
                if (settings.ucPreset) document.getElementById('ucPreset').value = settings.ucPreset;
                if (settings.qualityTags !== undefined) document.getElementById('qualityTags').checked = settings.qualityTags;
                if (settings.furryModeEnabled !== undefined) {
                    furryModeEnabled = settings.furryModeEnabled;
                    if (furryModeEnabled) {
                        modeToggle.textContent = '🐾';
                        modeToggle.title = '퍼리 모드';
                        modeToggle.classList.add('furry');
                    } else {
                        modeToggle.textContent = '🌸';
                        modeToggle.title = '일반 모드';
                        modeToggle.classList.remove('furry');
                    }
                }
                if (settings.cfgRescale !== undefined) {
                    const cfgRescaleEl = document.getElementById('cfgRescale');
                    cfgRescaleEl.value = settings.cfgRescale;
                    document.getElementById('cfgRescaleValue').textContent = settings.cfgRescale;
                    updateSliderFill(cfgRescaleEl);
                }
                if (settings.varietyPlus !== undefined) document.getElementById('varietyPlus').checked = settings.varietyPlus;
                if (settings.enableVibeTransfer !== undefined) {
                    document.getElementById('enableVibeTransfer').checked = settings.enableVibeTransfer;
                    document.getElementById('vibeTransferSettings').style.display = settings.enableVibeTransfer ? 'block' : 'none';
                }
                if (settings.vibeList) {
                    vibeList = settings.vibeList;
                    renderVibeList();
                }
                // CharRef: enableCharRef, charRefData는 복원 안 함 (재실행 시 초기화)
                // fidelity, styleAware 설정값만 복원
                if (settings.charRefFidelity !== undefined) {
                    const charRefFidelityEl = document.getElementById('charRefFidelity');
                    charRefFidelityEl.value = settings.charRefFidelity;
                    document.getElementById('charRefFidelityValue').textContent = settings.charRefFidelity;
                    updateSliderFill(charRefFidelityEl);
                }
                if (settings.charRefStyleAware !== undefined) {
                    document.getElementById('charRefStyleAware').checked = settings.charRefStyleAware;
                }
            }
            
            // Local-specific
            if (currentProvider === 'local') {
                if (settings.localModel) {
                    window._pendingLocalModel = settings.localModel;
                }
                if (settings.loraSlots) {
                    loraSlots = settings.loraSlots;
                    renderLoraSlots();
                }
                if (settings.enableUpscale !== undefined) {
                    document.getElementById('enableUpscale').checked = settings.enableUpscale;
                    document.getElementById('upscaleSettings').style.display = settings.enableUpscale ? 'block' : 'none';
                }
                if (settings.upscaleModel) window._pendingUpscaleModel = settings.upscaleModel;
                if (settings.downscaleRatio) document.getElementById('downscaleRatio').value = settings.downscaleRatio;
                if (settings.sizeAlignment) document.getElementById('sizeAlignment').value = settings.sizeAlignment;
                if (settings.upscaleSteps) document.getElementById('upscaleSteps').value = settings.upscaleSteps;
                if (settings.upscaleCfg) document.getElementById('upscaleCfg').value = settings.upscaleCfg;
                if (settings.upscaleDenoise !== undefined) {
                    const upscaleDenoiseEl = document.getElementById('upscaleDenoise');
                    upscaleDenoiseEl.value = settings.upscaleDenoise;
                    document.getElementById('upscaleDenoiseValue').textContent = settings.upscaleDenoise;
                    updateSliderFill(upscaleDenoiseEl);
                }

                // LUT settings
                if (settings.enableLut !== undefined) {
                    document.getElementById('enableLut').checked = settings.enableLut;
                    document.getElementById('lutSettings').style.display = settings.enableLut ? 'block' : 'none';
                }
                // LUT 파일은 loadResources 후에 적용 (select 옵션이 로드된 후)
                if (settings.lutFile) window._pendingLutFile = settings.lutFile;
                if (settings.lutIntensity !== undefined) {
                    const lutIntensityEl = document.getElementById('lutIntensity');
                    lutIntensityEl.value = settings.lutIntensity;
                    document.getElementById('lutIntensityValue').textContent = settings.lutIntensity;
                    updateSliderFill(lutIntensityEl);
                }
            }

            // Tag Autocomplete (기본값 true 유지)
            console.log('[PeroPix] applyProviderSettings - tagAutocompleteEnabled in settings:', settings.tagAutocompleteEnabled);
            if (settings.tagAutocompleteEnabled !== undefined) {
                tagAutocompleteEnabled = settings.tagAutocompleteEnabled;
                console.log('[PeroPix] applyProviderSettings - set to saved value:', tagAutocompleteEnabled);
            } else {
                // 설정이 없으면 기본값 true
                tagAutocompleteEnabled = true;
                console.log('[PeroPix] applyProviderSettings - using default value: true');
            }

            // Prompt Highlight (기본값 true 유지)
            if (settings.promptHighlightEnabled !== undefined) {
                promptHighlightEnabled = settings.promptHighlightEnabled;
            } else {
                promptHighlightEnabled = true;
            }

            // UI 토글 상태 업데이트
            const tagToggle = document.getElementById('tagAutocompleteToggle');
            if (tagToggle) tagToggle.checked = tagAutocompleteEnabled;

            const highlightToggle = document.getElementById('promptHighlightToggle');
            if (highlightToggle) highlightToggle.checked = promptHighlightEnabled;
        }
        
        function saveAppSettings() {
            // 현재 provider 설정 수집
            const currentSettings = collectCurrentProviderSettings();
            if (currentProvider === 'nai') {
                naiSettings = currentSettings;
            } else {
                localSettings = currentSettings;
            }
            
            const settings = {
                // 현재 provider
                provider: currentProvider,
                
                // Provider별 설정 (완전 분리)
                nai: naiSettings,
                local: localSettings,
                
                // UI 레이아웃 (공유)
                slotWidth: currentSlotWidth,
                sidebarWidth: currentSidebarWidth,
                basePromptHeight: document.getElementById('basePrompt').style.height || null,
                negativePromptHeight: document.getElementById('negativePrompt').style.height || null,
                basePromptCollapsed: document.getElementById('basePromptContent').classList.contains('collapsed'),
                charactersCollapsed: document.getElementById('charactersContent').classList.contains('collapsed'),
                negativePromptCollapsed: document.getElementById('negativePromptContent').classList.contains('collapsed'),
            };
            
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        }
        
        function loadAppSettings() {
            console.log('[PeroPix] loadAppSettings() called');
            console.log('[PeroPix] tagAutocompleteEnabled before loading:', tagAutocompleteEnabled);

            // 새 설정 키로 로드 시도
            let saved = localStorage.getItem(SETTINGS_KEY);
            let isLegacy = false;
            
            // 새 설정이 없으면 레거시 키 확인
            if (!saved) {
                saved = localStorage.getItem('nai_generator_settings');
                if (saved) {
                    isLegacy = true;
                    console.log('Legacy settings found, will migrate to new format');
                } else {
                    return; // 설정 없음
                }
            }
            
            try {
                const settings = JSON.parse(saved);
                
                // ============================================
                // 새 구조 (peropix_settings_v2) 로드
                // ============================================
                if (!isLegacy && settings.nai !== undefined) {
                    // Provider별 설정을 전역 변수에 저장
                    naiSettings = settings.nai || {};
                    localSettings = settings.local || {};
                    
                    // Provider 결정 (local은 설치 확인 후 적용)
                    if (settings.provider === 'local') {
                        window._pendingProvider = 'local';
                        currentProvider = 'nai'; // 일단 NAI로
                    } else {
                        currentProvider = settings.provider || 'nai';
                    }
                    
                    // UI 탭 활성화
                    tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === currentProvider));
                    providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === currentProvider));
                    
                    // UI 레이아웃 복원 (공유)
                    if (settings.slotWidth) setSlotWidth(settings.slotWidth);
                    if (settings.sidebarWidth) setSidebarWidth(settings.sidebarWidth);
                    if (settings.basePromptHeight) document.getElementById('basePrompt').style.height = settings.basePromptHeight;
                    if (settings.negativePromptHeight) document.getElementById('negativePrompt').style.height = settings.negativePromptHeight;
                    if (settings.basePromptCollapsed) {
                        document.getElementById('basePromptContent').classList.add('collapsed');
                        document.querySelector('[data-target="basePromptContent"]').classList.add('collapsed');
                    }
                    if (settings.charactersCollapsed) {
                        document.getElementById('charactersContent').classList.add('collapsed');
                        document.querySelector('[data-target="charactersContent"]').classList.add('collapsed');
                    }
                    if (settings.negativePromptCollapsed) {
                        document.getElementById('negativePromptContent').classList.add('collapsed');
                        document.querySelector('[data-target="negativePromptContent"]').classList.add('collapsed');
                    }
                    
                    // 현재 provider 설정 적용 (NAI로 시작)
                    const currentSettings = currentProvider === 'nai' ? naiSettings : localSettings;
                    
                    // Prompts
                    if (currentSettings.basePrompt !== undefined) document.getElementById('basePrompt').value = currentSettings.basePrompt;
                    if (currentSettings.negativePrompt !== undefined) document.getElementById('negativePrompt').value = currentSettings.negativePrompt;
                    
                    // Size
                    if (currentSettings.sizePreset) document.getElementById('sizePreset').value = currentSettings.sizePreset;
                    if (currentSettings.width) document.getElementById('width').value = currentSettings.width;
                    if (currentSettings.height) document.getElementById('height').value = currentSettings.height;
                    
                    // Generation - 샘플러/스케줄러는 옵션 로드 후 적용
                    if (currentSettings.steps) document.getElementById('steps').value = currentSettings.steps;
                    if (currentSettings.cfg) document.getElementById('cfg').value = currentSettings.cfg;
                    window._pendingSampler = currentSettings.sampler;
                    window._pendingScheduler = currentSettings.scheduler;
                    if (currentSettings.seed !== undefined) document.getElementById('seed').value = currentSettings.seed;
                    if (currentSettings.randomSeed !== undefined) document.getElementById('randomSeed').checked = currentSettings.randomSeed;
                    if (currentSettings.lockSeed !== undefined) document.getElementById('lockSeed').checked = currentSettings.lockSeed;
                    
                    // naiGenerationSettings / localGenerationSettings도 동기화
                    if (naiSettings.steps) {
                        naiGenerationSettings = {
                            steps: naiSettings.steps,
                            cfg: naiSettings.cfg,
                            sampler: naiSettings.sampler || 'k_euler_ancestral',
                            scheduler: naiSettings.scheduler || 'karras'
                        };
                    }
                    if (localSettings.steps) {
                        localGenerationSettings = {
                            steps: localSettings.steps,
                            cfg: localSettings.cfg,
                            sampler: localSettings.sampler || 'euler_ancestral',
                            scheduler: localSettings.scheduler || 'normal'
                        };
                    }
                    
                    // Save Options
                    if (currentSettings.saveFormat) document.getElementById('saveFormat').value = currentSettings.saveFormat;
                    if (currentSettings.jpgQuality) document.getElementById('jpgQuality').value = currentSettings.jpgQuality;
                    if (currentSettings.stripMetadata !== undefined) document.getElementById('stripMetadata').checked = currentSettings.stripMetadata;
                    
                    // Output
                    if (currentSettings.outputFolder !== undefined) setOutputFolder(currentSettings.outputFolder);
                    if (currentSettings.repeatCount) document.getElementById('repeatCount').value = currentSettings.repeatCount;
                    
                    // Slots - provider별로 분리됨 (락 상태 포함)
                    if (currentSettings.slots && currentSettings.slots.length > 0) {
                        slotsContainer.innerHTML = '';
                        currentSettings.slots.forEach(slot => {
                            addSlot(slot.name || '', slot.content || '', slot.locked || false);
                        });
                    }
                    
                    // Preset
                    if (currentSettings.currentPreset) {
                        currentPreset = currentSettings.currentPreset;
                        presetNameSpan.textContent = currentPreset.name || 'Slot Set';
                    }
                    
                    // Character prompts
                    if (currentSettings.characterPromptsLayout && currentSettings.characterPromptsLayout.length > 0) {
                        window._pendingCharacterPromptsLayout = currentSettings.characterPromptsLayout;
                    }
                    
                    // NAI-specific (시작 provider가 NAI일 때)
                    if (currentProvider === 'nai' && naiSettings) {
                        if (naiSettings.naiModel) document.getElementById('naiModel').value = naiSettings.naiModel;
                        if (naiSettings.smea) document.getElementById('smea').value = naiSettings.smea;
                        if (naiSettings.ucPreset) document.getElementById('ucPreset').value = naiSettings.ucPreset;
                        if (naiSettings.qualityTags !== undefined) document.getElementById('qualityTags').checked = naiSettings.qualityTags;
                        if (naiSettings.furryModeEnabled) {
                            furryModeEnabled = true;
                            modeToggle.textContent = '🐾';
                            modeToggle.title = '퍼리 모드';
                            modeToggle.classList.add('furry');
                        }
                        if (naiSettings.cfgRescale !== undefined) {
                            const cfgRescaleEl = document.getElementById('cfgRescale');
                            cfgRescaleEl.value = naiSettings.cfgRescale;
                            document.getElementById('cfgRescaleValue').textContent = naiSettings.cfgRescale;
                            updateSliderFill(cfgRescaleEl);
                        }
                        if (naiSettings.varietyPlus !== undefined) document.getElementById('varietyPlus').checked = naiSettings.varietyPlus;
                        if (naiSettings.enableVibeTransfer !== undefined) {
                            document.getElementById('enableVibeTransfer').checked = naiSettings.enableVibeTransfer;
                            document.getElementById('vibeTransferSettings').style.display = naiSettings.enableVibeTransfer ? 'block' : 'none';
                        }
                        if (naiSettings.vibeList && naiSettings.vibeList.length > 0) {
                            vibeList = naiSettings.vibeList;
                            renderVibeList();
                        }
                        // CharRef: enableCharRef, charRefData는 복원 안 함 (재실행 시 초기화)
                        // fidelity, styleAware 설정값만 복원
                        if (naiSettings.charRefFidelity !== undefined) {
                            const charRefFidelityEl = document.getElementById('charRefFidelity');
                            charRefFidelityEl.value = naiSettings.charRefFidelity;
                            document.getElementById('charRefFidelityValue').textContent = naiSettings.charRefFidelity;
                            updateSliderFill(charRefFidelityEl);
                        }
                        if (naiSettings.charRefStyleAware !== undefined) {
                            document.getElementById('charRefStyleAware').checked = naiSettings.charRefStyleAware;
                        }
                    }
                    
                    // Local-specific - 모델은 loadResources 후 적용
                    if (localSettings) {
                        window._pendingLocalModel = localSettings.localModel;
                        window._pendingUpscaleModel = localSettings.upscaleModel;
                        if (localSettings.loraSlots && localSettings.loraSlots.length > 0) {
                            loraSlots = localSettings.loraSlots;
                        }
                        if (localSettings.enableUpscale !== undefined) {
                            document.getElementById('enableUpscale').checked = localSettings.enableUpscale;
                            document.getElementById('upscaleSettings').style.display = localSettings.enableUpscale ? 'block' : 'none';
                        }
                        if (localSettings.downscaleRatio) document.getElementById('downscaleRatio').value = localSettings.downscaleRatio;
                        if (localSettings.sizeAlignment) document.getElementById('sizeAlignment').value = localSettings.sizeAlignment;
                        if (localSettings.upscaleSteps) document.getElementById('upscaleSteps').value = localSettings.upscaleSteps;
                        if (localSettings.upscaleCfg) document.getElementById('upscaleCfg').value = localSettings.upscaleCfg;
                        if (localSettings.upscaleDenoise !== undefined) {
                            const upscaleDenoiseEl = document.getElementById('upscaleDenoise');
                            upscaleDenoiseEl.value = localSettings.upscaleDenoise;
                            document.getElementById('upscaleDenoiseValue').textContent = localSettings.upscaleDenoise;
                            updateSliderFill(upscaleDenoiseEl);
                        }
                    }
                    
                    return; // 새 구조 로드 완료
                }
                
                // ============================================
                // 레거시 구조 마이그레이션 (flat structure)
                // ============================================
                console.log('Migrating legacy settings...');
                
                // 레거시 설정을 NAI 설정으로 변환
                naiSettings = {
                    basePrompt: settings.basePrompt || '',
                    negativePrompt: settings.negativePrompt || '',
                    characterPromptsLayout: settings.characterPromptsLayout || 
                        (settings.characterPrompts ? settings.characterPrompts.map(c => ({ content: c, collapsed: false, height: null, enabled: true })) : []),
                    sizePreset: settings.sizePreset || 'custom',
                    width: settings.width || 832,
                    height: settings.height || 1216,
                    steps: settings.naiGeneration?.steps || settings.steps || 28,
                    cfg: settings.naiGeneration?.cfg || settings.cfg || 6,
                    sampler: settings.naiGeneration?.sampler || settings.sampler || 'k_euler_ancestral',
                    scheduler: settings.naiGeneration?.scheduler || settings.scheduler || 'karras',
                    seed: settings.seed || '',
                    randomSeed: settings.randomSeed !== false,
                    lockSeed: settings.lockSeed || false,
                    saveFormat: settings.saveFormat || 'png',
                    jpgQuality: settings.jpgQuality || 95,
                    stripMetadata: settings.stripMetadata || false,
                    outputFolder: settings.outputFolder || '',
                    repeatCount: settings.repeatCount || 1,
                    slots: settings.slots || [],
                    currentPreset: settings.currentPreset || null,
                    naiModel: settings.naiModel || 'nai-diffusion-4-5-curated',
                    smea: settings.smea || 'none',
                    ucPreset: settings.ucPreset || 'none',
                    qualityTags: settings.qualityTags !== false,
                    furryModeEnabled: settings.furryModeEnabled || false,
                    cfgRescale: settings.cfgRescale || 0,
                    varietyPlus: settings.varietyPlus || false,
                    enableVibeTransfer: settings.enableVibeTransfer || false,
                    vibeList: settings.vibeList || [],
                    enableCharRef: settings.enableCharRef || false,
                    charRefData: settings.charRefData || null,
                    charRefFidelity: settings.charRefFidelity || 1,
                    charRefStyleAware: settings.charRefStyleAware !== false,
                };
                
                // Local 설정 (레거시에서 가능한 것만)
                localSettings = {
                    basePrompt: '',
                    negativePrompt: '',
                    characterPromptsLayout: [],
                    sizePreset: 'custom',
                    width: 1024,
                    height: 1024,
                    steps: settings.localGeneration?.steps || 20,
                    cfg: settings.localGeneration?.cfg || 7,
                    sampler: settings.localGeneration?.sampler || 'euler_ancestral',
                    scheduler: settings.localGeneration?.scheduler || 'normal',
                    seed: '',
                    randomSeed: true,
                    lockSeed: false,
                    saveFormat: 'png',
                    jpgQuality: 95,
                    stripMetadata: false,
                    outputFolder: '',
                    repeatCount: 1,
                    slots: [],
                    currentPreset: null,
                    localModel: settings.localModel || '',
                    loraSlots: settings.loraSlots || [],
                    enableUpscale: settings.enableUpscale || false,
                    upscaleModel: settings.upscaleModel || '',
                    downscaleRatio: settings.downscaleRatio || 2,
                    sizeAlignment: settings.sizeAlignment || 64,
                    upscaleSteps: settings.upscaleSteps || 15,
                    upscaleCfg: settings.upscaleCfg || 6,
                    upscaleDenoise: settings.upscaleDenoise || 0.35,
                };
                
                // naiGenerationSettings / localGenerationSettings 동기화
                naiGenerationSettings = {
                    steps: naiSettings.steps,
                    cfg: naiSettings.cfg,
                    sampler: naiSettings.sampler,
                    scheduler: naiSettings.scheduler
                };
                localGenerationSettings = {
                    steps: localSettings.steps,
                    cfg: localSettings.cfg,
                    sampler: localSettings.sampler,
                    scheduler: localSettings.scheduler
                };
                
                // Provider (레거시는 항상 NAI)
                currentProvider = 'nai';
                if (settings.provider === 'local') {
                    window._pendingProvider = 'local';
                }
                tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === currentProvider));
                providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === currentProvider));
                
                // NAI 설정을 UI에 적용
                document.getElementById('basePrompt').value = naiSettings.basePrompt;
                document.getElementById('negativePrompt').value = naiSettings.negativePrompt;
                document.getElementById('sizePreset').value = naiSettings.sizePreset;
                document.getElementById('width').value = naiSettings.width;
                document.getElementById('height').value = naiSettings.height;
                document.getElementById('steps').value = naiSettings.steps;
                document.getElementById('cfg').value = naiSettings.cfg;
                window._pendingSampler = naiSettings.sampler;
                window._pendingScheduler = naiSettings.scheduler;
                if (naiSettings.seed) document.getElementById('seed').value = naiSettings.seed;
                document.getElementById('randomSeed').checked = naiSettings.randomSeed;
                document.getElementById('lockSeed').checked = naiSettings.lockSeed;
                document.getElementById('saveFormat').value = naiSettings.saveFormat;
                document.getElementById('jpgQuality').value = naiSettings.jpgQuality;
                document.getElementById('stripMetadata').checked = naiSettings.stripMetadata;
                if (naiSettings.outputFolder) setOutputFolder(naiSettings.outputFolder);
                document.getElementById('repeatCount').value = naiSettings.repeatCount;
                
                // Slots (락 상태 포함)
                if (naiSettings.slots && naiSettings.slots.length > 0) {
                    slotsContainer.innerHTML = '';
                    naiSettings.slots.forEach(slot => {
                        addSlot(slot.name || '', slot.content || '', slot.locked || false);
                    });
                }
                
                // Preset
                if (naiSettings.currentPreset) {
                    currentPreset = naiSettings.currentPreset;
                    presetNameSpan.textContent = currentPreset.name || 'Slot Set';
                }
                
                // Character prompts
                if (naiSettings.characterPromptsLayout && naiSettings.characterPromptsLayout.length > 0) {
                    window._pendingCharacterPromptsLayout = naiSettings.characterPromptsLayout;
                }
                
                // NAI-specific
                document.getElementById('naiModel').value = naiSettings.naiModel;
                document.getElementById('smea').value = naiSettings.smea;
                document.getElementById('ucPreset').value = naiSettings.ucPreset;
                document.getElementById('qualityTags').checked = naiSettings.qualityTags;
                if (naiSettings.furryModeEnabled) {
                    furryModeEnabled = true;
                    modeToggle.textContent = '🐾';
                    modeToggle.title = '퍼리 모드';
                    modeToggle.classList.add('furry');
                }
                const cfgRescaleEl = document.getElementById('cfgRescale');
                cfgRescaleEl.value = naiSettings.cfgRescale;
                document.getElementById('cfgRescaleValue').textContent = naiSettings.cfgRescale;
                updateSliderFill(cfgRescaleEl);
                document.getElementById('varietyPlus').checked = naiSettings.varietyPlus;
                document.getElementById('enableVibeTransfer').checked = naiSettings.enableVibeTransfer;
                document.getElementById('vibeTransferSettings').style.display = naiSettings.enableVibeTransfer ? 'block' : 'none';
                if (naiSettings.vibeList && naiSettings.vibeList.length > 0) {
                    vibeList = naiSettings.vibeList;
                    renderVibeList();
                }
                document.getElementById('enableCharRef').checked = naiSettings.enableCharRef;
                document.getElementById('charRefSettings').style.display = naiSettings.enableCharRef ? 'block' : 'none';
                if (naiSettings.charRefData) {
                    charRefData = naiSettings.charRefData;
                    document.getElementById('charRefImage').src = 'data:image/png;base64,' + charRefData.image;
                    document.getElementById('charRefPreview').style.display = 'block';
                    document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
                }
                document.getElementById('charRefFidelity').value = naiSettings.charRefFidelity;
                document.getElementById('charRefFidelityValue').textContent = naiSettings.charRefFidelity;
                document.getElementById('charRefStyleAware').checked = naiSettings.charRefStyleAware;
                
                // Local-specific
                window._pendingLocalModel = localSettings.localModel;
                window._pendingUpscaleModel = localSettings.upscaleModel;
                if (localSettings.loraSlots && localSettings.loraSlots.length > 0) {
                    loraSlots = localSettings.loraSlots;
                }
                document.getElementById('enableUpscale').checked = localSettings.enableUpscale;
                document.getElementById('upscaleSettings').style.display = localSettings.enableUpscale ? 'block' : 'none';
                document.getElementById('downscaleRatio').value = localSettings.downscaleRatio;
                document.getElementById('sizeAlignment').value = localSettings.sizeAlignment;
                document.getElementById('upscaleSteps').value = localSettings.upscaleSteps;
                document.getElementById('upscaleCfg').value = localSettings.upscaleCfg;
                const upscaleDenoiseEl = document.getElementById('upscaleDenoise');
                upscaleDenoiseEl.value = localSettings.upscaleDenoise;
                document.getElementById('upscaleDenoiseValue').textContent = localSettings.upscaleDenoise;
                updateSliderFill(upscaleDenoiseEl);

                // UI 레이아웃 (공유)
                if (settings.slotWidth) setSlotWidth(settings.slotWidth);
                if (settings.sidebarWidth) setSidebarWidth(settings.sidebarWidth);
                if (settings.basePromptHeight) document.getElementById('basePrompt').style.height = settings.basePromptHeight;
                if (settings.negativePromptHeight) document.getElementById('negativePrompt').style.height = settings.negativePromptHeight;
                if (settings.basePromptCollapsed) {
                    document.getElementById('basePromptContent').classList.add('collapsed');
                    document.querySelector('[data-target="basePromptContent"]').classList.add('collapsed');
                }
                if (settings.charactersCollapsed) {
                    document.getElementById('charactersContent').classList.add('collapsed');
                    document.querySelector('[data-target="charactersContent"]').classList.add('collapsed');
                }
                if (settings.negativePromptCollapsed) {
                    document.getElementById('negativePromptContent').classList.add('collapsed');
                    document.querySelector('[data-target="negativePromptContent"]').classList.add('collapsed');
                }
                
                // 레거시 키 삭제하고 새 형식으로 저장
                localStorage.removeItem('nai_generator_settings');
                saveAppSettings();
                console.log('Legacy settings migrated successfully');
                
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
        }
        
        // 설정 변경 시 자동 저장 (debounce)
        let saveTimeout = null;
        function autoSaveSettings() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveAppSettings, 500);
        }
        
        // 주요 입력 요소에 자동 저장 연결
        function setupAutoSave() {
            const inputs = [
                'basePrompt', 'negativePrompt', 'width', 'height', 'steps', 'cfg',
                'sampler', 'scheduler', 'seed', 'randomSeed', 'naiModel', 'smea',
                'ucPreset', 'qualityTags', 'localModel', 'enableUpscale', 'upscaleModel',
                'downscaleRatio', 'sizeAlignment', 'upscaleSteps', 'upscaleCfg',
                'upscaleDenoise', 'repeatCount', 'sizePreset',
                'cfgRescale', 'varietyPlus', 'lockSeed',
                'saveFormat', 'jpgQuality', 'stripMetadata'
            ];
            
            inputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', autoSaveSettings);
                    if (el.tagName === 'TEXTAREA' || el.type === 'text' || el.type === 'number') {
                        el.addEventListener('input', autoSaveSettings);
                    }
                }
            });
            
            // 슬롯 변경 감지
            slotsContainer.addEventListener('input', autoSaveSettings);
            slotsContainer.addEventListener('change', autoSaveSettings);

            // 캐릭터 프롬프트 변경 감지
            charactersList.addEventListener('input', autoSaveSettings);
            charactersList.addEventListener('change', autoSaveSettings);

            // 프롬프트 창 리사이즈 감지
            const resizeObserver = new ResizeObserver(() => autoSaveSettings());
            resizeObserver.observe(document.getElementById('basePrompt'));
            resizeObserver.observe(document.getElementById('negativePrompt'));

            // Tag autocomplete toggle
            const tagAutocompleteToggle = document.getElementById('tagAutocompleteToggle');
            if (tagAutocompleteToggle) {
                tagAutocompleteToggle.addEventListener('change', () => {
                    tagAutocompleteEnabled = tagAutocompleteToggle.checked;
                    autoSaveSettings();
                });
            }

            // Prompt highlight toggle
            const promptHighlightToggle = document.getElementById('promptHighlightToggle');
            if (promptHighlightToggle) {
                promptHighlightToggle.addEventListener('change', () => {
                    promptHighlightEnabled = promptHighlightToggle.checked;
                    autoSaveSettings();

                    // 모든 프롬프트 필드 다시 렌더링
                    document.querySelectorAll('.prompt-highlight-overlay').forEach(overlay => {
                        const container = overlay.parentElement;
                        const textarea = container.querySelector('textarea');
                        if (textarea) {
                            highlightPrompt(textarea, overlay);
                        }
                    });
                });
            }
        }
        
        // Init
        loadAppSettings();  // 저장된 설정 먼저 로드
        initAllSliders();   // 모든 range 슬라이더 채움 초기화
        console.log('[PeroPix] After loadAppSettings, tagAutocompleteEnabled:', tagAutocompleteEnabled);
        loadSlotSizePresets();  // 슬롯 사이즈 프리셋 로드

        // Setup tag autocomplete for base prompts
        console.log('[PeroPix] Setting up tag autocomplete for base prompts...');
        setupTagAutocomplete(document.getElementById('basePrompt'));
        setupTagAutocomplete(document.getElementById('negativePrompt'));

        // Setup prompt weight highlighting for base prompts
        console.log('[PeroPix] Setting up prompt weight highlighting...');
        setupPromptHighlighting(document.getElementById('basePrompt'));
        setupPromptHighlighting(document.getElementById('negativePrompt'));

        // 현재 provider에 맞게 샘플러/스케줄러 옵션 설정 및 복원
        updateSamplerSchedulerOptions(currentProvider);

        // Anlas 정보 초기화 (NAI인 경우)
        updateAnlasVisibility();
        if (window._pendingSampler) {
            const samplerSelect = document.getElementById('sampler');
            // 현재 옵션에 있는 값만 복원
            if ([...samplerSelect.options].some(o => o.value === window._pendingSampler)) {
                samplerSelect.value = window._pendingSampler;
                window._pendingSampler = null;
            }
            // 없으면 pending 유지 (local 전환 시 복원)
        }
        if (window._pendingScheduler) {
            const schedulerSelect = document.getElementById('scheduler');
            if ([...schedulerSelect.options].some(o => o.value === window._pendingScheduler)) {
                schedulerSelect.value = window._pendingScheduler;
                window._pendingScheduler = null;
            }
        }
        
        loadResources().then(() => {
            // 모델 선택 복원 (loadResources 완료 후)
            if (window._pendingLocalModel) {
                document.getElementById('localModel').value = window._pendingLocalModel;
            }
            if (window._pendingUpscaleModel) {
                document.getElementById('upscaleModel').value = window._pendingUpscaleModel;
            }
            if (window._pendingLutFile) {
                document.getElementById('lutFile').value = window._pendingLutFile;
            }
            // 캐릭터 프롬프트 복원 (레이아웃 포함)
            if (window._pendingCharacterPromptsLayout) {
                window._pendingCharacterPromptsLayout.forEach(charData => {
                    const content = charData.content || '';
                    const collapsed = charData.collapsed || false;
                    const height = charData.height || null;
                    const enabled = charData.enabled !== false;  // 기본값 true (하위 호환)
                    if (content.trim() || collapsed) {
                        const item = createCharacterItem(content, collapsed, enabled);
                        if (height) {
                            item.querySelector('textarea').style.height = height;
                        }
                        charactersList.appendChild(item);
                    }
                });
                updateCharacterNumbers();
                window._pendingCharacterPromptsLayout = null;
            }

            // 모든 복원 완료 후 자동 저장 설정
            setupAutoSave();
        });
        connectWebSocket();
        checkLocalEnvStatus();
        
        // 슬롯이 없으면 하나 추가
        if (slotsContainer.children.length === 0) {
            addSlot();
        }
        
        // 시드가 비어있으면 랜덤 생성
        if (!document.getElementById('seed').value) {
            document.getElementById('seed').value = Math.floor(Math.random() * 2147483647);
        }
        
        // 초기 그라데이션 업데이트
        setTimeout(updateScrollGradients, 100);
        
        // 페이지 떠날 때 저장 및 경고
        window.isIntentionalClose = false;  // 재시작 등 의도적 종료 플래그 (전역)
        window.addEventListener('beforeunload', (e) => {
            saveAppSettings();
            // 의도적 종료가 아닌 경우에만 경고 표시
            if (!window.isIntentionalClose) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // ============================================================
        // Gallery Mode
        // ============================================================
        const slotModeBtn = document.getElementById('slotModeBtn');
        const galleryModeBtn = document.getElementById('galleryModeBtn');
        const censorModeBtn = document.getElementById('censorModeBtn');
        const slotsToolbar = document.getElementById('slotsToolbar');
        const galleryContainer = document.getElementById('galleryContainer');
        const censorContainer = document.getElementById('censorContainer');
        const galleryGrid = document.getElementById('galleryGrid');
        const galleryEmpty = document.getElementById('galleryEmpty');
        const gallerySubfolders = document.getElementById('gallerySubfolders');
        const galleryRootBtn = document.getElementById('galleryRootBtn');

        let currentMode = 'slot'; // 'slot' | 'gallery' | 'censor'
        let currentGalleryFolder = ''; // 현재 선택된 폴더 (빈 문자열 = gallery 루트)
        let isVibeMode = false; // vibe cache mode

        slotModeBtn.onclick = () => {
            if (currentMode === 'slot') return;
            currentMode = 'slot';
            slotModeBtn.classList.add('active');
            galleryModeBtn.classList.remove('active');
            censorModeBtn.classList.remove('active');
            slotsToolbar.style.display = 'flex';
            slotsWrapper.style.display = 'flex';
            galleryContainer.style.display = 'none';
            censorContainer.style.display = 'none';
        };

        galleryModeBtn.onclick = () => {
            if (currentMode === 'gallery') return;
            currentMode = 'gallery';
            galleryModeBtn.classList.add('active');
            slotModeBtn.classList.remove('active');
            censorModeBtn.classList.remove('active');
            slotsToolbar.style.display = 'none';
            slotsWrapper.style.display = 'none';
            galleryContainer.style.display = 'flex';
            censorContainer.style.display = 'none';

            // 갤러리가 이미 로드되어 있으면 스킵 (폴더는 첫 진입 시 로드됨)
            if (!window.galleryInitialized) {
                loadGalleryFolders();
                loadGallery(currentGalleryFolder);
                window.galleryInitialized = true;
            }
        };

        censorModeBtn.onclick = async () => {
            if (currentMode === 'censor') return;

            currentMode = 'censor';
            censorModeBtn.classList.add('active');
            slotModeBtn.classList.remove('active');
            galleryModeBtn.classList.remove('active');
            slotsToolbar.style.display = 'none';
            slotsWrapper.style.display = 'none';
            galleryContainer.style.display = 'none';
            censorContainer.style.display = 'flex';

            // 검열 모드 초기화 (내부에서 캐싱 처리)
            if (typeof initCensorMode === 'function') {
                await initCensorMode();
            }
        };

        // 갤러리 폴더 열기 (현재 선택된 폴더)
        document.getElementById('openGalleryFolderBtn').onclick = async () => {
            try {
                const response = await fetch(`${API_BASE}/api/gallery/open-folder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder: currentGalleryFolder })
                });
                const result = await response.json();
                if (!result.success) {
                    showToast('폴더 열기 실패', 'error');
                }
            } catch (err) {
                showToast('폴더 열기 오류', 'error');
            }
        };

        // 새 폴더 생성
        document.getElementById('addFolderBtn').onclick = () => {
            showInputModal('📁 새 폴더', '폴더 이름을 입력하세요', async (folderName) => {
                try {
                    const response = await fetch(`${API_BASE}/api/gallery/folders`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: folderName })
                    });
                    const result = await response.json();
                    if (result.success) {
                        showToast('폴더 생성됨', 'success');
                        loadGalleryFolders();
                    } else {
                        showToast('폴더 생성 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('폴더 생성 오류: ' + err.message, 'error');
                }
            }, '생성');
        };

        // 폴더 아이콘 업데이트 (📂 선택됨 / 📁 미선택)
        function updateFolderIcons() {
            const vibeCacheBtn = document.getElementById('vibeCacheBtn');

            // vibe 폴더
            vibeCacheBtn.classList.toggle('active', isVibeMode);

            // 루트 폴더
            const isRootActive = !isVibeMode && currentGalleryFolder === '';
            galleryRootBtn.textContent = `${isRootActive ? '📂' : '📁'} gallery`;
            galleryRootBtn.classList.toggle('active', isRootActive);

            // 하위 폴더들
            gallerySubfolders.querySelectorAll('.folder-tab').forEach(tab => {
                const isActive = !isVibeMode && tab.dataset.folder === currentGalleryFolder;
                const folderName = tab.dataset.folder;
                const count = tab.dataset.count || '';
                tab.textContent = `${isActive ? '📂' : '📁'} ${folderName}${count ? ` (${count})` : ''}`;
                tab.classList.toggle('active', isActive);
            });
        }

        // 폴더 목록 로드
        async function loadGalleryFolders() {
            try {
                const response = await fetch(`${API_BASE}/api/gallery/folders`);
                const result = await response.json();

                // 기존 하위 폴더 탭 제거
                gallerySubfolders.innerHTML = '';

                if (result.success && result.folders) {
                    result.folders.forEach(folder => {
                        const tab = document.createElement('button');
                        tab.type = 'button';
                        tab.className = 'folder-tab';
                        tab.dataset.folder = folder.name;
                        tab.dataset.count = folder.image_count;
                        tab.title = `${folder.image_count}개 이미지`;
                        setupFolderTab(tab);
                        gallerySubfolders.appendChild(tab);
                    });
                }

                // 루트 폴더 탭 이벤트 설정
                setupFolderTab(galleryRootBtn);

                // 아이콘 상태 업데이트
                updateFolderIcons();
            } catch (err) {
                console.error('폴더 목록 로드 실패:', err);
            }
        }

        // Vibe 캐시 버튼 클릭
        document.getElementById('vibeCacheBtn').onclick = () => {
            if (isVibeMode) return;
            isVibeMode = true;
            updateFolderIcons();
            loadVibeCache();
        };

        // 폴더 탭 이벤트 설정
        function setupFolderTab(tab) {
            tab.onclick = () => {
                if (!isVibeMode && tab.dataset.folder === currentGalleryFolder) return;
                isVibeMode = false;  // Exit vibe mode when clicking gallery folders
                currentGalleryFolder = tab.dataset.folder;
                updateFolderIcons();
                loadGallery(currentGalleryFolder);
            };

            // 드래그 오버 이벤트 (이미지를 폴더로 이동할 때)
            tab.ondragover = (e) => {
                e.preventDefault();
                tab.classList.add('drag-over');
            };
            tab.ondragleave = () => {
                tab.classList.remove('drag-over');
            };
            tab.ondrop = async (e) => {
                e.preventDefault();
                tab.classList.remove('drag-over');
                const filename = e.dataTransfer.getData('text/plain');
                const fromFolder = e.dataTransfer.getData('application/x-gallery-folder');
                const toFolder = tab.dataset.folder;

                if (!filename || fromFolder === toFolder) return;

                try {
                    const response = await fetch(`${API_BASE}/api/gallery/${encodeURIComponent(filename)}/move`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ from_folder: fromFolder, to_folder: toFolder })
                    });
                    const result = await response.json();
                    if (result.success) {
                        showToast('이미지 이동됨', 'success');
                        loadGallery(currentGalleryFolder);
                        loadGalleryFolders();
                    } else {
                        showToast('이동 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('이동 오류: ' + err.message, 'error');
                }
            };
        }

        let galleryLoaded = false;

        async function loadGallery(folder = '') {
            // 바이브 모드면 갤러리 로드 안함
            if (isVibeMode) return;

            // 로딩 중 표시
            galleryGrid.style.display = 'none';
            galleryEmpty.innerHTML = `
                <div class="icon">⏳</div>
                <p>갤러리 로딩 중...</p>
            `;
            galleryEmpty.style.display = 'flex';

            try {
                const response = await fetch(`${API_BASE}/api/gallery?folder=${encodeURIComponent(folder)}`);
                const result = await response.json();

                // 로딩 중에 바이브 모드로 전환되었으면 렌더링 안함
                if (isVibeMode) return;

                if (result.images && result.images.length > 0) {
                    galleryEmpty.style.display = 'none';
                    galleryGrid.style.display = 'grid';
                    renderGallery(result.images, folder);
                } else {
                    galleryEmpty.innerHTML = `
                        <div class="icon">🖼️</div>
                        <p>${folder ? `'${folder}' 폴더가` : '갤러리가'} 비어있습니다</p>
                        <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                    `;
                    galleryEmpty.style.display = 'flex';
                    galleryGrid.style.display = 'none';
                    galleryGrid.innerHTML = '';
                }
                galleryLoaded = true;
            } catch (err) {
                galleryEmpty.innerHTML = `
                    <div class="icon">❌</div>
                    <p>갤러리 로드 실패</p>
                    <small>${err.message}</small>
                `;
                showToast('갤러리 로드 실패: ' + err.message, 'error');
            }
        }

        function renderGallery(images, folder = '') {
            galleryGrid.innerHTML = '';

            images.forEach(img => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                item._filename = img.filename;
                item._folder = folder;
                item.draggable = true;
                item.innerHTML = `
                    <img src="data:image/png;base64,${img.thumbnail}" alt="">
                    <div class="gallery-item-info">
                        <div class="filename-row">
                            <span class="filename" title="${img.filename}">${img.filename.replace('.png', '')}</span>
                            <button class="rename-btn" title="이름 변경">✏️</button>
                        </div>
                        <div class="seed">${img.seed ? 'Seed: ' + img.seed : '메타데이터 없음'}</div>
                    </div>
                    <div class="gallery-item-actions">
                        <button class="inpaint-btn" title="인페인트">🎨 Inpaint</button>
                        <button class="enhance-btn" title="Enhance (NAI)" style="display: ${currentProvider === 'nai' ? 'inline-block' : 'none'};">✨ Enhance</button>
                        <button class="apply-all-btn" title="설정 적용">📋 Apply</button>
                        <button class="delete-btn" title="삭제">🗑️</button>
                    </div>
                `;

                // 드래그 시작 (폴더 이동용)
                item.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', item._filename);
                    e.dataTransfer.setData('application/x-gallery-folder', item._folder);
                    e.dataTransfer.effectAllowed = 'move';

                    // 커스텀 드래그 고스트 생성
                    const ghost = document.createElement('div');
                    ghost.id = 'dragGhost';
                    ghost.style.cssText = 'position: fixed; top: -100px; left: -100px; width: 60px; height: 60px; background: var(--accent); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: none; z-index: 10000;';
                    ghost.textContent = '📁';
                    document.body.appendChild(ghost);
                    e.dataTransfer.setDragImage(ghost, 30, 30);

                    item.classList.add('dragging');
                };
                item.ondragend = () => {
                    item.classList.remove('dragging');
                    // 드래그 고스트 제거
                    const ghost = document.getElementById('dragGhost');
                    if (ghost) ghost.remove();
                };

                // 이미지 자체의 기본 드래그 동작 방지 (부모 item의 드래그로 대체)
                const imgEl = item.querySelector('img');
                if (imgEl) {
                    imgEl.draggable = false;
                }

                // 라이트박스 표시 함수
                const folderQuery = folder ? `?folder=${encodeURIComponent(folder)}` : '';
                const showLightbox = async () => {
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success) {
                            lightboxImg.src = 'data:image/png;base64,' + result.image;
                            lightboxCurrentGalleryItem = item;  // 휠 네비게이션용
                            lightbox.classList.add('active');
                        }
                    } catch (err) {
                        showToast('이미지 로드 실패', 'error');
                    }
                };

                // 카드 클릭 - 라이트박스 (버튼 제외)
                item.onclick = (e) => {
                    // 버튼이나 입력 필드 클릭시 무시
                    if (e.target.closest('.gallery-item-actions') || e.target.closest('.rename-btn') || e.target.tagName === 'INPUT') {
                        return;
                    }
                    showLightbox();
                };

                // 이름 변경
                item.querySelector('.rename-btn').onclick = (e) => {
                    e.stopPropagation();
                    const filenameRow = item.querySelector('.filename-row');
                    const filenameSpan = item.querySelector('.filename');
                    const currentName = item._filename.replace('.png', '');

                    // 입력 필드로 교체
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'filename-input';
                    input.value = currentName;

                    filenameSpan.style.display = 'none';
                    filenameRow.insertBefore(input, filenameRow.querySelector('.rename-btn'));
                    input.focus();
                    input.select();

                    const saveRename = async () => {
                        const newName = input.value.trim();
                        if (!newName || newName === currentName) {
                            // 취소
                            input.remove();
                            filenameSpan.style.display = '';
                            return;
                        }

                        try {
                            const response = await fetch(`${API_BASE}/api/gallery/${item._filename}`, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ new_name: newName, folder: item._folder })
                            });
                            const result = await response.json();
                            if (result.success) {
                                item._filename = result.new_filename;
                                filenameSpan.textContent = newName;
                                filenameSpan.title = result.new_filename;
                                showToast('이름 변경됨', 'success');
                            } else {
                                showToast(result.error || '이름 변경 실패', 'error');
                            }
                        } catch (err) {
                            showToast('이름 변경 오류', 'error');
                        }

                        input.remove();
                        filenameSpan.style.display = '';
                    };

                    input.onblur = saveRename;
                    input.onkeydown = (ke) => {
                        if (ke.key === 'Enter') {
                            ke.preventDefault();
                            input.blur();
                        } else if (ke.key === 'Escape') {
                            input.value = currentName;
                            input.blur();
                        }
                    };
                };

                // 설정 적용 (팝업) - 이미지 드롭과 동일한 모달 사용
                item.querySelector('.apply-all-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success && result.image) {
                            // 이미지 드롭과 동일한 방식으로 dropModal 표시
                            showGalleryDropModal(result.image, result.metadata, item._filename);
                        } else {
                            showToast('이미지 로드 실패', 'error');
                        }
                    } catch (err) {
                        showToast('적용 실패: ' + err.message, 'error');
                    }
                };

                // 인페인트
                item.querySelector('.inpaint-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success && result.image) {
                            setBaseImageForInpaint(result.image);
                            showToast('인페인트 모드로 전환', 'success');
                        } else {
                            showToast('이미지 로드 실패', 'error');
                        }
                    } catch (err) {
                        showToast('인페인트 오류: ' + err.message, 'error');
                    }
                };

                // Enhance (NAI 전용)
                item.querySelector('.enhance-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success && result.image) {
                            openEnhanceModal(result.image, result.metadata);
                        } else {
                            showToast('이미지 로드 실패', 'error');
                        }
                    } catch (err) {
                        showToast('Enhance 오류: ' + err.message, 'error');
                    }
                };

                // 삭제
                item.querySelector('.delete-btn').onclick = async (e) => {
                    e.stopPropagation();
                    showConfirmModal(
                        '🗑️ 이미지 삭제',
                        '<p>이 이미지를 갤러리에서 삭제하시겠습니까?</p>',
                        async () => {
                            try {
                                const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`, {
                                    method: 'DELETE'
                                });
                                const result = await response.json();
                                if (result.success) {
                                    item.remove();
                                    showToast('삭제됨', 'success');
                                    // 갤러리가 비었는지 확인
                                    if (galleryGrid.children.length === 0) {
                                        galleryEmpty.innerHTML = `
                                            <div class="icon">🖼️</div>
                                            <p>갤러리가 비어있습니다</p>
                                            <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                                        `;
                                        galleryEmpty.style.display = 'flex';
                                        galleryGrid.style.display = 'none';
                                    }
                                } else {
                                    showToast('삭제 실패', 'error');
                                }
                            } catch (err) {
                                showToast('삭제 오류: ' + err.message, 'error');
                            }
                        },
                        '삭제',
                        true
                    );
                };

                galleryGrid.appendChild(item);
            });
        }

        // ============================================================
        // Vibe Cache Loading
        // ============================================================
        async function loadVibeCache() {
            // 로딩 중 표시
            galleryGrid.style.display = 'none';
            galleryEmpty.innerHTML = `
                <div class="icon">⏳</div>
                <p>바이브 캐시 로딩 중...</p>
            `;
            galleryEmpty.style.display = 'flex';

            try {
                const response = await fetch(`${API_BASE}/api/vibe-cache`);
                const result = await response.json();

                if (result.vibes && result.vibes.length > 0) {
                    galleryEmpty.style.display = 'none';
                    galleryGrid.style.display = 'grid';
                    renderVibeCache(result.vibes);
                } else {
                    galleryEmpty.innerHTML = `
                        <div class="icon">🎨</div>
                        <p>바이브 캐시가 비어있습니다</p>
                        <small>이미지 생성 시 바이브가 자동으로 캐시됩니다</small>
                    `;
                    galleryEmpty.style.display = 'flex';
                    galleryGrid.style.display = 'none';
                    galleryGrid.innerHTML = '';
                }
            } catch (err) {
                galleryEmpty.innerHTML = `
                    <div class="icon">❌</div>
                    <p>바이브 캐시 로드 실패</p>
                    <small>${err.message}</small>
                `;
                showToast('바이브 캐시 로드 실패: ' + err.message, 'error');
            }
        }

        function renderVibeCache(vibes) {
            galleryGrid.innerHTML = '';

            vibes.forEach(vibe => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                item._filename = vibe.filename;
                item._isVibe = true;  // 바이브 캐시 아이템 마커
                item._thumbnail = vibe.thumbnail;  // 휠 네비게이션용
                item.draggable = false;  // Vibe items are not draggable

                // 파일명에서 이름 추출 (예: name_0.6_1.0_0000001.png → name)
                const displayName = vibe.filename.replace(/\.png$/i, '').replace(/_[\d.]+_[\d.]+_\d+$/, '');

                item.innerHTML = `
                    <img src="data:image/png;base64,${vibe.thumbnail}" alt="">
                    <div class="gallery-item-info">
                        <div class="filename-row">
                            <span class="filename" title="${vibe.filename}">${displayName}</span>
                        </div>
                        <div class="seed">S:${vibe.strength} IE:${vibe.info_extracted}</div>
                    </div>
                    <div class="gallery-item-actions">
                        <button class="apply-vibe-btn" title="바이브 적용">🎨 Vibe</button>
                        <button class="delete-btn" title="삭제">🗑️</button>
                    </div>
                `;

                // 이미지 클릭 시 라이트박스
                const imgEl = item.querySelector('img');
                imgEl.onclick = () => {
                    lightboxImg.src = `data:image/png;base64,${vibe.thumbnail}`;
                    lightboxCurrentGalleryItem = item;  // 휠 네비게이션용
                    lightbox.classList.add('active');
                };

                // 바이브 적용 버튼
                item.querySelector('.apply-vibe-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/vibe-cache/${vibe.filename}`);
                        const result = await response.json();
                        if (result.success && result.vibe_data) {
                            // vibeList에 추가
                            if (vibeList.length >= 16) {
                                showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                                return;
                            }

                            vibeList.push({
                                image: result.image,
                                strength: result.strength,
                                info_extracted: result.info_extracted,
                                name: displayName,
                                encoded: result.vibe_data,  // Pre-encoded vibe data
                                encoded_model: result.model,  // Model used for encoding
                                encoded_info_extracted: result.info_extracted  // Info extracted used for encoding
                            });
                            renderVibeList();
                            saveAppSettings();
                            updateAnlasCost();

                            // Vibe Transfer 활성화
                            document.getElementById('enableVibeTransfer').checked = true;
                            document.getElementById('vibeTransferSettings').style.display = 'block';
                            // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                            document.getElementById('enableCharRef').checked = false;
                            document.getElementById('charRefSettings').style.display = 'none';

                            showToast('바이브가 추가되었습니다', 'success');
                        } else {
                            showToast('바이브 데이터 없음', 'warning');
                        }
                    } catch (err) {
                        showToast('바이브 적용 실패: ' + err.message, 'error');
                    }
                };

                // 삭제 버튼
                item.querySelector('.delete-btn').onclick = async (e) => {
                    e.stopPropagation();
                    showConfirmModal(
                        '🗑️ 바이브 삭제',
                        '<p>이 바이브 캐시를 삭제하시겠습니까?</p>',
                        async () => {
                            try {
                                const response = await fetch(`${API_BASE}/api/vibe-cache/${vibe.filename}`, {
                                    method: 'DELETE'
                                });
                                const result = await response.json();
                                if (result.success) {
                                    item.remove();
                                    showToast('삭제됨', 'success');
                                    // 캐시가 비었는지 확인
                                    if (galleryGrid.children.length === 0) {
                                        galleryEmpty.innerHTML = `
                                            <div class="icon">🎨</div>
                                            <p>바이브 캐시가 비어있습니다</p>
                                            <small>이미지 생성 시 바이브가 자동으로 캐시됩니다</small>
                                        `;
                                        galleryEmpty.style.display = 'flex';
                                        galleryGrid.style.display = 'none';
                                    }
                                } else {
                                    showToast('삭제 실패', 'error');
                                }
                            } catch (err) {
                                showToast('삭제 오류: ' + err.message, 'error');
                            }
                        },
                        '삭제',
                        true
                    );
                };

                galleryGrid.appendChild(item);
            });
        }

        // ============================================================
        // 외부 이미지 드롭 처리
        // ============================================================
        const dropOverlay = document.getElementById('dropOverlay');
        const dropModal = document.getElementById('dropModal');
        let pendingDropData = null;

        // 드래그 이벤트 처리
        let dragCounter = 0;
        
        // 자동검열 모드인지 확인하는 헬퍼
        function isInCensorMode() {
            const censorContainer = document.getElementById('censorContainer');
            return censorContainer && censorContainer.style.display !== 'none';
        }
        
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            // 자동검열 모드에서는 전역 드롭 오버레이 표시 안 함
            if (e.dataTransfer.types.includes('Files') && !isInCensorMode()) {
                dropOverlay.classList.add('active');
            }
        });

        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dropOverlay.classList.remove('active');
            }
        });

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropOverlay.classList.remove('active');
            
            // 자동검열 모드에서는 전역 드롭 처리 안 함 (검열용 드롭 핸들러에서 처리)
            if (isInCensorMode()) return;

            const files = e.dataTransfer.files;
            if (files.length === 0) return;

            const file = files[0];

            // NAI 바이브 파일 (.naiv4vibe) 처리
            if (file.name.endsWith('.naiv4vibe')) {
                try {
                    const text = await file.text();
                    const vibeData = JSON.parse(text);

                    // NAI 바이브 파일 검증
                    if (vibeData.identifier !== 'novelai-vibe-transfer') {
                        showToast('유효하지 않은 NAI 바이브 파일입니다', 'error');
                        return;
                    }

                    // 바이브 정보 추출
                    const importInfo = vibeData.importInfo || {};
                    const model = importInfo.model || 'nai-diffusion-4-5-full';
                    const strength = importInfo.strength || 0.6;
                    const infoExtracted = importInfo.information_extracted || 1.0;

                    // 모델에 맞는 인코딩 찾기
                    const modelKeyMap = {
                        'nai-diffusion-4-5-full': 'v4-5full',
                        'nai-diffusion-4-curated-preview': 'v4-curated',
                        'nai-diffusion-4-full': 'v4-full'
                    };
                    const encodingKey = modelKeyMap[model] || 'v4-5full';
                    const modelEncodings = vibeData.encodings?.[encodingKey] || {};

                    // info_extracted에 맞는 인코딩 찾기 (없으면 첫 번째 사용)
                    let encodedData = null;
                    let encodedInfoExtracted = infoExtracted;
                    for (const [hash, data] of Object.entries(modelEncodings)) {
                        if (data.params?.information_extracted === infoExtracted) {
                            encodedData = data.encoding;
                            break;
                        }
                        if (!encodedData) {
                            encodedData = data.encoding;
                            encodedInfoExtracted = data.params?.information_extracted || infoExtracted;
                        }
                    }

                    // 모달 표시
                    const thumbnail = vibeData.thumbnail || '';
                    const imageBase64 = vibeData.image || '';

                    document.getElementById('dropModalPreview').src = thumbnail || 'data:image/png;base64,' + imageBase64;
                    document.getElementById('dropModalTitle').textContent = '🎨 NAI 바이브 파일';
                    document.getElementById('dropModalMetadata').innerHTML = `
                        <div><strong>Name:</strong> ${vibeData.name || file.name}</div>
                        <div><strong>Model:</strong> ${model}</div>
                        <div><strong>Strength:</strong> ${strength}</div>
                        <div><strong>Info Extracted:</strong> ${infoExtracted}</div>
                        ${encodedData ? '<div style="color:#4ade80">✓ 인코딩 캐시 있음 (Anlas 무료)</div>' : '<div style="color:#fbbf24">⚠ 인코딩 없음 - 생성 시 인코딩됨</div>'}
                    `;
                    // 바이브 파일: 확인/취소만 표시
                    document.getElementById('dropModalVibeActions').style.display = 'flex';

                    pendingDropData = {
                        type: 'nai-vibe',
                        image: imageBase64,
                        strength: strength,
                        info_extracted: infoExtracted,
                        name: vibeData.name || file.name.replace('.naiv4vibe', ''),
                        encoded: encodedData,
                        encoded_model: encodedData ? model : null,
                        encoded_info_extracted: encodedData ? encodedInfoExtracted : null
                    };

                    dropModal.classList.add('active');
                    return;
                } catch (err) {
                    showToast('NAI 바이브 파일 파싱 오류: ' + err.message, 'error');
                    return;
                }
            }

            if (!file.type.startsWith('image/')) {
                showToast('이미지 파일만 드롭할 수 있습니다', 'error');
                return;
            }

            // 이미지를 base64로 변환
            const base64 = await fileToBase64(file);

            // 서버에서 메타데이터 추출
            try {
                const response = await fetch(`${API_BASE}/api/extract-metadata`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: base64 })
                });
                const result = await response.json();

                if (!result.success) {
                    showToast('메타데이터 추출 실패: ' + result.error, 'error');
                    return;
                }

                // 모달 표시 준비
                document.getElementById('dropModalPreview').src = 'data:image/png;base64,' + base64;
                const metadataDiv = document.getElementById('dropModalMetadata');

                if (result.is_vibe) {
                    // 바이브 캐시 파일
                    const hasCache = result.vibe_data && result.vibe_model;
                    document.getElementById('dropModalTitle').textContent = hasCache ? '🎨 바이브 캐시 파일' : '🎨 바이브 파일';
                    metadataDiv.innerHTML = `
                        <div><strong>Strength:</strong> ${result.vibe_strength}</div>
                        <div><strong>Info Extracted:</strong> ${result.vibe_info_extracted}</div>
                        ${hasCache ? `<div><strong>Model:</strong> ${result.vibe_model}</div><div style="color:#4ade80">✓ 인코딩 캐시 있음 (Anlas 무료)</div>` : ''}
                    `;
                    // 바이브 캐시 파일: 확인/취소만 표시
                    document.getElementById('dropModalVibeActions').style.display = 'flex';
                    pendingDropData = {
                        type: 'vibe',
                        image: base64,
                        strength: result.vibe_strength,
                        info_extracted: result.vibe_info_extracted,
                        name: file.name,
                        encoded: result.vibe_data || null,
                        encoded_model: result.vibe_model || null,
                        encoded_info_extracted: result.vibe_data ? result.vibe_info_extracted : null  // 캐시된 경우 인코딩 시 사용된 info_extracted
                    };
                } else if (result.is_nai && result.nai_metadata) {
                    // NAI 생성 이미지 - 정규화된 메타데이터로 표시
                    const meta = normalizeMetadata(result.nai_metadata);
                    const isPureNai = !result.nai_metadata.peropix;
                    document.getElementById('dropModalTitle').textContent = isPureNai ? '🖼️ NAI 원본 이미지' : '🖼️ PeroPix 이미지';

                    metadataDiv.innerHTML = `
                        <div><strong>Prompt:</strong> ${(meta.prompt || '').substring(0, 100)}${(meta.prompt || '').length > 100 ? '...' : ''}</div>
                        <div><strong>Negative:</strong> ${(meta.negative_prompt || '').substring(0, 50)}${(meta.negative_prompt || '').length > 50 ? '...' : ''}</div>
                        <div><strong>Seed:</strong> ${meta.seed || 'N/A'}</div>
                        <div><strong>Size:</strong> ${meta.width}x${meta.height}</div>
                        <div><strong>Steps:</strong> ${meta.steps}, <strong>CFG:</strong> ${meta.cfg}, <strong>Rescale:</strong> ${meta.cfg_rescale || 0}</div>
                        <div><strong>Sampler:</strong> ${meta.sampler}, <strong>Scheduler:</strong> ${meta.scheduler}</div>
                        <div><strong>SMEA:</strong> ${meta.smea}, <strong>Variety+:</strong> ${meta.variety_plus ? 'On' : 'Off'}</div>
                        <div><strong>Model:</strong> ${meta.nai_model || 'N/A'}</div>
                        ${isPureNai ? '<div style="color:#4ade80; margin-top:8px;">✓ NAI 원본: 퀄리티 태그/UC 프리셋 자동 분리됨</div>' : ''}
                    `;
                    // NAI/PeroPix 이미지: 이미지 용도 + 메타데이터 적용 버튼 모두 표시
                    document.getElementById('dropModalImageOptions').style.display = 'flex';
                    document.getElementById('dropModalMetaOptions').style.display = 'flex';
                    document.getElementById('dropModalMetaActions').style.display = 'flex';
                    pendingDropData = {
                        type: 'nai',
                        metadata: result.nai_metadata,  // 원본 저장 (적용 시 다시 정규화)
                        image: base64,
                        name: file.name
                    };
                    window._isPureNaiImage = isPureNai;
                } else {
                    // 일반 이미지 - 바이브, 캐릭터 레퍼런스, 베이스 이미지로 추가 제안
                    document.getElementById('dropModalTitle').textContent = '📷 일반 이미지';
                    metadataDiv.innerHTML = '<div>메타데이터가 없습니다. 바이브, 캐릭터 레퍼런스, 또는 베이스 이미지로 추가할 수 있습니다.</div>';
                    // 일반 이미지: 이미지 용도 + 취소 버튼만 표시
                    document.getElementById('dropModalImageOptions').style.display = 'flex';
                    document.getElementById('dropModalPlainActions').style.display = 'flex';
                    pendingDropData = {
                        type: 'plain',
                        image: base64,
                        name: file.name
                    };
                }

                dropModal.classList.add('active');

            } catch (err) {
                showToast('메타데이터 추출 오류: ' + err.message, 'error');
            }
        });

        // 갤러리 Apply 버튼용 - dropModal 표시 (이미지 드롭과 동일한 UI)
        window.showGalleryDropModal = function(imageBase64, metadata, filename) {
            const dropModal = document.getElementById('dropModal');

            // 모달 표시 준비
            document.getElementById('dropModalPreview').src = 'data:image/png;base64,' + imageBase64;
            const metadataDiv = document.getElementById('dropModalMetadata');

            if (metadata) {
                // NAI/PeroPix 이미지 - 정규화된 메타데이터로 표시
                const meta = normalizeMetadata(metadata);
                const isPureNai = !metadata.peropix;
                document.getElementById('dropModalTitle').textContent = isPureNai ? '🖼️ NAI 원본 이미지' : '🖼️ PeroPix 이미지';

                metadataDiv.innerHTML = `
                    <div><strong>Prompt:</strong> ${(meta.prompt || '').substring(0, 100)}${(meta.prompt || '').length > 100 ? '...' : ''}</div>
                    <div><strong>Negative:</strong> ${(meta.negative_prompt || '').substring(0, 50)}${(meta.negative_prompt || '').length > 50 ? '...' : ''}</div>
                    <div><strong>Seed:</strong> ${meta.seed || 'N/A'}</div>
                    <div><strong>Size:</strong> ${meta.width}x${meta.height}</div>
                    <div><strong>Steps:</strong> ${meta.steps}, <strong>CFG:</strong> ${meta.cfg}, <strong>Rescale:</strong> ${meta.cfg_rescale || 0}</div>
                    <div><strong>Sampler:</strong> ${meta.sampler}, <strong>Scheduler:</strong> ${meta.scheduler}</div>
                    <div><strong>SMEA:</strong> ${meta.smea}, <strong>Variety+:</strong> ${meta.variety_plus ? 'On' : 'Off'}</div>
                    <div><strong>Model:</strong> ${meta.nai_model || 'N/A'}</div>
                    ${isPureNai ? '<div style="color:#4ade80; margin-top:8px;">✓ NAI 원본: 퀄리티 태그/UC 프리셋 자동 분리됨</div>' : ''}
                `;
                // NAI/PeroPix 이미지: 이미지 용도 + 메타데이터 적용 버튼 모두 표시
                document.getElementById('dropModalImageOptions').style.display = 'flex';
                document.getElementById('dropModalMetaOptions').style.display = 'flex';
                document.getElementById('dropModalMetaActions').style.display = 'flex';
                pendingDropData = {
                    type: 'nai',
                    metadata: metadata,  // 원본 저장 (적용 시 다시 정규화)
                    image: imageBase64,
                    name: filename
                };
                window._isPureNaiImage = isPureNai;
            } else {
                // 메타데이터 없는 이미지 - 바이브, 캐릭터 레퍼런스, 베이스 이미지로 추가 제안
                document.getElementById('dropModalTitle').textContent = '📷 갤러리 이미지';
                metadataDiv.innerHTML = '<div>메타데이터가 없습니다. 바이브, 캐릭터 레퍼런스, 또는 베이스 이미지로 추가할 수 있습니다.</div>';
                // 일반 이미지: 이미지 용도 + 취소 버튼만 표시
                document.getElementById('dropModalImageOptions').style.display = 'flex';
                document.getElementById('dropModalPlainActions').style.display = 'flex';
                pendingDropData = {
                    type: 'plain',
                    image: imageBase64,
                    name: filename
                };
            }

            dropModal.classList.add('active');
        };

        // 모달 닫기 헬퍼
        function closeDropModal() {
            dropModal.classList.remove('active');
            pendingDropData = null;
            window._pendingLoadMetadata = null;
            window._isPureNaiImage = false;
            document.getElementById('dropModalPreview').style.display = '';
            // 버튼 그룹 숨기기
            document.getElementById('dropModalImageOptions').style.display = 'none';
            document.getElementById('dropModalMetaOptions').style.display = 'none';
            document.getElementById('dropModalPlainActions').style.display = 'none';
            document.getElementById('dropModalMetaActions').style.display = 'none';
            // 개별 버튼 display 리셋 (설정 불러오기에서 숨겼을 수 있음)
            document.getElementById('dropModalSeedOnly').style.display = '';
            document.getElementById('dropModalVibeActions').style.display = 'none';
        }

        // 모달 버튼 이벤트 - 취소 버튼들
        document.getElementById('dropModalCancel').onclick = () => closeDropModal();
        document.getElementById('dropModalCancelMeta').onclick = () => closeDropModal();
        document.getElementById('dropModalCancelVibe').onclick = () => closeDropModal();

        // 바이브 파일 추가 버튼 (nai-vibe, vibe 타입)
        document.getElementById('dropModalAddVibe').onclick = () => {
            if (!pendingDropData || (pendingDropData.type !== 'nai-vibe' && pendingDropData.type !== 'vibe')) return;

            if (vibeList.length >= 16) {
                showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                closeDropModal();
                return;
            }

            const vibeEntry = {
                image: pendingDropData.image,
                strength: pendingDropData.strength || 0.6,
                info_extracted: pendingDropData.info_extracted || 1.0,
                name: pendingDropData.name
            };
            if (pendingDropData.encoded) {
                vibeEntry.encoded = pendingDropData.encoded;
                vibeEntry.encoded_model = pendingDropData.encoded_model;
                vibeEntry.encoded_info_extracted = pendingDropData.encoded_info_extracted || vibeEntry.info_extracted;
            }
            vibeList.push(vibeEntry);
            renderVibeList();
            saveAppSettings();
            updateAnlasCost();
            document.getElementById('enableVibeTransfer').checked = true;
            document.getElementById('vibeTransferSettings').style.display = 'block';
            document.getElementById('enableCharRef').checked = false;
            document.getElementById('charRefSettings').style.display = 'none';
            let msg;
            if (pendingDropData.type === 'nai-vibe') {
                msg = pendingDropData.encoded ? 'NAI 바이브 추가됨 (캐시 사용)' : 'NAI 바이브 추가됨';
            } else {
                msg = pendingDropData.encoded ? '바이브 추가됨 (캐시 사용)' : '바이브 추가됨';
            }
            showToast(msg, 'success');
            closeDropModal();
        };

        // 프롬프트만 적용 버튼
        document.getElementById('dropModalPromptOnly').onclick = () => {
            const doApply = () => {
                if (window._pendingLoadMetadata) {
                    applyPromptOnly(window._pendingLoadMetadata);
                    closeDropModal();
                } else if (pendingDropData && pendingDropData.type === 'nai') {
                    // 정규화된 메타데이터로 applyPromptOnly 호출 (캐릭터 프롬프트 포함)
                    const normalized = normalizeMetadata(pendingDropData.metadata);
                    applyPromptOnly(normalized);
                    closeDropModal();
                }
            };

            // 순수 NAI 이미지면 경고 팝업 표시
            if (window._isPureNaiImage) {
                showPureNaiWarning(doApply);
            } else {
                doApply();
            }
        };

        // 시드만 적용 버튼
        document.getElementById('dropModalSeedOnly').onclick = () => {
            if (pendingDropData && pendingDropData.type === 'nai') {
                const meta = pendingDropData.metadata;
                if (meta.seed) {
                    document.getElementById('seed').value = meta.seed;
                    saveAppSettings();
                    showToast(`시드 ${meta.seed} 적용됨`, 'success');
                }
                closeDropModal();
            }
        };

        // 섹션 펼치고 스크롤하는 헬퍼 함수
        // noScroll=true 시 스크롤하지 않고 펼치기만 함
        function expandAndScrollToSection(collapsibleContentId, scrollTargetId = null, noScroll = false) {
            const collapsibleContent = document.getElementById(collapsibleContentId);

            if (collapsibleContent) {
                // 접혀있으면 펼치기
                if (collapsibleContent.classList.contains('collapsed')) {
                    collapsibleContent.classList.remove('collapsed');
                    // 토글 버튼 화살표 업데이트 (부모 section에서 찾기)
                    const parentSection = collapsibleContent.closest('.section');
                    if (parentSection) {
                        const toggleBtn = parentSection.querySelector('.collapse-toggle');
                        if (toggleBtn) toggleBtn.textContent = '▼';
                    }
                }

                // 스크롤 비활성화 요청 시 종료
                if (noScroll) return;

                // 스크롤 대상 결정 (지정된 타겟 또는 collapsible content의 부모 섹션)
                const scrollTarget = scrollTargetId
                    ? document.getElementById(scrollTargetId)
                    : collapsibleContent.closest('.section');

                // 스크롤 (약간 딜레이 후 - 펼침 애니메이션 대기)
                setTimeout(() => {
                    if (scrollTarget) {
                        scrollTarget.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 100);
            }
        }

        // 바이브로 추가 버튼
        document.getElementById('dropModalAsVibe').onclick = () => {
            if (pendingDropData && pendingDropData.image) {
                if (vibeList.length >= 16) {
                    showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                } else {
                    vibeList.push({
                        image: pendingDropData.image,
                        strength: 0.6,
                        info_extracted: 1.0,
                        name: pendingDropData.name
                    });
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                    document.getElementById('enableCharRef').checked = false;
                    document.getElementById('charRefSettings').style.display = 'none';
                    showToast('바이브에 추가됨', 'success');
                    // Vibe / CharRef 섹션 펼치고 스크롤
                    expandAndScrollToSection('vibeCharRefContent');
                }
                closeDropModal();
            }
        };

        // 캐릭터 레퍼런스로 추가 버튼
        document.getElementById('dropModalAsCharRef').onclick = async () => {
            if (pendingDropData && pendingDropData.image) {
                try {
                    // Canvas로 이미지 처리 (NAI 웹/NAIS2와 동일한 방식)
                    let processedImage;
                    try {
                        processedImage = await processCharacterReferenceImage(pendingDropData.image);
                    } catch (e) {
                        console.error('[CharRef] Processing failed:', e);
                        processedImage = pendingDropData.image; // 실패시 원본 사용
                    }
                    
                    charRefData = { image: processedImage };
                    document.getElementById('charRefImage').src = 'data:image/png;base64,' + processedImage;
                    document.getElementById('charRefPreview').style.display = 'block';
                    document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
                    
                    // 캐릭터 레퍼런스 활성화
                    document.getElementById('enableCharRef').checked = true;
                    document.getElementById('charRefSettings').style.display = 'block';
                    // Vibe Transfer와 Character Reference는 동시 사용 불가 - Vibe 비활성화
                    document.getElementById('enableVibeTransfer').checked = false;
                    document.getElementById('vibeTransferSettings').style.display = 'none';
                    
                    saveAppSettings();
                    updateAnlasCost();
                    showToast('캐릭터 레퍼런스에 추가됨', 'success');
                    // Vibe / CharRef 섹션 펼치고 Character Reference로 스크롤
                    expandAndScrollToSection('vibeCharRefContent', 'charRefSection');
                } catch (e) {
                    showToast('캐릭터 레퍼런스 추가 실패: ' + e.message, 'error');
                }
                closeDropModal();
            }
        };

        // 베이스 이미지로 추가 버튼
        document.getElementById('dropModalAsBaseImage').onclick = () => {
            if (pendingDropData && pendingDropData.image) {
                const imageBase64 = pendingDropData.image;  // 클로저 문제 방지
                const img = new Image();
                img.onload = () => {
                    baseImageData = {
                        enabled: true,
                        image: imageBase64,
                        mask: null,
                        mode: 'img2img',
                        strength: 0.7,
                        noise: 0,
                        width: img.width,
                        height: img.height
                    };
                    updateBaseImageUI();
                    // 슬롯 모드로 전환
                    if (currentMode !== 'slot') {
                        document.getElementById('slotModeBtn').click();
                    }
                    showToast('베이스 이미지로 등록됨', 'success');
                    // Base Image 섹션 펼치고 스크롤
                    expandAndScrollToSection('baseImageContent', 'baseImageSection');
                };
                img.src = 'data:image/png;base64,' + imageBase64;
                closeDropModal();
            }
        };

        document.getElementById('dropModalConfirm').onclick = () => {
            // 설정 불러오기 처리
            if (window._pendingLoadMetadata) {
                const doApply = () => {
                    applyMetadataSettings(window._pendingLoadMetadata);
                    closeDropModal();
                };

                // 순수 NAI 이미지면 경고 팝업 표시
                if (window._isPureNaiImage) {
                    showPureNaiWarning(doApply);
                } else {
                    doApply();
                }
                return;
            }

            if (!pendingDropData) return;

            if (pendingDropData.type === 'nai') {
                // NAI 메타데이터 전체 적용 - 정규화 후 applyMetadataSettings 사용
                const doApply = () => {
                    const normalized = normalizeMetadata(pendingDropData.metadata);
                    applyMetadataSettings(normalized);
                    closeDropModal();
                };

                // 순수 NAI 이미지면 경고 팝업 표시
                if (window._isPureNaiImage) {
                    showPureNaiWarning(doApply);
                    return;  // closeDropModal은 doApply 안에서 호출
                } else {
                    doApply();
                    return;
                }
            }

            closeDropModal();
        };

        // ============================================================
        // Mask Editor & Base Image (Inpaint/Img2Img)
        // ============================================================

        // Base Image 데이터
        let baseImageData = {
            enabled: false,
            image: null,        // base64
            mask: null,         // base64 (white = inpaint area)
            mode: 'img2img',    // 'img2img' | 'inpaint'
            strength: 0.7,
            noise: 0,
            width: 0,
            height: 0
        };

        // Mask Editor 상태
        const maskEditor = {
            isDrawing: false,
            tool: 'brush',  // 'brush' | 'eraser'
            brushSize: 30,
            imageCanvas: null,
            maskCanvas: null,
            drawCanvas: null,
            imageCtx: null,
            maskCtx: null,
            drawCtx: null,
            originalImage: null,
            scale: 1,
            paintedCells: new Set()  // 그리드 셀 추적 (8x8 그리드 브러시용)
        };

        // Mask Editor 열기
        function openMaskEditor(imageBase64, existingMask = null) {
            const modal = document.getElementById('maskEditorModal');
            const img = new Image();

            img.onload = () => {
                maskEditor.originalImage = img;

                // 원본 크기로 캔버스 설정 (축소/업스케일 없음)
                // 디스플레이는 CSS로 조정
                const maxWidth = window.innerWidth * 0.9;
                const maxHeight = window.innerHeight * 0.65;
                let displayScale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
                maskEditor.scale = displayScale;

                // 캔버스 실제 크기 = 원본 이미지 크기
                const canvasWidth = img.width;
                const canvasHeight = img.height;

                // 디스플레이 크기 (CSS)
                const displayWidth = Math.round(img.width * displayScale);
                const displayHeight = Math.round(img.height * displayScale);

                // 캔버스 초기화
                maskEditor.imageCanvas = document.getElementById('maskEditorImageCanvas');
                maskEditor.maskCanvas = document.getElementById('maskEditorMaskCanvas');
                maskEditor.drawCanvas = document.getElementById('maskEditorDrawCanvas');

                [maskEditor.imageCanvas, maskEditor.maskCanvas, maskEditor.drawCanvas].forEach(c => {
                    c.width = canvasWidth;      // 실제 해상도 = 원본
                    c.height = canvasHeight;
                    c.style.width = displayWidth + 'px';   // 디스플레이만 축소
                    c.style.height = displayHeight + 'px';
                });

                maskEditor.imageCtx = maskEditor.imageCanvas.getContext('2d');
                maskEditor.maskCtx = maskEditor.maskCanvas.getContext('2d');
                maskEditor.drawCtx = maskEditor.drawCanvas.getContext('2d');

                // 이미지 그리기 (원본 크기)
                maskEditor.imageCtx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

                // paintedCells 초기화
                maskEditor.paintedCells.clear();

                // 기존 마스크 로드 또는 클리어 (검정 배경)
                maskEditor.maskCtx.fillStyle = 'black';
                maskEditor.maskCtx.fillRect(0, 0, canvasWidth, canvasHeight);
                if (existingMask) {
                    const maskImg = new Image();
                    maskImg.onload = () => {
                        maskEditor.maskCtx.drawImage(maskImg, 0, 0, canvasWidth, canvasHeight);
                        // 기존 마스크에서 paintedCells 복원 (흰색 영역 스캔)
                        syncPaintedCellsFromMask(canvasWidth, canvasHeight);
                    };
                    maskImg.src = existingMask;
                }

                // 설정 복원 (인페인트 모드 고정)
                document.getElementById('maskEditorStrength').value = baseImageData.strength;
                document.getElementById('maskEditorStrengthValue').textContent = baseImageData.strength;

                modal.classList.add('active');
            };

            img.src = imageBase64.startsWith('data:') ? imageBase64 : 'data:image/png;base64,' + imageBase64;
        }

        // 기존 마스크에서 paintedCells 동기화 (8x8 그리드 기반)
        function syncPaintedCellsFromMask(canvasWidth, canvasHeight) {
            const GRID_SIZE = 8;
            const imageData = maskEditor.maskCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            const data = imageData.data;

            const gridCols = Math.floor(canvasWidth / GRID_SIZE);
            const gridRows = Math.floor(canvasHeight / GRID_SIZE);

            for (let gy = 0; gy < gridRows; gy++) {
                for (let gx = 0; gx < gridCols; gx++) {
                    // 그리드 셀의 중앙 픽셀 확인
                    const centerX = gx * GRID_SIZE + Math.floor(GRID_SIZE / 2);
                    const centerY = gy * GRID_SIZE + Math.floor(GRID_SIZE / 2);
                    const idx = (centerY * canvasWidth + centerX) * 4;

                    // 흰색(또는 밝은 색)이면 paintedCells에 추가
                    if (data[idx] > 128) {  // R 채널로 판단
                        maskEditor.paintedCells.add(`${gx},${gy}`);
                    }
                }
            }
        }

        // Mask Editor 닫기
        function closeMaskEditor() {
            document.getElementById('maskEditorModal').classList.remove('active');
        }

        // 마스크 그리기 이벤트
        function setupMaskEditorEvents() {
            const drawCanvas = document.getElementById('maskEditorDrawCanvas');

            // NAIS2/NAI 웹 방식: 8x8 그리드 기반 브러시
            const GRID_SIZE = 8;
            let lastGridPos = null;  // 마지막 그리드 위치 (선 그리기용)
            // paintedCells 초기화는 openMaskEditor에서 수행

            function getPos(e) {
                const rect = drawCanvas.getBoundingClientRect();
                const displayX = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
                const displayY = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
                // CSS 스케일링 보정: 디스플레이 좌표 → 캔버스 좌표
                const x = displayX * (drawCanvas.width / rect.width);
                const y = displayY * (drawCanvas.height / rect.height);
                return { x, y };
            }

            // 픽셀 좌표를 그리드 좌표로 변환
            function pixelToGrid(pixelX, pixelY) {
                const gx = Math.floor(pixelX / GRID_SIZE);
                const gy = Math.floor(pixelY / GRID_SIZE);
                const maxGx = Math.floor(maskEditor.maskCanvas.width / GRID_SIZE) - 1;
                const maxGy = Math.floor(maskEditor.maskCanvas.height / GRID_SIZE) - 1;
                return {
                    gx: Math.max(0, Math.min(gx, maxGx)),
                    gy: Math.max(0, Math.min(gy, maxGy))
                };
            }

            // 그리드 셀 채우기
            function fillGridCell(ctx, gx, gy, erase) {
                const cellKey = `${gx},${gy}`;

                if (erase) {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(gx * GRID_SIZE, gy * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    maskEditor.paintedCells.delete(cellKey);
                } else {
                    if (maskEditor.paintedCells.has(cellKey)) return;  // 이미 칠한 셀은 스킵
                    ctx.fillStyle = 'white';
                    ctx.fillRect(gx * GRID_SIZE, gy * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    maskEditor.paintedCells.add(cellKey);
                }
            }

            // 브러시 영역 채우기 (브러시 크기에 따라 여러 셀)
            function fillBrushArea(ctx, gx, gy, erase) {
                const brushGridSize = Math.max(1, Math.floor(maskEditor.brushSize / GRID_SIZE));
                const halfBrush = Math.floor(brushGridSize / 2);

                for (let offsetY = -halfBrush; offsetY <= halfBrush; offsetY++) {
                    for (let offsetX = -halfBrush; offsetX <= halfBrush; offsetX++) {
                        const targetGx = gx + offsetX;
                        const targetGy = gy + offsetY;
                        const maxGx = Math.floor(maskEditor.maskCanvas.width / GRID_SIZE) - 1;
                        const maxGy = Math.floor(maskEditor.maskCanvas.height / GRID_SIZE) - 1;

                        if (targetGx >= 0 && targetGx <= maxGx && targetGy >= 0 && targetGy <= maxGy) {
                            fillGridCell(ctx, targetGx, targetGy, erase);
                        }
                    }
                }
            }

            // Bresenham 선 알고리즘 (그리드 셀 간 부드러운 연결)
            function drawGridLine(ctx, startGx, startGy, endGx, endGy, erase) {
                const dx = Math.abs(endGx - startGx);
                const dy = Math.abs(endGy - startGy);
                const sx = startGx < endGx ? 1 : -1;
                const sy = startGy < endGy ? 1 : -1;
                let err = dx - dy;

                let gx = startGx;
                let gy = startGy;

                while (true) {
                    fillBrushArea(ctx, gx, gy, erase);

                    if (gx === endGx && gy === endGy) break;

                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        gx += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        gy += sy;
                    }
                }
            }

            function draw(e) {
                if (!maskEditor.isDrawing) return;
                const pos = getPos(e);
                const ctx = maskEditor.maskCtx;
                const erase = maskEditor.tool !== 'brush';

                const gridPos = pixelToGrid(pos.x, pos.y);

                if (lastGridPos) {
                    // 이전 위치에서 현재 위치까지 선 그리기
                    drawGridLine(ctx, lastGridPos.gx, lastGridPos.gy, gridPos.gx, gridPos.gy, erase);
                } else {
                    // 첫 클릭
                    fillBrushArea(ctx, gridPos.gx, gridPos.gy, erase);
                }

                lastGridPos = gridPos;
            }

            // 브러시 커서 미리보기 (그리드 정렬, 실제 칠해지는 영역과 동일)
            function drawCursor(e) {
                const pos = getPos(e);
                const ctx = maskEditor.drawCtx;
                const gridPos = pixelToGrid(pos.x, pos.y);
                const brushGridSize = Math.max(1, Math.floor(maskEditor.brushSize / GRID_SIZE));
                const halfBrush = Math.floor(brushGridSize / 2);

                // 이전 커서 지우기
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

                // 실제 칠해지는 영역: -halfBrush ~ +halfBrush (총 halfBrush*2+1 셀)
                const cellCount = halfBrush * 2 + 1;
                const startX = (gridPos.gx - halfBrush) * GRID_SIZE;
                const startY = (gridPos.gy - halfBrush) * GRID_SIZE;
                const size = cellCount * GRID_SIZE;

                ctx.strokeStyle = maskEditor.tool === 'brush' ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(startX, startY, size, size);

                // 내부 점선 테두리 (대비용)
                ctx.strokeStyle = maskEditor.tool === 'brush' ? 'rgba(0, 0, 0, 0.5)' : 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.strokeRect(startX + 1, startY + 1, size - 2, size - 2);
                ctx.setLineDash([]);
            }

            function clearCursor() {
                maskEditor.drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            }

            drawCanvas.addEventListener('mousedown', (e) => {
                maskEditor.isDrawing = true;
                lastGridPos = null;  // 새 스트로크 시작
                draw(e);
            });
            drawCanvas.addEventListener('mousemove', (e) => {
                draw(e);
                drawCursor(e);
            });
            drawCanvas.addEventListener('mouseup', () => {
                maskEditor.isDrawing = false;
                lastGridPos = null;
            });
            drawCanvas.addEventListener('mouseleave', () => {
                maskEditor.isDrawing = false;
                lastGridPos = null;
                clearCursor();
            });

            // Touch support
            drawCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                maskEditor.isDrawing = true;
                lastGridPos = null;
                draw(e);
            });
            drawCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                draw(e);
            });
            drawCanvas.addEventListener('touchend', () => {
                maskEditor.isDrawing = false;
                lastGridPos = null;
            });

            // 도구 버튼
            document.getElementById('maskToolBrush').onclick = () => {
                maskEditor.tool = 'brush';
                document.getElementById('maskToolBrush').classList.add('active');
                document.getElementById('maskToolEraser').classList.remove('active');
            };
            document.getElementById('maskToolEraser').onclick = () => {
                maskEditor.tool = 'eraser';
                document.getElementById('maskToolEraser').classList.add('active');
                document.getElementById('maskToolBrush').classList.remove('active');
            };

            // 브러시 크기
            document.getElementById('maskBrushSize').oninput = function() {
                maskEditor.brushSize = parseInt(this.value);
                document.getElementById('maskBrushSizeValue').textContent = this.value;
            };

            // Clear (검정으로 채우기 = 마스크 없음)
            document.getElementById('maskToolClear').onclick = () => {
                maskEditor.maskCtx.fillStyle = 'black';
                maskEditor.maskCtx.fillRect(0, 0, maskEditor.maskCanvas.width, maskEditor.maskCanvas.height);
                maskEditor.paintedCells.clear();  // 그리드 셀 추적도 초기화
            };

            // Invert (검정 ↔ 흰색 반전)
            document.getElementById('maskToolInvert').onclick = () => {
                const ctx = maskEditor.maskCtx;
                const imageData = ctx.getImageData(0, 0, maskEditor.maskCanvas.width, maskEditor.maskCanvas.height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];       // R
                    data[i + 1] = 255 - data[i + 1]; // G
                    data[i + 2] = 255 - data[i + 2]; // B
                    data[i + 3] = 255;             // A (항상 불투명)
                }
                ctx.putImageData(imageData, 0, 0);
            };

            // Strength slider
            document.getElementById('maskEditorStrength').oninput = function() {
                document.getElementById('maskEditorStrengthValue').textContent = this.value;
            };

            // Cancel
            document.getElementById('maskEditorCancel').onclick = closeMaskEditor;
            document.getElementById('maskEditorClose').onclick = closeMaskEditor;

            // Apply
            document.getElementById('maskEditorApply').onclick = () => {
                // 캔버스가 이미 원본 해상도이므로 직접 사용 (업스케일 불필요)
                // NAI는 순수 흑백 마스크만 지원 - 회색 픽셀이 생기면 경계선 아티팩트 발생

                // 원본 크기 이미지
                const fullImageCanvas = document.createElement('canvas');
                fullImageCanvas.width = maskEditor.originalImage.width;
                fullImageCanvas.height = maskEditor.originalImage.height;
                fullImageCanvas.getContext('2d').drawImage(maskEditor.originalImage, 0, 0);

                // Base Image 데이터 설정
                baseImageData.enabled = true;
                baseImageData.image = fullImageCanvas.toDataURL('image/png').split(',')[1];
                baseImageData.mask = maskEditor.maskCanvas.toDataURL('image/png').split(',')[1];  // 이미 원본 크기
                baseImageData.mode = 'inpaint';  // 마스크 에디터는 항상 인페인트
                baseImageData.strength = parseFloat(document.getElementById('maskEditorStrength').value);
                baseImageData.noise = 0;  // 인페인트는 noise 미사용
                baseImageData.width = maskEditor.originalImage.width;
                baseImageData.height = maskEditor.originalImage.height;

                // UI 업데이트
                updateBaseImageUI();
                closeMaskEditor();
                showToast('베이스 이미지로 등록됨', 'success');
            };
        }

        // Base Image UI 업데이트
        function updateBaseImageUI() {
            const dropZone = document.getElementById('baseImageDropZone');
            const settings = document.getElementById('baseImageSettings');
            const clearBtn = document.getElementById('clearBaseImage');
            const preview = document.getElementById('baseImageImg');
            const maskOverlay = document.getElementById('baseImageMaskOverlay');
            const editMaskBtn = document.getElementById('editMaskBtn');

            if (baseImageData.enabled && baseImageData.image) {
                // 이미지가 있을 때: 드롭존 숨기고 설정 표시
                dropZone.style.display = 'none';
                settings.style.display = 'block';
                clearBtn.style.display = 'block';
                preview.src = 'data:image/png;base64,' + baseImageData.image;

                if (baseImageData.mask) {
                    maskOverlay.style.backgroundImage = `url(data:image/png;base64,${baseImageData.mask})`;
                    maskOverlay.style.backgroundSize = 'contain';
                    maskOverlay.style.backgroundPosition = 'center';
                    maskOverlay.style.backgroundRepeat = 'no-repeat';
                } else {
                    maskOverlay.style.backgroundImage = 'none';
                }

                document.getElementById('baseImageMode').value = baseImageData.mode;
                document.getElementById('baseImageStrength').value = baseImageData.strength;
                document.getElementById('baseImageStrengthValue').textContent = baseImageData.strength;
                document.getElementById('baseImageNoise').value = baseImageData.noise;
                document.getElementById('baseImageNoiseValue').textContent = baseImageData.noise;
                updateBaseImageNoiseVisibility();

                // 마스크 수정 버튼: inpaint 모드일 때만 표시
                editMaskBtn.style.display = baseImageData.mode === 'inpaint' ? 'block' : 'none';

                // 사이즈 동기화
                document.getElementById('width').value = baseImageData.width;
                document.getElementById('height').value = baseImageData.height;
            } else {
                // 이미지가 없을 때: 드롭존 표시
                dropZone.style.display = 'block';
                settings.style.display = 'none';
                clearBtn.style.display = 'none';
            }

            // 비용 업데이트
            updateAnlasCost();
        }

        // Base Image 섹션 이벤트
        function setupBaseImageEvents() {
            const selectBtn = document.getElementById('baseImageSelectBtn');
            const fileInput = document.getElementById('baseImageFileInput');

            // 버튼 클릭 → 파일 선택
            selectBtn.onclick = () => fileInput.click();

            // 파일 선택 처리
            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadBaseImageFromFile(file);
                }
                fileInput.value = '';  // 리셋
            };

            // Clear 버튼
            document.getElementById('clearBaseImage').onclick = () => {
                baseImageData = {
                    enabled: false,
                    image: null,
                    mask: null,
                    mode: 'img2img',
                    strength: 0.7,
                    noise: 0,
                    width: 0,
                    height: 0
                };
                updateBaseImageUI();
                showToast('Base Image 제거됨', 'success');
            };

            // Edit Mask 버튼
            document.getElementById('editMaskBtn').onclick = () => {
                if (baseImageData.image) {
                    openMaskEditor('data:image/png;base64,' + baseImageData.image,
                        baseImageData.mask ? 'data:image/png;base64,' + baseImageData.mask : null);
                }
            };

            // Sliders
            document.getElementById('baseImageStrength').oninput = function() {
                baseImageData.strength = parseFloat(this.value);
                document.getElementById('baseImageStrengthValue').textContent = this.value;
            };
            document.getElementById('baseImageNoise').oninput = function() {
                baseImageData.noise = parseFloat(this.value);
                document.getElementById('baseImageNoiseValue').textContent = this.value;
            };
            document.getElementById('baseImageMode').onchange = function() {
                baseImageData.mode = this.value;
                updateBaseImageNoiseVisibility();
                // 마스크 수정 버튼 표시 업데이트
                document.getElementById('editMaskBtn').style.display = this.value === 'inpaint' ? 'block' : 'none';
                // 비용 업데이트
                updateAnlasCost();
            };

            // Strength/Noise 변경 시에도 비용 업데이트 (input + change 모두)
            ['input', 'change'].forEach(evt => {
                document.getElementById('baseImageStrength').addEventListener(evt, updateAnlasCost);
                document.getElementById('baseImageNoise').addEventListener(evt, updateAnlasCost);
            });
        }

        // Base Image 파일 로드
        function loadBaseImageFromFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Canvas로 PNG 변환
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const base64 = canvas.toDataURL('image/png').split(',')[1];

                    baseImageData = {
                        enabled: true,
                        image: base64,
                        mask: null,
                        mode: 'img2img',  // 드롭으로 등록 시 기본 img2img
                        strength: 0.7,
                        noise: 0,
                        width: img.width,
                        height: img.height
                    };
                    updateBaseImageUI();
                    showToast('Base Image 등록됨', 'success');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Noise 슬라이더 가시성 및 라벨 업데이트
        // - 인페인트: Noise 숨김
        // - 로컬 엔진: Noise 숨김, Strength → Denoise
        function updateBaseImageNoiseVisibility() {
            const noiseContainer = document.getElementById('baseImageNoiseContainer');
            const strengthLabel = document.getElementById('baseImageStrengthLabel');
            const mode = document.getElementById('baseImageMode').value;

            // 로컬 엔진이거나 인페인트 모드면 Noise 숨김
            const hideNoise = currentProvider === 'local' || mode === 'inpaint';
            noiseContainer.style.display = hideNoise ? 'none' : 'block';

            // 로컬 엔진: Strength → Denoise 라벨 변경
            if (strengthLabel) {
                strengthLabel.textContent = currentProvider === 'local' ? 'Denoise' : 'Strength';
            }
        }

        // Inpaint용 이미지 설정 함수 (외부에서 호출)
        function setBaseImageForInpaint(imageBase64) {
            // 슬롯 모드로 전환 (생성은 슬롯 모드에서만 가능)
            if (currentMode !== 'slot') {
                document.getElementById('slotModeBtn').click();
            }
            openMaskEditor(imageBase64);
        }

        // Enhance용 이미지 설정 함수 (NAI 전용)
        function setBaseImageForEnhance(imageBase64, metadata = null) {
            // 슬롯 모드로 전환
            if (currentMode !== 'slot') {
                document.getElementById('slotModeBtn').click();
            }

            const img = new Image();
            img.onload = () => {
                // data:image/png;base64, 접두사 제거
                const base64 = imageBase64.includes(',') ? imageBase64.split(',')[1] : imageBase64;

                // NAI Enhance 기본값: Magnitude 3 (strength 0.5, noise 0)
                baseImageData = {
                    enabled: true,
                    image: base64,
                    mask: null,
                    mode: 'img2img',
                    strength: 0.5,
                    noise: 0,
                    width: img.width,
                    height: img.height
                };

                // 메타데이터가 있으면 프롬프트 등 복원
                if (metadata) {
                    const normalized = normalizeMetadata(metadata);
                    if (normalized.prompt) {
                        document.getElementById('prompt').value = normalized.prompt;
                    }
                    if (normalized.negative_prompt) {
                        document.getElementById('negativePrompt').value = normalized.negative_prompt;
                    }
                }

                updateBaseImageUI();
                showToast('Enhance 모드: Base Image 등록됨', 'success');
            };
            img.src = imageBase64.startsWith('data:') ? imageBase64 : 'data:image/png;base64,' + imageBase64;
        }

        // ============================================================
        // Enhance Modal (NAI)
        // ============================================================
        const enhanceState = {
            imageBase64: null,
            metadata: null,
            width: 0,
            height: 0,
            scale: 1,       // 1 또는 1.5
            magnitude: 3    // 1-5
        };

        // Magnitude별 strength/noise 매핑
        const magnitudePresets = {
            1: { strength: 0.2, noise: 0 },
            2: { strength: 0.4, noise: 0 },
            3: { strength: 0.5, noise: 0 },
            4: { strength: 0.6, noise: 0 },
            5: { strength: 0.7, noise: 0.1 }
        };

        function openEnhanceModal(imageBase64, metadata = null) {
            if (currentProvider !== 'nai') {
                showToast('Enhance는 NAI 전용 기능입니다', 'error');
                return;
            }

            const img = new Image();
            img.onload = () => {
                enhanceState.imageBase64 = imageBase64.includes(',') ? imageBase64.split(',')[1] : imageBase64;
                enhanceState.metadata = metadata;
                enhanceState.width = img.width;
                enhanceState.height = img.height;
                enhanceState.scale = 1;
                enhanceState.magnitude = 3;

                // 모달 UI 업데이트
                document.getElementById('enhanceModalImg').src = img.src;
                document.getElementById('enhanceModalMagnitude').textContent = '3';
                const magnitudeSlider = document.getElementById('enhanceModalMagnitudeSlider');
                magnitudeSlider.value = 3;
                updateSliderFill(magnitudeSlider);

                // Large 이미지(1MP 초과)는 1.5x 비활성화 (NAI 제한)
                const megapixels = (img.width * img.height) / 1000000;
                const isLargeImage = megapixels > 1.1;  // Normal 최대 ~1MP, Large는 그 이상

                // Resolution 버튼 초기화
                document.querySelectorAll('.enhance-res-btn').forEach(btn => {
                    const isLargeBtn = btn.dataset.scale === '1.5';
                    btn.classList.toggle('active', btn.dataset.scale === '1');
                    if (isLargeBtn && isLargeImage) {
                        btn.disabled = true;
                        btn.title = '이미 Large 이미지입니다';
                        btn.style.opacity = '0.5';
                    } else {
                        btn.disabled = false;
                        btn.title = '';
                        btn.style.opacity = '1';
                    }
                });

                updateEnhanceResInfo();
                updateEnhanceModalCost();

                document.getElementById('enhanceModal').classList.add('active');
            };
            img.src = imageBase64.startsWith('data:') ? imageBase64 : 'data:image/png;base64,' + imageBase64;
        }

        function closeEnhanceModal() {
            document.getElementById('enhanceModal').classList.remove('active');
            enhanceState.imageBase64 = null;
            enhanceState.metadata = null;
        }

        // NAI Large 해상도 목록 (1.5배용)
        const NAI_LARGE_RESOLUTIONS = [
            [2304, 960], [2112, 1088], [1984, 1152], [1856, 1280], [1728, 1408], [1536, 1536],
            [1408, 1728], [1280, 1856], [1152, 1984], [1088, 2112], [960, 2304]
        ];

        // 가장 가까운 NAI 해상도 찾기
        function findClosestNAIResolution(targetW, targetH) {
            let closest = NAI_LARGE_RESOLUTIONS[0];
            let minDiff = Infinity;
            for (const [w, h] of NAI_LARGE_RESOLUTIONS) {
                const diff = Math.abs(w - targetW) + Math.abs(h - targetH);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = [w, h];
                }
            }
            return closest;
        }

        function getEnhanceTargetSize() {
            if (enhanceState.scale > 1) {
                const targetW = Math.round(enhanceState.width * enhanceState.scale);
                const targetH = Math.round(enhanceState.height * enhanceState.scale);
                return findClosestNAIResolution(targetW, targetH);
            }
            return [enhanceState.width, enhanceState.height];
        }

        function updateEnhanceResInfo() {
            const [w, h] = getEnhanceTargetSize();
            document.getElementById('enhanceResInfo').textContent = `${w} × ${h}`;
        }

        async function updateEnhanceModalCost() {
            // Enhance 비용 계산: sidebar steps 사용, 해상도 * scale, magnitude별 strength
            const [w, h] = getEnhanceTargetSize();
            const steps = parseInt(document.getElementById('steps').value) || 28;
            const preset = magnitudePresets[enhanceState.magnitude];
            const strength = preset.strength;

            try {
                const response = await fetch(`${API_BASE}/api/nai/calculate-cost`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        width: w,
                        height: h,
                        steps: steps,
                        is_opus: isOpusTier,
                        vibe_count: 0,
                        has_char_ref: false,
                        count: 1,
                        strength: strength
                    })
                });
                const data = await response.json();

                if (data.is_free) {
                    document.getElementById('enhanceModalAnlas').textContent = 'Free';
                } else {
                    document.getElementById('enhanceModalAnlas').textContent = data.cost_per_image || data.total_cost || '?';
                }
            } catch (e) {
                // 백엔드 실패 시 로컬 계산 (fallback)
                const pixels = w * h;
                const basePixels = 1024 * 1024;
                let cost = Math.ceil(pixels / basePixels * 20);
                if (steps > 28) {
                    cost = Math.ceil(cost * (steps / 28));
                }
                cost = Math.max(Math.ceil(cost * strength), 2);
                document.getElementById('enhanceModalAnlas').textContent = cost;
            }
        }

        async function executeEnhance() {
            if (!enhanceState.imageBase64) {
                showToast('이미지가 없습니다', 'error');
                return;
            }

            const preset = magnitudePresets[enhanceState.magnitude];

            // 목표 해상도 (1.5x면 NAI 지원 해상도로 스냅)
            const [w, h] = getEnhanceTargetSize();

            // 이미지 준비 (1.5x면 Canvas로 업스케일)
            let imageBase64 = enhanceState.imageBase64;
            if (enhanceState.scale > 1) {
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = 'data:image/png;base64,' + enhanceState.imageBase64;
                });

                const canvas = document.createElement('canvas');
                canvas.width = w;
                canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, w, h);
                imageBase64 = canvas.toDataURL('image/png').split(',')[1];
            }

            // 메타데이터에서 프롬프트 가져오기
            let prompt = '';
            let negativePrompt = '';
            if (enhanceState.metadata) {
                const normalized = normalizeMetadata(enhanceState.metadata);
                prompt = normalized.prompt || '';
                negativePrompt = normalized.negative_prompt || '';
            }

            // 현재 UI에서 가져오기 (메타데이터가 없으면)
            if (!prompt) {
                prompt = document.getElementById('prompt').value || '';
            }
            if (!negativePrompt) {
                negativePrompt = document.getElementById('negativePrompt').value || '';
            }

            const enhanceParams = {
                nai_model: document.getElementById('naiModel').value,
                base_prompt: prompt,
                negative_prompt: negativePrompt,
                width: w,
                height: h,
                steps: parseInt(document.getElementById('steps').value) || 28,
                cfg: parseFloat(document.getElementById('cfg').value) || 5,
                seed: Math.floor(Math.random() * 2147483647),
                sampler: document.getElementById('sampler').value || 'k_euler_ancestral',
                scheduler: document.getElementById('scheduler').value || 'karras',
                base_image: imageBase64,
                base_mode: 'img2img',
                base_strength: preset.strength,
                base_noise: preset.noise,
                // 저장 옵션 추가
                save_format: document.getElementById('saveFormat').value || 'png',
                jpg_quality: parseInt(document.getElementById('jpgQuality')?.value) || 95
            };

            closeEnhanceModal();

            try {
                // 큐 시스템 사용 (기존 생성과 동일)
                const response = await fetch(`${API_BASE}/api/generate/multi`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(enhanceParams)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Enhance 큐 등록 실패');
                }

                showToast('Enhance 큐에 추가됨', 'success');

            } catch (error) {
                console.error('Enhance error:', error);
                showToast('Enhance 실패: ' + error.message, 'error');
            }
        }

        // Enhance 모달 이벤트 설정
        function setupEnhanceModalEvents() {
            // Resolution 버튼 토글
            document.querySelectorAll('.enhance-res-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.enhance-res-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    enhanceState.scale = parseFloat(btn.dataset.scale);
                    updateEnhanceResInfo();
                    updateEnhanceModalCost();
                });
            });

            // Magnitude 슬라이더
            const magnitudeSlider = document.getElementById('enhanceModalMagnitudeSlider');
            magnitudeSlider.addEventListener('input', () => {
                enhanceState.magnitude = parseInt(magnitudeSlider.value);
                document.getElementById('enhanceModalMagnitude').textContent = enhanceState.magnitude;
                updateEnhanceModalCost();
            });

            // 취소 버튼
            document.getElementById('enhanceModalCancel').addEventListener('click', closeEnhanceModal);

            // 확인 버튼
            document.getElementById('enhanceModalConfirm').addEventListener('click', executeEnhance);

            // 모달 배경 클릭시 닫기
            document.getElementById('enhanceModal').addEventListener('click', (e) => {
                if (e.target.id === 'enhanceModal') {
                    closeEnhanceModal();
                }
            });
        }

        setupEnhanceModalEvents();

        // 초기화
        setupMaskEditorEvents();
        setupBaseImageEvents();
        updateBaseImageNoiseVisibility();
        updateProviderLabels();
        enforceNaiLimits();

        // 시작 시 업데이트 자동 확인 (조용하게)
        (async function checkUpdateOnStart() {
            try {
                const res = await fetch(`${API_BASE}/api/check-update`);
                const data = await res.json();
                if (data.has_update) {
                    showToast(`New version v${data.latest_version} available! Check Settings to update.`, 'warning', 8000);
                }
            } catch (e) {
                // 시작 시에는 에러 무시
            }
        })();

        // ============================================================
        // Censor Mode - New Implementation
        // ============================================================
        
        // 검열 모드 상태
        const censorState = {
            currentTab: 'before',  // 'before' | 'processing' | 'after'
            images: [],            // 검열 전 이미지 목록 (드롭된 이미지들)
            censoredImages: [],    // 검열 후 이미지 목록
            // 드롭된 이미지 정보: [{path: '절대경로', filename: '파일명', thumbnail: 'base64', imgObj: Image}]
            droppedMode: true,     // 드롭 모드 활성화 (폴더 스캔 대신 드롭된 이미지 사용)
            currentIndex: 0,
            beforeIndex: 0,        // 검열전 탭 인덱스
            afterIndex: 0,         // 검열후 탭 인덱스 (항상 0으로 리셋)
            beforeTabVisited: true,  // 검열전 탭 방문 여부 (기본값 true - 시작 탭이므로)
            currentImage: null,    // {path, filename, width, height, imgObj(Image객체)}
            originalImageObj: null, // Image 객체 (재렌더링용)
            imageCache: {},        // 하위호환용 (deprecated)
            // LRU 이미지 캐시 (Image 객체 직접 저장)
            imgCache: new Map(),   // Map<cacheKey, {img: Image, width, height, filename}>
            imgCacheMaxSize: 30,   // 최대 캐시 크기
            detections: [],        // [{label, confidence, box: [x1,y1,x2,y2]}]
            editBoxes: [],         // 편집용 박스들 [{box: [x1,y1,x2,y2], method: string}]
            modelClasses: [],      // 현재 모델의 클래스 목록
            labelConf: {},         // 클래스별 confidence
            selectedBoxIndex: -1,
            hoverBoxIndex: -1,     // 마우스 호버 중인 박스 인덱스
            isScanning: false,
            displayScale: 1,
            overlayOffsetX: 0,     // 오버레이 캔버스 좌측 여백 (핸들 조작용)
            overlayOffsetY: 0,     // 오버레이 캔버스 상단 여백 (핸들 조작용)
            // 폴더 상태
            currentUncensoredFolder: '',  // uncensored 하위 폴더
            currentCensoredFolder: '',    // censored 하위 폴더
            // 편집 상태
            currentTool: 'select', // 'select' | 'add' | 'delete'
            isDragging: false,
            isResizing: false,
            isRotating: false,
            isDrawing: false,
            dragStartX: 0,
            dragStartY: 0,
            dragBoxOriginal: null,
            resizeHandle: null,    // 'nw' | 'ne' | 'sw' | 'se' | 'n' | 's' | 'e' | 'w' | null
            resizeAnchor: null,    // {localX, localY, worldX, worldY} 리사이즈 앵커
            rotateCenter: null,    // {x, y} 회전 중심점
            rotateStartAngle: 0,   // 회전 시작 각도
            newBoxStart: null,     // {x, y} 새 박스 시작점
            // 검열중(processing) 모드 상태
            processingMode: false,
            processingResults: {}, // 이미지별 스캔 결과 {path: {detections, editBoxes, originalImage}}
            processingMethod: 'black',
            processingImages: [],  // 검열중인 이미지 경로 목록
            // 편집 모달 상태
            editModalOpen: false,
            editModalImage: null,  // 편집 중인 이미지 정보
            editModalBoxes: [],
            editModalOriginal: null,
            // 검열후 탭 편집 상태
            afterEditDirty: false,  // 편집 변경 여부
            // 휠 네비게이션 상태
            wheelDebounceTimer: null,  // 휠 디바운스 타이머
            wheelRequestId: 0,         // 휠 요청 ID (취소용)
            // 확장/그라데이션 옵션
            expandPixels: 0,           // 박스 확장 픽셀
            feather: 0,                // 그라데이션 테두리 픽셀
            // 초기화 플래그
            eventsInitialized: false  // 이벤트 리스너 초기화 여부
        };
        
        // LRU 캐시 헬퍼 함수
        function censorCacheGet(key) {
            if (censorState.imgCache.has(key)) {
                // LRU: 접근 시 맨 뒤로 이동 (가장 최근 사용)
                const value = censorState.imgCache.get(key);
                censorState.imgCache.delete(key);
                censorState.imgCache.set(key, value);
                return value;
            }
            return null;
        }
        
        function censorCacheSet(key, value) {
            // 이미 있으면 삭제 후 다시 추가 (LRU 순서 갱신)
            if (censorState.imgCache.has(key)) {
                censorState.imgCache.delete(key);
            }
            censorState.imgCache.set(key, value);
            // 최대 크기 초과 시 가장 오래된 항목 제거
            while (censorState.imgCache.size > censorState.imgCacheMaxSize) {
                const oldestKey = censorState.imgCache.keys().next().value;
                censorState.imgCache.delete(oldestKey);
            }
        }
        
        // ========== 드롭존 관련 함수 ==========
        
        // 드롭존 UI 업데이트
        function updateCensorDropzoneUI() {
            const dropzone = document.getElementById('censorDropzone');
            const thumbnailsWrapper = document.getElementById('censorThumbnailsWrapper');
            const clearBtn = document.getElementById('censorClearImagesBtn');
            const previewEmpty = document.getElementById('censorPreviewEmpty');
            const hasImages = censorState.images.length > 0;

            // 썸네일 래퍼는 항상 표시
            thumbnailsWrapper.style.display = 'flex';

            if (censorState.currentTab === 'before') {
                // 검열전 탭: 이미지 없으면 드롭존 표시 (프리뷰 영역 내부)
                dropzone.style.display = hasImages ? 'none' : 'block';
                previewEmpty.style.display = 'none';
                clearBtn.style.display = hasImages ? 'inline-flex' : 'none';
            } else {
                // 검열중/후 탭: 드롭존 숨기고, 이미지 없으면 empty 표시
                dropzone.style.display = 'none';
                clearBtn.style.display = 'none';
                // previewEmpty는 다른 곳에서 관리 (selectProcessingImage, selectAfterImage 등)
            }
        }
        
        // 드롭존 이벤트 설정
        function setupDropzoneEvents() {
            const dropzone = document.getElementById('censorDropzone');
            const fileInput = document.getElementById('censorFileInput');
            const clearBtn = document.getElementById('censorClearImagesBtn');
            const censorContainer = document.getElementById('censorContainer');
            
            if (!dropzone || !fileInput || !censorContainer) {
                console.warn('Dropzone elements not found');
                return;
            }
            
            // 클릭하여 파일 선택 (드롭존 클릭 시)
            dropzone.addEventListener('click', () => {
                fileInput.click();
            });
            
            // 파일 선택 시
            fileInput.addEventListener('change', (e) => {
                if (e.target.files && e.target.files.length > 0) {
                    handleDroppedFiles(Array.from(e.target.files));
                    fileInput.value = ''; // 리셋
                }
            });
            
            // ====== 전체 컨테이너에서 드래그 앤 드롭 (검열 전 탭 + 자동검열 모드일 때만) ======
            
            // 자동검열 모드이고 검열 전 탭인지 확인하는 헬퍼
            function canAcceptDrop() {
                // censorContainer가 보이는지 확인 (자동검열 모드)
                const isVisible = censorContainer.style.display !== 'none';
                // 검열 전 탭인지 확인
                const isBeforeTab = censorState.currentTab === 'before';
                return isVisible && isBeforeTab;
            }
            
            censorContainer.addEventListener('dragenter', (e) => {
                // 드롭 불가 상태면 완전히 무시
                if (!canAcceptDrop()) return;
                
                e.preventDefault();
                censorContainer.classList.add('drag-over');
            });
            
            censorContainer.addEventListener('dragover', (e) => {
                // 드롭 불가 상태면 완전히 무시
                if (!canAcceptDrop()) return;
                
                e.preventDefault();
            });
            
            censorContainer.addEventListener('dragleave', (e) => {
                // 컨테이너 밖으로 나갔는지 확인 (자식 요소로의 이동 무시)
                if (!e.relatedTarget || !censorContainer.contains(e.relatedTarget)) {
                    censorContainer.classList.remove('drag-over');
                }
            });
            
            censorContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // 항상 드롭 UI 제거
                censorContainer.classList.remove('drag-over');
                
                // 드롭 불가 상태면 파일 처리 안 함
                if (!canAcceptDrop()) return;
                
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                if (files.length > 0) {
                    handleDroppedFiles(files);
                }
            });
            
            // 초기화 버튼
            if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                    clearDroppedImages();
                });
            }
        }
        
        // 드롭된 파일 처리
        async function handleDroppedFiles(files) {
            if (!files || files.length === 0) {
                console.warn('No files to process');
                return;
            }
            
            // 파일명 기준 정렬
            files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
            
            const newImages = [];
            let skippedCount = 0;
            
            for (const file of files) {
                try {
                    // base64로 변환 (서버 전송용)
                    const base64Data = await fileToBase64(file);
                    
                    // 썸네일 생성 (미리보기용)
                    const thumbnail = await createThumbnailFromFile(file);
                    
                    // Image 객체 생성
                    const imgObj = await loadImageFromFile(file);
                    
                    // 고유 ID 생성 (파일명 + 타임스탬프)
                    const uniqueId = `dropped_${Date.now()}_${file.name}`;
                    
                    newImages.push({
                        id: uniqueId,                 // 고유 식별자
                        filename: file.name,
                        base64: base64Data,           // base64 데이터 (서버 전송용)
                        thumbnail: thumbnail,         // 썸네일 base64
                        imgObj: imgObj,
                        width: imgObj.naturalWidth,
                        height: imgObj.naturalHeight,
                        isDropped: true               // 드롭된 이미지 표시
                    });
                } catch (err) {
                    console.error('이미지 로드 실패:', file.name, err);
                    skippedCount++;
                }
            }
            
            if (newImages.length === 0) {
                showToast('이미지를 로드할 수 없습니다.', 'error');
                return;
            }
            
            // 기존 이미지에 추가 (파일명 기준 중복 제거) - 실제로 추가된 이미지 추적
            const actuallyAdded = [];
            for (const img of newImages) {
                const exists = censorState.images.some(i => i.filename === img.filename);
                if (!exists) {
                    censorState.images.push(img);
                    actuallyAdded.push(img);
                }
            }
            
            // 추가된 이미지가 없으면 (모두 중복)
            if (actuallyAdded.length === 0) {
                showToast('모든 이미지가 이미 추가되어 있습니다.', 'info');
                return;
            }
            
            // 새로 추가된 첫 번째 이미지 기억
            const firstNewImage = actuallyAdded[0];
            
            // 이름순 재정렬
            censorState.images.sort((a, b) => 
                a.filename.localeCompare(b.filename, undefined, { numeric: true, sensitivity: 'base' })
            );
            
            // 새로 추가된 첫 번째 이미지의 정렬 후 인덱스 찾기
            const firstNewIndex = censorState.images.findIndex(img => img.id === firstNewImage.id);
            
            // UI 업데이트
            updateCensorDropzoneUI();
            renderCensorThumbnails(censorState.images);
            
            // 새로 추가된 첫 번째 이미지 선택
            if (firstNewIndex >= 0) {
                selectCensorImage(firstNewIndex);
            } else if (censorState.images.length > 0) {
                // fallback: 첫 번째 이미지 선택
                selectCensorImage(0);
            }
            
            showToast(`${actuallyAdded.length}개 이미지 추가됨 (총 ${censorState.images.length}개)`, 'success');
        }
        
        // File에서 썸네일 생성
        function createThumbnailFromFile(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const maxSize = 80;
                        let w = img.width, h = img.height;
                        if (w > h) {
                            if (w > maxSize) { h = h * maxSize / w; w = maxSize; }
                        } else {
                            if (h > maxSize) { w = w * maxSize / h; h = maxSize; }
                        }
                        canvas.width = w;
                        canvas.height = h;
                        ctx.drawImage(img, 0, 0, w, h);
                        resolve(canvas.toDataURL('image/jpeg', 0.6));
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // File에서 Image 객체 생성
        function loadImageFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // File을 base64로 변환 (data:image/... 프리픽스 제거)
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // data:image/png;base64,xxxxx 형식에서 base64 부분만 추출
                    const dataUrl = e.target.result;
                    const base64 = dataUrl.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // 드롭된 이미지 초기화
        function clearDroppedImages() {
            // 진행 중인 스캔 즉시 중단
            censorState.wheelRequestId++;
            showCensorScanLoading(false);
            if (scanDebounceTimer) {
                clearTimeout(scanDebounceTimer);
                scanDebounceTimer = null;
            }

            censorState.images = [];
            censorState.currentIndex = -1;
            censorState.currentImage = null;
            censorState.detections = [];
            censorState.editBoxes = [];
            censorState.processingResults = {};

            // UI 업데이트
            updateCensorDropzoneUI();
            renderCensorThumbnails(censorState.images);
            clearCensorPreview();
            document.getElementById('censorImageCounter').textContent = '0 / 0';

            // 안내 문구 숨김
            const previewHint = document.getElementById('censorPreviewHint');
            if (previewHint) previewHint.style.display = 'none';
        }
        
        // 이미지 로드 함수 (FileResponse URL + crossOrigin)
        function loadCensorImageFile(source, path) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Image load failed'));
                // 경로의 각 부분을 개별 인코딩 (슬래시는 유지)
                const encodedPath = path.split('/').map(p => encodeURIComponent(p)).join('/');
                img.src = `${API_BASE}/api/censor/file/${source}/${encodedPath}?t=${Date.now()}`;
            });
        }
        
        // 스캔 로딩 표시
        function showCensorScanLoading(show) {
            const el = document.getElementById('censorScanLoading');
            if (el) el.classList.toggle('active', show);
        }
        
        // 프리페치: 좌우 이미지 백그라운드 로드
        function prefetchCensorImages(currentIndex, count = 3) {
            const images = censorState.currentTab === 'before' 
                ? censorState.images 
                : censorState.censoredImages;
            const source = censorState.currentTab === 'before' ? 'uncensored' : 'censored';
            
            for (let offset = 1; offset <= count; offset++) {
                // 다음 이미지
                const nextIdx = currentIndex + offset;
                if (nextIdx < images.length) {
                    const nextPath = images[nextIdx].path;
                    const nextKey = `${source}:${nextPath}`;
                    if (!censorState.imgCache.has(nextKey)) {
                        loadCensorImageFile(source, nextPath).then(img => {
                            censorCacheSet(nextKey, {
                                img,
                                width: img.naturalWidth,
                                height: img.naturalHeight,
                                filename: images[nextIdx].filename
                            });
                        }).catch(() => {});
                    }
                }
                // 이전 이미지
                const prevIdx = currentIndex - offset;
                if (prevIdx >= 0) {
                    const prevPath = images[prevIdx].path;
                    const prevKey = `${source}:${prevPath}`;
                    if (!censorState.imgCache.has(prevKey)) {
                        loadCensorImageFile(source, prevPath).then(img => {
                            censorCacheSet(prevKey, {
                                img,
                                width: img.naturalWidth,
                                height: img.naturalHeight,
                                filename: images[prevIdx].filename
                            });
                        }).catch(() => {});
                    }
                }
            }
        }
        
        // 캔버스 참조
        const censorPreviewCanvas = document.getElementById('censorPreviewCanvas');
        const censorOverlayCanvas = document.getElementById('censorOverlayCanvas');
        const censorPreviewCtx = censorPreviewCanvas?.getContext('2d');
        const censorOverlayCtx = censorOverlayCanvas?.getContext('2d');
        
        // 현재 탭에 맞는 재렌더링 함수
        function redrawCurrentTab(overlayOnly = false) {
            if (censorState.currentTab === 'processing') {
                redrawProcessingPreview(overlayOnly);
            } else if (censorState.currentTab === 'after') {
                redrawAfterPreview(overlayOnly);
            } else {
                drawEditBoxes();
            }
        }
        
        // 현재 탭의 검열 방식 선택자 ID 반환 (모든 탭에서 공통 censorMethod 사용)
        function getCurrentMethodSelector() {
            return 'censorMethod';
        }
        
        // 편집 가능 탭인지 확인 (processing 또는 after)
        function isEditableTab() {
            return censorState.currentTab === 'processing' || censorState.currentTab === 'after';
        }
        
        // 검열 설정 저장 (localStorage)
        function saveCensorSettings() {
            const settings = {
                currentUncensoredFolder: censorState.currentUncensoredFolder,
                currentCensoredFolder: censorState.currentCensoredFolder,
                censorModel: document.getElementById('censorModel')?.value || '',
                censorMethod: document.getElementById('censorMethod')?.value || 'black',
                labelConf: censorState.labelConf,
                selectedTargets: Array.from(document.querySelectorAll('#censorTargets input[type="checkbox"]:checked'))
                    .map(cb => cb.dataset.class),
                expandPixels: censorState.expandPixels,
                feather: censorState.feather
            };
            localStorage.setItem('censorSettings', JSON.stringify(settings));
        }
        
        // 검열 설정 복원 (localStorage)
        function restoreCensorSettings() {
            try {
                const saved = localStorage.getItem('censorSettings');
                if (!saved) return null;
                return JSON.parse(saved);
            } catch (e) {
                console.error('Failed to restore censor settings:', e);
                return null;
            }
        }
        
        // 검열 모드 초기화
        async function initCensorMode() {
            // 스캔 로딩 숨기기 (다른 모드에서 돌아왔을 때)
            showCensorScanLoading(false);
            
            // 검열전 탭 안내 문구 표시 (이미지가 1개 이상 있을 때만)
            const previewHint = document.getElementById('censorPreviewHint');
            if (previewHint) {
                previewHint.style.display = (censorState.currentTab === 'before' && censorState.images.length > 0) ? 'block' : 'none';
            }
            
            // 네비게이션 UI 표시 (초기 진입 시)
            document.getElementById('censorNavLeft').style.display = 'flex';
            document.getElementById('censorNavRight').style.display = 'flex';
            document.getElementById('censorImageCounter').style.display = 'block';
            
            
            // 이미 초기화되어 있으면 현재 이미지만 다시 표시하고 스킵
            if (censorState.eventsInitialized &&
                (censorState.images.length > 0 || censorState.censoredImages.length > 0)) {
                // 현재 이미지가 있으면 다시 그리기
                if (censorState.currentImage) {
                    drawCensorPreview();
                }
                return;
            }

            const savedSettings = restoreCensorSettings();

            // 폴더 상태 복원
            if (savedSettings) {
                censorState.currentUncensoredFolder = savedSettings.currentUncensoredFolder || '';
                censorState.currentCensoredFolder = savedSettings.currentCensoredFolder || '';
                censorState.labelConf = savedSettings.labelConf || {};
            }

            // 모델만 로드 (폴더 로드 제거 - 드롭 모드 사용)
            await loadCensorModels(savedSettings);

            // 드롭존 UI 초기화 (검열 전 탭용)
            updateCensorDropzoneUI();

            // 썸네일 리스트 초기화 (이미지가 없으면 "이미지가 없습니다" 표시)
            renderCensorThumbnails(censorState.images);

            // 이벤트는 최초 1회만 등록
            if (!censorState.eventsInitialized) {
                setupCensorEvents();
                censorState.eventsInitialized = true;
            }
        }
        
        // 모델 목록 로드
        async function loadCensorModels(savedSettings = null) {
            const modelSelect = document.getElementById('censorModel');
            const methodSelect = document.getElementById('censorMethod');
            
            try {
                const response = await fetch(`${API_BASE}/api/censor/models`);
                const result = await response.json();
                
                if (result.models && result.models.length > 0) {
                    // 저장된 모델 또는 기본 모델 선택
                    const defaultModel = 'ntd11_anime_nsfw_segm_v5-variant1.pt';
                    let selectedModel;
                    if (savedSettings?.censorModel && result.models.includes(savedSettings.censorModel)) {
                        selectedModel = savedSettings.censorModel;
                    } else if (result.models.includes(defaultModel)) {
                        selectedModel = defaultModel;
                    } else {
                        selectedModel = result.models[0];
                    }
                    
                    modelSelect.innerHTML = result.models.map(m => 
                        `<option value="${m}" ${m === selectedModel ? 'selected' : ''}>${m}</option>`
                    ).join('');
                    
                    // 저장된 검열 방식 복원
                    if (savedSettings?.censorMethod && methodSelect) {
                        methodSelect.value = savedSettings.censorMethod;
                    }

                    // 저장된 확장/부드럽게 값 복원
                    if (savedSettings?.expandPixels !== undefined) {
                        censorState.expandPixels = savedSettings.expandPixels;
                        const expandEl = document.getElementById('censorExpandPixels');
                        expandEl.value = savedSettings.expandPixels;
                        document.getElementById('censorExpandValue').textContent = savedSettings.expandPixels;
                        updateSliderFill(expandEl);
                    }
                    if (savedSettings?.feather !== undefined) {
                        censorState.feather = savedSettings.feather;
                        const featherEl = document.getElementById('censorFeather');
                        featherEl.value = savedSettings.feather;
                        document.getElementById('censorFeatherValue').textContent = savedSettings.feather;
                        updateSliderFill(featherEl);
                    }

                    // 선택된 모델의 클래스 로드
                    await loadModelClasses(selectedModel, savedSettings);
                } else {
                    modelSelect.innerHTML = '<option value="">모델 없음</option>';
                }
            } catch (err) {
                console.error('Failed to load censor models:', err);
                modelSelect.innerHTML = '<option value="">로드 실패</option>';
            }
        }
        
        // 모델 클래스 로드 및 UI 생성
        async function loadModelClasses(modelName, savedSettings = null) {
            const targetsContainer = document.getElementById('censorTargets');
            try {
                const response = await fetch(`${API_BASE}/api/censor/model-info?model=${encodeURIComponent(modelName)}`);
                const result = await response.json();
                
                if (result.success && result.classes) {
                    censorState.modelClasses = result.classes;
                    // 기본 confidence 설정
                    result.classes.forEach(cls => {
                        if (!(cls in censorState.labelConf)) {
                            censorState.labelConf[cls] = 0.3;  // 기본값
                        }
                    });
                    renderCensorTargets(savedSettings?.selectedTargets);
                } else {
                    console.error('Model info failed:', result.error);
                    targetsContainer.innerHTML = `<div class="censor-target-loading">클래스 로드 실패: ${result.error || '알 수 없는 오류'}</div>`;
                }
            } catch (err) {
                console.error('Failed to load model classes:', err);
                targetsContainer.innerHTML = `<div class="censor-target-loading">클래스 로드 실패: ${err.message}</div>`;
            }
        }

        // 검열 대상 UI 렌더링
        function renderCensorTargets(selectedTargets = null) {
            const container = document.getElementById('censorTargets');
            if (censorState.modelClasses.length === 0) {
                container.innerHTML = '<div class="censor-target-loading">모델을 선택하면 감지 대상이 표시됩니다</div>';
                return;
            }
            
            container.innerHTML = censorState.modelClasses.map(cls => {
                const conf = censorState.labelConf[cls] || 0.3;
                // 저장된 선택 상태 복원 (없거나 빈 배열이면 기본 체크)
                const isChecked = (selectedTargets && selectedTargets.length > 0) ? selectedTargets.includes(cls) : true;
                return `
                    <div class="censor-target-item">
                        <input type="checkbox" id="censor-target-${cls}" ${isChecked ? 'checked' : ''} data-class="${cls}">
                        <label for="censor-target-${cls}">${cls}</label>
                        <input type="number" min="0" max="1" step="0.01" value="${conf.toFixed(2)}"
                               data-class="${cls}" class="censor-conf-input">
                    </div>
                `;
            }).join('');

            // 수치 입력 이벤트
            container.querySelectorAll('.censor-conf-input').forEach(input => {
                input.onchange = function() {
                    let val = parseFloat(this.value);
                    // 범위 제한
                    if (isNaN(val)) val = 0.3;
                    if (val < 0) val = 0;
                    if (val > 1) val = 1;
                    this.value = val.toFixed(2);
                    const cls = this.dataset.class;
                    censorState.labelConf[cls] = val;
                    // 실시간 재스캔
                    if (censorState.currentImage) {
                        debouncedScan();
                    }
                    saveCensorSettings();
                };
            });
            
            // 체크박스 이벤트
            container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.onchange = () => {
                    if (censorState.currentImage) {
                        debouncedScan();
                    }
                    saveCensorSettings();
                };
            });
        }
        
        // 디바운스된 스캔
        let scanDebounceTimer = null;
        function debouncedScan() {
            clearTimeout(scanDebounceTimer);
            scanDebounceTimer = setTimeout(() => {
                scanCurrentImage();
            }, 300);
        }
        
        // 폴더 목록 로드
        async function loadCensorFolders() {
            // uncensored 폴더 목록
            await loadCensorSubfolders('uncensored');
            // censored 폴더 목록
            await loadCensorSubfolders('censored');
        }
        
        // 폴더 목록을 드롭다운에 렌더링
        async function loadCensorSubfolders(type) {
            const listId = type === 'uncensored' ? 'censorUncensoredFolderList' : 'censorCensoredFolderList';
            const listEl = document.getElementById(listId);
            if (!listEl) return;
            
            try {
                const response = await fetch(`${API_BASE}/api/censor/folders?type=${type}`);
                const result = await response.json();
                
                renderCensorFolderList(type, result.folders || []);
            } catch (err) {
                console.error(`Failed to load ${type} folders:`, err);
                listEl.innerHTML = '<div class="folder-item">로드 실패</div>';
            }
        }
        
        // 폴더 목록 렌더링 (슬롯모드와 동일한 패턴)
        function renderCensorFolderList(type, folders) {
            const listId = type === 'uncensored' ? 'censorUncensoredFolderList' : 'censorCensoredFolderList';
            const listEl = document.getElementById(listId);
            const currentFolder = type === 'uncensored' ? censorState.currentUncensoredFolder : censorState.currentCensoredFolder;
            
            const rootName = type === 'uncensored' ? 'uncensored' : 'censored';
            const isRootSelected = currentFolder === '';
            
            let html = `
                <div class="folder-item root-folder ${isRootSelected ? 'active' : ''}" data-folder="" data-type="${type}">
                    <span>${isRootSelected ? '📂' : '📁'}</span>
                    <span>${rootName}</span>
                </div>
            `;
            
            folders.forEach(folder => {
                const isSelected = currentFolder === folder.name;
                html += `
                    <div class="folder-item subfolder ${isSelected ? 'active' : ''}" data-folder="${folder.name}" data-type="${type}">
                        <span>${isSelected ? '📂' : '📁'}</span>
                        <span>${folder.name}</span>
                        <span style="margin-left: auto; opacity: 0.6; font-size: 0.75rem;">${folder.image_count}</span>
                    </div>
                `;
            });
            
            listEl.innerHTML = html;
            
            // 폴더 클릭 이벤트
            listEl.querySelectorAll('.folder-item').forEach(item => {
                item.onclick = () => {
                    const folderName = item.dataset.folder;
                    const folderType = item.dataset.type;
                    selectCensorFolder(folderType, folderName);
                };
            });
        }
        
        // 폴더 선택 시 UI 업데이트 및 이미지 로드
        function selectCensorFolder(type, folderName) {
            const nameId = type === 'uncensored' ? 'censorUncensoredFolderName' : 'censorCensoredFolderName';
            const menuId = type === 'uncensored' ? 'censorUncensoredFolderMenu' : 'censorCensoredFolderMenu';
            const dropdownId = type === 'uncensored' ? 'censorFolderBefore' : 'censorFolderAfter';
            
            // 배치 모드 중 폴더 변경 시 초기화
            if (censorState.batchMode) {
                censorState.batchMode = false;
                censorState.batchResults = {};
                document.getElementById('censorRunAllBtn').style.display = 'block';
                document.getElementById('censorSaveBatchBtn').style.display = 'none';
            }
            
            // 상태 업데이트
            if (type === 'uncensored') {
                censorState.currentUncensoredFolder = folderName;
            } else {
                censorState.currentCensoredFolder = folderName;
            }
            
            // 이름 표시 업데이트
            const nameEl = document.getElementById(nameId);
            if (nameEl) {
                nameEl.textContent = folderName || (type === 'uncensored' ? 'uncensored' : 'censored');
            }
            
            // 메뉴 닫기
            const menuEl = document.getElementById(menuId);
            const dropdownEl = document.getElementById(dropdownId);
            if (menuEl) {
                menuEl.classList.remove('show');
                if (menuEl.parentElement === document.body && dropdownEl) {
                    dropdownEl.appendChild(menuEl);
                }
            }
            
            // 현재 탭에 해당하는 폴더면 이미지 새로고침
            if ((type === 'uncensored' && censorState.currentTab === 'before') ||
                (type === 'censored' && censorState.currentTab === 'after')) {
                loadCensorImages();
            }
            
            // 설정 저장
            saveCensorSettings();
        }
        
        // 폴더 드롭다운 토글
        function toggleCensorFolderMenu(type, e) {
            e.stopPropagation();
            
            const menuId = type === 'uncensored' ? 'censorUncensoredFolderMenu' : 'censorCensoredFolderMenu';
            const btnId = type === 'uncensored' ? 'censorUncensoredFolderBtn' : 'censorCensoredFolderBtn';
            const dropdownId = type === 'uncensored' ? 'censorFolderBefore' : 'censorFolderAfter';
            
            const menuEl = document.getElementById(menuId);
            const btnEl = document.getElementById(btnId);
            const dropdownEl = document.getElementById(dropdownId);
            
            if (!menuEl || !btnEl) return;
            
            const isShowing = menuEl.classList.contains('show');
            
            // 다른 메뉴 닫기
            closeCensorFolderMenus();
            
            if (isShowing) {
                menuEl.classList.remove('show');
                if (dropdownEl) dropdownEl.appendChild(menuEl);
            } else {
                document.body.appendChild(menuEl);
                const btnRect = btnEl.getBoundingClientRect();
                menuEl.style.top = (btnRect.bottom + 4) + 'px';
                menuEl.style.right = (window.innerWidth - btnRect.right) + 'px';
                menuEl.style.left = 'auto';
                menuEl.classList.add('show');
                loadCensorSubfolders(type);
            }
        }
        
        // 모든 검열 폴더 메뉴 닫기
        function closeCensorFolderMenus() {
            ['censorUncensoredFolderMenu', 'censorCensoredFolderMenu'].forEach(menuId => {
                const menuEl = document.getElementById(menuId);
                if (menuEl && menuEl.classList.contains('show')) {
                    menuEl.classList.remove('show');
                    const dropdownId = menuId === 'censorUncensoredFolderMenu' ? 'censorFolderBefore' : 'censorFolderAfter';
                    const dropdownEl = document.getElementById(dropdownId);
                    if (menuEl.parentElement === document.body && dropdownEl) {
                        dropdownEl.appendChild(menuEl);
                    }
                }
            });
        }
        
        // 이미지 목록 로드
        async function loadCensorImages() {
            // 현재 탭에 맞는 폴더 선택 (상태값 사용)
            const folder = censorState.currentTab === 'before'
                ? censorState.currentUncensoredFolder
                : censorState.currentCensoredFolder;
            const thumbnailsContainer = document.getElementById('censorThumbnails');

            // 로딩 표시
            thumbnailsContainer.innerHTML = '<div class="censor-loading">⏳ 이미지 로딩중...</div>';

            try {
                const endpoint = censorState.currentTab === 'before'
                    ? `/api/censor/images?folder=${encodeURIComponent(folder)}`
                    : `/api/censor/censored?folder=${encodeURIComponent(folder)}`;

                const response = await fetch(`${API_BASE}${endpoint}`);
                const result = await response.json();

                if (result.success) {
                    // 파일명 순 정렬
                    const images = (result.images || []).sort((a, b) =>
                        a.filename.localeCompare(b.filename, undefined, { numeric: true, sensitivity: 'base' })
                    );

                    // 현재 인덱스 저장 (재로드 시 유지용)
                    const previousIndex = censorState.currentIndex;
                    const previousImagePath = censorState.currentImage?.path;

                    if (censorState.currentTab === 'before') {
                        censorState.images = images;
                    } else {
                        censorState.censoredImages = images;
                    }
                    renderCensorThumbnails(images);

                    // 이전에 보던 이미지가 있으면 그걸 유지, 없으면 첫 번째 선택
                    if (images.length > 0) {
                        let targetIndex = 0;

                        // 이전에 보던 이미지를 찾아서 유지
                        if (previousImagePath) {
                            const foundIndex = images.findIndex(img => img.path === previousImagePath);
                            if (foundIndex >= 0) {
                                targetIndex = foundIndex;
                            } else if (previousIndex < images.length) {
                                targetIndex = previousIndex;
                            }
                        }

                        // 인덱스만 설정하고 UI만 업데이트 (스캔은 하지 않음)
                        censorState.currentIndex = targetIndex;
                        document.querySelectorAll('.censor-thumbnail').forEach((t, i) => {
                            t.classList.toggle('active', i === targetIndex);
                        });
                        document.getElementById('censorImageCounter').textContent = `${targetIndex + 1} / ${images.length}`;

                        // 이전 이미지가 없었던 경우에만 실제로 선택 (스캔 포함)
                        if (!previousImagePath) {
                            selectCensorImage(targetIndex);
                        }
                    } else {
                        clearCensorPreview();
                    }
                }
            } catch (err) {
                console.error('Failed to load censor images:', err);
                thumbnailsContainer.innerHTML = '<div class="censor-loading">로드 실패</div>';
                clearCensorPreview();
            }
        }
        
        // 썸네일 렌더링
        function renderCensorThumbnails(images) {
            const container = document.getElementById('censorThumbnails');
            const isBeforeTab = censorState.currentTab === 'before';

            // 검열전 탭 안내 문구 갱신 (이미지 수에 따라)
            const previewHint = document.getElementById('censorPreviewHint');
            if (previewHint) {
                previewHint.style.display = (isBeforeTab && censorState.images.length > 0) ? 'block' : 'none';
            }

            if (images.length === 0) {
                container.innerHTML = '<div class="censor-loading">이미지가 없습니다</div>';
                return;
            }
            
            // 썸네일 HTML 생성
            const thumbnailsHtml = images.map((img, index) => {
                // 드롭된 이미지는 thumbnail이 이미 dataURL, 서버 이미지는 base64만
                const thumbSrc = img.thumbnail.startsWith('data:') 
                    ? img.thumbnail 
                    : `data:image/jpeg;base64,${img.thumbnail}`;
                // 검열 전 탭에서만 삭제 버튼 표시
                const deleteBtn = isBeforeTab 
                    ? `<button class="thumb-delete-btn" data-index="${index}" title="삭제">×</button>`
                    : '';
                return `
                <div class="censor-thumbnail ${index === censorState.currentIndex ? 'active' : ''}" 
                     data-index="${index}" data-id="${img.id || ''}">
                    ${deleteBtn}
                    <img src="${thumbSrc}" alt="${img.filename}">
                </div>
                `;
            }).join('');
            
            // 검열 전 탭에서만 추가 버튼 표시
            const addBtnHtml = isBeforeTab 
                ? `<div class="censor-add-btn" id="censorAddImageBtn" title="이미지 추가">
                       <span class="add-icon">+</span>
                       <span class="add-text">추가</span>
                   </div>`
                : '';
            
            container.innerHTML = thumbnailsHtml + addBtnHtml;
            
            // 추가 버튼 클릭 이벤트 (검열 전 탭에서만)
            if (isBeforeTab) {
                const addBtn = document.getElementById('censorAddImageBtn');
                if (addBtn) {
                    addBtn.onclick = () => {
                        document.getElementById('censorFileInput').click();
                    };
                }
                
                // 삭제 버튼 클릭 이벤트
                container.querySelectorAll('.thumb-delete-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();  // 썸네일 클릭 이벤트 방지
                        const index = parseInt(btn.dataset.index);
                        removeCensorImage(index);
                    };
                });
            }
            
            // 썸네일 클릭 이벤트
            container.querySelectorAll('.censor-thumbnail').forEach(thumb => {
                thumb.onclick = async (e) => {
                    // 삭제 버튼 클릭은 무시 (이미 처리됨)
                    if (e.target.classList.contains('thumb-delete-btn')) return;
                    
                    const index = parseInt(thumb.dataset.index);
                    
                    // 배치 모드에서는 현재 이미지의 editBoxes를 저장하고 배치 모드용 선택 함수 사용
                    if (censorState.batchMode && censorState.currentTab === 'before') {
                        // 현재 이미지의 editBoxes를 batchResults에 저장
                        if (censorState.currentImage && censorState.batchResults[censorState.currentImage.path]) {
                            censorState.batchResults[censorState.currentImage.path].editBoxes = censorState.editBoxes.map(b => ({...b, box: [...b.box]}));
                        }
                        await selectCensorImageForBatch(index);
                    } else {
                        selectCensorImage(index);
                    }
                };
            });
        }
        
        // 개별 이미지 삭제 (검열 전 탭에서만)
        function removeCensorImage(index) {
            if (censorState.currentTab !== 'before') return;
            if (index < 0 || index >= censorState.images.length) return;

            // 진행 중인 스캔 즉시 중단
            censorState.wheelRequestId++;
            showCensorScanLoading(false);
            if (scanDebounceTimer) {
                clearTimeout(scanDebounceTimer);
                scanDebounceTimer = null;
            }

            // 이미지 배열에서 삭제
            const removedImage = censorState.images.splice(index, 1)[0];

            // 현재 인덱스 조정
            if (censorState.images.length === 0) {
                // 모든 이미지가 삭제됨
                censorState.currentIndex = -1;
                censorState.currentImage = null;
                censorState.detections = [];
                censorState.editBoxes = [];
                clearCensorPreview();
                document.getElementById('censorImageCounter').textContent = '0 / 0';
                // 안내 문구 숨김
                const previewHint = document.getElementById('censorPreviewHint');
                if (previewHint) previewHint.style.display = 'none';
            } else {
                // 삭제 후 인덱스 조정
                if (censorState.currentIndex >= censorState.images.length) {
                    censorState.currentIndex = censorState.images.length - 1;
                } else if (censorState.currentIndex > index) {
                    censorState.currentIndex--;
                }
                
                // 현재 선택된 이미지가 삭제된 경우 다른 이미지 선택
                if (censorState.currentImage?.id === removedImage.id) {
                    selectCensorImage(censorState.currentIndex);
                }
            }
            
            // UI 업데이트
            updateCensorDropzoneUI();
            renderCensorThumbnails(censorState.images);
            
            showToast(`검열 대상에서 제외됨 (남은 ${censorState.images.length}개)`, 'info');
        }
        
        // 이미지 선택 (skipScan: 휠 네비게이션에서 스캔 스킵용)
        async function selectCensorImage(index, { skipScan = false } = {}) {
            const requestId = ++censorState.wheelRequestId;  // 요청 ID 증가

            // API 프리뷰 캐시 무효화 및 진행 중인 요청 취소
            cachedApiPreviewImage = null;
            cachedApiPreviewKey = null;
            censorPreviewRequestId++;  // 진행 중인 API 요청 무효화
            if (censorPreviewDebounceTimer) {
                clearTimeout(censorPreviewDebounceTimer);
                censorPreviewDebounceTimer = null;
            }

            const images = censorState.currentTab === 'before'
                ? censorState.images
                : censorState.censoredImages;

            if (index < 0 || index >= images.length) return;

            censorState.currentIndex = index;

            // 현재 탭의 인덱스도 저장
            if (censorState.currentTab === 'before') {
                censorState.beforeIndex = index;
            } else if (censorState.currentTab === 'after') {
                censorState.afterIndex = index;
            }
            const imgInfo = images[index];
            
            // 편집 상태 초기화
            censorState.editBoxes = [];
            censorState.selectedBoxIndex = -1;
            censorState.hoverBoxIndex = -1;
            censorState.detections = [];
            
            // 오버레이 클리어 (깜빡임 방지)
            if (censorOverlayCtx) {
                censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);
            }
            
            // 검열후 탭일 경우 편집 상태 초기화
            if (censorState.currentTab === 'after') {
                censorState.afterEditDirty = false;
                const saveBtn = document.getElementById('censorAfterSaveBtn');
                if (saveBtn) saveBtn.disabled = true;
            }
            
            // 썸네일 활성화 표시 및 자동 스크롤
            const thumbnails = document.querySelectorAll('.censor-thumbnail');
            thumbnails.forEach((t, i) => {
                t.classList.toggle('active', i === index);
            });
            // 선택된 썸네일이 보이도록 자동 스크롤
            if (thumbnails[index]) {
                thumbnails[index].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            }

            // 이미지 번호 표시
            document.getElementById('censorImageCounter').textContent = `${index + 1} / ${images.length}`;

            // 화살표 버튼 활성화/비활성화
            const leftBtn = document.getElementById('censorNavLeft');
            const rightBtn = document.getElementById('censorNavRight');
            leftBtn.disabled = index === 0;
            rightBtn.disabled = index === images.length - 1;
            
            // 검열전 탭 + 스캔 예정이면 로딩 표시
            if (censorState.currentTab === 'before' && !skipScan) {
                showCensorScanLoading(true);
            }
            
            // 이미지 로드 (드롭된 이미지면 imgObj 직접 사용, 아니면 서버에서 로드)
            try {
                let imgObj, width, height;
                
                // 검열 전 탭 + 드롭된 이미지면 이미 imgObj가 있음
                if (censorState.currentTab === 'before' && imgInfo.imgObj) {
                    imgObj = imgInfo.imgObj;
                    width = imgInfo.width;
                    height = imgInfo.height;
                } else {
                    // 기존 로직: 서버에서 로드 (검열 후 탭 등)
                    const source = censorState.currentTab === 'before' ? 'uncensored' : 'censored';
                    const cacheKey = `${source}:${imgInfo.path}`;
                    let cached = censorCacheGet(cacheKey);

                    // 캐시에 없으면 FileResponse로 로드
                    if (!cached) {
                        const img = await loadCensorImageFile(source, imgInfo.path);
                        // 로드 중 다른 이미지로 넘어갔으면 무시
                        if (requestId !== censorState.wheelRequestId) return;
                        
                        cached = {
                            img,
                            width: img.naturalWidth,
                            height: img.naturalHeight,
                            filename: imgInfo.filename
                        };
                        censorCacheSet(cacheKey, cached);
                    }
                    
                    imgObj = cached.img;
                    width = cached.width;
                    height = cached.height;
                }

                // 다른 이미지로 넘어갔으면 무시
                if (requestId !== censorState.wheelRequestId) return;

                // currentImage 설정 (Image 객체 직접 저장)
                censorState.currentImage = {
                    id: imgInfo.id,               // 드롭된 이미지 고유 ID
                    path: imgInfo.path,
                    filename: imgInfo.filename,
                    width: width,
                    height: height,
                    imgObj: imgObj,               // Image 객체 직접 참조
                    isDropped: imgInfo.isDropped  // 드롭된 이미지 여부
                };
                
                // 프리페치: 좌우 이미지 백그라운드 로드
                prefetchCensorImages(index);
                
                // 이미지 먼저 표시
                drawCensorPreview();

                // 검열 전 탭이면 스캔 실행 (skipScan이 아닐 때만)
                if (censorState.currentTab === 'before' && !skipScan) {
                    await scanCurrentImage();
                    // 스캔 완료 후 다른 이미지로 넘어갔으면 무시
                    if (requestId !== censorState.wheelRequestId) {
                        return;
                    }
                    showCensorScanLoading(false);
                    // 스캔 완료 후 박스와 함께 다시 그리기
                    drawCensorPreview();
                }
            } catch (err) {
                console.error('Failed to load image:', err);
                if (requestId === censorState.wheelRequestId) {
                    showCensorScanLoading(false);
                }
            }
        }
        
        // 프리뷰 그리기
        function drawCensorPreview() {
            if (!censorState.currentImage || !censorPreviewCtx) return;
            
            // 이미 로드된 Image 객체 사용 (캐시에서 가져옴)
            const img = censorState.currentImage.imgObj;
            if (!img) {
                console.error('No image object in currentImage');
                return;
            }
            
            // 원본 이미지 객체 저장 (재렌더링용)
            censorState.originalImageObj = img;
            
            // 캔버스 크기 설정 - 부모 영역(censor-preview-area)에서 크기 가져오기
            const previewArea = document.querySelector('.censor-preview-area');
            const areaW = previewArea.clientWidth;
            const areaH = previewArea.clientHeight;
            const maxW = areaW - 80;  // 네비게이션 화살표 공간
            const maxH = areaH - 80;
            
            let scale = Math.min(maxW / img.width, maxH / img.height, 1);
            const displayW = Math.round(img.width * scale);
            const displayH = Math.round(img.height * scale);
            
            // 이미지 캔버스
            censorPreviewCanvas.width = displayW;
            censorPreviewCanvas.height = displayH;
            censorPreviewCanvas.style.width = displayW + 'px';
            censorPreviewCanvas.style.height = displayH + 'px';
            
            // 오버레이 캔버스는 프리뷰 영역 전체 (CSS에서 100%로 설정됨)
            censorOverlayCanvas.width = areaW;
            censorOverlayCanvas.height = areaH;
            
            // 이미지 캔버스는 영역 중앙에 위치 (flex center)
            // 오버레이 좌표(=영역 좌표) → 이미지 좌표 변환용 오프셋
            const offsetX = (areaW - displayW) / 2;
            const offsetY = (areaH - displayH) / 2;
            censorState.overlayOffsetX = offsetX;
            censorState.overlayOffsetY = offsetY;
            
            // 스케일 저장
            censorState.displayScale = scale;
            
            // 이미지 그리기
            if (censorState.currentTab === 'processing') {
                // 검열중: 원본 + 검열 효과 적용
                drawCensoredImage(img, displayW, displayH);
                // 확장/그라데이션이 있으면 API 프리뷰 요청
                if ((censorState.expandPixels > 0 || censorState.feather > 0) && censorState.editBoxes.length > 0) {
                    requestCensorPreviewUpdate();
                }
            } else if (censorState.currentTab === 'after') {
                // 검열후: 이미 검열된 이미지 + 추가 편집 오버레이
                censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);
                drawAfterTabOverlay(img, displayW, displayH);
                // 확장/그라데이션이 있으면 API 프리뷰 요청
                if ((censorState.expandPixels > 0 || censorState.feather > 0) && censorState.editBoxes.length > 0) {
                    requestCensorPreviewUpdate();
                }
            } else {
                // 검열전: 원본 + 감지 박스 표시
                censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);
                drawDetectionBoxes();
            }
            
            // 빈 상태/드롭존 숨기기
            document.getElementById('censorPreviewEmpty').style.display = 'none';
            document.getElementById('censorDropzone').style.display = 'none';
        }

        // 검열 적용된 이미지 그리기 (검열중 탭용)
        function drawCensoredImage(img, displayW, displayH) {
            if (!img || !censorPreviewCtx) return;

            const scale = censorState.displayScale;
            const method = document.getElementById('censorMethod')?.value || censorState.processingMethod;

            // 스팀 텍스처 프리로드 (캐시에 없는 것만 생성)
            if (method === 'steam' || censorState.editBoxes.some(b => b.method === 'steam')) {
                preloadSteamTextures(censorState.editBoxes, scale);
            }
            
            // 원본 이미지 먼저 그리기
            censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);

            // 박스들에 검열 효과 적용 (검열중 탭에서는 editBoxes만 사용)
            const boxes = censorState.editBoxes;
            
            boxes.forEach((det, index) => {
                const [x1, y1, x2, y2] = det.box;
                const sx = x1 * scale;
                const sy = y1 * scale;
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                const boxMethod = det.method || method;
                const rotation = det.rotation || 0;
                
                if (rotation !== 0) {
                    const cx = sx + sw / 2;
                    const cy = sy + sh / 2;
                    censorPreviewCtx.save();
                    censorPreviewCtx.translate(cx, cy);
                    censorPreviewCtx.rotate(rotation);
                    censorPreviewCtx.translate(-cx, -cy);
                    applyCensorEffect(censorPreviewCtx, sx, sy, sw, sh, boxMethod, img, x1, y1, x2 - x1, y2 - y1);
                    censorPreviewCtx.restore();
                } else {
                    applyCensorEffect(censorPreviewCtx, sx, sy, sw, sh, boxMethod, img, x1, y1, x2 - x1, y2 - y1);
                }
            });
            
            // 오버레이에 선택된 박스 표시
            drawProcessingOverlay();
        }
        
        // 검열 효과 적용
        function applyCensorEffect(ctx, x, y, w, h, method, originalImg, origX, origY, origW, origH) {
            switch (method) {
                case 'black':
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x, y, w, h);
                    break;
                case 'white':
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(x, y, w, h);
                    break;
                case 'mosaic':
                    applyMosaicEffect(ctx, x, y, w, h, originalImg, origX, origY, origW, origH);
                    break;
                case 'blur':
                    applyBlurEffect(ctx, x, y, w, h);
                    break;
                case 'steam':
                    applySteamEffect(ctx, x, y, w, h, originalImg, origX, origY, origW, origH);
                    break;
                default:
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x, y, w, h);
            }
        }

        // 모자이크 효과
        function applyMosaicEffect(ctx, x, y, w, h, originalImg, origX, origY, origW, origH) {
            const blockSize = Math.max(8, Math.min(w, h) / 8);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = origW;
            tempCanvas.height = origH;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 원본에서 해당 영역 추출
            tempCtx.drawImage(originalImg, origX, origY, origW, origH, 0, 0, origW, origH);
            
            // 축소 후 확대로 모자이크
            const smallW = Math.ceil(w / blockSize);
            const smallH = Math.ceil(h / blockSize);
            
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tempCanvas, 0, 0, origW, origH, x, y, smallW, smallH);
            ctx.drawImage(ctx.canvas, x, y, smallW, smallH, x, y, w, h);
            ctx.imageSmoothingEnabled = true;
        }
        
        // 블러 효과 (간단한 버전)
        function applyBlurEffect(ctx, x, y, w, h) {
            // CSS blur 대신 다중 그리기로 블러 효과
            ctx.save();
            ctx.globalAlpha = 0.1;
            for (let i = -5; i <= 5; i++) {
                for (let j = -5; j <= 5; j++) {
                    ctx.drawImage(ctx.canvas, x, y, w, h, x + i, y + j, w, h);
                }
            }
            ctx.restore();

            // 반투명 오버레이
            ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
            ctx.fillRect(x, y, w, h);
        }

        // 스팀/구름 효과를 위한 Simplex Noise 생성기
        const SimplexNoise = (function() {
            const F2 = 0.5 * (Math.sqrt(3) - 1);
            const G2 = (3 - Math.sqrt(3)) / 6;
            const grad3 = [
                [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
            ];
            let perm = new Uint8Array(512);
            let permMod12 = new Uint8Array(512);

            function seed(s) {
                const p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) p[i] = i;
                for (let i = 255; i > 0; i--) {
                    s = (s * 16807 + 1) % 2147483647;
                    const j = s % (i + 1);
                    [p[i], p[j]] = [p[j], p[i]];
                }
                for (let i = 0; i < 512; i++) {
                    perm[i] = p[i & 255];
                    permMod12[i] = perm[i] % 12;
                }
            }

            function noise2D(x, y) {
                const s = (x + y) * F2;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = x - X0;
                const y0 = y - Y0;
                let i1, j1;
                if (x0 > y0) { i1 = 1; j1 = 0; }
                else { i1 = 0; j1 = 1; }
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1 + 2 * G2;
                const y2 = y0 - 1 + 2 * G2;
                const ii = i & 255;
                const jj = j & 255;
                let n0, n1, n2;
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 < 0) n0 = 0;
                else {
                    t0 *= t0;
                    const gi0 = permMod12[ii + perm[jj]];
                    n0 = t0 * t0 * (grad3[gi0][0] * x0 + grad3[gi0][1] * y0);
                }
                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 < 0) n1 = 0;
                else {
                    t1 *= t1;
                    const gi1 = permMod12[ii + i1 + perm[jj + j1]];
                    n1 = t1 * t1 * (grad3[gi1][0] * x1 + grad3[gi1][1] * y1);
                }
                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 < 0) n2 = 0;
                else {
                    t2 *= t2;
                    const gi2 = permMod12[ii + 1 + perm[jj + 1]];
                    n2 = t2 * t2 * (grad3[gi2][0] * x2 + grad3[gi2][1] * y2);
                }
                return 70 * (n0 + n1 + n2);
            }

            seed(Date.now());
            return { seed, noise2D };
        })();

        // 스팀 텍스처 캐시 (박스별로 미리 렌더링)
        const steamTextureCache = new Map();

        // 스팀 텍스처 생성 (캐시 키 기반)
        function generateSteamTexture(w, h, seed) {
            const expandRatio = 0.35;
            const expandX = w * expandRatio;
            const expandY = h * expandRatio;

            const tw = Math.max(1, Math.ceil(w + expandX * 2));
            const th = Math.max(1, Math.ceil(h + expandY * 2));

            const cloudCanvas = document.createElement('canvas');
            cloudCanvas.width = tw;
            cloudCanvas.height = th;
            const cloudCtx = cloudCanvas.getContext('2d');
            const imageData = cloudCtx.createImageData(tw, th);
            const data = imageData.data;

            SimplexNoise.seed(seed);
            const noiseScale = Math.max(tw, th) / 2;

            const rx = w / 2;
            const ry = h / 2;
            const cx = tw / 2;
            const cy = th / 2;
            const safeMargin = Math.min(expandX, expandY) * 0.25;

            for (let py = 0; py < th; py++) {
                for (let px = 0; px < tw; px++) {
                    const distFromEdge = Math.min(px, py, tw - 1 - px, th - 1 - py);

                    if (distFromEdge < safeMargin) {
                        const idx = (py * tw + px) * 4;
                        data[idx] = 255;
                        data[idx + 1] = 255;
                        data[idx + 2] = 255;
                        data[idx + 3] = 0;
                        continue;
                    }

                    // 밝기 노이즈 (범위를 좁혀서 박스 간 차이 줄임)
                    let brightNoise = 0;
                    brightNoise += SimplexNoise.noise2D(px / noiseScale, py / noiseScale) * 1.0;
                    brightNoise += SimplexNoise.noise2D(px / noiseScale * 2, py / noiseScale * 2) * 0.5;
                    brightNoise += SimplexNoise.noise2D(px / noiseScale * 4, py / noiseScale * 4) * 0.25;
                    brightNoise = (brightNoise / 1.75 + 1) / 2;  // 0~1 범위
                    brightNoise = 0.5 + brightNoise * 0.5;  // 0.5~1 범위로 압축 (더 밝고 균일하게)

                    const dx = (px - cx) / rx;
                    const dy = (py - cy) / ry;
                    const ellipseDist = Math.sqrt(dx * dx + dy * dy);

                    let edgeNoise = 0;
                    edgeNoise += SimplexNoise.noise2D(px / (noiseScale * 0.5) + 50, py / (noiseScale * 0.5) + 50) * 0.5;
                    edgeNoise += SimplexNoise.noise2D(px / (noiseScale * 0.25) + 150, py / (noiseScale * 0.25) + 150) * 0.35;
                    edgeNoise += SimplexNoise.noise2D(px / (noiseScale * 0.12) + 250, py / (noiseScale * 0.12) + 250) * 0.15;

                    const warpedDist = ellipseDist + edgeNoise * 0.25;

                    let alpha;
                    if (warpedDist < 0.6) {
                        alpha = 255;
                    } else if (warpedDist < 1.15) {
                        const t = (warpedDist - 0.6) / 0.55;
                        const smooth = t * t * (3 - 2 * t);
                        alpha = Math.floor((1 - smooth) * 255);
                    } else {
                        alpha = 0;
                    }

                    const fadeStart = safeMargin;
                    const fadeEnd = safeMargin * 4;
                    if (distFromEdge < fadeEnd) {
                        const edgeFade = (distFromEdge - fadeStart) / (fadeEnd - fadeStart);
                        alpha = Math.floor(alpha * Math.max(0, Math.min(1, edgeFade)));
                    }

                    const idx = (py * tw + px) * 4;
                    const brightness = Math.floor(230 + brightNoise * 25);  // 230~255 범위
                    data[idx] = brightness;
                    data[idx + 1] = brightness;
                    data[idx + 2] = brightness;
                    data[idx + 3] = alpha;
                }
            }

            cloudCtx.putImageData(imageData, 0, 0);
            return { canvas: cloudCanvas, expandX, expandY, tw, th };
        }

        // 스팀 캐시 키 생성 (확장/부드럽게 값 포함)
        function getSteamCacheKey(w, h, seed) {
            const expand = censorState.expandPixels || 0;
            const feather = censorState.feather || 0;
            return `${Math.round(w)}_${Math.round(h)}_${seed}_e${expand}_f${feather}`;
        }

        // 스팀 텍스처 캐시 프리로드 (박스 목록 기반, cleanupOld: 오래된 캐시 정리 여부)
        function preloadSteamTextures(boxes, scale, cleanupOld = false) {
            const currentKeys = new Set();

            boxes.forEach(det => {
                if ((det.method || 'black') !== 'steam') return;

                const [x1, y1, x2, y2] = det.box;
                const w = (x2 - x1) * scale;
                const h = (y2 - y1) * scale;
                const seed = Math.floor(x1 * 1000 + y1);
                const key = getSteamCacheKey(w, h, seed);

                currentKeys.add(key);

                if (!steamTextureCache.has(key)) {
                    steamTextureCache.set(key, generateSteamTexture(w, h, seed));
                }
            });

            // 옵션: 더 이상 필요없는 캐시 제거
            if (cleanupOld) {
                for (const key of steamTextureCache.keys()) {
                    if (!currentKeys.has(key)) {
                        steamTextureCache.delete(key);
                    }
                }
            }

            // 캐시가 너무 커지면 오래된 것부터 제거 (최대 100개)
            if (steamTextureCache.size > 100) {
                const keysToDelete = [...steamTextureCache.keys()].slice(0, steamTextureCache.size - 100);
                keysToDelete.forEach(k => steamTextureCache.delete(k));
            }
        }

        // 스팀/구름 효과 적용 (캐시 사용)
        function applySteamEffect(ctx, x, y, w, h, originalImg, origX, origY, origW, origH) {
            const seed = Math.floor(origX * 1000 + origY);
            const key = getSteamCacheKey(w, h, seed);

            let texture = steamTextureCache.get(key);
            if (!texture) {
                texture = generateSteamTexture(w, h, seed);
                steamTextureCache.set(key, texture);
            }

            ctx.drawImage(texture.canvas, x - texture.expandX, y - texture.expandY, texture.tw, texture.th);
        }

        // === 하이브리드 프리뷰: 확장/그라데이션 적용 시 백엔드 API로 정확한 프리뷰 ===
        let censorPreviewDebounceTimer = null;
        let censorPreviewRequestId = 0;
        let cachedApiPreviewImage = null;  // 현재 이미지용 캐시 (호환성)
        let cachedApiPreviewKey = null;    // 현재 캐시 키

        // 이미지별 검열 프리뷰 캐시 (Map: imageKey -> { image, settingsKey })
        const censoredPreviewCache = new Map();
        const MAX_CENSORED_CACHE_SIZE = 50;

        // 설정 키 생성 (박스, 확장, 그라데이션, 메서드)
        function getCensorSettingsKey(boxes, method) {
            return JSON.stringify({
                boxes: boxes.map(b => ({ box: b.box, method: b.method, rotation: b.rotation })),
                expand: censorState.expandPixels,
                feather: censorState.feather,
                method: method
            });
        }

        // 캐시 키 생성 (박스, 확장, 그라데이션, 메서드 기반) - 호환성 유지
        function getPreviewCacheKey() {
            const methodSelector = 'censorMethod';
            const method = document.getElementById(methodSelector)?.value || 'black';
            return JSON.stringify({
                boxes: censorState.editBoxes.map(b => ({ box: b.box, method: b.method, rotation: b.rotation })),
                expand: censorState.expandPixels,
                feather: censorState.feather,
                method: method,
                imagePath: censorState.currentImage?.path
            });
        }

        function requestCensorPreviewUpdate() {
            // 디바운스: 슬라이더 조작 중 너무 잦은 호출 방지
            if (censorPreviewDebounceTimer) {
                clearTimeout(censorPreviewDebounceTimer);
            }
            censorPreviewDebounceTimer = setTimeout(() => {
                updateCensorPreviewFromAPI();
            }, 300);
        }

        // 캐시된 프리뷰 이미지가 있으면 바로 그리기
        function drawCachedApiPreview() {
            const currentKey = getPreviewCacheKey();
            if (cachedApiPreviewImage && cachedApiPreviewKey === currentKey) {
                const displayW = censorPreviewCanvas.width;
                const displayH = censorPreviewCanvas.height;
                censorPreviewCtx.drawImage(cachedApiPreviewImage, 0, 0, displayW, displayH);
                return true;
            }
            return false;
        }

        // 이미지별 캐시에서 검열 프리뷰 가져오기
        function getCachedCensoredPreview(imageKey, boxes, method) {
            const cached = censoredPreviewCache.get(imageKey);
            if (!cached) return null;

            const settingsKey = getCensorSettingsKey(boxes, method);
            if (cached.settingsKey === settingsKey) {
                return cached.image;
            }
            return null;
        }

        // 이미지별 캐시에 검열 프리뷰 저장
        function setCachedCensoredPreview(imageKey, boxes, method, image) {
            const settingsKey = getCensorSettingsKey(boxes, method);
            censoredPreviewCache.set(imageKey, { image, settingsKey });

            // 캐시 크기 제한
            if (censoredPreviewCache.size > MAX_CENSORED_CACHE_SIZE) {
                const firstKey = censoredPreviewCache.keys().next().value;
                censoredPreviewCache.delete(firstKey);
            }
        }

        async function updateCensorPreviewFromAPI() {
            if (!censorState.currentImage) return;
            if (censorState.editBoxes.length === 0) {
                // 박스가 없으면 원본 이미지 그리기
                if (censorState.currentTab === 'after') {
                    redrawAfterPreviewBase();
                } else {
                    drawCensorPreview();
                }
                return;
            }

            const requestId = ++censorPreviewRequestId;
            const imageKey = censorState.currentImage?.id || censorState.currentImage?.path;
            const requestImagePath = censorState.currentImage.path;  // 요청 시점의 이미지 경로 저장
            // 탭에 따라 올바른 method selector 사용
            const methodSelector = 'censorMethod';
            const method = document.getElementById(methodSelector)?.value || censorState.processingMethod;

            // 이미지별 캐시 확인
            const cachedImg = getCachedCensoredPreview(imageKey, censorState.editBoxes, method);
            if (cachedImg) {
                const displayW = censorPreviewCanvas.width;
                const displayH = censorPreviewCanvas.height;
                censorPreviewCtx.drawImage(cachedImg, 0, 0, displayW, displayH);
                drawProcessingOverlay();
                // 현재 이미지 캐시도 업데이트
                cachedApiPreviewImage = cachedImg;
                cachedApiPreviewKey = getPreviewCacheKey();
                return;
            }

            try {
                const requestBody = {
                    boxes: censorState.editBoxes.map(box => ({
                        box: box.box,
                        method: box.method || method,
                        rotation: box.rotation || 0
                    })),
                    method: method,
                    expand_pixels: censorState.expandPixels || 0,
                    feather: censorState.feather || 0
                };

                // 이미지 소스 설정
                if (censorState.currentTab === 'processing') {
                    // 검열중 탭: 드롭된 이미지인지 확인
                    const imageKey = censorState.currentImage?.id || censorState.currentImage?.path;
                    const procResult = censorState.processingResults[imageKey];
                    const imgInfo = procResult?.imgInfo;

                    if (imgInfo?.isDropped) {
                        // 드롭된 이미지: absolutePath 또는 base64 사용
                        if (imgInfo.absolutePath) {
                            requestBody.absolute_path = imgInfo.absolutePath;
                        } else if (imgInfo.base64) {
                            requestBody.image_base64 = imgInfo.base64;
                        }
                    } else {
                        // 일반 이미지: uncensored 폴더
                        requestBody.image_path = censorState.currentImage.path;
                    }
                } else if (censorState.currentTab === 'after') {
                    // 검열후 탭: censored 폴더의 이미지
                    requestBody.image_path = censorState.currentImage.path;
                    requestBody.source = 'censored';
                } else {
                    // 기타 탭: uncensored 이미지
                    requestBody.image_path = censorState.currentImage.path;
                }

                const response = await fetch(`${API_BASE}/api/censor/apply`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                // 요청 ID 및 이미지 경로 확인 (다른 요청이 이미 처리 중이거나 이미지가 변경됐으면 무시)
                if (requestId !== censorPreviewRequestId) return;
                if (censorState.currentImage?.path !== requestImagePath) return;

                const result = await response.json();
                if (result.success && result.image) {
                    // base64 이미지를 캔버스에 그리기
                    const img = new Image();
                    img.onload = () => {
                        // 이미지 로드 완료 시에도 다시 확인
                        if (requestId !== censorPreviewRequestId) return;
                        if (censorState.currentImage?.path !== requestImagePath) return;

                        // 현재 이미지 캐시에 저장
                        cachedApiPreviewImage = img;
                        cachedApiPreviewKey = getPreviewCacheKey();

                        // 이미지별 캐시에도 저장
                        setCachedCensoredPreview(imageKey, censorState.editBoxes, method, img);

                        const displayW = censorPreviewCanvas.width;
                        const displayH = censorPreviewCanvas.height;
                        censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);

                        // 오버레이 (선택 박스 등)
                        drawProcessingOverlay();
                    };
                    img.src = `data:image/png;base64,${result.image}`;
                }
            } catch (err) {
                console.error('Censor preview update failed:', err);
            }
        }

        // 검열후 탭 원본만 그리기 (편집 박스 없이)
        function redrawAfterPreviewBase() {
            if (censorState.currentTab !== 'after' || !censorState.originalImageObj) return;

            const img = censorState.originalImageObj;
            const displayW = censorPreviewCanvas.width;
            const displayH = censorPreviewCanvas.height;
            censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);
        }

        // 검열중 탭 오버레이 그리기 (호버 시에만 핸들 표시)
        function drawProcessingOverlay() {
            if (!censorOverlayCtx) return;
            
            const scale = censorState.displayScale || 1;
            const offsetX = censorState.overlayOffsetX || 0;
            const offsetY = censorState.overlayOffsetY || 0;
            censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);

            // 검열중 탭에서는 editBoxes만 사용 (모두 삭제한 경우 빈 배열)
            const boxes = censorState.editBoxes;
            const isDeleteMode = censorState.currentTool === 'delete';
            const canEdit = censorState.currentTool === 'select' || censorState.currentTool === 'add';
            
            boxes.forEach((det, index) => {
                const [x1, y1, x2, y2] = det.box;
                const sx = x1 * scale + offsetX;
                const sy = y1 * scale + offsetY;
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                const rotation = det.rotation || 0;
                const cx = sx + sw / 2;
                const cy = sy + sh / 2;
                
                const isSelected = index === censorState.selectedBoxIndex;
                const isHovered = index === censorState.hoverBoxIndex;
                const showHandles = canEdit && (isHovered || isSelected);
                
                censorOverlayCtx.save();
                censorOverlayCtx.translate(cx, cy);
                censorOverlayCtx.rotate(rotation);
                censorOverlayCtx.translate(-cx, -cy);
                
                // 삭제 모드에서 호버 시 빨간 강조
                if (isDeleteMode && isHovered) {
                    censorOverlayCtx.strokeStyle = 'rgba(255, 80, 80, 1)';
                    censorOverlayCtx.lineWidth = 3;
                    censorOverlayCtx.setLineDash([]);
                    censorOverlayCtx.strokeRect(sx, sy, sw, sh);
                    censorOverlayCtx.fillStyle = 'rgba(255, 80, 80, 0.3)';
                    censorOverlayCtx.fillRect(sx, sy, sw, sh);
                } else if (showHandles) {
                    // 호버/선택 시 테두리 + 핸들 표시
                    censorOverlayCtx.strokeStyle = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.9)';
                    censorOverlayCtx.lineWidth = 2;
                    censorOverlayCtx.setLineDash([]);
                    censorOverlayCtx.strokeRect(sx, sy, sw, sh);
                    
                    // 리사이즈 핸들
                    const hs = 7;
                    const handleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.95)';
                    censorOverlayCtx.fillStyle = handleColor;
                    
                    // 모서리 핸들
                    censorOverlayCtx.fillRect(sx - hs/2, sy - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx + sw - hs/2, sy - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx - hs/2, sy + sh - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx + sw - hs/2, sy + sh - hs/2, hs, hs);
                    
                    // 변 핸들
                    const ehs = 5;
                    censorOverlayCtx.fillRect(cx - ehs/2, sy - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(cx - ehs/2, sy + sh - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(sx - ehs/2, cy - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(sx + sw - ehs/2, cy - ehs/2, ehs, ehs);
                    
                    // 회전 핸들 (선택 또는 호버 시 모두)
                    const rotateY = sy - 25;
                    const rotHandleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.95)';
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.strokeStyle = rotHandleColor;
                    censorOverlayCtx.lineWidth = 1;
                    censorOverlayCtx.moveTo(cx, sy);
                    censorOverlayCtx.lineTo(cx, rotateY + 6);
                    censorOverlayCtx.stroke();
                    
                    censorOverlayCtx.fillStyle = rotHandleColor;
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.arc(cx, rotateY, 6, 0, Math.PI * 2);
                    censorOverlayCtx.fill();
                    
                    censorOverlayCtx.fillStyle = isSelected ? 'white' : 'rgba(0, 0, 0, 0.7)';
                    censorOverlayCtx.font = '8px sans-serif';
                    censorOverlayCtx.textAlign = 'center';
                    censorOverlayCtx.textBaseline = 'middle';
                    censorOverlayCtx.fillText('↻', cx, rotateY);
                }
                // 호버/선택 아닐 때는 테두리 없음 (검열 효과만 보임)
                
                censorOverlayCtx.restore();
            });
        }
        
        // 검열중 모드에서 이미지 재렌더링 (박스 편집 후)
        // overlayOnly=true면 오버레이만 갱신 (호버 등)
        function redrawProcessingPreview(overlayOnly = false) {
            if (censorState.currentTab !== 'processing' || !censorState.originalImageObj) return;

            const img = censorState.originalImageObj;
            const displayW = censorPreviewCanvas.width;
            const displayH = censorPreviewCanvas.height;

            // 드래그/리사이즈/회전/그리기 중에는 API 호출 안 함 (Canvas만 사용)
            const isEditing = censorState.isDragging || censorState.isResizing || censorState.isRotating || censorState.isDrawing;

            // 하이브리드 프리뷰: 확장/그라데이션이 있으면 API 결과 사용
            if ((censorState.expandPixels > 0 || censorState.feather > 0) && censorState.editBoxes.length > 0) {
                if (overlayOnly && !isEditing) {
                    // 오버레이만 갱신: 캐시된 이미지가 있으면 그대로 사용, 오버레이만 다시 그리기
                    if (drawCachedApiPreview()) {
                        drawProcessingOverlay();
                        return;
                    }
                }
                // Canvas로 빠르게 그리기
                drawCensoredImage(img, displayW, displayH);
                // 편집 중이 아닐 때만 API 호출
                if (!isEditing) {
                    requestCensorPreviewUpdate();
                }
            } else {
                drawCensoredImage(img, displayW, displayH);
            }
        }
        
        // 검열후 탭 오버레이 그리기 (추가된 편집 박스 + 검열 효과)
        function drawAfterTabOverlay(img, displayW, displayH) {
            if (!censorOverlayCtx) return;
            
            const scale = censorState.displayScale || 1;
            const method = document.getElementById('censorMethod')?.value || 'black';
            
            // 추가된 editBoxes에 검열 효과 적용
            if (censorState.editBoxes.length > 0) {
                censorState.editBoxes.forEach(det => {
                    const [x1, y1, x2, y2] = det.box;
                    const sx = x1 * scale;
                    const sy = y1 * scale;
                    const sw = (x2 - x1) * scale;
                    const sh = (y2 - y1) * scale;
                    const rotation = det.rotation || 0;
                    
                    if (rotation !== 0) {
                        const cx = sx + sw / 2;
                        const cy = sy + sh / 2;
                        censorPreviewCtx.save();
                        censorPreviewCtx.translate(cx, cy);
                        censorPreviewCtx.rotate(rotation);
                        censorPreviewCtx.translate(-cx, -cy);
                        applyCensorEffect(censorPreviewCtx, sx, sy, sw, sh, det.method || method, img, x1, y1, x2 - x1, y2 - y1);
                        censorPreviewCtx.restore();
                    } else {
                        applyCensorEffect(censorPreviewCtx, sx, sy, sw, sh, det.method || method, img, x1, y1, x2 - x1, y2 - y1);
                    }
                });
            }
            
            // 오버레이에 편집 박스 표시 (호버/선택 시 핸들 표시)
            drawAfterTabBoxOverlay();
        }
        
        // 검열후 탭 박스 오버레이 (drawProcessingOverlay와 동일한 로직)
        function drawAfterTabBoxOverlay() {
            if (!censorOverlayCtx) return;
            
            const scale = censorState.displayScale || 1;
            const offsetX = censorState.overlayOffsetX || 0;
            const offsetY = censorState.overlayOffsetY || 0;
            censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);
            
            const boxes = censorState.editBoxes;
            const isDeleteMode = censorState.currentTool === 'delete';
            const canEdit = censorState.currentTool === 'select' || censorState.currentTool === 'add';
            
            boxes.forEach((det, index) => {
                const [x1, y1, x2, y2] = det.box;
                const sx = x1 * scale + offsetX;
                const sy = y1 * scale + offsetY;
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                const rotation = det.rotation || 0;
                const cx = sx + sw / 2;
                const cy = sy + sh / 2;
                
                const isSelected = index === censorState.selectedBoxIndex;
                const isHovered = index === censorState.hoverBoxIndex;
                const showHandles = canEdit && (isHovered || isSelected);
                
                censorOverlayCtx.save();
                censorOverlayCtx.translate(cx, cy);
                censorOverlayCtx.rotate(rotation);
                censorOverlayCtx.translate(-cx, -cy);
                
                if (isDeleteMode && isHovered) {
                    censorOverlayCtx.strokeStyle = 'rgba(255, 80, 80, 1)';
                    censorOverlayCtx.lineWidth = 3;
                    censorOverlayCtx.setLineDash([]);
                    censorOverlayCtx.strokeRect(sx, sy, sw, sh);
                    censorOverlayCtx.fillStyle = 'rgba(255, 80, 80, 0.3)';
                    censorOverlayCtx.fillRect(sx, sy, sw, sh);
                } else if (showHandles) {
                    censorOverlayCtx.strokeStyle = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.9)';
                    censorOverlayCtx.lineWidth = 2;
                    censorOverlayCtx.setLineDash([]);
                    censorOverlayCtx.strokeRect(sx, sy, sw, sh);
                    
                    const hs = 7;
                    const handleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.95)';
                    censorOverlayCtx.fillStyle = handleColor;
                    
                    censorOverlayCtx.fillRect(sx - hs/2, sy - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx + sw - hs/2, sy - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx - hs/2, sy + sh - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx + sw - hs/2, sy + sh - hs/2, hs, hs);
                    
                    const ehs = 5;
                    censorOverlayCtx.fillRect(cx - ehs/2, sy - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(cx - ehs/2, sy + sh - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(sx - ehs/2, cy - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(sx + sw - ehs/2, cy - ehs/2, ehs, ehs);
                    
                    // 회전 핸들 (선택 또는 호버 시 모두)
                    const rotateY = sy - 25;
                    const rotHandleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.95)';
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.strokeStyle = rotHandleColor;
                    censorOverlayCtx.lineWidth = 1;
                    censorOverlayCtx.moveTo(cx, sy);
                    censorOverlayCtx.lineTo(cx, rotateY + 6);
                    censorOverlayCtx.stroke();
                    
                    censorOverlayCtx.fillStyle = rotHandleColor;
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.arc(cx, rotateY, 6, 0, Math.PI * 2);
                    censorOverlayCtx.fill();
                    
                    censorOverlayCtx.fillStyle = isSelected ? 'white' : 'rgba(0, 0, 0, 0.7)';
                    censorOverlayCtx.font = '8px sans-serif';
                    censorOverlayCtx.textAlign = 'center';
                    censorOverlayCtx.textBaseline = 'middle';
                    censorOverlayCtx.fillText('↻', cx, rotateY);
                }
                
                censorOverlayCtx.restore();
            });
        }
        
        // 검열후 탭 재렌더링
        // overlayOnly=true면 오버레이만 갱신 (호버 등)
        function redrawAfterPreview(overlayOnly = false) {
            if (censorState.currentTab !== 'after' || !censorState.originalImageObj) return;

            const img = censorState.originalImageObj;
            const displayW = censorPreviewCanvas.width;
            const displayH = censorPreviewCanvas.height;

            // 드래그/리사이즈/회전/그리기 중에는 API 호출 안 함 (Canvas만 사용)
            const isEditing = censorState.isDragging || censorState.isResizing || censorState.isRotating || censorState.isDrawing;

            // 하이브리드 프리뷰: 확장/그라데이션이 있으면 API 결과 사용
            if ((censorState.expandPixels > 0 || censorState.feather > 0) && censorState.editBoxes.length > 0) {
                if (overlayOnly && !isEditing) {
                    // 오버레이만 갱신: 캐시된 이미지가 있으면 그대로 사용
                    if (drawCachedApiPreview()) {
                        drawProcessingOverlay();
                        return;
                    }
                }
                // 원본 + Canvas 오버레이 그린 후 API 호출 (편집 중 아닐 때만)
                censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);
                drawAfterTabOverlay(img, displayW, displayH);
                if (!isEditing) {
                    requestCensorPreviewUpdate();
                }
            } else {
                // 확장/그라데이션 없음: 기존 방식
                censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);
                drawAfterTabOverlay(img, displayW, displayH);
            }
        }
        
        // 검열후 탭 편집 변경 표시
        function markAfterEditDirty() {
            if (censorState.currentTab !== 'after') return;
            censorState.afterEditDirty = true;
            const saveBtn = document.getElementById('censorAfterSaveBtn');
            if (saveBtn) saveBtn.disabled = false;
        }
        
        // 검열후 탭 저장
        async function saveAfterEdit() {
            if (!censorState.currentImage || censorState.editBoxes.length === 0) {
                showToast('저장할 편집 내용이 없습니다', 'warning');
                return;
            }
            
            const method = document.getElementById('censorMethod').value;
            const boxes = censorState.editBoxes.map(d => ({
                box: d.box,
                method: d.method || method,
                rotation: d.rotation || 0
            }));
            
            const imagePath = censorState.currentImage.path;
            const pathParts = imagePath.split(/[\/\\]/);
            const outputFolder = pathParts.length > 1 ? pathParts.slice(0, -1).join('/') : '';
            
            try {
                const response = await fetch(`${API_BASE}/api/censor/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_path: imagePath,
                        boxes: boxes,
                        method: method,
                        output_folder: outputFolder,
                        filename: censorState.currentImage.filename,
                        source: 'censored',
                        expand_pixels: censorState.expandPixels || 0,
                        feather: censorState.feather || 0
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showToast('저장 완료', 'success');
                    censorState.afterEditDirty = false;
                    censorState.editBoxes = [];
                    document.getElementById('censorAfterSaveBtn').disabled = true;
                    
                    // 현재 인덱스 저장
                    const currentIndex = censorState.currentIndex;
                    
                    // 1. 모든 관련 캐시 삭제
                    const cacheKey = `censored:${imagePath}`;
                    censorState.imgCache.delete(cacheKey);

                    
                    // 2. 서버에서 새 썸네일 가져오기
                    const folder = censorState.currentCensoredFolder;
                    const endpoint = `/api/censor/censored?folder=${encodeURIComponent(folder)}`;
                    const listResponse = await fetch(`${API_BASE}${endpoint}`);
                    const listResult = await listResponse.json();
                    
                    if (listResult.success) {
                        // 파일명 순 정렬
                        const images = (listResult.images || []).sort((a, b) =>
                            a.filename.localeCompare(b.filename, undefined, { numeric: true, sensitivity: 'base' })
                        );
                        censorState.censoredImages = images;

                        
                        // 3. 썸네일 다시 렌더링
                        renderCensorThumbnails(images);
                        
                        // 4. 프리뷰 이미지 강제 새로고침
                        const imgInfo = images[currentIndex];
                        if (imgInfo) {
                            const img = await loadCensorImageFile('censored', imgInfo.path);

                            
                            // 캐시에 새 이미지 저장
                            censorCacheSet(cacheKey, {
                                img,
                                width: img.naturalWidth,
                                height: img.naturalHeight,
                                filename: imgInfo.filename
                            });
                            
                            // 캔버스에 그리기
                            censorState.originalImageObj = img;
                            censorState.currentImage = imgInfo;
                            drawCensorPreview(img);
                        }
                    }
                } else {
                    showToast('저장 실패: ' + result.error, 'error');
                }
            } catch (err) {
                showToast('저장 오류: ' + err.message, 'error');
            }
        }
        
        // 감지 박스 그리기 (검열 전 탭용 - 점선)
        function drawDetectionBoxes() {
            drawEditBoxes();
        }
        
        // 현재 이미지 스캔
        async function scanCurrentImage() {
            if (!censorState.currentImage) return;
            
            const scanRequestId = censorState.wheelRequestId;  // 스캔 시작 시점의 requestId 저장
            const scanImagePath = censorState.currentImage.path;  // 스캔 대상 이미지 경로 저장
            
            // 활성화된 타겟 클래스
            const targetLabels = [];
            const labelConf = {};
            document.querySelectorAll('#censorTargets input[type="checkbox"]:checked').forEach(cb => {
                const cls = cb.dataset.class;
                targetLabels.push(cls);
                labelConf[cls] = censorState.labelConf[cls] || 0.3;
            });
            
            if (targetLabels.length === 0) {
                censorState.detections = [];
                drawDetectionBoxes();
                return;
            }
            
            try {
                const model = document.getElementById('censorModel').value;
                
                // 드롭된 이미지인지 확인
                const droppedImg = censorState.images.find(img => 
                    img.id === censorState.currentImage?.id && img.isDropped
                );
                
                const scanBody = {
                    model: model,
                    target_labels: targetLabels,
                    label_conf: labelConf,
                    return_all: true  // 모든 감지 반환 (threshold 이하 포함)
                };
                
                // 드롭된 이미지면 image_base64 사용, 아니면 image_path 사용
                if (droppedImg && droppedImg.base64) {
                    scanBody.image_base64 = droppedImg.base64;
                } else {
                    scanBody.image_path = scanImagePath;
                }
                
                const response = await fetch(`${API_BASE}/api/censor/scan`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(scanBody)
                });
                
                const result = await response.json();
                
                // 스캔 완료 후 다른 이미지로 넘어갔으면 결과 무시
                if (scanRequestId !== censorState.wheelRequestId || 
                    censorState.currentImage?.path !== scanImagePath) {
                    return;
                }
                
                if (result.success) {
                    censorState.detections = result.detections || [];
                    drawDetectionBoxes();
                }
            } catch (err) {
                console.error('Scan failed:', err);
            }
        }
        
        // 프리뷰 초기화
        function clearCensorPreview() {
            if (censorPreviewCtx) {
                censorPreviewCtx.clearRect(0, 0, censorPreviewCanvas.width, censorPreviewCanvas.height);
            }
            if (censorOverlayCtx) {
                censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);
            }
            censorState.currentImage = null;
            censorState.detections = [];
            // 검열전 탭: 드롭존 표시, 검열중/후 탭: empty 표시
            if (censorState.currentTab === 'before') {
                document.getElementById('censorDropzone').style.display = 'block';
                document.getElementById('censorPreviewEmpty').style.display = 'none';
            } else {
                document.getElementById('censorDropzone').style.display = 'none';
                document.getElementById('censorPreviewEmpty').style.display = 'flex';
            }
        }
        
        // 전체 검열 실행 → 검열중 탭으로 전환
        async function runBatchCensor() {
            const model = document.getElementById('censorModel').value;
            const method = document.getElementById('censorMethod').value;
            
            // 활성화된 타겟 클래스
            const targetLabels = [];
            const labelConf = {};
            document.querySelectorAll('#censorTargets input[type="checkbox"]:checked').forEach(cb => {
                const cls = cb.dataset.class;
                targetLabels.push(cls);
                labelConf[cls] = censorState.labelConf[cls] || 0.3;
            });
            
            if (targetLabels.length === 0) {
                showToast('검열 대상을 선택하세요', 'warning');
                return;
            }
            
            if (censorState.images.length === 0) {
                showToast('검열할 이미지가 없습니다', 'warning');
                return;
            }
            
            // 버튼 비활성화
            const runBtn = document.getElementById('censorRunAllBtn');
            runBtn.disabled = true;
            runBtn.textContent = '⏳ 스캔 중...';
            
            const totalCount = censorState.images.length;
            
            // 토스트로 진행 상황 표시 (사라지지 않는 토스트)
            showToast(`스캔 중... 0/${totalCount} (0%)`, 'info', 0);
            
            // 검열중 모드 활성화
            censorState.processingMode = true;
            censorState.processingResults = {};
            censorState.processingMethod = method;
            censorState.processingImages = [];
            
            // 모든 이미지에 대해 스캔 수행
            let scannedCount = 0;
            let detectedCount = 0;
            
            for (const imgInfo of censorState.images) {
                try {
                    const scanBody = {
                        model: model,
                        target_labels: targetLabels,
                        label_conf: labelConf
                    };
                    
                    // 드롭된 이미지면 image_base64 사용
                    if (imgInfo.isDropped && imgInfo.base64) {
                        scanBody.image_base64 = imgInfo.base64;
                    } else {
                        scanBody.image_path = imgInfo.path;
                    }
                    
                    const response = await fetch(`${API_BASE}/api/censor/scan`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(scanBody)
                    });
                    
                    const result = await response.json();
                    // 감지 여부와 관계없이 모든 이미지를 processingImages에 추가
                    const detections = (result.success && result.detections) ? result.detections : [];
                    
                    // id를 키로 사용 (드롭된 이미지는 path가 없으므로)
                    const imageKey = imgInfo.id || imgInfo.path;
                    censorState.processingResults[imageKey] = {
                        detections: detections,
                        editBoxes: detections.map(d => ({
                            box: Array.isArray(d.box) ? [d.box[0], d.box[1], d.box[2], d.box[3]] : d.box,
                            label: d.label,
                            confidence: d.confidence,
                            method: method
                        })),
                        // 드롭된 이미지 정보 저장 (저장 시 필요)
                        imgInfo: imgInfo
                    };
                    censorState.processingImages.push(imageKey);
                    if (detections.length > 0) {
                        detectedCount++;
                    }
                    scannedCount++;
                    
                    // 토스트 업데이트
                    const percent = Math.round((scannedCount / totalCount) * 100);
                    showToast(`스캔 중... ${scannedCount}/${totalCount} (${percent}%)`, 'info', 0);
                } catch (err) {
                    console.error('Scan failed for:', imgInfo.filename, err);
                    scannedCount++;
                    // 실패해도 토스트 업데이트
                    const percent = Math.round((scannedCount / totalCount) * 100);
                    showToast(`스캔 중... ${scannedCount}/${totalCount} (${percent}%)`, 'info', 0);
                }
            }
            
            // 버튼 복원
            runBtn.disabled = false;
            runBtn.textContent = '🔍 전체 검열';
            
            if (scannedCount === 0) {
                showToast('스캔할 이미지가 없습니다', 'warning');
                censorState.processingMode = false;
                censorState.processingResults = {};
                return;
            }

            if (detectedCount === 0) {
                showToast('검열 대상이 감지되지 않았습니다', 'info');
                censorState.processingMode = false;
                censorState.processingResults = {};
                return;
            }

            showToast(`스캔 완료: ${detectedCount}/${scannedCount} 이미지에서 감지`, 'success');

            // 이벤트가 초기화되지 않았으면 초기화
            if (!censorState.eventsInitialized) {
                setupCensorEvents();
                censorState.eventsInitialized = true;
            }

            // 검열중 탭 표시 및 전환
            document.getElementById('censorTabProcessing').style.display = 'inline-block';
            document.getElementById('censorMethod').value = method;

            // 이전 탭의 상태 초기화 (editBoxes 덮어쓰기 방지)
            censorState.currentImage = null;
            censorState.editBoxes = [];

            // 스팀 방식일 때 모든 이미지의 텍스처를 미리 캐싱 (비동기)
            if (method === 'steam') {
                setTimeout(() => {
                    precacheAllSteamTextures();
                }, 100);
            }

            // 확장/부드럽게가 설정되어 있으면 모든 이미지 검열 프리뷰를 미리 캐싱
            setTimeout(() => {
                precacheAllCensoredPreviews(method);
            }, 200);

            switchCensorTab('processing');
        }

        // 모든 이미지의 스팀 텍스처를 미리 캐싱
        function precacheAllSteamTextures() {
            const canvasW = censorPreviewCanvas?.width || 800;
            const canvasH = censorPreviewCanvas?.height || 600;

            for (const imageKey of censorState.processingImages) {
                const result = censorState.processingResults[imageKey];
                if (!result?.editBoxes || result.editBoxes.length === 0) continue;

                const imgInfo = result.imgInfo;
                if (!imgInfo?.width || !imgInfo?.height) continue;

                const scale = Math.min(canvasW / imgInfo.width, canvasH / imgInfo.height);
                preloadSteamTextures(result.editBoxes, scale);
            }
            console.log(`Steam textures precached: ${steamTextureCache.size} entries`);
        }

        // 모든 이미지의 검열 프리뷰를 백그라운드에서 미리 캐싱 (확장/부드럽게 적용)
        async function precacheAllCensoredPreviews(method) {
            const expand = censorState.expandPixels || 0;
            const feather = censorState.feather || 0;

            // 확장/부드럽게가 없으면 캐싱 불필요 (프론트엔드에서 직접 렌더링)
            if (expand === 0 && feather === 0) {
                console.log('No expand/feather, skipping precache');
                return;
            }

            console.log(`Precaching censored previews for ${censorState.processingImages.length} images...`);

            for (const imageKey of censorState.processingImages) {
                const result = censorState.processingResults[imageKey];
                if (!result?.editBoxes || result.editBoxes.length === 0) continue;

                // 이미 캐시되어 있으면 스킵
                const cached = getCachedCensoredPreview(imageKey, result.editBoxes, method);
                if (cached) continue;

                const imgInfo = result.imgInfo;
                if (!imgInfo) continue;

                try {
                    const requestBody = {
                        boxes: result.editBoxes.map(box => ({
                            box: box.box,
                            method: box.method || method,
                            rotation: box.rotation || 0
                        })),
                        method: method,
                        expand_pixels: expand,
                        feather: feather
                    };

                    // 이미지 소스 설정
                    if (imgInfo.isDropped) {
                        if (imgInfo.absolutePath) {
                            requestBody.absolute_path = imgInfo.absolutePath;
                        } else if (imgInfo.base64) {
                            requestBody.image_base64 = imgInfo.base64;
                        }
                    } else {
                        requestBody.image_path = imgInfo.path;
                    }

                    const response = await fetch(`${API_BASE}/api/censor/apply`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });

                    const apiResult = await response.json();
                    if (apiResult.success && apiResult.image) {
                        // 이미지 로드 후 캐시에 저장
                        const img = new Image();
                        img.onload = () => {
                            setCachedCensoredPreview(imageKey, result.editBoxes, method, img);
                        };
                        img.src = `data:image/png;base64,${apiResult.image}`;
                    }
                } catch (err) {
                    console.error('Precache failed for:', imageKey, err);
                }
            }
            console.log(`Censored previews precached: ${censoredPreviewCache.size} entries`);
        }
        
        // 검열중 모드에서 이미지 선택
        async function selectProcessingImage(index) {
            const imageKeys = censorState.processingImages;
            if (index < 0 || index >= imageKeys.length) return;

            // API 프리뷰 캐시 무효화 및 진행 중인 요청 취소
            cachedApiPreviewImage = null;
            cachedApiPreviewKey = null;
            censorPreviewRequestId++;  // 진행 중인 API 요청 무효화
            if (censorPreviewDebounceTimer) {
                clearTimeout(censorPreviewDebounceTimer);
                censorPreviewDebounceTimer = null;
            }

            // 현재 이미지의 editBoxes를 저장 (이미 검열중 탭에 있을 때만)
            const currentKey = censorState.currentImage?.id || censorState.currentImage?.path;
            if (censorState.currentTab === 'processing' && 
                currentKey && 
                censorState.processingResults[currentKey]) {
                censorState.processingResults[currentKey].editBoxes = censorState.editBoxes.map(b => ({...b, box: [...b.box]}));
            }
            
            censorState.currentIndex = index;
            const imageKey = imageKeys[index];
            const processingResult = censorState.processingResults[imageKey];
            
            // 썸네일 활성화 표시 및 자동 스크롤
            const thumbnails = document.querySelectorAll('.censor-thumbnail');
            thumbnails.forEach((t, i) => {
                t.classList.toggle('active', i === index);
            });
            // 선택된 썸네일이 보이도록 자동 스크롤
            if (thumbnails[index]) {
                thumbnails[index].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            }

            // 이미지 번호 표시
            document.getElementById('censorImageCounter').textContent = `${index + 1} / ${imageKeys.length}`;

            // 화살표 버튼 활성화/비활성화
            const leftBtn = document.getElementById('censorNavLeft');
            const rightBtn = document.getElementById('censorNavRight');
            leftBtn.disabled = index === 0;
            rightBtn.disabled = index === imageKeys.length - 1;
            
            // 이미지 로드
            try {
                let imgObj, width, height, filename;
                
                // processingResult에서 imgInfo 가져오기
                const imgInfo = processingResult?.imgInfo;
                
                if (imgInfo && imgInfo.isDropped && imgInfo.imgObj) {
                    // 드롭된 이미지면 이미 imgObj가 있음
                    imgObj = imgInfo.imgObj;
                    width = imgInfo.width;
                    height = imgInfo.height;
                    filename = imgInfo.filename;
                } else {
                    // 기존 로직: 서버에서 로드
                    const cacheKey = `uncensored:${imageKey}`;
                    let cached = censorCacheGet(cacheKey);

                    // 캐시에 없으면 FileResponse로 로드
                    if (!cached) {
                        const img = await loadCensorImageFile('uncensored', imageKey);
                        cached = {
                            img,
                            width: img.naturalWidth,
                            height: img.naturalHeight,
                            filename: imageKey.split('/').pop()
                        };
                        censorCacheSet(cacheKey, cached);
                    }
                    
                    imgObj = cached.img;
                    width = cached.width;
                    height = cached.height;
                    filename = cached.filename;
                }

                // currentImage 설정 (Image 객체 직접 저장)
                censorState.currentImage = {
                    id: imgInfo?.id || imageKey,
                    path: imgInfo?.path || imageKey,
                    filename: filename,
                    width: width,
                    height: height,
                    imgObj: imgObj,
                    isDropped: imgInfo?.isDropped
                };

                // 원본 이미지 객체 저장 (재렌더링용)
                censorState.originalImageObj = imgObj;

                // 저장된 결과에서 editBoxes 로드
                const procResult = censorState.processingResults[imageKey];
                if (procResult) {
                    censorState.detections = procResult.detections || [];
                    censorState.editBoxes = (procResult.editBoxes || []).map(b => ({
                        ...b,
                        box: Array.isArray(b.box) ? [...b.box] : b.box
                    }));
                    console.log('Loaded editBoxes:', JSON.stringify(censorState.editBoxes));
                } else {
                    censorState.detections = [];
                    censorState.editBoxes = [];
                }
                censorState.selectedBoxIndex = -1;

                const method = document.getElementById('censorMethod')?.value || censorState.processingMethod;
                const canvasW = censorPreviewCanvas.width;
                const canvasH = censorPreviewCanvas.height;

                // 스팀 텍스처 프리로드 (현재 이미지 + 다음 이미지)
                if (method === 'steam' || censorState.editBoxes.some(b => b.method === 'steam')) {
                    const scale = Math.min(canvasW / width, canvasH / height);
                    preloadSteamTextures(censorState.editBoxes, scale);

                    // 다음 이미지도 미리 프리로드
                    if (index + 1 < imageKeys.length) {
                        const nextKey = imageKeys[index + 1];
                        const nextResult = censorState.processingResults[nextKey];
                        if (nextResult?.editBoxes) {
                            const nextImgInfo = nextResult.imgInfo;
                            if (nextImgInfo) {
                                const nextScale = Math.min(canvasW / nextImgInfo.width, canvasH / nextImgInfo.height);
                                preloadSteamTextures(nextResult.editBoxes, nextScale);
                            }
                        }
                    }
                }

                // 이미지별 검열 프리뷰 캐시 확인 (확장/부드럽게 적용된 이미지)
                const cachedImg = getCachedCensoredPreview(imageKey, censorState.editBoxes, method);
                if (cachedImg) {
                    // 캔버스 크기와 오프셋 계산 (drawCensorPreview와 동일하게)
                    const previewArea = document.querySelector('.censor-preview-area');
                    const areaW = previewArea.clientWidth;
                    const areaH = previewArea.clientHeight;
                    const maxW = areaW - 80;
                    const maxH = areaH - 80;

                    const scale = Math.min(maxW / width, maxH / height, 1);
                    const displayW = Math.round(width * scale);
                    const displayH = Math.round(height * scale);

                    // 캔버스 크기 설정
                    censorPreviewCanvas.width = displayW;
                    censorPreviewCanvas.height = displayH;
                    censorPreviewCanvas.style.width = displayW + 'px';
                    censorPreviewCanvas.style.height = displayH + 'px';

                    // 오버레이 캔버스 설정
                    censorOverlayCanvas.width = areaW;
                    censorOverlayCanvas.height = areaH;

                    // 오프셋과 스케일 저장 (핸들 위치 계산용)
                    censorState.overlayOffsetX = (areaW - displayW) / 2;
                    censorState.overlayOffsetY = (areaH - displayH) / 2;
                    censorState.displayScale = scale;

                    // 캐시된 이미지를 바로 그리기
                    cachedApiPreviewImage = cachedImg;
                    cachedApiPreviewKey = getPreviewCacheKey();
                    censorPreviewCtx.drawImage(cachedImg, 0, 0, displayW, displayH);
                    drawProcessingOverlay();
                } else {
                    drawCensorPreview();
                }
            } catch (err) {
                console.error('Failed to load image:', err);
            }
        }
        
        // 검열 완료 (저장 후 검열중 탭 숨김)
        async function completeCensoring() {
            if (!censorState.processingMode || Object.keys(censorState.processingResults).length === 0) {
                showToast('저장할 검열 결과가 없습니다', 'warning');
                return;
            }
            
            // 현재 이미지의 editBoxes를 저장 (검증 포함)
            const currentKey = censorState.currentImage?.id || censorState.currentImage?.path;
            if (currentKey && censorState.processingResults[currentKey]) {
                const validBoxes = censorState.editBoxes.filter(b => {
                    if (!b.box || !Array.isArray(b.box) || b.box.length !== 4) {
                        console.error('Invalid box in current editBoxes:', b);
                        return false;
                    }
                    return true;
                });
                censorState.processingResults[currentKey].editBoxes = validBoxes.map(b => ({
                    ...b,
                    box: [b.box[0], b.box[1], b.box[2], b.box[3]]
                }));
            }
            
            const method = document.getElementById('censorMethod')?.value || censorState.processingMethod;
            // 검열후 탭에서 선택된 폴더 사용 (없으면 루트)
            const outputFolder = censorState.currentCensoredFolder || '';
            let savedCount = 0;
            let failedCount = 0;
            const totalCount = censorState.processingImages.length;
            
            showToast(`저장 중... 0/${totalCount} (0%)`, 'info', 0);
            
            console.log('=== completeCensoring START ===');
            console.log('processingImages:', censorState.processingImages);
            console.log('processingResults keys:', Object.keys(censorState.processingResults));
            
            for (let i = 0; i < censorState.processingImages.length; i++) {
                const imageKey = censorState.processingImages[i];
                const result = censorState.processingResults[imageKey];
                const imgInfo = result?.imgInfo;
                
                try {
                    // 원본 데이터 로깅 (상세)
                    console.log('=== Saving image:', imgInfo?.filename || imageKey, '===');
                    console.log('imageKey:', imageKey);
                    console.log('result:', result);
                    console.log('imgInfo:', imgInfo);
                    console.log('Raw editBoxes count:', result?.editBoxes?.length || 0);
                    
                    // 박스 데이터 검증 및 변환 (박스 없으면 빈 배열 - 원본 복사됨)
                    const boxes = (result?.editBoxes || [])
                        .filter(d => {
                            if (!d.box) {
                                console.error(`Invalid box (no box property):`, d);
                                return false;
                            }
                            if (!Array.isArray(d.box)) {
                                console.error(`Invalid box (not array): type=${typeof d.box}, value=`, d.box);
                                return false;
                            }
                            if (d.box.length !== 4) {
                                console.error(`Invalid box (wrong length): len=${d.box.length}, box=`, d.box);
                                return false;
                            }
                            // 각 좌표가 숫자인지 확인
                            for (let j = 0; j < 4; j++) {
                                if (typeof d.box[j] !== 'number' || isNaN(d.box[j])) {
                                    console.error(`Invalid box (bad coordinate at index ${j}): box=`, d.box);
                                    return false;
                                }
                            }
                            return true;
                        })
                        .map(d => ({
                            box: [Math.round(d.box[0]), Math.round(d.box[1]), Math.round(d.box[2]), Math.round(d.box[3])],
                            method: d.method || method,
                            rotation: d.rotation || 0  // 회전 값 포함
                        }));
                    
                    // 박스 없어도 저장 (원본 이미지가 그대로 복사됨)
                    console.log('Saving:', imgInfo?.filename || imageKey, 'boxes:', boxes.length);
                    
                    const saveBody = {
                        boxes: boxes,
                        method: method,
                        output_folder: outputFolder,  // 검열후 탭에서 선택된 폴더
                        filename: imgInfo?.filename,  // 원본 파일명 유지
                        expand_pixels: censorState.expandPixels || 0,
                        feather: censorState.feather || 0
                    };
                    
                    // 드롭된 이미지면 image_base64 사용, 아니면 path 사용
                    if (imgInfo?.isDropped && imgInfo?.base64) {
                        saveBody.image_base64 = imgInfo.base64;
                        console.log('Using image_base64 for dropped image');
                    } else if (imgInfo?.path) {
                        saveBody.image_path = imgInfo.path;
                        console.log('Using image_path:', imgInfo.path);
                    } else {
                        // fallback: imageKey가 경로일 수 있음
                        saveBody.image_path = imageKey;
                        console.log('Using imageKey as path:', imageKey);
                    }
                    
                    // 이미지 소스가 없으면 건너뛰기
                    if (!saveBody.image_base64 && !saveBody.image_path) {
                        console.error('No image source for:', imageKey);
                        failedCount++;
                        continue;
                    }
                    
                    const response = await fetch(`${API_BASE}/api/censor/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(saveBody)
                    });
                    
                    const saveResult = await response.json();
                    console.log('Save result:', saveResult);
                    
                    if (saveResult.success) {
                        savedCount++;
                    } else {
                        failedCount++;
                        console.error('Save returned failure:', saveResult);
                    }
                } catch (err) {
                    failedCount++;
                    console.error('Save failed:', imagePath, err);
                }
                
                // 진행률 업데이트
                const percent = Math.round(((i + 1) / totalCount) * 100);
                showToast(`저장 중... ${i + 1}/${totalCount} (${percent}%)`, 'info', 0);
            }
            
            if (savedCount > 0) {
                showToast(`저장 완료: ${savedCount}/${totalCount} 이미지`, 'success');
                
                // 검열 후 폴더를 저장된 폴더로 변경
                censorState.currentCensoredFolder = outputFolder;
                document.getElementById('censorCensoredFolderName').textContent = outputFolder || 'censored';
                
                // 저장된 이미지들의 censored 캐시 무효화 (덮어쓴 파일의 이전 캐시 제거)
                censorState.processingImages.forEach(imagePath => {
                    // Windows/Unix 경로 모두 처리
                    const filename = imagePath.split(/[\/\\]/).pop();
                    const censoredPath = outputFolder ? `${outputFolder}/${filename}` : filename;
                    const cacheKey = `censored:${censoredPath}`;
                    console.log('[Cache] Deleting:', cacheKey, 'exists:', censorState.imgCache.has(cacheKey));
                    censorState.imgCache.delete(cacheKey);
                });
                // 전체 censored 캐시도 삭제 (확실하게)
                for (const key of censorState.imgCache.keys()) {
                    if (key.startsWith('censored:')) {
                        console.log('[Cache] Also deleting:', key);
                        censorState.imgCache.delete(key);
                    }
                }
            } else if (failedCount > 0) {
                showToast(`저장 실패: ${failedCount}개 이미지`, 'error');
            } else {
                showToast('저장할 검열 영역이 없습니다', 'warning');
            }
            
            // 검열중 모드 종료
            exitProcessingMode();

            // 검열후 탭 인덱스 리셋 (첫 이미지부터 보여주기 위해)
            censorState.afterIndex = 0;
            censorState.currentIndex = 0;

            // 검열된 이미지 목록 클리어 (새로 로드하도록)
            censorState.censoredImages = [];
            
            // 강제 새로고침 플래그 설정
            censorState.forceReloadAfterTab = true;

            // 검열 후 탭으로 전환
            switchCensorTab('after');
        }
        
        // 검열중 모드 취소/종료
        function exitProcessingMode() {
            censorState.processingMode = false;
            censorState.processingResults = {};
            censorState.processingImages = [];
            censorState.editBoxes = [];
            censorState.detections = [];
            censorState.currentImage = null;
            censorState.originalImageObj = null;
            
            // 캔버스 클리어
            if (censorPreviewCtx) {
                censorPreviewCtx.clearRect(0, 0, censorPreviewCanvas.width, censorPreviewCanvas.height);
            }
            if (censorOverlayCtx) {
                censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);
            }
            
            // 검열중 탭 숨김
            document.getElementById('censorTabProcessing').style.display = 'none';
        }
        
        // 검열 취소
        function cancelCensoring() {
            exitProcessingMode();
            switchCensorTab('before');
        }
        
        // 탭 전환
        function switchCensorTab(tab) {
            // 현재 탭의 인덱스 저장
            if (censorState.currentTab === 'before') {
                censorState.beforeIndex = censorState.currentIndex;
            } else if (censorState.currentTab === 'after') {
                censorState.afterIndex = censorState.currentIndex;
            }

            censorState.currentTab = tab;

            // 새 탭의 인덱스 복원
            if (tab === 'before') {
                // 검열전 탭: 첫 방문이면 0, 아니면 저장된 인덱스
                if (!censorState.beforeTabVisited) {
                    censorState.currentIndex = 0;
                    censorState.beforeTabVisited = true;
                } else {
                    censorState.currentIndex = censorState.beforeIndex;
                }
            } else if (tab === 'after') {
                // 검열후 탭: 항상 저장된 인덱스 사용 (기본값 0)
                censorState.currentIndex = censorState.afterIndex;
            } else {
                censorState.currentIndex = 0;
            }

            // 휠 디바운스 타이머 클리어
            if (censorState.wheelDebounceTimer) {
                clearTimeout(censorState.wheelDebounceTimer);
                censorState.wheelDebounceTimer = null;
            }
            
            // 스캔 로딩 숨기기 + 진행 중인 스캔 무효화
            showCensorScanLoading(false);
            censorState.wheelRequestId++;  // 진행 중인 스캔 결과 무시하도록

            // 탭 버튼 활성화 상태
            document.getElementById('censorTabBefore').classList.toggle('active', tab === 'before');
            document.getElementById('censorTabProcessing').classList.toggle('active', tab === 'processing');
            document.getElementById('censorTabAfter').classList.toggle('active', tab === 'after');

            // 하단 옵션 패널 표시 (기존 호환용 - 숨김 처리됨)
            document.getElementById('censorOptionsBefore').style.display = tab === 'before' ? 'flex' : 'none';
            document.getElementById('censorOptionsProcessing').style.display = tab === 'processing' ? 'flex' : 'none';
            document.getElementById('censorOptionsAfter').style.display = tab === 'after' ? 'flex' : 'none';

            // 우측 패널 섹션 표시/숨김
            const sideModel = document.getElementById('censorSideModel');
            const sideTargets = document.getElementById('censorSideTargets');
            const sideTools = document.getElementById('censorSideTools');
            const sideToolsAfter = document.getElementById('censorSideToolsAfter');
            const sideShortcuts = document.getElementById('censorSideShortcuts');
            const runAllBtn = document.getElementById('censorRunAllBtn');
            const completeBtn = document.getElementById('censorCompleteBtn');
            const cancelBtn = document.getElementById('censorCancelBtn');
            const afterSaveBtn = document.getElementById('censorAfterSaveBtn');

            // 검열전: 모델/감지대상 표시, 도구/단축키 숨김
            // 검열중/후: 모델/감지대상 숨김, 도구/단축키 표시
            if (sideModel) sideModel.style.display = tab === 'before' ? 'block' : 'none';
            if (sideTargets) sideTargets.style.display = tab === 'before' ? 'block' : 'none';
            if (sideTools) sideTools.style.display = tab === 'processing' ? 'block' : 'none';
            if (sideToolsAfter) sideToolsAfter.style.display = tab === 'after' ? 'block' : 'none';
            if (sideShortcuts) sideShortcuts.style.display = (tab === 'processing' || tab === 'after') ? 'block' : 'none';

            // 액션 버튼 표시/숨김
            if (runAllBtn) runAllBtn.style.display = tab === 'before' ? 'block' : 'none';
            if (completeBtn) completeBtn.style.display = tab === 'processing' ? 'block' : 'none';
            if (cancelBtn) cancelBtn.style.display = tab === 'processing' ? 'block' : 'none';
            if (afterSaveBtn) afterSaveBtn.style.display = tab === 'after' ? 'block' : 'none';

            // 프리뷰 영역 배경 구분 (검열중 탭만 다른 배경)
            document.querySelector('.censor-preview-area')?.classList.toggle('processing', tab === 'processing');

            // 검열전 탭 안내 문구: 검열전 탭이고 이미지가 1개 이상 있을 때만 표시
            const previewHint = document.getElementById('censorPreviewHint');
            if (previewHint) {
                previewHint.style.display = (tab === 'before' && censorState.images.length > 0) ? 'block' : 'none';
            }

            // 네비게이션 화살표 및 카운터 항상 표시
            const navLeft = document.getElementById('censorNavLeft');
            const navRight = document.getElementById('censorNavRight');
            const imageCounter = document.getElementById('censorImageCounter');

            // 모든 탭에서 표시
            navLeft.style.display = 'flex';
            navRight.style.display = 'flex';
            imageCounter.style.display = 'block';

            // 초기 상태 설정
            navLeft.disabled = true;
            navRight.disabled = true;
            imageCounter.textContent = '0 / 0';
            
            // 탭 전환 시 캔버스 및 상태 초기화
            if (censorPreviewCtx) {
                censorPreviewCtx.clearRect(0, 0, censorPreviewCanvas.width, censorPreviewCanvas.height);
            }
            if (censorOverlayCtx) {
                censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);
            }
            // 빈 상태 표시 (탭에 따라 드롭존 또는 empty 메시지)
            const dropzone = document.getElementById('censorDropzone');
            const emptyEl = document.getElementById('censorPreviewEmpty');
            const emptyIcon = emptyEl.querySelector('.icon');
            const emptyText = emptyEl.querySelector('p');

            if (tab === 'before') {
                // 검열전 탭: 드롭존 표시, empty 숨김
                dropzone.style.display = 'block';
                emptyEl.style.display = 'none';
            } else {
                // 검열중/후 탭: 드롭존 숨김, empty 표시
                dropzone.style.display = 'none';
                emptyEl.style.display = 'flex';
                if (tab === 'after') {
                    emptyIcon.textContent = '📭';
                    emptyText.textContent = '검열된 이미지가 없습니다';
                } else {
                    emptyIcon.textContent = '⏳';
                    emptyText.textContent = '검열 중인 이미지가 없습니다';
                }
            }

            // 이전 탭의 detections/editBoxes 상태 초기화
            censorState.detections = [];
            censorState.editBoxes = [];
            censorState.selectedBoxIndex = -1;
            censorState.hoverBoxIndex = -1;
            censorState.currentImage = null;
            censorState.originalImageObj = null;
            
            // 드롭존/썸네일 UI 업데이트 (검열 전 탭용)
            updateCensorDropzoneUI();
            
            // 폴더 드롭다운은 항상 표시 (저장 위치 선택용)
            
            // 검열중 탭이면 processingImages 기반 썸네일 렌더링
            if (tab === 'processing') {
                // 도구 상태 초기화
                censorState.currentTool = 'select';
                censorState.selectedBoxIndex = -1;
                censorState.hoverBoxIndex = -1;
                // 도구 버튼 활성화 상태 초기화
                ['procToolSelect', 'procToolAdd', 'procToolDelete'].forEach((id, i) => {
                    document.getElementById(id)?.classList.toggle('active', i === 0);
                });
                
                renderProcessingThumbnails();
                if (censorState.processingImages.length > 0) {
                    selectProcessingImage(0);
                }
            } else if (tab === 'after') {
                // 검열후 탭 도구 상태 초기화
                censorState.currentTool = 'select';
                censorState.selectedBoxIndex = -1;
                censorState.hoverBoxIndex = -1;
                censorState.afterEditDirty = false;
                // 도구 버튼 활성화 상태 초기화
                ['afterToolSelect', 'afterToolAdd', 'afterToolDelete'].forEach((id, i) => {
                    document.getElementById(id)?.classList.toggle('active', i === 0);
                });
                // 저장 버튼 비활성화
                const saveBtn = document.getElementById('censorAfterSaveBtn');
                if (saveBtn) {
                    saveBtn.disabled = true;
                }

                // 이미지 목록이 비어있거나 강제 새로고침이면 새로 로드
                const currentImages = censorState.censoredImages;
                if (currentImages.length === 0 || censorState.forceReloadAfterTab) {
                    censorState.forceReloadAfterTab = false;
                    // 새로 로드 후 첫 이미지 선택
                    loadCensorImages().then(() => {
                        if (censorState.censoredImages.length > 0) {
                            selectCensorImage(0);
                        }
                    });
                } else {
                    // 기존 이미지로 썸네일만 렌더링
                    renderCensorThumbnails(currentImages);
                    // 저장된 인덱스의 이미지 선택
                    const validIndex = Math.min(censorState.currentIndex, currentImages.length - 1);
                    selectCensorImage(validIndex);
                }
            } else {
                // 검열 전 탭: 드롭 모드 (서버 로드 안 함)
                const currentImages = censorState.images;
                updateCensorDropzoneUI();

                // 항상 썸네일 렌더링 (이전 탭 썸네일 제거 위해)
                renderCensorThumbnails(currentImages);

                if (currentImages.length > 0) {
                    // 저장된 인덱스의 이미지 선택
                    const validIndex = Math.min(censorState.currentIndex, currentImages.length - 1);
                    if (validIndex >= 0) {
                        selectCensorImage(validIndex);
                    }
                }
            }
        }
        
        // 검열중 탭 썸네일 렌더링
        function renderProcessingThumbnails() {
            const container = document.getElementById('censorThumbnails');
            const imageKeys = censorState.processingImages;
            
            if (imageKeys.length === 0) {
                container.innerHTML = '<div class="censor-loading">검열 대상이 없습니다</div>';
                return;
            }
            
            // processingResults에서 이미지 정보 찾기
            container.innerHTML = imageKeys.map((key, index) => {
                const result = censorState.processingResults[key];
                const imgInfo = result?.imgInfo;
                const thumb = imgInfo?.thumbnail || '';
                // 드롭된 이미지는 thumbnail이 이미 dataURL
                const thumbSrc = thumb.startsWith('data:') ? thumb : `data:image/jpeg;base64,${thumb}`;
                return `
                    <div class="censor-thumbnail ${index === 0 ? 'active' : ''}" 
                         data-index="${index}" data-key="${key}">
                        <img src="${thumbSrc}" alt="${imgInfo?.filename || ''}">
                    </div>
                `;
            }).join('');
            
            // 클릭 이벤트
            container.querySelectorAll('.censor-thumbnail').forEach(thumb => {
                thumb.onclick = async () => {
                    const index = parseInt(thumb.dataset.index);
                    await selectProcessingImage(index);
                };
            });
        }
        
        // 이벤트 설정
        function setupCensorEvents() {
            // 드롭존 이벤트 설정
            setupDropzoneEvents();
            
            // 탭 전환
            document.getElementById('censorTabBefore').onclick = () => {
                if (censorState.processingMode) {
                    if (!confirm('검열 작업이 진행중입니다. 취소하시겠습니까?')) return;
                    exitProcessingMode();
                }
                switchCensorTab('before');
            };
            document.getElementById('censorTabProcessing').onclick = () => {
                if (censorState.processingMode) {
                    switchCensorTab('processing');
                }
            };
            document.getElementById('censorTabAfter').onclick = () => {
                if (censorState.processingMode) {
                    if (!confirm('검열 작업이 진행중입니다. 취소하시겠습니까?')) return;
                    exitProcessingMode();
                }
                // 검열후 탭으로 전환 시 항상 afterIndex 값 사용 (탭 간 이동 시 인덱스 독립)
                switchCensorTab('after');
            };
            
            // 모델 변경
            document.getElementById('censorModel').onchange = async function() {
                await loadModelClasses(this.value);
                if (censorState.currentImage && censorState.currentTab === 'before') {
                    await scanCurrentImage();
                }
                saveCensorSettings();
            };
            // 확장 픽셀 슬라이더
            const expandSlider = document.getElementById('censorExpandPixels');
            expandSlider.oninput = function() {
                censorState.expandPixels = parseInt(this.value);
                document.getElementById('censorExpandValue').textContent = this.value;
                // 검열전 탭: 박스 시각화 갱신
                if (censorState.currentTab === 'before') {
                    drawDetectionBoxes();
                }
                // 검열중/후 탭: 프리뷰 갱신 요청 (디바운스)
                else if (censorState.currentTab === 'processing' || censorState.currentTab === 'after') {
                    requestCensorPreviewUpdate();
                }
                saveCensorSettings();
            };

            // 부드럽게 슬라이더
            const featherSlider = document.getElementById('censorFeather');
            featherSlider.oninput = function() {
                censorState.feather = parseInt(this.value);
                document.getElementById('censorFeatherValue').textContent = this.value;
                // 검열전 탭: 박스 시각화 갱신
                if (censorState.currentTab === 'before') {
                    drawDetectionBoxes();
                }
                // 검열중/후 탭: 프리뷰 갱신 요청 (디바운스)
                else if (censorState.currentTab === 'processing' || censorState.currentTab === 'after') {
                    requestCensorPreviewUpdate();
                }
                saveCensorSettings();
            };

            // 검열 후 탭 폴더 드롭다운 버튼 클릭 이벤트 (검열 전 폴더 드롭다운은 제거됨)
            const censoredFolderBtn = document.getElementById('censorCensoredFolderBtn');
            if (censoredFolderBtn) {
                censoredFolderBtn.onclick = (e) => toggleCensorFolderMenu('censored', e);
            }
            
            // 외부 클릭 시 폴더 메뉴 닫기 (검열 후 탭용)
            document.addEventListener('click', (e) => {
                const folderAfter = document.getElementById('censorFolderAfter');
                const menuAfter = document.getElementById('censorCensoredFolderMenu');
                
                if (folderAfter && !folderAfter.contains(e.target) && menuAfter && !menuAfter.contains(e.target)) {
                    if (menuAfter.classList.contains('show')) {
                        menuAfter.classList.remove('show');
                        if (menuAfter.parentElement === document.body) {
                            folderAfter.appendChild(menuAfter);
                        }
                    }
                }
            });
            
            // 검열 후 폴더 추가 버튼
            const addCensoredBtn = document.getElementById('censorAddCensoredBtn');
            if (addCensoredBtn) {
                addCensoredBtn.onclick = () => {
                    closeCensorFolderMenus();
                    showInputModal('📁 새 폴더', '폴더 이름을 입력하세요', async (folderName) => {
                        if (!folderName) return;
                        try {
                            const response = await fetch(`${API_BASE}/api/censor/folders`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ type: 'censored', name: folderName })
                            });
                            const result = await response.json();
                            if (result.success) {
                                showToast(`폴더 생성: ${folderName}`, 'success');
                                selectCensorFolder('censored', folderName);
                            } else {
                                showToast(result.error || '폴더 생성 실패', 'error');
                            }
                        } catch (err) {
                            showToast('폴더 생성 오류', 'error');
                        }
                    });
                };
            }
            
            // 폴더 열기 버튼 (검열 후/검열중 탭용: outputs/censored 폴더 열기)
            const openFolderBtn = document.getElementById('censorOpenFolderBtn');
            if (openFolderBtn) {
                openFolderBtn.onclick = () => {
                    // 검열 전 탭에서는 버튼이 숨겨져 있으므로 여기에 올 수 없지만, 안전하게 체크
                    if (censorState.currentTab === 'before') return;
                    
                    // openFolder 함수 사용 (통일)
                    const subfolder = censorState.currentCensoredFolder || '';
                    openFolder('censored', subfolder);
                };
            }
            
            // 전체 검열 실행
            document.getElementById('censorRunAllBtn').onclick = runBatchCensor;

            // === 네비게이션 화살표 버튼 ===
            document.getElementById('censorNavLeft').onclick = () => {
                if (censorState.currentIndex > 0) {
                    if (censorState.currentTab === 'processing') {
                        selectProcessingImage(censorState.currentIndex - 1);
                    } else {
                        // before, after 탭 모두 selectCensorImage 사용
                        selectCensorImage(censorState.currentIndex - 1);
                    }
                }
            };
            document.getElementById('censorNavRight').onclick = () => {
                const maxIndex = censorState.currentTab === 'processing'
                    ? censorState.processingImages.length - 1
                    : censorState.currentTab === 'before'
                    ? censorState.images.length - 1
                    : censorState.censoredImages.length - 1;

                if (censorState.currentIndex < maxIndex) {
                    if (censorState.currentTab === 'processing') {
                        selectProcessingImage(censorState.currentIndex + 1);
                    } else {
                        // before, after 탭 모두 selectCensorImage 사용
                        selectCensorImage(censorState.currentIndex + 1);
                    }
                }
            };

            // === UI 즉시 업데이트 헬퍼 함수 ===
            function updateCensorNavigationUI(index, maxIndex) {
                // 썸네일 활성화 표시
                document.querySelectorAll('.censor-thumbnail').forEach((t, i) => {
                    t.classList.toggle('active', i === index);
                });

                // 이미지 번호 표시
                document.getElementById('censorImageCounter').textContent = `${index + 1} / ${maxIndex + 1}`;

                // 화살표 버튼 활성화/비활성화
                const leftBtn = document.getElementById('censorNavLeft');
                const rightBtn = document.getElementById('censorNavRight');
                leftBtn.disabled = index === 0;
                rightBtn.disabled = index === maxIndex;
            }

            // === 마우스 휠로 이미지 전환 ===
            const censorPreviewArea = document.querySelector('.censor-preview-area');

            // 휠 핸들러 함수 (중복 등록 방지를 위해 명명)
            if (!window.censorWheelHandler) {
                window.censorWheelHandler = (e) => {
                    e.preventDefault();

                    const delta = e.deltaY;

                    // 현재 탭의 최대 인덱스 계산
                    const maxIndex = censorState.currentTab === 'processing'
                        ? censorState.processingImages.length - 1
                        : censorState.currentTab === 'before'
                        ? censorState.images.length - 1
                        : censorState.censoredImages.length - 1;

                    // 새 인덱스 계산
                    let newIndex = censorState.currentIndex;
                    if (delta > 0 && newIndex < maxIndex) {
                        newIndex++;
                    } else if (delta < 0 && newIndex > 0) {
                        newIndex--;
                    }

                    // 인덱스가 변경된 경우에만 처리
                    if (newIndex !== censorState.currentIndex) {
                        // 검열전 탭: 스캔 디바운스 처리
                        if (censorState.currentTab === 'before') {
                            // 즉시 이미지만 로드 (스캔은 스킵)
                            selectCensorImage(newIndex, { skipScan: true });
                            
                            // 로딩 표시
                            showCensorScanLoading(true);
                            
                            // 스캔은 휠 멈춘 후에만 실행
                            if (censorState.wheelDebounceTimer) {
                                clearTimeout(censorState.wheelDebounceTimer);
                            }
                            censorState.wheelDebounceTimer = setTimeout(async () => {
                                const scanRequestId = censorState.wheelRequestId;
                                if (censorState.currentImage) {
                                    await scanCurrentImage();
                                    // 스캔 완료 후 다른 이미지로 넘어갔으면 무시
                                    if (scanRequestId === censorState.wheelRequestId) {
                                        showCensorScanLoading(false);
                                        drawCensorPreview();
                                    }
                                }
                            }, 200);
                        } else if (censorState.currentTab === 'processing') {
                            // 검열중 탭: selectProcessingImage 사용
                            selectProcessingImage(newIndex);
                        } else {
                            // 검열후 탭: 일반 selectCensorImage 사용
                            selectCensorImage(newIndex);
                        }
                    }
                };
            }

            // 프리뷰 영역 전체에 휠 이벤트 등록 (이미지 배경에서도 작동)
            if (censorPreviewArea) {
                censorPreviewArea.removeEventListener('wheel', window.censorWheelHandler);
                censorPreviewArea.addEventListener('wheel', window.censorWheelHandler, { passive: false });
            }

            // 썸네일 리스트에는 좌우 스크롤 허용 (기본 동작)
            const censorThumbnails = document.getElementById('censorThumbnails');
            if (censorThumbnails) {
                censorThumbnails.addEventListener('wheel', (e) => {
                    // 썸네일 영역에서는 좌우 스크롤만 허용 (이미지 전환 방지)
                    e.stopPropagation();
                    // 세로 휠을 가로 스크롤로 변환
                    if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
                        censorThumbnails.scrollLeft += e.deltaY;
                        e.preventDefault();
                    }
                }, { passive: false });
            }

            // === 우클릭으로 박스 삭제 ===
            const censorOverlayCanvas = document.getElementById('censorOverlayCanvas');
            censorOverlayCanvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();

                if (!censorState.currentImage) return;

                // 편집 불가능한 탭(검열전)에서는 삭제 비활성화
                if (!isEditableTab()) return;

                // 클릭 위치 계산 (canvasToImageCoords 사용)
                const coords = canvasToImageCoords(e);
                const imgX = coords.imageX;
                const imgY = coords.imageY;

                // 클릭 위치의 박스 찾기
                for (let i = censorState.editBoxes.length - 1; i >= 0; i--) {
                    const box = censorState.editBoxes[i].box;
                    const [x1, y1, x2, y2] = box;
                    if (imgX >= x1 && imgX <= x2 && imgY >= y1 && imgY <= y2) {
                        // 박스 삭제
                        censorState.editBoxes.splice(i, 1);
                        censorState.selectedBoxIndex = -1;
                        censorState.hoverBoxIndex = -1;

                        // 검열중 탭: processingResults에도 반영
                        if (censorState.currentTab === 'processing' && censorState.currentImage) {
                            const path = censorState.currentImage.path;
                            if (censorState.processingResults[path]) {
                                censorState.processingResults[path].editBoxes = [...censorState.editBoxes];
                            }
                        }

                        // 검열후 탭: dirty 표시
                        if (censorState.currentTab === 'after') {
                            markAfterEditDirty();
                        }

                        // 박스가 삭제되었으므로 캐시 무효화
                        cachedApiPreviewImage = null;
                        cachedApiPreviewKey = null;
                        redrawCurrentTab();
                        break;
                    }
                }
            });

            // === 검열중 탭 이벤트 ===
            // 검열중/검열후 탭에서도 공통 네비게이션 화살표 사용 (censorNavLeft/Right)
            // 화살표 버튼 이벤트는 아래 "=== 네비게이션 화살표 버튼 ===" 섹션에서 처리됨

            document.getElementById('censorCompleteBtn').onclick = completeCensoring;
            document.getElementById('censorCancelBtn').onclick = cancelCensoring;
            
            // 검열 방식 변경 시 재렌더링 (모든 탭 공통)
            document.getElementById('censorMethod').onchange = function() {
                censorState.processingMethod = this.value;
                const newMethod = this.value;

                if (censorState.currentTab === 'processing') {
                    // 검열중 탭: 모든 이미지의 박스 방식 변경
                    censorState.editBoxes.forEach(box => {
                        box.method = newMethod;
                    });
                    // processingResults의 모든 이미지에도 적용
                    for (const key of Object.keys(censorState.processingResults)) {
                        const result = censorState.processingResults[key];
                        if (result.editBoxes) {
                            result.editBoxes.forEach(box => {
                                box.method = newMethod;
                            });
                        }
                    }
                    redrawCurrentTab();
                } else if (censorState.currentTab === 'after') {
                    // 검열후 탭: 현재 이미지만 변경
                    censorState.editBoxes.forEach(box => {
                        box.method = newMethod;
                    });
                    redrawCurrentTab();
                } else if (censorState.currentTab === 'before') {
                    // 검열전 탭: 프리뷰 박스 색상만 변경
                    drawEditBoxes();
                }
                saveCensorSettings();
            };

            // 검열중 탭 도구 버튼
            const procToolBtns = ['procToolSelect', 'procToolAdd', 'procToolDelete'];
            procToolBtns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.onclick = function() {
                        procToolBtns.forEach(bid => {
                            document.getElementById(bid)?.classList.remove('active');
                        });
                        this.classList.add('active');
                        if (id === 'procToolSelect') censorState.currentTool = 'select';
                        else if (id === 'procToolAdd') censorState.currentTool = 'add';
                        else if (id === 'procToolDelete') censorState.currentTool = 'delete';
                        // 도구 변경 시 호버 상태 초기화 및 재렌더링
                        censorState.hoverBoxIndex = -1;
                        if (censorState.currentTab === 'processing') {
                            redrawProcessingPreview();
                        }
                    };
                }
            });
            
            // === 검열 후 탭 이벤트 ===
            // 검열후 탭에서도 공통 네비게이션 화살표 사용 (censorNavLeft/Right)
            // 화살표 버튼 이벤트는 위 "=== 네비게이션 화살표 버튼 ===" 섹션에서 처리됨

            // 검열후 탭 도구 버튼
            const afterToolBtns = ['afterToolSelect', 'afterToolAdd', 'afterToolDelete'];
            afterToolBtns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.onclick = function() {
                        afterToolBtns.forEach(bid => {
                            document.getElementById(bid)?.classList.remove('active');
                        });
                        this.classList.add('active');
                        if (id === 'afterToolSelect') censorState.currentTool = 'select';
                        else if (id === 'afterToolAdd') censorState.currentTool = 'add';
                        else if (id === 'afterToolDelete') censorState.currentTool = 'delete';
                        // 도구 변경 시 호버 상태 초기화 및 재렌더링
                        censorState.hoverBoxIndex = -1;
                        if (censorState.currentTab === 'after') {
                            redrawAfterPreview();
                        }
                    };
                }
            });
            
            // 검열후 탭 저장 버튼
            document.getElementById('censorAfterSaveBtn').onclick = saveAfterEdit;

            // 캔버스 마우스 이벤트
            setupCensorCanvasEvents();
            
            // 윈도우 리사이즈 대응
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                if (currentMode !== 'censor') return;
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (censorState.currentImage) {
                        drawCensorPreview();
                    }
                }, 100);
            });
            
            // 키보드 이벤트 (Delete 키, 숫자키)
            document.addEventListener('keydown', (e) => {
                // 검열 모드가 활성화되어 있는지 확인
                if (currentMode !== 'censor') return;

                // 입력 필드에서는 무시
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

                // 숫자키로 모드 전환 (1: 선택, 2: 추가, 3: 삭제) - 편집 가능 탭에서만
                if ((e.key === '1' || e.key === '2' || e.key === '3') && isEditableTab()) {
                    e.preventDefault();
                    const newTool = e.key === '1' ? 'select' : e.key === '2' ? 'add' : 'delete';
                    censorState.currentTool = newTool;

                    // 버튼 UI 업데이트
                    if (censorState.currentTab === 'processing') {
                        const procToolBtns = ['procToolSelect', 'procToolAdd', 'procToolDelete'];
                        procToolBtns.forEach(id => document.getElementById(id)?.classList.remove('active'));
                        const activeBtn = e.key === '1' ? 'procToolSelect' : e.key === '2' ? 'procToolAdd' : 'procToolDelete';
                        document.getElementById(activeBtn)?.classList.add('active');
                    } else if (censorState.currentTab === 'after') {
                        const afterToolBtns = ['afterToolSelect', 'afterToolAdd', 'afterToolDelete'];
                        afterToolBtns.forEach(id => document.getElementById(id)?.classList.remove('active'));
                        const activeBtn = e.key === '1' ? 'afterToolSelect' : e.key === '2' ? 'afterToolAdd' : 'afterToolDelete';
                        document.getElementById(activeBtn)?.classList.add('active');
                    }

                    redrawCurrentTab();
                    return;
                }

                // Delete 키로 선택된 박스 삭제 (편집 가능 탭에서만)
                if (e.key === 'Delete' && censorState.selectedBoxIndex >= 0 && isEditableTab()) {
                    e.preventDefault();

                    // 선택된 박스 삭제
                    censorState.editBoxes.splice(censorState.selectedBoxIndex, 1);
                    censorState.selectedBoxIndex = -1;
                    censorState.hoverBoxIndex = -1;

                    // 검열중 탭: processingResults에도 반영
                    if (censorState.currentTab === 'processing' && censorState.currentImage) {
                        const path = censorState.currentImage.path;
                        if (censorState.processingResults[path]) {
                            censorState.processingResults[path].editBoxes = [...censorState.editBoxes];
                        }
                    }

                    // 검열후 탭: dirty 표시
                    if (censorState.currentTab === 'after') {
                        markAfterEditDirty();
                    }

                    redrawCurrentTab();
                }
            });
        }
        
        // === 편집 모달 함수들 ===
        async function openEditModal() {
            if (!censorState.currentImage) {
                showToast('편집할 이미지가 없습니다', 'warning');
                return;
            }
            
            const imagePath = censorState.currentImage.path;  // test/102.png (하위폴더 포함)
            const filename = censorState.currentImage.filename;  // 102.png
            
            // censored 폴더에서 이미 검열된 이미지 로드 (새 박스 추가만 가능)
            try {
                const response = await fetch(`${API_BASE}/api/censor/image?path=${encodeURIComponent(imagePath)}&source=censored`);
                const result = await response.json();
                
                if (!result.success || !result.image) {
                    showToast('검열된 이미지를 찾을 수 없습니다', 'warning');
                    return;
                }
                
                censorState.editModalOpen = true;
                censorState.editModalImage = {
                    path: imagePath,
                    filename: filename,
                    width: result.width,
                    height: result.height,
                    image: result.image
                };
                censorState.editModalOriginal = null;
                censorState.currentTool = 'box';  // 기본 도구를 박스 추가로 설정
                censorState.selectedBoxIndex = -1;
                
                document.getElementById('censorEditModal').classList.add('show');
                
                // 검열된 이미지로 모달 캔버스 설정 (이미지 로드 완료까지 대기)
                await setupEditModalCanvas();
                
                // 빈 박스 목록으로 시작 (새 박스 추가만 가능, 기존 검열은 이미지에 적용됨)
                censorState.editModalBoxes = [];
                drawEditModalPreview();
                
            } catch (err) {
                console.error('Failed to open edit modal:', err);
                showToast('편집 모달 열기 실패', 'error');
            }
        }
        
        function closeEditModal() {
            censorState.editModalOpen = false;
            censorState.editModalImage = null;
            censorState.editModalBoxes = [];
            document.getElementById('censorEditModal').classList.remove('show');
        }
        
        function setupEditModalCanvas() {
            return new Promise((resolve) => {
                const canvas = document.getElementById('censorEditCanvas');
                const overlay = document.getElementById('censorEditOverlay');
                const ctx = canvas.getContext('2d');
                
                const img = new Image();
                img.onload = () => {
                    censorState.editModalOriginal = img;
                    
                    const container = document.querySelector('.censor-edit-modal-body');
                    const maxW = container.clientWidth - 40;
                    const maxH = container.clientHeight - 40;
                    
                    const scale = Math.min(maxW / img.width, maxH / img.height, 1);
                    const displayW = Math.round(img.width * scale);
                    const displayH = Math.round(img.height * scale);
                    
                    canvas.width = displayW;
                    canvas.height = displayH;
                    overlay.width = displayW;
                    overlay.height = displayH;
                    
                    canvas.style.width = displayW + 'px';
                    canvas.style.height = displayH + 'px';
                    overlay.style.width = displayW + 'px';
                    overlay.style.height = displayH + 'px';
                    overlay.style.position = 'absolute';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    
                    censorState.displayScale = scale;
                    
                    ctx.drawImage(img, 0, 0, displayW, displayH);
                    
                    // 마우스 이벤트 설정
                    setupEditModalCanvasEvents(overlay);
                    
                    resolve();
                };
                img.src = 'data:image/png;base64,' + censorState.editModalImage.image;
            });
        }
        
        async function scanForEditModal() {
            if (!censorState.editModalImage) return;
            
            const model = document.getElementById('censorModel').value;
            const targetLabels = [];
            const labelConf = {};
            
            document.querySelectorAll('#censorTargets input[type="checkbox"]:checked').forEach(cb => {
                const cls = cb.dataset.class;
                targetLabels.push(cls);
                labelConf[cls] = censorState.labelConf[cls] || 0.3;
            });
            
            if (targetLabels.length === 0) {
                // 타겟이 없으면 기본값 사용
                censorState.modelClasses.forEach(cls => {
                    targetLabels.push(cls);
                    labelConf[cls] = 0.3;
                });
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/censor/scan`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_path: censorState.editModalImage.path,
                        model: model,
                        target_labels: targetLabels,
                        label_conf: labelConf
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    const method = document.getElementById('editCensorMethod').value;
                    censorState.editModalBoxes = (result.detections || []).map(d => ({
                        box: [...d.box],
                        label: d.label,
                        method: method
                    }));
                    drawEditModalPreview();
                }
            } catch (err) {
                console.error('Scan failed:', err);
            }
        }
        
        function drawEditModalPreview() {
            const canvas = document.getElementById('censorEditCanvas');
            const overlay = document.getElementById('censorEditOverlay');
            const ctx = canvas.getContext('2d');
            const overlayCtx = overlay.getContext('2d');
            
            if (!censorState.editModalOriginal) return;
            
            const img = censorState.editModalOriginal;
            const scale = censorState.displayScale;
            const method = document.getElementById('editCensorMethod').value;
            
            // 원본 그리기
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // 검열 효과 적용
            censorState.editModalBoxes.forEach(det => {
                const [x1, y1, x2, y2] = det.box;
                const sx = x1 * scale;
                const sy = y1 * scale;
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                const rotation = det.rotation || 0;
                
                if (rotation !== 0) {
                    const cx = sx + sw / 2;
                    const cy = sy + sh / 2;
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(rotation);
                    ctx.translate(-cx, -cy);
                    applyCensorEffect(ctx, sx, sy, sw, sh, det.method || method, img, x1, y1, x2 - x1, y2 - y1);
                    ctx.restore();
                } else {
                    applyCensorEffect(ctx, sx, sy, sw, sh, det.method || method, img, x1, y1, x2 - x1, y2 - y1);
                }
            });
            
            // 오버레이 (호버/선택된 박스에만 핸들 표시)
            overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
            const isDeleteMode = censorState.currentTool === 'delete';
            const canEdit = censorState.currentTool === 'select' || censorState.currentTool === 'add';
            
            censorState.editModalBoxes.forEach((det, index) => {
                const [x1, y1, x2, y2] = det.box;
                const sx = x1 * scale;
                const sy = y1 * scale;
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                const rotation = det.rotation || 0;
                const cx = sx + sw / 2;
                const cy = sy + sh / 2;
                
                const isSelected = index === censorState.selectedBoxIndex;
                const isHovered = index === censorState.hoverBoxIndex;
                const showHandles = canEdit && (isHovered || isSelected);
                
                overlayCtx.save();
                overlayCtx.translate(cx, cy);
                overlayCtx.rotate(rotation);
                overlayCtx.translate(-cx, -cy);
                
                // 삭제 모드에서 호버 시 빨간 강조
                if (isDeleteMode && isHovered) {
                    overlayCtx.strokeStyle = 'rgba(255, 80, 80, 1)';
                    overlayCtx.lineWidth = 3;
                    overlayCtx.setLineDash([]);
                    overlayCtx.strokeRect(sx, sy, sw, sh);
                    overlayCtx.fillStyle = 'rgba(255, 80, 80, 0.3)';
                    overlayCtx.fillRect(sx, sy, sw, sh);
                } else if (showHandles) {
                    // 호버/선택 시 테두리 + 핸들 표시
                    overlayCtx.strokeStyle = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.9)';
                    overlayCtx.lineWidth = 2;
                    overlayCtx.setLineDash([]);
                    overlayCtx.strokeRect(sx, sy, sw, sh);
                    
                    // 리사이즈 핸들
                    const hs = 7;
                    const handleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.95)';
                    overlayCtx.fillStyle = handleColor;
                    
                    // 모서리 핸들
                    overlayCtx.fillRect(sx - hs/2, sy - hs/2, hs, hs);
                    overlayCtx.fillRect(sx + sw - hs/2, sy - hs/2, hs, hs);
                    overlayCtx.fillRect(sx - hs/2, sy + sh - hs/2, hs, hs);
                    overlayCtx.fillRect(sx + sw - hs/2, sy + sh - hs/2, hs, hs);
                    
                    // 변 핸들
                    const ehs = 5;
                    overlayCtx.fillRect(cx - ehs/2, sy - ehs/2, ehs, ehs);
                    overlayCtx.fillRect(cx - ehs/2, sy + sh - ehs/2, ehs, ehs);
                    overlayCtx.fillRect(sx - ehs/2, cy - ehs/2, ehs, ehs);
                    overlayCtx.fillRect(sx + sw - ehs/2, cy - ehs/2, ehs, ehs);
                    
                    // 회전 핸들 (선택된 박스만)
                    if (isSelected) {
                        const rotateY = sy - 25;
                        overlayCtx.beginPath();
                        overlayCtx.strokeStyle = 'rgba(0, 200, 255, 0.8)';
                        overlayCtx.lineWidth = 1;
                        overlayCtx.moveTo(cx, sy);
                        overlayCtx.lineTo(cx, rotateY + 6);
                        overlayCtx.stroke();
                        
                        overlayCtx.fillStyle = 'rgba(0, 200, 255, 1)';
                        overlayCtx.beginPath();
                        overlayCtx.arc(cx, rotateY, 6, 0, Math.PI * 2);
                        overlayCtx.fill();
                        
                        overlayCtx.fillStyle = 'white';
                        overlayCtx.font = '8px sans-serif';
                        overlayCtx.textAlign = 'center';
                        overlayCtx.textBaseline = 'middle';
                        overlayCtx.fillText('↻', cx, rotateY);
                    }
                }
                // 호버/선택 아닐 때는 테두리 없음 (검열 효과만 보임)
                
                overlayCtx.restore();
            });
        }
        
        function setupEditModalCanvasEvents(overlay) {
            overlay.onmousedown = (e) => handleEditModalMouseDown(e, overlay);
            overlay.onmousemove = (e) => handleEditModalMouseMove(e, overlay);
            overlay.onmouseup = handleEditModalMouseUp;
            overlay.onmouseleave = handleEditModalMouseUp;
        }
        
        // 편집 모달용 박스 히트 테스트 (회전 고려)
        function hitTestEditModalBox(imageX, imageY) {
            for (let i = censorState.editModalBoxes.length - 1; i >= 0; i--) {
                const det = censorState.editModalBoxes[i];
                const [x1, y1, x2, y2] = det.box;
                const rotation = det.rotation || 0;
                const cx = (x1 + x2) / 2;
                const cy = (y1 + y2) / 2;
                const cos = Math.cos(-rotation);
                const sin = Math.sin(-rotation);
                const dx = imageX - cx;
                const dy = imageY - cy;
                const localX = cx + dx * cos - dy * sin;
                const localY = cy + dx * sin + dy * cos;
                if (localX >= x1 && localX <= x2 && localY >= y1 && localY <= y2) {
                    return i;
                }
            }
            return -1;
        }
        
        // 편집 모달용 리사이즈/회전 핸들 히트 테스트 (호버/선택된 박스만 체크)
        // 반환: { handle: 'nw'|'ne'|...|'rotate'|null, boxIndex: number }
        function hitTestEditModalResizeHandle(imageX, imageY) {
            const boxes = censorState.editModalBoxes;
            const handleSize = 12 / (censorState.displayScale || 1);
            
            // 호버 또는 선택된 박스만 핸들 체크 (핸들이 보이는 박스만)
            const visibleBoxes = [];
            for (let i = boxes.length - 1; i >= 0; i--) {
                if (i === censorState.selectedBoxIndex || i === censorState.hoverBoxIndex) {
                    visibleBoxes.push(i);
                }
            }
            
            for (const i of visibleBoxes) {
                const det = boxes[i];
                if (!det?.box) continue;
                
                const [x1, y1, x2, y2] = det.box;
                const rotation = det.rotation || 0;
                const cx = (x1 + x2) / 2;
                const cy = (y1 + y2) / 2;
                
                // 마우스 좌표를 박스 중심 기준으로 역회전
                const rotated = rotatePointAroundCenter(imageX, imageY, cx, cy, rotation);
                const rx = rotated.x;
                const ry = rotated.y;
                
                // 회전 핸들 (선택된 박스만)
                if (i === censorState.selectedBoxIndex) {
                    const rotateHandleY = y1 - 25 / (censorState.displayScale || 1);
                    if (Math.abs(rx - cx) < handleSize && Math.abs(ry - rotateHandleY) < handleSize) {
                        return { handle: 'rotate', boxIndex: i };
                    }
                }
                
                // 모서리 핸들 (코너)
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'nw', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'ne', boxIndex: i };
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 'sw', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 'se', boxIndex: i };
                
                // 변 핸들 (엣지)
                if (Math.abs(rx - cx) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'n', boxIndex: i };
                if (Math.abs(rx - cx) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 's', boxIndex: i };
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - cy) < handleSize) return { handle: 'w', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - cy) < handleSize) return { handle: 'e', boxIndex: i };
            }
            
            return { handle: null, boxIndex: -1 };
        }
        
        function handleEditModalMouseDown(e, overlay) {
            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const scale = censorState.displayScale;
            const imageX = x / scale;
            const imageY = y / scale;
            
            censorState.dragStartX = imageX;
            censorState.dragStartY = imageY;
            
            if (censorState.currentTool === 'select') {
                // 리사이즈/회전 핸들 체크 (모든 박스)
                const handleResult = hitTestEditModalResizeHandle(imageX, imageY);
                if (handleResult.handle === 'rotate') {
                    censorState.selectedBoxIndex = handleResult.boxIndex;
                    censorState.isRotating = true;
                    const box = censorState.editModalBoxes[handleResult.boxIndex].box;
                    censorState.rotateCenter = {
                        x: (box[0] + box[2]) / 2,
                        y: (box[1] + box[3]) / 2
                    };
                    overlay.style.cursor = 'grabbing';
                    return;
                } else if (handleResult.handle) {
                    censorState.selectedBoxIndex = handleResult.boxIndex;
                    censorState.isResizing = true;
                    censorState.resizeHandle = handleResult.handle;
                    const box = censorState.editModalBoxes[handleResult.boxIndex].box;
                    const rotation = censorState.editModalBoxes[handleResult.boxIndex].rotation || 0;
                    censorState.dragBoxOriginal = [...box];
                    
                    // 앵커 포인트 계산 (핸들 반대편 코너)
                    const [x1, y1, x2, y2] = box;
                    const cx = (x1 + x2) / 2;
                    const cy = (y1 + y2) / 2;
                    let anchorLocalX, anchorLocalY;
                    switch (handleResult.handle) {
                        // 코너 핸들: 대각선 반대편 코너
                        case 'nw': anchorLocalX = x2; anchorLocalY = y2; break;
                        case 'ne': anchorLocalX = x1; anchorLocalY = y2; break;
                        case 'sw': anchorLocalX = x2; anchorLocalY = y1; break;
                        case 'se': anchorLocalX = x1; anchorLocalY = y1; break;
                        // 엣지 핸들: 대각선 반대편 코너 (코너처럼 처리하되 한 축 고정)
                        case 'n': anchorLocalX = x1; anchorLocalY = y2; break;  // SW
                        case 's': anchorLocalX = x2; anchorLocalY = y1; break;  // NE
                        case 'w': anchorLocalX = x2; anchorLocalY = y1; break;  // NE
                        case 'e': anchorLocalX = x1; anchorLocalY = y2; break;  // SW
                    }
                    // 앵커를 월드 좌표로 변환 (회전 적용) - 월드 좌표만 저장
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    const dx = anchorLocalX - cx;
                    const dy = anchorLocalY - cy;
                    censorState.resizeAnchor = {
                        worldX: cx + dx * cos - dy * sin,
                        worldY: cy + dx * sin + dy * cos
                    };
                    return;
                }
                
                // 박스 선택 (드래그 시작)
                let found = -1;
                for (let i = censorState.editModalBoxes.length - 1; i >= 0; i--) {
                    const det = censorState.editModalBoxes[i];
                    const [x1, y1, x2, y2] = det.box;
                    const rotation = det.rotation || 0;
                    const cx = (x1 + x2) / 2;
                    const cy = (y1 + y2) / 2;
                    const cos = Math.cos(-rotation);
                    const sin = Math.sin(-rotation);
                    const dx = imageX - cx;
                    const dy = imageY - cy;
                    const localX = cx + dx * cos - dy * sin;
                    const localY = cy + dx * sin + dy * cos;
                    if (localX >= x1 && localX <= x2 && localY >= y1 && localY <= y2) {
                        found = i;
                        break;
                    }
                }
                censorState.selectedBoxIndex = found;
                if (found >= 0) {
                    censorState.isDragging = true;
                    censorState.dragBoxOriginal = [...censorState.editModalBoxes[found].box];
                }
                drawEditModalPreview();
            } else if (censorState.currentTool === 'add') {
                // 핸들 위에서 클릭하면 리사이즈 (호버된 박스의 핸들)
                const addHandleResult = hitTestEditModalResizeHandle(imageX, imageY);
                if (addHandleResult.handle && addHandleResult.handle !== 'rotate') {
                    censorState.selectedBoxIndex = addHandleResult.boxIndex;
                    censorState.isResizing = true;
                    censorState.resizeHandle = addHandleResult.handle;
                    const box = censorState.editModalBoxes[addHandleResult.boxIndex].box;
                    const rotation = censorState.editModalBoxes[addHandleResult.boxIndex].rotation || 0;
                    censorState.dragBoxOriginal = [...box];
                    
                    const [x1, y1, x2, y2] = box;
                    const cx = (x1 + x2) / 2;
                    const cy = (y1 + y2) / 2;
                    let anchorLocalX, anchorLocalY;
                    switch (addHandleResult.handle) {
                        case 'nw': anchorLocalX = x2; anchorLocalY = y2; break;
                        case 'ne': anchorLocalX = x1; anchorLocalY = y2; break;
                        case 'sw': anchorLocalX = x2; anchorLocalY = y1; break;
                        case 'se': anchorLocalX = x1; anchorLocalY = y1; break;
                        case 'n': anchorLocalX = x1; anchorLocalY = y2; break;
                        case 's': anchorLocalX = x2; anchorLocalY = y1; break;
                        case 'w': anchorLocalX = x2; anchorLocalY = y1; break;
                        case 'e': anchorLocalX = x1; anchorLocalY = y2; break;
                    }
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    const dx = anchorLocalX - cx;
                    const dy = anchorLocalY - cy;
                    censorState.resizeAnchor = {
                        worldX: cx + dx * cos - dy * sin,
                        worldY: cy + dx * sin + dy * cos
                    };
                } else {
                    // 새 박스 그리기 시작 (선택 해제)
                    censorState.selectedBoxIndex = -1;
                    censorState.isDrawing = true;
                    censorState.newBoxStart = { x: imageX, y: imageY };
                    drawEditModalPreview();
                }
            } else if (censorState.currentTool === 'delete') {
                const deleteIndex = hitTestEditModalBox(imageX, imageY);
                if (deleteIndex >= 0) {
                    censorState.editModalBoxes.splice(deleteIndex, 1);
                    censorState.selectedBoxIndex = -1;
                    censorState.hoverBoxIndex = -1;
                    drawEditModalPreview();
                }
            }
        }
        
        function handleEditModalMouseMove(e, overlay) {
            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const scale = censorState.displayScale;
            const imageX = x / scale;
            const imageY = y / scale;
            
            // 삭제 모드에서 호버 박스 추적
            if (censorState.currentTool === 'delete') {
                const hoverIndex = hitTestEditModalBox(imageX, imageY);
                if (hoverIndex !== censorState.hoverBoxIndex) {
                    censorState.hoverBoxIndex = hoverIndex;
                    drawEditModalPreview();
                }
                overlay.style.cursor = hoverIndex >= 0 ? 'pointer' : 'default';
            }
            // 커서 업데이트 및 호버 추적 (선택/추가 도구)
            else if ((censorState.currentTool === 'select' || censorState.currentTool === 'add') && 
                     !censorState.isDragging && !censorState.isResizing && !censorState.isRotating) {
                // 호버 박스 추적
                const newHoverIndex = hitTestEditModalBox(imageX, imageY);
                if (newHoverIndex !== censorState.hoverBoxIndex) {
                    censorState.hoverBoxIndex = newHoverIndex;
                    drawEditModalPreview();
                }
                
                const handleResult = hitTestEditModalResizeHandle(imageX, imageY);
                if (handleResult.handle) {
                    const cursors = {
                        'n': 'ns-resize', 's': 'ns-resize',
                        'e': 'ew-resize', 'w': 'ew-resize',
                        'nw': 'nwse-resize', 'se': 'nwse-resize',
                        'ne': 'nesw-resize', 'sw': 'nesw-resize',
                        'rotate': 'grab'
                    };
                    overlay.style.cursor = cursors[handleResult.handle];
                } else {
                    const boxIndex = hitTestEditModalBox(imageX, imageY);
                    overlay.style.cursor = boxIndex >= 0 ? 'move' : (censorState.currentTool === 'add' ? 'crosshair' : 'default');
                }
            }
            
            // 드래그 중 (박스 이동)
            if (censorState.isDragging && censorState.selectedBoxIndex >= 0) {
                const dx = imageX - censorState.dragStartX;
                const dy = imageY - censorState.dragStartY;
                const orig = censorState.dragBoxOriginal;
                censorState.editModalBoxes[censorState.selectedBoxIndex].box = [
                    orig[0] + dx, orig[1] + dy, orig[2] + dx, orig[3] + dy
                ];
                drawEditModalPreview();
            }
            
            // 리사이즈 중 (회전 고려, Ctrl: 중심 기준 확장)
            if (censorState.isResizing && censorState.selectedBoxIndex >= 0 && censorState.resizeAnchor) {
                const det = censorState.editModalBoxes[censorState.selectedBoxIndex];
                const rotation = det.rotation || 0;
                const anchor = censorState.resizeAnchor;
                const handle = censorState.resizeHandle;
                const orig = censorState.dragBoxOriginal;
                const isCtrl = e.ctrlKey;
                
                // 마우스 월드 좌표
                const mwx = imageX;
                const mwy = imageY;
                
                let x1, y1, x2, y2;
                const cos = Math.cos(-rotation);
                const sin = Math.sin(-rotation);
                
                if (isCtrl) {
                    // Ctrl 누름: 중심 기준 대칭 확장
                    const [ox1, oy1, ox2, oy2] = orig;
                    const ocx = (ox1 + ox2) / 2;
                    const ocy = (oy1 + oy2) / 2;
                    
                    // 마우스를 원래 중심 기준으로 역회전 → 로컬 좌표
                    const mox = mwx - ocx;
                    const moy = mwy - ocy;
                    const mlx = ocx + mox * cos - moy * sin;
                    const mly = ocy + mox * sin + moy * cos;
                    
                    if (handle === 'nw' || handle === 'ne' || handle === 'sw' || handle === 'se') {
                        // 코너: 중심에서 마우스까지의 거리를 양쪽으로
                        const dx = Math.abs(mlx - ocx);
                        const dy = Math.abs(mly - ocy);
                        x1 = ocx - dx;
                        y1 = ocy - dy;
                        x2 = ocx + dx;
                        y2 = ocy + dy;
                    } else {
                        // 엣지: 해당 축만 대칭 확장
                        x1 = ox1; y1 = oy1; x2 = ox2; y2 = oy2;
                        if (handle === 'n' || handle === 's') {
                            const dy = Math.abs(mly - ocy);
                            y1 = ocy - dy;
                            y2 = ocy + dy;
                        } else {
                            const dx = Math.abs(mlx - ocx);
                            x1 = ocx - dx;
                            x2 = ocx + dx;
                        }
                    }
                } else if (handle === 'nw' || handle === 'ne' || handle === 'sw' || handle === 'se') {
                    // 코너 핸들: 앵커 월드 좌표 고정
                    const wcx = (anchor.worldX + mwx) / 2;
                    const wcy = (anchor.worldY + mwy) / 2;
                    
                    const aox = anchor.worldX - wcx;
                    const aoy = anchor.worldY - wcy;
                    const alx = wcx + aox * cos - aoy * sin;
                    const aly = wcy + aox * sin + aoy * cos;
                    
                    const mox = mwx - wcx;
                    const moy = mwy - wcy;
                    const mlx = wcx + mox * cos - moy * sin;
                    const mly = wcy + mox * sin + moy * cos;
                    
                    x1 = Math.min(alx, mlx);
                    y1 = Math.min(aly, mly);
                    x2 = Math.max(alx, mlx);
                    y2 = Math.max(aly, mly);
                } else {
                    // 엣지 핸들: 마우스의 해당 축만 사용
                    const origWidth = orig[2] - orig[0];
                    const origHeight = orig[3] - orig[1];
                    
                    const dwx = mwx - anchor.worldX;
                    const dwy = mwy - anchor.worldY;
                    const dlx = dwx * cos - dwy * sin;
                    const dly = dwx * sin + dwy * cos;
                    
                    let effectiveDLX, effectiveDLY;
                    switch (handle) {
                        case 'n': effectiveDLX = origWidth; effectiveDLY = dly; break;
                        case 's': effectiveDLX = -origWidth; effectiveDLY = dly; break;
                        case 'w': effectiveDLX = dlx; effectiveDLY = origHeight; break;
                        case 'e': effectiveDLX = dlx; effectiveDLY = -origHeight; break;
                    }
                    
                    const cosR = Math.cos(rotation);
                    const sinR = Math.sin(rotation);
                    const effectiveDWX = effectiveDLX * cosR - effectiveDLY * sinR;
                    const effectiveDWY = effectiveDLX * sinR + effectiveDLY * cosR;
                    
                    const emwx = anchor.worldX + effectiveDWX;
                    const emwy = anchor.worldY + effectiveDWY;
                    
                    const wcx = (anchor.worldX + emwx) / 2;
                    const wcy = (anchor.worldY + emwy) / 2;
                    
                    const aox = anchor.worldX - wcx;
                    const aoy = anchor.worldY - wcy;
                    const alx = wcx + aox * cos - aoy * sin;
                    const aly = wcy + aox * sin + aoy * cos;
                    
                    const emox = emwx - wcx;
                    const emoy = emwy - wcy;
                    const emlx = wcx + emox * cos - emoy * sin;
                    const emly = wcy + emox * sin + emoy * cos;
                    
                    x1 = Math.min(alx, emlx);
                    y1 = Math.min(aly, emly);
                    x2 = Math.max(alx, emlx);
                    y2 = Math.max(aly, emly);
                }
                
                censorState.editModalBoxes[censorState.selectedBoxIndex].box = [x1, y1, x2, y2];
                drawEditModalPreview();
            }
            
            // 회전 중
            if (censorState.isRotating && censorState.selectedBoxIndex >= 0 && censorState.rotateCenter) {
                const cx = censorState.rotateCenter.x;
                const cy = censorState.rotateCenter.y;
                const angle = Math.atan2(imageY - cy, imageX - cx) + Math.PI / 2;
                censorState.editModalBoxes[censorState.selectedBoxIndex].rotation = angle;
                drawEditModalPreview();
            }
            
            // 새 박스 그리는 중 - 프리뷰 표시
            if (censorState.isDrawing && censorState.newBoxStart) {
                drawEditModalPreview();
                // 임시 박스 프리뷰
                const overlayCanvas = document.getElementById('censorEditOverlay');
                const ctx = overlayCanvas.getContext('2d');
                const sx = censorState.newBoxStart.x * scale;
                const sy = censorState.newBoxStart.y * scale;
                const sw = (imageX - censorState.newBoxStart.x) * scale;
                const sh = (imageY - censorState.newBoxStart.y) * scale;
                
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(sx, sy, sw, sh);
                ctx.setLineDash([]);
                
                // 크기 표시
                const w = Math.abs(Math.round(imageX - censorState.newBoxStart.x));
                const h = Math.abs(Math.round(imageY - censorState.newBoxStart.y));
                ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
                ctx.font = '12px monospace';
                ctx.fillText(`${w} x ${h}`, sx + 4, sy - 4);
            }
        }
        
        function handleEditModalMouseUp(e) {
            if (censorState.isDrawing && censorState.newBoxStart) {
                const overlay = document.getElementById('censorEditOverlay');
                const rect = overlay.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const scale = censorState.displayScale;
                const imageX = x / scale;
                const imageY = y / scale;
                
                const x1 = Math.min(censorState.newBoxStart.x, imageX);
                const y1 = Math.min(censorState.newBoxStart.y, imageY);
                const x2 = Math.max(censorState.newBoxStart.x, imageX);
                const y2 = Math.max(censorState.newBoxStart.y, imageY);
                
                if (x2 - x1 > 10 && y2 - y1 > 10) {
                    const method = document.getElementById('editCensorMethod').value;
                    censorState.editModalBoxes.push({
                        box: [x1, y1, x2, y2],
                        label: 'manual',
                        method: method
                    });
                    censorState.selectedBoxIndex = censorState.editModalBoxes.length - 1;
                    drawEditModalPreview();
                }
            }
            
            censorState.isDragging = false;
            censorState.isResizing = false;
            censorState.isRotating = false;
            censorState.isDrawing = false;
            censorState.newBoxStart = null;
            censorState.rotateCenter = null;
            censorState.resizeAnchor = null;
        }
        
        async function saveEditModal() {
            if (!censorState.editModalImage || censorState.editModalBoxes.length === 0) {
                showToast('저장할 박스가 없습니다', 'warning');
                return;
            }
            
            const method = document.getElementById('editCensorMethod').value;
            const boxes = censorState.editModalBoxes.map(d => ({
                box: d.box,
                method: d.method || method,
                rotation: d.rotation || 0  // 회전 값 포함
            }));
            
            const imagePath = censorState.editModalImage.path;
            const pathParts = imagePath.split(/[\/\\]/);  // Windows 백슬래시 지원
            const outputFolder = pathParts.length > 1 ? pathParts.slice(0, -1).join('/') : '';
            
            try {
                const response = await fetch(`${API_BASE}/api/censor/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_path: imagePath,
                        boxes: boxes,
                        method: method,
                        output_folder: outputFolder,
                        filename: censorState.editModalImage.filename,
                        source: 'censored'  // 편집 모달에서는 검열된 이미지 기준
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showToast('저장 완료', 'success');
                    closeEditModal();
                    // 이미지 새로고침
                    loadCensorImages();
                } else {
                    showToast('저장 실패: ' + result.error, 'error');
                }
            } catch (err) {
                showToast('저장 오류: ' + err.message, 'error');
            }
        }
        
        // 커서 업데이트
        function updateCensorCursor() {
            if (!censorOverlayCanvas) return;
            switch (censorState.currentTool) {
                case 'select':
                    censorOverlayCanvas.style.cursor = 'default';
                    break;
                case 'add':
                    censorOverlayCanvas.style.cursor = 'crosshair';
                    break;
                case 'delete':
                    censorOverlayCanvas.style.cursor = 'not-allowed';
                    break;
            }
        }
        
        // 캔버스 마우스 이벤트 설정
        function setupCensorCanvasEvents() {
            if (!censorOverlayCanvas) return;
            
            censorOverlayCanvas.onmousedown = handleCensorMouseDown;
            censorOverlayCanvas.onmousemove = handleCensorMouseMove;
            censorOverlayCanvas.onmouseup = handleCensorMouseUp;
            censorOverlayCanvas.onmouseleave = handleCensorMouseUp;
        }
        
        // 마우스 좌표 → 이미지 좌표 변환
        function canvasToImageCoords(e) {
            const rect = censorOverlayCanvas.getBoundingClientRect();
            
            // CSS 크기와 캔버스 픽셀 크기의 비율 계산
            const scaleX = censorOverlayCanvas.width / rect.width;
            const scaleY = censorOverlayCanvas.height / rect.height;
            
            // 마우스 좌표를 캔버스 픽셀 좌표로 변환
            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;
            
            const scale = censorState.displayScale || 1;
            const offsetX = censorState.overlayOffsetX || 0;
            const offsetY = censorState.overlayOffsetY || 0;
            return {
                canvasX: canvasX,
                canvasY: canvasY,
                imageX: (canvasX - offsetX) / scale,  // X 오프셋 보정
                imageY: (canvasY - offsetY) / scale   // Y 오프셋 보정
            };
        }
        
        // 박스 히트 테스트 (어떤 박스 위에 있는지, 회전 고려)
        function hitTestBox(imageX, imageY) {
            const boxes = censorState.editBoxes.length > 0 ? censorState.editBoxes : censorState.detections;
            for (let i = boxes.length - 1; i >= 0; i--) {
                const det = boxes[i];
                const [x1, y1, x2, y2] = det.box;
                const rotation = det.rotation || 0;
                const cx = (x1 + x2) / 2;
                const cy = (y1 + y2) / 2;
                
                // 마우스 좌표를 박스 중심 기준으로 역회전하여 로컬 좌표로 변환
                const cos = Math.cos(-rotation);
                const sin = Math.sin(-rotation);
                const dx = imageX - cx;
                const dy = imageY - cy;
                const localX = cx + dx * cos - dy * sin;
                const localY = cy + dx * sin + dy * cos;
                
                // 로컬 좌표에서 AABB 체크
                if (localX >= x1 && localX <= x2 && localY >= y1 && localY <= y2) {
                    return i;
                }
            }
            return -1;
        }
        
        // 점을 중심 기준으로 역회전
        function rotatePointAroundCenter(px, py, cx, cy, angle) {
            const cos = Math.cos(-angle);
            const sin = Math.sin(-angle);
            const dx = px - cx;
            const dy = py - cy;
            return {
                x: cx + dx * cos - dy * sin,
                y: cy + dx * sin + dy * cos
            };
        }
        
        // 리사이즈/회전 핸들 히트 테스트 (호버/선택된 박스만)
        // 반환: { handle: 'nw'|'ne'|...|'rotate'|null, boxIndex: number }
        function hitTestResizeHandle(imageX, imageY) {
            const boxes = censorState.editBoxes.length > 0 ? censorState.editBoxes : censorState.detections;
            const handleSize = 12 / (censorState.displayScale || 1);
            
            // 호버 또는 선택된 박스만 핸들 체크 (핸들이 보이는 박스만)
            const visibleBoxes = [];
            for (let i = boxes.length - 1; i >= 0; i--) {
                if (i === censorState.selectedBoxIndex || i === censorState.hoverBoxIndex) {
                    visibleBoxes.push(i);
                }
            }
            
            for (const i of visibleBoxes) {
                const det = boxes[i];
                if (!det?.box) continue;
                
                const [x1, y1, x2, y2] = det.box;
                const rotation = det.rotation || 0;
                const cx = (x1 + x2) / 2;
                const cy = (y1 + y2) / 2;
                
                // 마우스 좌표를 박스 중심 기준으로 역회전
                const rotated = rotatePointAroundCenter(imageX, imageY, cx, cy, rotation);
                const rx = rotated.x;
                const ry = rotated.y;
                
                // 회전 핸들 (선택 또는 호버된 박스 - 둘 다 허용)
                const rotateHandleY = y1 - 25 / (censorState.displayScale || 1);
                if (Math.abs(rx - cx) < handleSize && Math.abs(ry - rotateHandleY) < handleSize) {
                    return { handle: 'rotate', boxIndex: i };
                }
                
                // 모서리 핸들 (코너)
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'nw', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'ne', boxIndex: i };
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 'sw', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 'se', boxIndex: i };
                
                // 변 핸들 (엣지)
                if (Math.abs(rx - cx) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'n', boxIndex: i };
                if (Math.abs(rx - cx) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 's', boxIndex: i };
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - cy) < handleSize) return { handle: 'w', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - cy) < handleSize) return { handle: 'e', boxIndex: i };
            }
            
            return { handle: null, boxIndex: -1 };
        }
        
        // 마우스 다운
        function handleCensorMouseDown(e) {
            if (!censorState.currentImage) return;

            // 편집 불가능한 탭(검열전)에서는 편집 기능 비활성화
            if (!isEditableTab()) return;

            const coords = canvasToImageCoords(e);
            censorState.dragStartX = coords.imageX;
            censorState.dragStartY = coords.imageY;

            // editBoxes가 비어있으면 detections로 초기화 (검열전 탭만)
            // 검열중/검열후 탭은 selectProcessingImage/selectCensorImage에서 이미 로드되므로 제외
            if (censorState.editBoxes.length === 0 && censorState.detections.length > 0 && censorState.currentTab === 'before') {
                censorState.editBoxes = censorState.detections.map(d => ({
                    box: [...d.box],
                    label: d.label,
                    method: document.getElementById('censorMethod')?.value || 'black'
                }));
            }

            switch (censorState.currentTool) {
                case 'select':
                    // 리사이즈/회전 핸들 체크 (모든 박스)
                    const handleResult = hitTestResizeHandle(coords.imageX, coords.imageY);
                    if (handleResult.handle === 'rotate') {
                        censorState.selectedBoxIndex = handleResult.boxIndex;
                        censorState.isRotating = true;
                        const box = censorState.editBoxes[handleResult.boxIndex].box;
                        censorState.rotateCenter = {
                            x: (box[0] + box[2]) / 2,
                            y: (box[1] + box[3]) / 2
                        };
                        censorOverlayCanvas.style.cursor = 'grabbing';
                    } else if (handleResult.handle) {
                        censorState.selectedBoxIndex = handleResult.boxIndex;
                        censorState.isResizing = true;
                        censorState.resizeHandle = handleResult.handle;
                        const box = censorState.editBoxes[handleResult.boxIndex].box;
                        const rotation = censorState.editBoxes[handleResult.boxIndex].rotation || 0;
                        censorState.dragBoxOriginal = [...box];
                        
                        // 앵커 포인트 계산 (핸들 반대편 코너)
                        const [x1, y1, x2, y2] = box;
                        const cx = (x1 + x2) / 2;
                        const cy = (y1 + y2) / 2;
                        let anchorLocalX, anchorLocalY;
                        switch (handleResult.handle) {
                            // 코너 핸들: 대각선 반대편 코너
                            case 'nw': anchorLocalX = x2; anchorLocalY = y2; break;
                            case 'ne': anchorLocalX = x1; anchorLocalY = y2; break;
                            case 'sw': anchorLocalX = x2; anchorLocalY = y1; break;
                            case 'se': anchorLocalX = x1; anchorLocalY = y1; break;
                            // 엣지 핸들: 대각선 반대편 코너 (코너처럼 처리하되 한 축 고정)
                            case 'n': anchorLocalX = x1; anchorLocalY = y2; break;  // SW
                            case 's': anchorLocalX = x2; anchorLocalY = y1; break;  // NE
                            case 'w': anchorLocalX = x2; anchorLocalY = y1; break;  // NE
                            case 'e': anchorLocalX = x1; anchorLocalY = y2; break;  // SW
                        }
                        // 앵커를 월드 좌표로 변환 (회전 적용) - 월드 좌표만 저장
                        const cos = Math.cos(rotation);
                        const sin = Math.sin(rotation);
                        const dx = anchorLocalX - cx;
                        const dy = anchorLocalY - cy;
                        censorState.resizeAnchor = {
                            worldX: cx + dx * cos - dy * sin,
                            worldY: cy + dx * sin + dy * cos
                        };
                    } else {
                        // 박스 선택 (드래그 시작)
                        const hitIndex = hitTestBox(coords.imageX, coords.imageY);
                        if (hitIndex >= 0) {
                            censorState.selectedBoxIndex = hitIndex;
                            censorState.isDragging = true;
                            censorState.dragBoxOriginal = [...censorState.editBoxes[hitIndex].box];
                        } else {
                            censorState.selectedBoxIndex = -1;
                        }
                    }
                    redrawCurrentTab(true);  // 선택 변경만: 오버레이만 갱신
                    break;
                    
                case 'add':
                    // 핸들 위에서 클릭하면 리사이즈/회전 (호버된 박스의 핸들)
                    const addHandleResult = hitTestResizeHandle(coords.imageX, coords.imageY);
                    if (addHandleResult.handle === 'rotate') {
                        // 회전 핸들
                        censorState.selectedBoxIndex = addHandleResult.boxIndex;
                        censorState.isRotating = true;
                        const rotBox = censorState.editBoxes[addHandleResult.boxIndex].box;
                        censorState.rotateCenter = {
                            x: (rotBox[0] + rotBox[2]) / 2,
                            y: (rotBox[1] + rotBox[3]) / 2
                        };
                        censorOverlayCanvas.style.cursor = 'grabbing';
                    } else if (addHandleResult.handle) {
                        // 리사이즈 핸들
                        censorState.selectedBoxIndex = addHandleResult.boxIndex;
                        censorState.isResizing = true;
                        censorState.resizeHandle = addHandleResult.handle;
                        const box = censorState.editBoxes[addHandleResult.boxIndex].box;
                        const rotation = censorState.editBoxes[addHandleResult.boxIndex].rotation || 0;
                        censorState.dragBoxOriginal = [...box];
                        
                        const [x1, y1, x2, y2] = box;
                        const cx = (x1 + x2) / 2;
                        const cy = (y1 + y2) / 2;
                        let anchorLocalX, anchorLocalY;
                        switch (addHandleResult.handle) {
                            case 'nw': anchorLocalX = x2; anchorLocalY = y2; break;
                            case 'ne': anchorLocalX = x1; anchorLocalY = y2; break;
                            case 'sw': anchorLocalX = x2; anchorLocalY = y1; break;
                            case 'se': anchorLocalX = x1; anchorLocalY = y1; break;
                            case 'n': anchorLocalX = x1; anchorLocalY = y2; break;
                            case 's': anchorLocalX = x2; anchorLocalY = y1; break;
                            case 'w': anchorLocalX = x2; anchorLocalY = y1; break;
                            case 'e': anchorLocalX = x1; anchorLocalY = y2; break;
                        }
                        const cos = Math.cos(rotation);
                        const sin = Math.sin(rotation);
                        const dx = anchorLocalX - cx;
                        const dy = anchorLocalY - cy;
                        censorState.resizeAnchor = {
                            worldX: cx + dx * cos - dy * sin,
                            worldY: cy + dx * sin + dy * cos
                        };
                    } else {
                        // 새 박스 그리기 시작 (선택 해제)
                        censorState.selectedBoxIndex = -1;
                        censorState.isDrawing = true;
                        censorState.newBoxStart = { x: coords.imageX, y: coords.imageY };
                        if (censorState.currentTab === 'processing') {
                            drawProcessingOverlay();
                        } else if (censorState.currentTab === 'after') {
                            drawAfterTabBoxOverlay();
                        }
                    }
                    break;
                    
                case 'delete':
                    // 박스 삭제
                    const deleteIndex = hitTestBox(coords.imageX, coords.imageY);
                    if (deleteIndex >= 0) {
                        censorState.editBoxes.splice(deleteIndex, 1);
                        censorState.selectedBoxIndex = -1;
                        if (censorState.currentTab === 'after') {
                            markAfterEditDirty();
                        }
                        // 박스가 삭제되었으므로 캐시 무효화
                        cachedApiPreviewImage = null;
                        cachedApiPreviewKey = null;
                        redrawCurrentTab();
                    }
                    break;
            }
        }
        
        // 마우스 이동
        function handleCensorMouseMove(e) {
            if (!censorState.currentImage) return;

            const coords = canvasToImageCoords(e);

            // 편집 불가능한 탭(검열전)에서는 호버/편집 기능 비활성화
            if (!isEditableTab()) {
                // 드래그/리사이즈/회전 중이어도 중단
                if (censorState.isDragging || censorState.isResizing || censorState.isRotating || censorState.isDrawing) {
                    censorState.isDragging = false;
                    censorState.isResizing = false;
                    censorState.isRotating = false;
                    censorState.isDrawing = false;
                }
                censorOverlayCanvas.style.cursor = 'default';
                return;
            }

            // 삭제 모드에서 호버 박스 추적
            if (censorState.currentTool === 'delete') {
                const hoverIndex = hitTestBox(coords.imageX, coords.imageY);
                if (hoverIndex !== censorState.hoverBoxIndex) {
                    censorState.hoverBoxIndex = hoverIndex;
                    redrawCurrentTab(true);  // 호버 변경: 오버레이만 갱신
                }
                censorOverlayCanvas.style.cursor = hoverIndex >= 0 ? 'pointer' : 'default';
            }
            // 선택/추가 모드에서 호버 시 핸들 표시
            else if ((censorState.currentTool === 'select' || censorState.currentTool === 'add') &&
                     !censorState.isDragging && !censorState.isResizing && !censorState.isRotating && !censorState.isDrawing) {
                // 호버 중인 박스 또는 핸들 체크
                const handleResult = hitTestResizeHandle(coords.imageX, coords.imageY);
                const hoverIndex = handleResult.boxIndex >= 0 ? handleResult.boxIndex : hitTestBox(coords.imageX, coords.imageY);

                if (hoverIndex !== censorState.hoverBoxIndex) {
                    censorState.hoverBoxIndex = hoverIndex;
                    redrawCurrentTab(true);  // 호버 변경: 오버레이만 갱신
                }
                
                // 커서 업데이트
                if (handleResult.handle) {
                    const cursors = {
                        'n': 'ns-resize', 's': 'ns-resize',
                        'e': 'ew-resize', 'w': 'ew-resize',
                        'nw': 'nwse-resize', 'se': 'nwse-resize',
                        'ne': 'nesw-resize', 'sw': 'nesw-resize',
                        'rotate': 'grab'
                    };
                    censorOverlayCanvas.style.cursor = cursors[handleResult.handle];
                } else if (hoverIndex >= 0) {
                    censorOverlayCanvas.style.cursor = censorState.currentTool === 'select' ? 'move' : 'crosshair';
                } else {
                    censorOverlayCanvas.style.cursor = censorState.currentTool === 'add' ? 'crosshair' : 'default';
                }
            }
            
            // 드래그 중
            if (censorState.isDragging && censorState.selectedBoxIndex >= 0) {
                const dx = coords.imageX - censorState.dragStartX;
                const dy = coords.imageY - censorState.dragStartY;
                const orig = censorState.dragBoxOriginal;
                censorState.editBoxes[censorState.selectedBoxIndex].box = [
                    orig[0] + dx, orig[1] + dy,
                    orig[2] + dx, orig[3] + dy
                ];
                redrawCurrentTab();
            }
            
            // 리사이즈 중 (회전 고려, Ctrl: 중심 기준 확장)
            if (censorState.isResizing && censorState.selectedBoxIndex >= 0 && censorState.resizeAnchor) {
                const det = censorState.editBoxes[censorState.selectedBoxIndex];
                const rotation = det.rotation || 0;
                const anchor = censorState.resizeAnchor;
                const handle = censorState.resizeHandle;
                const orig = censorState.dragBoxOriginal;
                const isCtrl = e.ctrlKey;
                
                // 마우스 월드 좌표
                const mwx = coords.imageX;
                const mwy = coords.imageY;
                
                let x1, y1, x2, y2;
                const cos = Math.cos(-rotation);
                const sin = Math.sin(-rotation);
                
                if (isCtrl) {
                    // Ctrl 누름: 중심 기준 대칭 확장
                    const [ox1, oy1, ox2, oy2] = orig;
                    const ocx = (ox1 + ox2) / 2;
                    const ocy = (oy1 + oy2) / 2;
                    
                    // 원래 중심의 월드 좌표 계산
                    const cosR = Math.cos(rotation);
                    const sinR = Math.sin(rotation);
                    
                    // 마우스를 원래 중심 기준으로 역회전 → 로컬 좌표
                    const mox = mwx - ocx;
                    const moy = mwy - ocy;
                    const mlx = ocx + mox * cos - moy * sin;
                    const mly = ocy + mox * sin + moy * cos;
                    
                    if (handle === 'nw' || handle === 'ne' || handle === 'sw' || handle === 'se') {
                        // 코너: 중심에서 마우스까지의 거리를 양쪽으로
                        const dx = Math.abs(mlx - ocx);
                        const dy = Math.abs(mly - ocy);
                        x1 = ocx - dx;
                        y1 = ocy - dy;
                        x2 = ocx + dx;
                        y2 = ocy + dy;
                    } else {
                        // 엣지: 해당 축만 대칭 확장
                        x1 = ox1; y1 = oy1; x2 = ox2; y2 = oy2;
                        if (handle === 'n' || handle === 's') {
                            const dy = Math.abs(mly - ocy);
                            y1 = ocy - dy;
                            y2 = ocy + dy;
                        } else {
                            const dx = Math.abs(mlx - ocx);
                            x1 = ocx - dx;
                            x2 = ocx + dx;
                        }
                    }
                } else if (handle === 'nw' || handle === 'ne' || handle === 'sw' || handle === 'se') {
                    // 코너 핸들: 앵커 월드 좌표 고정, 새 중심 기준 역회전
                    const wcx = (anchor.worldX + mwx) / 2;
                    const wcy = (anchor.worldY + mwy) / 2;
                    
                    const aox = anchor.worldX - wcx;
                    const aoy = anchor.worldY - wcy;
                    const alx = wcx + aox * cos - aoy * sin;
                    const aly = wcy + aox * sin + aoy * cos;
                    
                    const mox = mwx - wcx;
                    const moy = mwy - wcy;
                    const mlx = wcx + mox * cos - moy * sin;
                    const mly = wcy + mox * sin + moy * cos;
                    
                    x1 = Math.min(alx, mlx);
                    y1 = Math.min(aly, mly);
                    x2 = Math.max(alx, mlx);
                    y2 = Math.max(aly, mly);
                } else {
                    // 엣지 핸들: 마우스의 해당 축만 사용
                    const origWidth = orig[2] - orig[0];
                    const origHeight = orig[3] - orig[1];
                    
                    const dwx = mwx - anchor.worldX;
                    const dwy = mwy - anchor.worldY;
                    const dlx = dwx * cos - dwy * sin;
                    const dly = dwx * sin + dwy * cos;
                    
                    let effectiveDLX, effectiveDLY;
                    switch (handle) {
                        case 'n': effectiveDLX = origWidth; effectiveDLY = dly; break;
                        case 's': effectiveDLX = -origWidth; effectiveDLY = dly; break;
                        case 'w': effectiveDLX = dlx; effectiveDLY = origHeight; break;
                        case 'e': effectiveDLX = dlx; effectiveDLY = -origHeight; break;
                    }
                    
                    const cosR = Math.cos(rotation);
                    const sinR = Math.sin(rotation);
                    const effectiveDWX = effectiveDLX * cosR - effectiveDLY * sinR;
                    const effectiveDWY = effectiveDLX * sinR + effectiveDLY * cosR;
                    
                    const emwx = anchor.worldX + effectiveDWX;
                    const emwy = anchor.worldY + effectiveDWY;
                    
                    const wcx = (anchor.worldX + emwx) / 2;
                    const wcy = (anchor.worldY + emwy) / 2;
                    
                    const aox = anchor.worldX - wcx;
                    const aoy = anchor.worldY - wcy;
                    const alx = wcx + aox * cos - aoy * sin;
                    const aly = wcy + aox * sin + aoy * cos;
                    
                    const emox = emwx - wcx;
                    const emoy = emwy - wcy;
                    const emlx = wcx + emox * cos - emoy * sin;
                    const emly = wcy + emox * sin + emoy * cos;
                    
                    x1 = Math.min(alx, emlx);
                    y1 = Math.min(aly, emly);
                    x2 = Math.max(alx, emlx);
                    y2 = Math.max(aly, emly);
                }
                
                censorState.editBoxes[censorState.selectedBoxIndex].box = [x1, y1, x2, y2];
                redrawCurrentTab();
            }
            
            // 회전 중
            if (censorState.isRotating && censorState.selectedBoxIndex >= 0 && censorState.rotateCenter) {
                const cx = censorState.rotateCenter.x;
                const cy = censorState.rotateCenter.y;
                const angle = Math.atan2(coords.imageY - cy, coords.imageX - cx) + Math.PI / 2;
                censorState.editBoxes[censorState.selectedBoxIndex].rotation = angle;
                redrawCurrentTab();
            }
            
            // 새 박스 그리는 중
            if (censorState.isDrawing && censorState.newBoxStart) {
                drawEditBoxes();
                // 임시 박스 그리기
                const scale = censorState.displayScale || 1;
                const offsetX = censorState.overlayOffsetX || 0;
                const offsetY = censorState.overlayOffsetY || 0;
                const sx = censorState.newBoxStart.x * scale + offsetX;
                const sy = censorState.newBoxStart.y * scale + offsetY;
                const sw = (coords.imageX - censorState.newBoxStart.x) * scale;
                const sh = (coords.imageY - censorState.newBoxStart.y) * scale;
                
                censorOverlayCtx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                censorOverlayCtx.lineWidth = 2;
                censorOverlayCtx.setLineDash([5, 5]);
                censorOverlayCtx.strokeRect(sx, sy, sw, sh);
                censorOverlayCtx.setLineDash([]);
            }
        }
        
        // 마우스 업
        function handleCensorMouseUp(e) {
            // 새 박스 완성
            if (censorState.isDrawing && censorState.newBoxStart) {
                const coords = canvasToImageCoords(e);
                const x1 = Math.min(censorState.newBoxStart.x, coords.imageX);
                const y1 = Math.min(censorState.newBoxStart.y, coords.imageY);
                const x2 = Math.max(censorState.newBoxStart.x, coords.imageX);
                const y2 = Math.max(censorState.newBoxStart.y, coords.imageY);

                // 상태 먼저 초기화 (redrawCurrentTab 호출 전에 isDrawing=false 필요)
                censorState.isDrawing = false;
                censorState.newBoxStart = null;

                // 최소 크기 체크 (10x10 픽셀)
                if (x2 - x1 > 10 && y2 - y1 > 10) {
                    const method = document.getElementById(getCurrentMethodSelector())?.value || 'black';
                    censorState.editBoxes.push({
                        box: [x1, y1, x2, y2],
                        label: 'manual',
                        method: method
                    });
                    censorState.selectedBoxIndex = censorState.editBoxes.length - 1;
                    // 검열후 탭에서 새 박스 추가 시 dirty 표시
                    if (censorState.currentTab === 'after') {
                        markAfterEditDirty();
                    }
                    // 박스가 추가되었으므로 캐시 무효화
                    cachedApiPreviewImage = null;
                    cachedApiPreviewKey = null;
                    redrawCurrentTab();  // 박스 추가됨: 전체 갱신
                } else {
                    redrawCurrentTab(true);  // 박스 미추가(클릭만): 오버레이만 갱신
                }
            }
            
            // 드래그/리사이즈/회전 완료 시 결과 저장 및 API 프리뷰 업데이트
            if (censorState.isDragging || censorState.isResizing || censorState.isRotating) {
                if (censorState.currentTab === 'processing') {
                    if (censorState.currentImage && censorState.processingResults[censorState.currentImage.path]) {
                        // 저장 전 검증
                        const validBoxes = censorState.editBoxes.filter(b => {
                            if (!b.box || !Array.isArray(b.box) || b.box.length !== 4) {
                                console.error('Invalid box detected during save:', b);
                                return false;
                            }
                            return true;
                        });
                        censorState.processingResults[censorState.currentImage.path].editBoxes = validBoxes.map(b => ({
                            ...b,
                            box: [b.box[0], b.box[1], b.box[2], b.box[3]]  // 명시적 4개 값 복사
                        }));
                    }
                } else if (censorState.currentTab === 'after') {
                    // 검열후 탭에서 편집 시 dirty 표시
                    markAfterEditDirty();
                }

                // 박스가 변경되었으므로 캐시 무효화 및 API 프리뷰 업데이트
                cachedApiPreviewImage = null;
                cachedApiPreviewKey = null;
            }

            // 상태 초기화 (API 호출 전에 해야 isEditing이 false가 됨)
            const wasEditing = censorState.isDragging || censorState.isResizing || censorState.isRotating;
            censorState.isDragging = false;
            censorState.isResizing = false;
            censorState.isRotating = false;
            censorState.isDrawing = false;
            censorState.newBoxStart = null;
            censorState.resizeHandle = null;
            censorState.rotateCenter = null;
            censorState.resizeAnchor = null;

            // 편집 완료 후 API 프리뷰 업데이트 (확장/그라데이션이 있을 때만)
            if (wasEditing && (censorState.expandPixels > 0 || censorState.feather > 0) && censorState.editBoxes.length > 0) {
                requestCensorPreviewUpdate();
            }
        }
        
        // 편집 박스 그리기 (선택 상태, 핸들 포함)
        function drawEditBoxes() {
            if (!censorOverlayCtx) return;

            const scale = censorState.displayScale || 1;
            const offsetX = censorState.overlayOffsetX || 0;
            const offsetY = censorState.overlayOffsetY || 0;
            censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);

            // 검열전 탭: detections 사용 (스캔 결과 표시용)
            // 검열중/검열후 탭: editBoxes 사용 (편집 가능)
            const boxes = censorState.currentTab === 'before'
                ? censorState.detections
                : censorState.editBoxes;
            
            boxes.forEach((det, index) => {
                const [x1, y1, x2, y2] = det.box;
                const sx1 = x1 * scale + offsetX;
                const sy1 = y1 * scale + offsetY;
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                
                const isSelected = index === censorState.selectedBoxIndex;
                
                // threshold 통과 여부 확인 (passes_threshold 필드 또는 현재 설정과 비교)
                let passesThreshold = det.passes_threshold;
                if (passesThreshold === undefined && det.confidence !== undefined && det.label) {
                    // 현재 설정된 threshold와 비교
                    const requiredConf = censorState.labelConf[det.label] || 0.3;
                    passesThreshold = det.confidence >= requiredConf;
                }
                if (passesThreshold === undefined) passesThreshold = true;  // 기본값
                
                // 색상 결정: 선택 = 청록, threshold 통과 = 빨강, 미통과 = 회색
                let strokeColor, fillColor;
                if (isSelected) {
                    strokeColor = 'rgba(0, 200, 255, 1)';
                    fillColor = 'rgba(0, 200, 255, 0.9)';
                } else if (passesThreshold) {
                    strokeColor = 'rgba(255, 0, 0, 0.8)';
                    fillColor = 'rgba(255, 0, 0, 0.8)';
                } else {
                    strokeColor = 'rgba(128, 128, 128, 0.4)';
                    fillColor = 'rgba(128, 128, 128, 0.5)';
                }

                // 검열전 탭: 확장/그라데이션 영역 시각화 (개념도)
                const isBeforeTab = censorState.currentTab === 'before';
                const expandPx = censorState.expandPixels || 0;
                const featherPx = censorState.feather || 0;

                if (isBeforeTab && passesThreshold && (expandPx > 0 || featherPx > 0)) {
                    const expandScaled = expandPx * scale;
                    const featherScaled = featherPx * scale;

                    // 그라데이션 영역 (가장 바깥, 연한 색)
                    if (featherPx > 0) {
                        const totalExpand = expandScaled + featherScaled;
                        censorOverlayCtx.fillStyle = 'rgba(255, 100, 100, 0.15)';
                        censorOverlayCtx.fillRect(
                            sx1 - totalExpand,
                            sy1 - totalExpand,
                            sw + totalExpand * 2,
                            sh + totalExpand * 2
                        );
                        // 그라데이션 경계선 (점선)
                        censorOverlayCtx.strokeStyle = 'rgba(255, 100, 100, 0.4)';
                        censorOverlayCtx.lineWidth = 1;
                        censorOverlayCtx.setLineDash([3, 3]);
                        censorOverlayCtx.strokeRect(
                            sx1 - totalExpand,
                            sy1 - totalExpand,
                            sw + totalExpand * 2,
                            sh + totalExpand * 2
                        );
                    }

                    // 확장 영역 (중간, 더 진한 색)
                    if (expandPx > 0) {
                        censorOverlayCtx.fillStyle = 'rgba(255, 50, 50, 0.25)';
                        censorOverlayCtx.fillRect(
                            sx1 - expandScaled,
                            sy1 - expandScaled,
                            sw + expandScaled * 2,
                            sh + expandScaled * 2
                        );
                        // 확장 경계선 (점선)
                        censorOverlayCtx.strokeStyle = 'rgba(255, 50, 50, 0.6)';
                        censorOverlayCtx.lineWidth = 1;
                        censorOverlayCtx.setLineDash([4, 4]);
                        censorOverlayCtx.strokeRect(
                            sx1 - expandScaled,
                            sy1 - expandScaled,
                            sw + expandScaled * 2,
                            sh + expandScaled * 2
                        );
                    }
                }

                // 박스 그리기 (원본 감지 영역)
                censorOverlayCtx.strokeStyle = strokeColor;
                censorOverlayCtx.lineWidth = isSelected ? 3 : 2;
                censorOverlayCtx.setLineDash(isSelected ? [] : (passesThreshold ? [5, 5] : [3, 6]));
                censorOverlayCtx.strokeRect(sx1, sy1, sw, sh);
                
                // 라벨 표시
                censorOverlayCtx.setLineDash([]);
                censorOverlayCtx.fillStyle = fillColor;
                const label = det.label + (det.confidence ? ` ${(det.confidence * 100).toFixed(0)}%` : '');
                const textW = censorOverlayCtx.measureText(label).width + 8;
                censorOverlayCtx.fillRect(sx1, sy1 - 18, textW, 18);
                censorOverlayCtx.fillStyle = passesThreshold ? 'white' : 'rgba(255, 255, 255, 0.7)';
                censorOverlayCtx.font = '12px sans-serif';
                censorOverlayCtx.fillText(label, sx1 + 4, sy1 - 5);
                
                // 선택된 박스 또는 호버된 박스면 리사이즈/회전 핸들 그리기
                if (isSelected || index === censorState.hoverBoxIndex) {
                    const handleSize = 8;
                    const handleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 200, 0, 0.8)';
                    censorOverlayCtx.fillStyle = handleColor;
                    // 4개 모서리
                    censorOverlayCtx.fillRect(sx1 - handleSize/2, sy1 - handleSize/2, handleSize, handleSize);
                    censorOverlayCtx.fillRect(sx1 + sw - handleSize/2, sy1 - handleSize/2, handleSize, handleSize);
                    censorOverlayCtx.fillRect(sx1 - handleSize/2, sy1 + sh - handleSize/2, handleSize, handleSize);
                    censorOverlayCtx.fillRect(sx1 + sw - handleSize/2, sy1 + sh - handleSize/2, handleSize, handleSize);
                    
                    // 회전 핸들도 그리기 (선택 또는 호버 시 모두)
                    const cx = sx1 + sw / 2;
                    const rotateHandleY = sy1 - 25;
                    // 회전 핸들 연결선
                    censorOverlayCtx.strokeStyle = handleColor;
                    censorOverlayCtx.lineWidth = 1;
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.moveTo(cx, sy1);
                    censorOverlayCtx.lineTo(cx, rotateHandleY);
                    censorOverlayCtx.stroke();
                    // 회전 핸들 (원형)
                    censorOverlayCtx.fillStyle = handleColor;
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.arc(cx, rotateHandleY, 6, 0, Math.PI * 2);
                    censorOverlayCtx.fill();
                }
            });
        }
        
    </script>
</body>
</html>
