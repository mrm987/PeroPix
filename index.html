<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PeroPix</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        :root {
            /* Background - Deep Navy */
            --bg: #0C1219;
            --bg-light: #141C26;
            --bg-lighter: #1C2530;
            /* Accent - Navy Blue */
            --accent: #4A7AB8;
            --accent-hover: #5B98D4;
            --accent-dim: #2D4A6F;
            /* Accent - Gold (CTA, 강조) */
            --accent-gold: #F5B942;
            --accent-gold-hover: #FFD06A;
            --accent-gold-dim: #9A7A35;
            /* Text */
            --text: #FFFFFF;
            --text-dim: #7A8BA0;
            /* Border */
            --border: #243044;
            /* Semantic */
            --success: #4CAF82;
            --error: #E57373;
            --warning: #F5B942;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
        }
        
        /* Layout */
        .app {
            display: flex;
            height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width, 540px);
            min-width: 360px;
            max-width: 800px;
            background: var(--bg-light);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
        }

        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.active {
            opacity: 1;
            background: var(--accent-gold-dim);
        }
        
        .sidebar-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .logo {
            font-size: 1.8rem;
            font-weight: 700;
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }
        .logo img {
            vertical-align: bottom;
        }
        
        .settings-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .settings-btn:hover {
            background: var(--bg-lighter);
            color: var(--text);
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }

        .sidebar-content::-webkit-scrollbar {
            width: 8px;
        }
        .sidebar-content::-webkit-scrollbar-track {
            background: transparent;
        }
        .sidebar-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        .sidebar-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
        }
        
        /* Sections */
        .section {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }
        
        .section:last-child,
        .sidebar-content > .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .section-title {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
            padding: 8px 10px;
            margin: 0 -10px 10px -10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .section-title:hover {
            background: var(--bg-lighter);
        }
        
        .section-title .section-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: none;
            letter-spacing: 0;
            color: var(--text);
            cursor: pointer;
        }
        
        .section-title .section-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            cursor: pointer;
        }

        .subsection {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .subsection:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .subsection-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .subsection-title .section-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text);
            cursor: pointer;
        }

        .subsection-title .section-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            cursor: pointer;
        }

        /* Form */
        label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 4px;
            color: var(--text-dim);
        }

        label.prompt-label {
            color: var(--text);
            font-weight: 500;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 0.9rem;
            margin-bottom: 12px;
            transition: border-color 0.2s;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        textarea {
            resize: vertical;
            min-height: 70px;
            font-family: inherit;
        }

        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-track {
            background: transparent;
        }
        textarea::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        textarea::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        
        .size-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .size-preset {
            flex: 1;
        }

        .size-inputs {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .size-inputs input {
            flex: 1;
            min-width: 0;
            text-align: center;
            padding: 10px 8px;
        }

        .size-x {
            color: var(--text-dim);
            font-size: 0.85rem;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }
        
        .tab {
            flex: 1;
            padding: 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-dim);
            cursor: pointer;
            text-align: center;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .tab:hover:not(.active) {
            border-color: var(--accent);
        }
        
        .provider-section { display: none; }
        .provider-section.active { 
            display: block;
            padding-bottom: 16px;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }
        .provider-section .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        /* Checkbox */
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .checkbox-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin: 0;
            accent-color: var(--accent);
        }
        
        .checkbox-row label {
            margin: 0;
            color: var(--text);
            font-size: 0.9rem;
        }
        
        /* Characters */
        .characters-section {
            margin: 12px 0;
        }
        
        .characters-header {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 8px;
            padding: 8px 10px;
            margin: 0 -10px 8px -10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .characters-header:hover {
            background: var(--bg-lighter);
        }

        .characters-header label {
            font-size: 0.85rem;
            flex: 1;
        }

        .characters-header label.prompt-label {
            color: var(--text);
        }
        
        .add-char-btn {
            background: var(--accent);
            border: none;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .add-char-btn:hover {
            background: var(--accent-hover);
        }
        
        .add-char-btn:disabled {
            background: var(--bg-lighter);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .characters-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .character-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: var(--bg);
            border-radius: 6px;
            padding: 6px 8px;
        }
        
        .character-item-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            margin: 0 -6px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .character-item-header:hover {
            background: var(--bg-lighter);
        }

        .character-item .char-num {
            color: var(--accent-gold);
            font-size: 0.75rem;
            font-weight: bold;
            font-family: monospace;
            min-width: 18px;
        }
        
        .character-item .prompt-preset-dropdown {
            margin-left: auto;
        }

        .character-item .prompt-preset-btn {
            padding: 2px 6px;
            font-size: 0.7rem;
        }

        .character-item textarea {
            width: 100%;
            min-height: 40px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 6px;
            color: var(--text);
            font-size: 0.85rem;
            font-family: inherit;
            resize: vertical;
        }
        
        .character-item textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .character-item .delete-char-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 1rem;
            opacity: 0.5;
        }
        
        .character-item .delete-char-btn:hover {
            opacity: 1;
            color: var(--error);
        }

        .char-enable-toggle {
            width: 14px;
            height: 14px;
            margin: 0 4px 0 0;
            cursor: pointer;
            accent-color: var(--accent);
            vertical-align: middle;
        }

        .character-item.disabled {
            opacity: 0.5;
        }

        .character-item.disabled textarea {
            background: var(--bg-tertiary);
            color: var(--text-dim);
        }

        /* Prompt Preset Dropdown */
        .prompt-label-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            padding: 8px 10px;
            margin: 0 -10px 4px -10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .prompt-label-row:hover {
            background: var(--bg-lighter);
        }

        .prompt-label-left {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mode-toggle {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            line-height: 1;
        }

        .mode-toggle:hover {
            border-color: var(--accent);
            background: var(--bg);
        }

        .mode-toggle.furry {
            background: var(--bg);
            border-color: var(--accent);
        }

        /* Collapsible prompts */
        .collapse-toggle {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        .collapse-toggle:hover {
            color: var(--text);
        }
        .collapse-toggle.collapsed {
            transform: rotate(-90deg);
        }
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
        }
        .collapsible-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            margin: 0;
            padding: 0;
        }
        /* Characters 섹션만 드롭다운이 밖으로 나올 수 있도록 */
        #charactersContent:not(.collapsed) {
            overflow: visible;
        }

        .prompt-preset-dropdown {
            position: relative;
        }
        
        .prompt-preset-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .prompt-preset-btn:hover {
            background: var(--bg-light);
            border-color: var(--text-dim);
        }
        
        .prompt-preset-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            min-width: 200px;
            max-width: 280px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 100;
            overflow: hidden;
        }
        
        .prompt-preset-menu.show {
            display: block;
        }
        
        .prompt-preset-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .prompt-preset-item {
            padding: 6px 10px;
            border-bottom: 1px solid var(--border);
        }
        
        .prompt-preset-item:last-child {
            border-bottom: none;
        }
        
        .prompt-preset-item-name {
            font-size: 0.85rem;
            color: var(--text);
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .prompt-preset-item-actions {
            display: flex;
            gap: 4px;
        }
        
        .prompt-preset-item-actions button {
            flex: 1;
            padding: 3px 8px;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            background: var(--bg);
            color: var(--text);
        }
        
        .prompt-preset-item-actions button:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .prompt-preset-item-actions .delete-btn {
            flex: 0;
            padding: 3px 6px;
            color: var(--text-dim);
        }
        
        .prompt-preset-item-actions .delete-btn:hover {
            background: var(--error);
            border-color: var(--error);
            color: white;
        }
        
        .prompt-preset-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
        }
        
        .prompt-preset-save-btn {
            width: 100%;
            padding: 6px 10px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        .prompt-preset-save-btn:hover {
            background: var(--bg);
            border-color: var(--text-dim);
        }
        
        .prompt-preset-empty {
            padding: 12px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.8rem;
        }
        
        /* LoRA */
        .lora-list {
            max-height: 120px;
            overflow-y: auto;
        }
        
        .lora-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: var(--bg);
            border-radius: 6px;
            margin-bottom: 4px;
        }
        
        .lora-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
        }
        
        .lora-item .lora-name {
            flex: 1;
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .lora-item input[type="number"] {
            width: 55px;
            padding: 4px 6px;
            margin: 0;
            font-size: 0.8rem;
        }

        /* Vibe Transfer */
        .vibe-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .vibe-item {
            background: var(--bg);
            border-radius: 8px;
            padding: 10px;
        }

        .vibe-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .vibe-item-header img {
            width: 48px;
            height: 48px;
            object-fit: cover;
            border-radius: 6px;
        }

        .vibe-item-header .vibe-info {
            flex: 1;
            font-size: 0.8rem;
            color: var(--text-dim);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .vibe-item-header .remove-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255,100,100,0.2);
            color: var(--error);
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }

        .vibe-item-header .remove-btn:hover {
            background: rgba(255,100,100,0.4);
        }

        .vibe-sliders {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .vibe-slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
        }

        .vibe-slider-row label {
            width: 70px;
            color: var(--text-dim);
        }

        .vibe-slider-row input[type="range"] {
            flex: 1;
        }

        .vibe-slider-row .value {
            width: 35px;
            text-align: right;
            color: var(--text);
        }

        /* Character Reference */
        .char-ref-preview {
            position: relative;
            margin-bottom: 8px;
            text-align: center;
        }

        .char-ref-preview img {
            max-width: 100%;
            max-height: 150px;
            border-radius: 8px;
            object-fit: contain;
        }

        .char-ref-preview .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(0,0,0,0.7);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }

        .char-ref-preview .remove-btn:hover {
            background: rgba(255,100,100,0.8);
        }

        /* Anlas Info - Single line */
        .anlas-info {
            display: flex;
            align-items: center;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 6px;
            gap: 5px;
        }

        .anlas-info .anlas-icon { font-size: 0.8rem; }
        .anlas-info #anlasBalance { font-weight: 600; color: var(--text); }
        .anlas-info .anlas-separator { opacity: 0.3; margin: 0 2px; }
        .anlas-info .anlas-cost-label { opacity: 0.7; }
        .anlas-info #anlasCost { color: var(--accent-gold); font-weight: 600; }

        .anlas-refresh {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 0.7rem;
            padding: 0 2px;
            opacity: 0.6;
        }
        .anlas-refresh:hover { opacity: 1; color: var(--text); }

        .free-tag {
            background: #22c55e;
            color: white;
            font-size: 0.75rem;
            font-weight: 700;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 4px;
        }

        /* Button */
        .btn {
            width: 100%;
            padding: 14px;
            background: var(--accent);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .btn:hover { background: var(--accent-hover); }
        .btn:disabled { background: var(--border); cursor: not-allowed; }
        .btn:active { transform: scale(0.98); }

        /* Queue button - Gold accent */
        #generateBtn { background: var(--accent-gold); color: #1a1a2e; }
        #generateBtn:hover { background: var(--accent-gold-hover); }

        .btn-secondary {
            background: var(--bg);
            border: 1px solid var(--border);
            margin-top: 8px;
        }

        .btn-secondary:hover { background: var(--bg-lighter); }

        /* Inline button row (for vibe buttons, etc.) */
        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .btn-row .btn {
            width: auto;
            margin-top: 0;
            padding: 10px 16px;
        }
        .btn-row .btn-icon {
            padding: 10px 12px;
            flex-shrink: 0;
        }
        
        /* Main Area */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Mode Header (공통) */
        .mode-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            color: var(--text-dim);
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        /* Slots Toolbar */
        .slots-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
            flex-shrink: 0;
            gap: 12px;
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .add-slot-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .add-slot-btn:hover {
            background: var(--accent-hover);
        }

        .header-btn.icon-only {
            padding: 6px 8px;
            font-size: 1rem;
        }
        
        .header-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-dim);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .header-btn:hover {
            background: var(--bg-light);
            border-color: var(--text-dim);
        }
        
        .header-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        /* Preset Dropdown */
        .preset-dropdown {
            position: relative;
        }
        
        .preset-btn {
            min-width: 120px;
        }
        
        .preset-btn .preset-name {
            flex: 1;
            text-align: left;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .preset-btn .dropdown-arrow {
            font-size: 0.6rem;
            margin-left: 4px;
        }
        
        .preset-menu {
            display: none;
            position: fixed;
            min-width: 220px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 99999;
            overflow: hidden;
        }
        
        .preset-menu.show {
            display: block;
        }
        
        .preset-list {
            max-height: 250px;
            overflow-y: auto;
        }
        
        .preset-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.15s;
            gap: 8px;
        }
        
        .preset-item:hover {
            background: var(--bg-lighter);
        }
        
        .preset-item.selected {
            background: var(--accent);
            color: white;
        }
        
        .preset-item .check {
            width: 16px;
            font-size: 0.8rem;
        }
        
        .preset-item .label {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .preset-item .edit-btn,
        .preset-item .delete-btn {
            background: none;
            border: none;
            padding: 2px 4px;
            cursor: pointer;
            opacity: 0.5;
            font-size: 0.85rem;
            border-radius: 4px;
        }
        
        .preset-item .edit-btn:hover,
        .preset-item .delete-btn:hover {
            opacity: 1;
            background: var(--bg);
        }
        
        .preset-item.selected .edit-btn:hover,
        .preset-item.selected .delete-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .preset-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .preset-action-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.85rem;
            cursor: pointer;
            text-align: left;
            transition: all 0.15s;
        }
        
        .preset-action-btn:hover {
            background: var(--bg);
            border-color: var(--text-dim);
        }
        
        .preset-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        /* Output Folder Dropdown */
        .folder-dropdown {
            position: relative;
        }

        .folder-btn {
            min-width: 100px;
        }

        .folder-btn .folder-name {
            flex: 1;
            text-align: left;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .folder-btn .dropdown-arrow {
            font-size: 0.6rem;
            margin-left: 4px;
        }

        .folder-menu {
            display: none;
            position: fixed;
            min-width: 180px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 99999;
            overflow: hidden;
        }

        .folder-menu.show {
            display: block;
        }

        .folder-list {
            max-height: 250px;
            overflow-y: auto;
        }

        .folder-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.15s;
            gap: 6px;
            font-size: 0.85rem;
            color: var(--text);
        }

        .folder-item:hover {
            background: var(--bg-lighter);
        }

        .folder-item.active {
            background: var(--accent);
            color: white;
        }

        .folder-item.root-folder {
            font-weight: 500;
            border-bottom: 1px solid var(--border);
        }

        .folder-item.subfolder {
            padding-left: 24px;
        }

        .folder-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
        }

        .folder-action-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.85rem;
            cursor: pointer;
            text-align: left;
            transition: all 0.15s;
        }

        .folder-action-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .slots-container-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .slots-container-wrapper::before,
        .slots-container-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 40px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .slots-container-wrapper::before {
            left: 0;
            background: linear-gradient(to right, var(--bg) 0%, transparent 100%);
        }
        
        .slots-container-wrapper::after {
            right: 0;
            background: linear-gradient(to left, var(--bg) 0%, transparent 100%);
        }
        
        .slots-container-wrapper.can-scroll-left::before {
            opacity: 1;
        }
        
        .slots-container-wrapper.can-scroll-right::after {
            opacity: 1;
        }
        
        .slots-container {
            height: 100%;
            display: flex;
            gap: 16px;
            padding: 16px;
            overflow-x: auto;
            overflow-y: hidden;
            align-items: stretch;
            user-select: none;
        }
        
        .slots-container::-webkit-scrollbar {
            height: 8px;
        }
        
        .slots-container::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        
        .slots-container::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }
        
        .slot {
            width: var(--slot-width, 280px);
            min-width: 150px;
            max-width: 1200px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            overflow: visible;  /* 리사이즈 핸들이 바깥에 표시되도록 */
            flex-shrink: 0;
            transition: box-shadow 0.2s;
            position: relative;
        }

        /* 슬롯 리사이즈 핸들 (오른쪽만) */
        .slot-resize-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
            right: -8px;
            border-radius: 0 10px 10px 0;
        }

        .slot-resize-handle:hover,
        .slot-resize-handle.active {
            opacity: 1;
            background: var(--accent-gold-dim);
        }

        body.resizing-slot {
            cursor: ew-resize !important;
            user-select: none !important;
        }

        body.resizing-slot * {
            cursor: ew-resize !important;
        }
        
        /* input, textarea는 선택 가능 */
        .slot input, .slot textarea {
            user-select: text;
        }
        
        .slot.dragging {
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            opacity: 0.9;
        }
        
        .slot-placeholder {
            background: var(--bg-lighter);
            border: 2px dashed var(--border);
            border-radius: 10px;
            flex-shrink: 0;
        }
        
        .slot-prompt {
            flex-shrink: 0;
            border-bottom: 1px solid var(--border);
        }
        
        .slot-prompt-header {
            display: flex;
            align-items: center;
            background: var(--bg-lighter);
            padding: 6px 8px;
            gap: 6px;
        }
        
        .slot-number {
            font-size: 0.75rem;
            color: var(--accent-gold);
            font-weight: bold;
            font-family: monospace;
            background: var(--bg);
            padding: 2px 6px;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .slot-prompt-header input {
            flex: 1;
            background: transparent;
            border: none;
            padding: 4px;
            margin: 0;
            font-size: 0.85rem;
            color: var(--text);
            min-width: 0;
        }
        
        .slot-prompt-header input::placeholder {
            color: var(--text-dim);
        }
        
        .slot-prompt-header input:focus {
            outline: none;
        }
        
        .slot-drag {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: grab;
            padding: 2px 4px;
            font-size: 0.9rem;
            line-height: 1;
            border-radius: 4px;
        }
        
        .slot-drag:hover {
            background: var(--bg);
            color: var(--text);
        }
        
        .slot-drag:active {
            cursor: grabbing;
        }
        
        .slot-delete {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 1.1rem;
            line-height: 1;
            border-radius: 4px;
        }
        
        .slot-delete:hover {
            background: var(--error);
            color: white;
        }
        
        .slot-prompt textarea {
            width: 100%;
            border: none;
            background: var(--bg-light);
            padding: 10px;
            margin: 0;
            min-height: 70px;
            resize: vertical;
            font-size: 0.85rem;
            color: var(--text);
        }
        
        .slot-prompt textarea:focus {
            outline: none;
        }
        
        .slot-images {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .slot-images::-webkit-scrollbar {
            width: 5px;
        }
        
        .slot-images::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }
        
        .slot-image-card {
            position: relative;
            background: var(--bg);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            transition: border-color 0.2s;
            flex-shrink: 0;
        }
        
        .slot-image-card:hover {
            border-color: var(--accent);
        }
        
        .slot-image-card img {
            width: 100%;
            height: auto;
            cursor: pointer;
            display: block;
            user-select: none;
            -webkit-user-drag: none;
        }
        
        .slot-image-card .info {
            padding: 6px 8px;
            font-size: 0.7rem;
        }
        
        .slot-image-card .filename {
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .slot-image-card .seed {
            color: var(--text-dim);
            margin-top: 2px;
        }
        
        .slot-empty {
            color: var(--text-dim);
            font-size: 0.8rem;
            text-align: center;
            padding: 20px 10px;
        }
        
        .progress-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-lighter);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s;
        }
        
        .status-text {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        
        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-dim);
            text-align: center;
        }
        
        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        
        .empty-state p {
            font-size: 1.1rem;
            margin-bottom: 8px;
        }
        
        .empty-state small {
            opacity: 0.7;
        }
        
        /* Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .lightbox.active { display: flex; }
        
        .lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
        }
        
        .lightbox .close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 2.5rem;
            color: white;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .lightbox .close:hover { opacity: 1; }

        /* Drop Overlay */
        .drop-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(59, 130, 246, 0.15);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            border: 4px dashed var(--accent);
            pointer-events: none;
        }
        .drop-overlay.active { display: flex; }
        .drop-overlay-content {
            background: var(--bg-light);
            padding: 40px 60px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        .drop-overlay-content .icon { font-size: 48px; margin-bottom: 16px; }
        .drop-overlay-content h3 { margin: 0 0 8px 0; font-size: 1.5rem; }
        .drop-overlay-content p { margin: 0; color: var(--text-dim); }

        /* Drop Confirm Modal */
        .drop-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .drop-modal.active { display: flex; }
        .drop-modal-content {
            background: var(--bg-light);
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
        }
        .drop-modal-content h3 { margin: 0 0 16px 0; }
        .drop-modal-content .preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        .drop-modal-content .metadata {
            background: var(--bg);
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            margin-bottom: 16px;
            max-height: 200px;
            overflow-y: auto;
        }
        .drop-modal-content .metadata::-webkit-scrollbar {
            width: 8px;
        }
        .drop-modal-content .metadata::-webkit-scrollbar-track {
            background: transparent;
        }
        .drop-modal-content .metadata::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        .drop-modal-content .metadata::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }
        .drop-modal-content .metadata div { margin-bottom: 4px; }
        .drop-modal-content .buttons { display: flex; gap: 12px; justify-content: flex-end; }
        .drop-modal-content .buttons .btn {
            width: auto;
            flex: 1;
            padding: 10px 16px;
        }

        /* Mask Editor Modal */
        .mask-editor-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .mask-editor-modal.active { display: flex; }
        .mask-editor-container {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 20px;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .mask-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .mask-editor-header h3 { margin: 0; }
        .mask-editor-canvas-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
        }
        .mask-editor-canvas-wrapper canvas {
            max-width: 100%;
            max-height: 70vh;
        }
        #maskEditorMaskCanvas {
            position: absolute;
            top: 0; left: 0;
            opacity: 0.5;
            pointer-events: none;
        }
        .mask-editor-toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .mask-editor-toolbar .tool-group {
            display: flex;
            gap: 4px;
            background: var(--bg);
            padding: 4px;
            border-radius: 8px;
        }
        .mask-editor-toolbar .tool-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
        }
        .mask-editor-toolbar .tool-btn:hover { background: var(--border); }
        .mask-editor-toolbar .tool-btn.active { background: var(--primary); color: white; }
        .mask-editor-toolbar .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .mask-editor-toolbar .slider-group label {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        .mask-editor-toolbar .slider-group input[type="range"] {
            width: 100px;
        }
        .mask-editor-footer {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        .mask-editor-footer .btn { padding: 10px 20px; }

        /* Censor Mode Container */
        .censor-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .censor-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-light);
            border-bottom: 1px solid var(--border);
            gap: 16px;
            flex-wrap: wrap;
        }
        .censor-toolbar .toolbar-left,
        .censor-toolbar .toolbar-center,
        .censor-toolbar .toolbar-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .censor-folder-select {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .censor-folder-select label {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        .censor-folder-select select {
            padding: 6px 10px;
            border-radius: 6px;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            min-width: 150px;
        }
        .censor-stats {
            display: flex;
            gap: 12px;
            font-size: 0.9rem;
        }
        .censor-stats .stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .censor-stats .stat.ok { color: #4CAF50; }
        .censor-stats .stat.warning { color: #FF9800; }
        .censor-stats .stat.total { color: var(--text-dim); }
        .censor-content {
            flex: 1;
            overflow: auto;
            padding: 16px;
        }
        .censor-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 16px;
        }
        .censor-grid-item {
            position: relative;
            background: var(--bg);
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: border-color 0.2s, transform 0.2s;
        }
        .censor-grid-item:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }
        .censor-grid-item.status-ok { border-color: #4CAF50; }
        .censor-grid-item.status-warning { border-color: #FF9800; }
        .censor-grid-item img {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
        }
        .censor-grid-item .status-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
        }
        .censor-grid-item .status-badge.ok {
            background: #4CAF50;
            color: white;
        }
        .censor-grid-item .status-badge.warning {
            background: #FF9800;
            color: white;
        }
        .censor-grid-item .filename {
            padding: 8px;
            font-size: 0.75rem;
            color: var(--text-dim);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .censor-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-dim);
            text-align: center;
        }
        .censor-empty .icon { font-size: 4rem; margin-bottom: 16px; }
        .censor-empty p { font-size: 1.2rem; margin-bottom: 8px; }
        .censor-empty small { font-size: 0.9rem; opacity: 0.7; }

        /* Censor Quick Editor Modal */
        .censor-editor-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .censor-editor-modal.active { display: flex; }
        .censor-editor-container {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 20px;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .censor-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .censor-editor-header .header-left,
        .censor-editor-header .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .censor-editor-header h3 { margin: 0; }
        .censor-editor-header .image-counter {
            font-size: 0.9rem;
            color: var(--text-dim);
            padding: 4px 12px;
            background: var(--bg);
            border-radius: 4px;
        }
        .censor-editor-header .nav-btn {
            padding: 8px 16px;
            border: none;
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
        }
        .censor-editor-header .nav-btn:hover { background: var(--border); }
        .censor-editor-toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .censor-editor-toolbar .tool-group {
            display: flex;
            gap: 4px;
            background: var(--bg);
            padding: 4px;
            border-radius: 8px;
        }
        .censor-editor-toolbar .tool-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .censor-editor-toolbar .tool-btn:hover { background: var(--border); }
        .censor-editor-toolbar .tool-btn.active { background: var(--primary); color: white; }
        .censor-editor-toolbar .tool-btn.fill-btn {
            width: 36px;
            padding: 8px;
            text-align: center;
        }
        .censor-editor-toolbar .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .censor-editor-toolbar .slider-group label {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        .censor-editor-toolbar .slider-group input[type="range"] {
            width: 100px;
        }
        .censor-editor-canvas-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
        }
        .censor-editor-canvas-wrapper canvas {
            max-width: 100%;
            max-height: 70vh;
        }
        .censor-editor-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .censor-editor-footer .footer-left,
        .censor-editor-footer .footer-right {
            display: flex;
            gap: 8px;
        }
        .censor-editor-footer .btn { padding: 10px 16px; }
        .btn-warning {
            background: #FF9800 !important;
            color: white !important;
        }
        .btn-warning:hover {
            background: #F57C00 !important;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: var(--bg);
            border-radius: 10px;
            padding: 4px;
            gap: 4px;
            border: 1px solid var(--border);
        }
        .mode-btn {
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .mode-btn:hover {
            color: var(--text);
            background: var(--bg-light);
        }
        .mode-btn.active {
            background: var(--accent);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Gallery */
        .gallery-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            overflow: hidden;
        }
        /* Gallery Toolbar */
        .gallery-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
            flex-shrink: 0;
            gap: 12px;
        }

        /* Gallery Subfolders Row */
        .gallery-subfolders {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .folder-separator {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 4px;
            align-self: center;
        }
        .folder-separator.double {
            width: 4px;
            background: linear-gradient(90deg, var(--border) 0%, var(--border) 40%, transparent 40%, transparent 60%, var(--border) 60%, var(--border) 100%);
            margin: 0 8px;
        }
        .folder-tab.vibe-folder {
            background: var(--bg-light);
            border-color: var(--accent-gold);
        }
        .folder-tab.vibe-folder:hover {
            background: var(--bg-lighter);
        }
        .folder-tab.vibe-folder.active {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: black;
        }

        .folder-tab {
            padding: 6px 12px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .folder-tab:hover {
            background: var(--bg-lighter);
        }
        .folder-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        .folder-tab.root-folder {
            font-weight: 500;
        }
        .folder-tab.drag-over {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: black;
        }

        .add-folder-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }
        .add-folder-btn:hover {
            background: var(--accent-hover);
        }
        .gallery-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
        }
        .gallery-content::-webkit-scrollbar {
            width: 8px;
        }
        .gallery-content::-webkit-scrollbar-track {
            background: transparent;
        }
        .gallery-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        .gallery-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }
        .gallery-folder-btn {
            padding: 6px 10px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }
        .gallery-folder-btn:hover {
            background: var(--bg-lighter);
            border-color: var(--accent-gold);
        }
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 20px;
            width: 100%;
            align-items: start;
            align-content: start;
            padding-bottom: 8px;
        }
        .gallery-item {
            background: var(--bg-light);
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            height: fit-content;
            position: relative;
            max-width: 520px;
        }
        .gallery-item:hover {
            transform: translateY(-4px);
            z-index: 1;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        .gallery-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .gallery-item img {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            display: block;
        }
        .gallery-item-info {
            padding: 12px;
        }
        .gallery-item-info .filename-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }
        .gallery-item-info .filename {
            font-size: 0.85rem;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }
        .gallery-item-info .filename-input {
            flex: 1;
            min-width: 0;
            font-size: 0.85rem;
            padding: 2px 6px;
            border: 1px solid var(--accent-gold);
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
        }
        .gallery-item-info .rename-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .gallery-item-info .rename-btn:hover {
            opacity: 1;
        }
        .gallery-item-info .seed {
            font-size: 0.75rem;
            color: var(--text-dim);
        }
        .gallery-item-actions {
            display: flex;
            gap: 8px;
            padding: 8px 12px 12px;
        }
        .gallery-item-actions button {
            flex: 1;
            padding: 6px 8px;
            font-size: 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
        }
        .gallery-item-actions button:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }
        .gallery-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            min-height: 300px;
            color: var(--text-dim);
            text-align: center;
        }
        .gallery-empty .icon { font-size: 64px; margin-bottom: 16px; opacity: 0.5; }
        .gallery-empty p { margin: 0 0 8px 0; font-size: 1.1rem; }
        .gallery-empty small { opacity: 0.7; }

        /* Slot image save button */
        .slot-image-card .save-gallery-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 14px;
        }
        .slot-image-card:hover .save-gallery-btn { opacity: 1; }
        .slot-image-card .save-gallery-btn:hover { background: rgba(0,0,0,0.9); opacity: 1; }
        .slot-image-card .save-gallery-btn.saved { color: gold; opacity: 1; }

        /* Info row layout */
        .slot-image-card .info-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .slot-image-card .info-row .filename {
            flex: 1;
            min-width: 0;
        }

        /* Load settings button */
        .slot-image-card .load-settings-btn,
        .slot-image-card .apply-seed-btn,
        .slot-image-card .inpaint-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        .slot-image-card .load-settings-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .slot-image-card .apply-seed-btn:hover {
            background: var(--accent-gold);
            color: black;
            border-color: var(--accent-gold);
        }
        .slot-image-card .inpaint-btn:hover {
            background: #9b59b6;
            color: white;
            border-color: #9b59b6;
        }

        /* Settings Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 900;
            justify-content: center;
            align-items: center;
        }
        
        .modal.active { display: flex; }
        
        .modal-content {
            background: var(--bg-light);
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-header h2 {
            font-size: 1.25rem;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .input-group {
            margin-bottom: 16px;
        }
        
        .input-group label {
            margin-bottom: 6px;
        }
        
        .input-group small {
            display: block;
            margin-top: -8px;
            margin-bottom: 12px;
            color: var(--text-dim);
            font-size: 0.8rem;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .status-badge.success {
            background: rgba(34, 197, 94, 0.2);
            color: var(--success);
        }
        
        .status-badge.warning {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }
        
        /* Local Environment */
        .local-env-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border-radius: 6px;
            margin-top: 6px;
        }
        
        .local-env-status .status-icon {
            font-size: 1.2rem;
        }
        
        .local-env-status.installed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }
        
        .local-env-status.not-installed {
            background: rgba(245, 158, 11, 0.15);
            color: var(--warning);
        }
        
        .local-env-status.installing {
            background: rgba(111, 41, 222, 0.15);
            color: var(--accent);
        }
        
        .local-env-status.error {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }
        
        .local-env-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }
        
        .local-env-progress-bar {
            flex: 1;
            height: 8px;
            background: var(--bg-lighter);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .local-env-progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .local-env-progress-text {
            font-size: 0.8rem;
            color: var(--text-dim);
            min-width: 40px;
        }
        
        #localEnvActions .btn {
            margin-right: 8px;
        }
        
        #localEnvActions .btn-danger {
            background: rgba(239, 68, 68, 0.2);
            color: var(--error);
        }
        
        #localEnvActions .btn-danger:hover {
            background: rgba(239, 68, 68, 0.3);
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            padding: 12px 24px;
            border-radius: 8px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1100;
        }
        
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .toast.success { border-color: var(--success); }
        .toast.error { border-color: var(--error); }
        .toast.warning { border-color: var(--warning); }
    </style>
</head>
<body>
    <div class="app">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="logo"><img src="assets/icon.png" alt="" style="width: 42px; height: 42px;"> PeroPix</div>
                <button class="settings-btn" onclick="openSettings()">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                </button>
            </div>
            
            <div class="sidebar-content">
                <!-- Provider Tabs -->
                <div class="section">
                    <div class="tabs">
                        <div class="tab active" data-provider="nai">NAI</div>
                        <div class="tab" data-provider="local">Local</div>
                    </div>
                </div>
                
                <!-- Prompts -->
                <div class="section">
                    <div class="prompt-label-row">
                        <div class="prompt-label-left">
                            <button type="button" class="collapse-toggle" data-target="basePromptContent" title="접기/펼치기">▼</button>
                            <button type="button" id="modeToggle" class="mode-toggle" title="아니메 모드">🌸</button>
                            <label for="basePrompt" class="prompt-label">Base Prompt</label>
                        </div>
                        <div class="prompt-preset-dropdown" data-category="base">
                            <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">🔖 ▼</button>
                            <div class="prompt-preset-menu">
                                <div class="prompt-preset-list"></div>
                                <div class="prompt-preset-actions">
                                    <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="basePromptContent" class="collapsible-content">
                        <textarea id="basePrompt" placeholder="1girl, solo, masterpiece..."></textarea>
                    </div>

                    <!-- Characters -->
                    <div class="characters-section">
                        <div class="characters-header">
                            <button type="button" class="collapse-toggle" data-target="charactersContent" title="접기/펼치기">▼</button>
                            <label class="prompt-label">Characters</label>
                            <button type="button" class="add-char-btn" id="addCharBtn" title="캐릭터 추가">+</button>
                        </div>
                        <div id="charactersContent" class="collapsible-content">
                            <div class="characters-list" id="charactersList">
                                <!-- 캐릭터들이 여기에 추가됨 -->
                            </div>
                        </div>
                    </div>

                    <div class="prompt-label-row">
                        <div class="prompt-label-left">
                            <button type="button" class="collapse-toggle" data-target="negativePromptContent" title="접기/펼치기">▼</button>
                            <label for="negativePrompt" class="prompt-label">Negative Prompt</label>
                        </div>
                        <div class="prompt-preset-dropdown" data-category="negative">
                            <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">🔖 ▼</button>
                            <div class="prompt-preset-menu">
                                <div class="prompt-preset-list"></div>
                                <div class="prompt-preset-actions">
                                    <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="negativePromptContent" class="collapsible-content">
                        <textarea id="negativePrompt" rows="2" placeholder="lowres, bad quality..."></textarea>
                    </div>
                </div>
                
                <!-- NAI Settings -->
                <div class="provider-section active" data-provider="nai">
                    <div class="section">
                        <div class="section-title">
                            <button type="button" class="collapse-toggle" data-target="naiSettingsContent" title="접기/펼치기">▼</button>
                            <span>NAI Settings</span>
                        </div>
                        <div id="naiSettingsContent" class="collapsible-content">
                            <label>Model</label>
                            <select id="naiModel">
                                <option value="nai-diffusion-4-5-full">V4.5 Full</option>
                                <option value="nai-diffusion-4-curated-preview">V4 Curated</option>
                                <option value="nai-diffusion-3">V3</option>
                            </select>

                            <div class="row">
                                <div>
                                    <label>Undesired Content Preset</label>
                                    <select id="ucPreset">
                                        <option value="Heavy">Heavy</option>
                                        <option value="Light">Light</option>
                                        <option value="Human Focus">Human Focus</option>
                                        <option value="Furry Focus">Furry Focus</option>
                                        <option value="None">None</option>
                                    </select>
                                </div>
                                <div>
                                    <label>SMEA</label>
                                    <select id="smea">
                                        <option value="none">None</option>
                                        <option value="SMEA">SMEA</option>
                                        <option value="SMEA+DYN">SMEA+DYN</option>
                                    </select>
                                </div>
                            </div>

                            <div class="checkbox-row">
                                <input type="checkbox" id="qualityTags" checked>
                                <label for="qualityTags">Add Quality Tags</label>
                            </div>
                        </div>
                    </div>

                    <!-- Vibe / Character Reference -->
                    <div class="section">
                        <div class="section-title">
                            <button type="button" class="collapse-toggle" data-target="vibeCharRefContent" title="접기/펼치기">▼</button>
                            <span>Vibe / Character Ref</span>
                            <small style="font-weight: normal; text-transform: none; letter-spacing: 0; opacity: 0.7;">(택1)</small>
                        </div>
                        <div id="vibeCharRefContent" class="collapsible-content">
                            <!-- Vibe Transfer -->
                            <div class="subsection">
                                <div class="subsection-title">
                                    <span>Vibe Transfer</span>
                                    <label class="section-toggle">
                                        <input type="checkbox" id="enableVibeTransfer">
                                        <span>Active</span>
                                    </label>
                                </div>

                                <div id="vibeTransferSettings" style="display: none;">
                                    <small style="color: var(--text-dim); display: block; margin-bottom: 8px;">
                                        최대 16개 이미지. 강도 합계가 1.0 이하가 되도록 권장.
                                    </small>

                                    <div id="vibeCacheInfo" style="display: none; font-size: 12px; margin-bottom: 8px; padding: 4px 8px; background: rgba(0,0,0,0.2); border-radius: 4px;"></div>

                                    <div id="vibeList" class="vibe-list"></div>

                                    <div class="btn-row">
                                        <button type="button" class="btn btn-secondary" id="addVibeBtn" style="flex: 1;">
                                            + 바이브 추가
                                        </button>
                                        <button type="button" class="btn btn-secondary btn-icon" id="openVibeFolderBtn" title="바이브 캐시 폴더 열기">
                                            📁
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Character Reference (V4.5 only) -->
                            <div class="subsection" id="charRefSection">
                                <div class="subsection-title">
                                    <span>Character Reference</span>
                                    <label class="section-toggle">
                                        <input type="checkbox" id="enableCharRef">
                                        <span>Active</span>
                                    </label>
                                </div>

                                <div id="charRefSettings" style="display: none;">
                                    <small style="color: var(--text-dim); display: block; margin-bottom: 8px;">
                                        V4.5 전용. Vibe Transfer와 동시 사용 불가.
                                    </small>

                                    <div id="charRefPreview" class="char-ref-preview" style="display: none;">
                                        <img id="charRefImage" src="" alt="Character Reference">
                                        <button type="button" class="remove-btn" id="removeCharRefBtn">×</button>
                                    </div>

                                    <button type="button" class="btn btn-secondary" id="uploadCharRefBtn" style="width: 100%;">
                                        이미지 선택
                                    </button>
                                    <input type="file" id="charRefInput" accept="image/*" style="display: none;">

                                    <div class="row" style="margin-top: 12px;">
                                        <div style="flex: 1;">
                                            <label>Fidelity</label>
                                            <input type="range" id="charRefFidelity" value="0.5" min="0" max="1" step="0.05" style="width: 100%;">
                                            <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim);">
                                                <span>유연</span>
                                                <span id="charRefFidelityValue">0.5</span>
                                                <span>정밀</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="checkbox-row" style="margin-top: 8px;">
                                        <input type="checkbox" id="charRefStyleAware" checked>
                                        <label for="charRefStyleAware">Style Aware (스타일도 복사)</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Local Settings -->
                <div class="provider-section" data-provider="local">
                    <div class="section">
                        <div class="section-title">Local Settings</div>
                        
                        <label>Model</label>
                        <div style="display: flex; gap: 8px;">
                            <select id="localModel" style="flex: 1;">
                                <option value="">-- Select Model --</option>
                            </select>
                            <button type="button" class="btn btn-secondary" id="openCheckpointsFolderBtn" title="체크포인트 폴더 열기" style="padding: 8px 12px;">
                                📁
                            </button>
                        </div>

                        <label>LoRAs</label>
                        <div class="lora-list" id="loraList">
                            <div style="color: var(--text-dim); font-size: 0.85rem; padding: 8px;">Loading...</div>
                        </div>
                        <button type="button" class="btn btn-secondary" id="openLorasFolderBtn" title="LoRA 폴더 열기" style="width: 100%; margin-top: 8px;">
                            📁 LoRA 폴더 열기
                        </button>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">
                            <span>Upscale</span>
                            <label class="section-toggle">
                                <input type="checkbox" id="enableUpscale">
                                <span>Active</span>
                            </label>
                        </div>
                        
                        <div id="upscaleSettings" style="display: none;">
                            <label>Upscale Model</label>
                            <select id="upscaleModel">
                                <option value="">-- Select Model --</option>
                            </select>
                            <small>Place .pth files in models/upscale_models/</small>
                            
                            <div class="row" style="margin-top: 8px;">
                                <div>
                                    <label>Final Scale</label>
                                    <input type="number" id="downscaleRatio" value="0.7" step="0.05" min="0.3" max="1.0">
                                    <small>×2 upscale × ratio</small>
                                </div>
                                <div>
                                    <label>Alignment</label>
                                    <select id="sizeAlignment">
                                        <option value="none">None</option>
                                        <option value="8">8px</option>
                                        <option value="64" selected>64px</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="row">
                                <div>
                                    <label>Steps</label>
                                    <input type="number" id="upscaleSteps" value="15" min="5" max="50">
                                </div>
                                <div>
                                    <label>CFG</label>
                                    <input type="number" id="upscaleCfg" value="5.0" step="0.1" min="1" max="20">
                                </div>
                            </div>
                            
                            <div class="row">
                                <div style="flex: 1;">
                                    <label>Denoise</label>
                                    <input type="range" id="upscaleDenoise" value="0.5" min="0.1" max="1.0" step="0.05" style="width: 100%;">
                                    <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim);">
                                        <span>0.1</span>
                                        <span id="upscaleDenoiseValue">0.5</span>
                                        <span>1.0</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Base Image (Inpaint/Img2Img) -->
                <div class="section" id="baseImageSection" style="display: none;">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="baseImageContent" title="접기/펼치기">▼</button>
                        <span>Base Image</span>
                        <button type="button" class="btn btn-secondary" id="clearBaseImage" style="margin-left: auto; padding: 4px 8px; font-size: 0.8rem;">✕ Clear</button>
                    </div>
                    <div id="baseImageContent" class="collapsible-content">
                        <div style="display: flex; gap: 12px; align-items: flex-start;">
                            <div id="baseImagePreview" style="flex: 0 0 120px; height: 120px; background: var(--bg); border-radius: 8px; overflow: hidden; display: flex; align-items: center; justify-content: center; position: relative;">
                                <img id="baseImageImg" src="" style="max-width: 100%; max-height: 100%; object-fit: contain;">
                                <div id="baseImageMaskOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.5; pointer-events: none;"></div>
                            </div>
                            <div style="flex: 1;">
                                <div class="row" style="margin-bottom: 8px;">
                                    <div style="flex: 1;">
                                        <label>Mode</label>
                                        <select id="baseImageMode">
                                            <option value="inpaint">Inpaint</option>
                                            <option value="img2img">Img2Img</option>
                                        </select>
                                    </div>
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <label>Strength: <span id="baseImageStrengthValue">0.7</span></label>
                                    <input type="range" id="baseImageStrength" min="0" max="1" step="0.05" value="0.7" style="width: 100%;">
                                </div>
                                <div id="baseImageNoiseContainer">
                                    <label>Noise: <span id="baseImageNoiseValue">0</span></label>
                                    <input type="range" id="baseImageNoise" min="0" max="1" step="0.05" value="0" style="width: 100%;">
                                </div>
                                <button type="button" class="btn" id="editMaskBtn" style="margin-top: 8px; width: 100%;">🎨 Edit Mask</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Generation Settings -->
                <div class="section">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="generationContent" title="접기/펼치기">▼</button>
                        <span>Generation</span>
                    </div>
                    <div id="generationContent" class="collapsible-content">
                        <div class="row">
                            <div>
                                <label>Size</label>
                                <select id="sizePreset">
                                    <optgroup label="Landscape">
                                        <option value="1536x640">1536 × 640</option>
                                        <option value="1344x768">1344 × 768</option>
                                        <option value="1216x832">1216 × 832</option>
                                        <option value="1152x896">1152 × 896</option>
                                    </optgroup>
                                    <optgroup label="Square">
                                        <option value="1024x1024">1024 × 1024</option>
                                    </optgroup>
                                    <optgroup label="Portrait">
                                        <option value="896x1152">896 × 1152</option>
                                        <option value="832x1216" selected>832 × 1216</option>
                                        <option value="768x1344">768 × 1344</option>
                                        <option value="640x1536">640 × 1536</option>
                                    </optgroup>
                                    <option value="custom">Custom</option>
                                </select>
                            </div>
                            <div>
                                <label>W × H</label>
                                <div class="size-inputs">
                                    <input type="number" id="width" value="832" step="64">
                                    <span class="size-x">×</span>
                                    <input type="number" id="height" value="1216" step="64">
                                </div>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Steps</label>
                                <input type="number" id="steps" value="28">
                            </div>
                            <div>
                                <label id="cfgLabel">CFG</label>
                                <input type="number" id="cfg" value="5.0" step="0.1">
                            </div>
                        </div>

                        <!-- NAI Advanced Settings -->
                        <div id="naiAdvancedSettings" class="provider-section" data-provider="nai">
                            <div class="row">
                                <div style="flex: 1;">
                                    <label style="display: flex; justify-content: space-between; align-items: center;">
                                        <span>Prompt Guidance Rescale</span>
                                        <span id="cfgRescaleValue" style="font-weight: 500;">0</span>
                                    </label>
                                    <input type="range" id="cfgRescale" value="0" min="0" max="1" step="0.02" style="width: 100%;">
                                </div>
                            </div>
                            <div class="checkbox-row">
                                <input type="checkbox" id="varietyPlus">
                                <label for="varietyPlus">Variety+</label>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Sampler</label>
                                <select id="sampler">
                                    <option value="k_euler_ancestral">Euler Ancestral</option>
                                    <option value="k_euler">Euler</option>
                                    <option value="k_dpmpp_2s_ancestral">DPM++ 2S Ancestral</option>
                                    <option value="k_dpmpp_2m_sde">DPM++ 2M SDE</option>
                                    <option value="k_dpmpp_2m">DPM++ 2M</option>
                                    <option value="k_dpmpp_sde">DPM++ SDE</option>
                                </select>
                            </div>
                            <div>
                                <label>Scheduler</label>
                                <select id="scheduler">
                                    <option value="karras">Karras</option>
                                    <option value="exponential">Exponential</option>
                                    <option value="polyexponential">Polyexponential</option>
                                </select>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Seed</label>
                                <input type="number" id="seed" value="-1">
                            </div>
                        </div>

                        <div class="checkbox-row">
                            <input type="checkbox" id="randomSeed">
                            <label for="randomSeed">매 슬롯마다 랜덤 시드</label>
                        </div>
                        <div class="checkbox-row">
                            <input type="checkbox" id="lockSeed">
                            <label for="lockSeed">시드 고정</label>
                        </div>
                    </div>
                </div>

                <!-- Save Options -->
                <div class="section">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="saveOptionsContent" title="접기/펼치기">▼</button>
                        <span>Save Options</span>
                    </div>
                    <div id="saveOptionsContent" class="collapsible-content">
                        <div class="row">
                            <div>
                                <label>Format</label>
                                <select id="saveFormat">
                                    <option value="png" selected>PNG</option>
                                    <option value="jpg">JPG</option>
                                    <option value="webp">WebP</option>
                                </select>
                            </div>
                            <div>
                                <label>JPG Quality</label>
                                <input type="number" id="jpgQuality" value="95" min="1" max="100" step="1">
                            </div>
                        </div>
                        <div class="checkbox-row">
                            <input type="checkbox" id="stripMetadata">
                            <label for="stripMetadata">메타데이터 제거</label>
                        </div>
                        <small style="color: var(--text-dim);">체크 시 이미지에서 생성 정보가 제거됩니다</small>
                    </div>
                </div>
            </div>

            <div class="sidebar-footer">
                <!-- Anlas Info (NAI only) - Single line -->
                <div id="anlasInfo" class="anlas-info" style="display: none;">
                    <span class="anlas-icon">💎</span>
                    <span id="anlasBalance">--</span>
                    <button type="button" class="anlas-refresh" id="refreshAnlasBtn" title="새로고침">↻</button>
                    <span class="anlas-separator">│</span>
                    <span class="anlas-cost-label">-</span>
                    <span id="anlasCost">0</span>
                    <span id="anlasFreeTag" class="free-tag" style="display: none;">FREE</span>
                </div>

                <div class="status-text" id="statusText" style="text-align: left; margin-bottom: 4px;">준비</div>
                <div class="progress-bar" style="margin-bottom: 12px;">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <div style="display: flex; margin-bottom: 8px; align-items: center; gap: 8px;">
                    <div style="flex: 1;">
                        <button class="btn" id="generateBtn">Queue (0)</button>
                    </div>
                    <span style="color: var(--text-dim); font-size: 0.9rem;">×</span>
                    <div style="width: 60px;">
                        <input type="number" id="repeatCount" value="1" min="1" style="margin: 0; height: 100%; text-align: center;" title="반복 횟수">
                    </div>
                </div>
                <div class="row" style="gap: 6px;">
                    <button class="btn btn-secondary" id="cancelCurrentBtn" title="현재 작업 취소 (진행중인 이미지 완료 후)">Cancel</button>
                    <button class="btn btn-secondary" id="clearQueueBtn" title="대기열 비우기">Clear Q</button>
                </div>
            </div>
            <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>
        </aside>

        <!-- Main -->
        <main class="main">
            <!-- 모드 토글 (공통) -->
            <div class="mode-header">
                <div class="mode-toggle">
                    <button type="button" class="mode-btn active" id="slotModeBtn">🎰 슬롯 모드</button>
                    <button type="button" class="mode-btn" id="galleryModeBtn">🖼️ 갤러리</button>
                    <button type="button" class="mode-btn" id="censorModeBtn">🔍 자동검열</button>
                </div>
            </div>

            <!-- 슬롯 모드 툴바 -->
            <div class="slots-toolbar" id="slotsToolbar">
                <div class="toolbar-left">
                    <button type="button" class="add-slot-btn" id="addSlotBtn" title="슬롯 추가">+🎰</button>
                    <div class="preset-dropdown" id="presetDropdown">
                        <button type="button" class="header-btn preset-btn" id="presetBtn">
                            <span>🔖</span>
                            <span class="preset-name" id="presetName">Slot Set</span>
                            <span class="dropdown-arrow">▼</span>
                        </button>
                        <div class="preset-menu" id="presetMenu">
                            <div class="preset-list" id="presetList">
                                <!-- 프리셋 목록 -->
                            </div>
                            <div class="preset-actions">
                                <button type="button" class="preset-action-btn" id="newPresetBtn">+ New Set</button>
                                <button type="button" class="preset-action-btn" id="savePresetBtn">💾 Save</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="header-btn" id="syncScrollBtn" title="전체 슬롯 스크롤 동기화">
                        <span>🔗</span>
                        <span>Sync</span>
                    </button>
                    <button type="button" class="header-btn" id="clearImagesBtn" title="미리보기 이미지 지우기 (파일은 삭제되지 않음)">
                        <span>🧹</span>
                        <span>Clear</span>
                    </button>
                </div>
                <div class="toolbar-right">
                    <div class="folder-dropdown" id="outputFolderDropdown">
                        <button type="button" class="header-btn folder-btn" id="outputFolderBtn">
                            <span class="folder-icon">📁</span>
                            <span class="folder-name" id="outputFolderName">output</span>
                            <span class="dropdown-arrow">▼</span>
                        </button>
                        <div class="folder-menu" id="outputFolderMenu">
                            <div class="folder-list" id="outputFolderList">
                                <!-- 폴더 목록 -->
                            </div>
                            <div class="folder-actions">
                                <button type="button" class="folder-action-btn" id="newOutputFolderBtn">+ 새 폴더</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="header-btn icon-only" id="openOutputFolderBtn" title="출력 폴더 열기">📂</button>
                </div>
            </div>

            <div class="slots-container-wrapper" id="slotsWrapper">
                <div class="slots-container" id="slotsContainer">
                    <!-- 슬롯들이 가로로 배치됨 -->
                </div>
            </div>

            <!-- 갤러리 모드 -->
            <div class="gallery-container" id="galleryContainer" style="display: none;">
                <div class="gallery-toolbar">
                    <div class="toolbar-left">
                        <button type="button" class="folder-tab vibe-folder" id="vibeCacheBtn" data-folder="vibe">🎨 vibe</button>
                        <span class="folder-separator double"></span>
                        <button type="button" class="folder-tab root-folder active" id="galleryRootBtn" data-folder="">📂 gallery</button>
                        <span class="folder-separator"></span>
                        <button type="button" class="add-folder-btn" id="addFolderBtn" title="새 폴더 추가">+📁</button>
                        <div class="gallery-subfolders" id="gallerySubfolders">
                            <!-- 하위 폴더 탭들이 여기에 추가됨 -->
                        </div>
                    </div>
                    <div class="toolbar-right">
                        <button type="button" class="header-btn icon-only" id="openGalleryFolderBtn" title="갤러리 폴더 열기">📂</button>
                    </div>
                </div>
                <div class="gallery-content">
                    <div class="gallery-grid" id="galleryGrid">
                        <!-- 갤러리 이미지들 -->
                    </div>
                    <div class="gallery-empty" id="galleryEmpty">
                        <div class="icon">🖼️</div>
                        <p>갤러리가 비어있습니다</p>
                        <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                    </div>
                </div>
            </div>

            <!-- 검열 모드 -->
            <div class="censor-container" id="censorContainer" style="display: none;">
                <div class="censor-toolbar">
                    <div class="toolbar-left">
                        <div class="censor-folder-select">
                            <label>Source:</label>
                            <select id="censorSourceFolder">
                                <option value="">📂 outputs</option>
                            </select>
                        </div>
                        <div class="censor-folder-select">
                            <label>Output:</label>
                            <select id="censorOutputFolder">
                                <option value="">📁 censored</option>
                            </select>
                        </div>
                    </div>
                    <div class="toolbar-center">
                        <button type="button" class="btn btn-primary" id="runAutoCensorBtn">🔍 자동 검열 실행</button>
                        <button type="button" class="btn" id="exportApprovedBtn">📤 승인된 이미지 내보내기</button>
                    </div>
                    <div class="toolbar-right">
                        <div class="censor-stats">
                            <span class="stat ok">✓ <span id="censorOkCount">0</span></span>
                            <span class="stat warning">⚠️ <span id="censorWarningCount">0</span></span>
                            <span class="stat total">전체: <span id="censorTotalCount">0</span></span>
                        </div>
                    </div>
                </div>
                <div class="censor-content">
                    <div class="censor-grid" id="censorGrid">
                        <!-- 검열 대상 이미지들 -->
                    </div>
                    <div class="censor-empty" id="censorEmpty">
                        <div class="icon">🔞</div>
                        <p>검열할 이미지가 없습니다</p>
                        <small>Source 폴더를 선택하고 [자동 검열 실행]을 클릭하세요</small>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <span class="close">&times;</span>
        <img src="" alt="">
    </div>

    <!-- Drop Overlay -->
    <div class="drop-overlay" id="dropOverlay">
        <div class="drop-overlay-content">
            <div class="icon">📥</div>
            <h3>이미지 드롭</h3>
            <p>바이브 또는 생성 이미지를 드롭하세요</p>
        </div>
    </div>

    <!-- Drop Confirm Modal -->
    <div class="drop-modal" id="dropModal">
        <div class="drop-modal-content">
            <h3 id="dropModalTitle">이미지 가져오기</h3>
            <img id="dropModalPreview" class="preview" src="" alt="">
            <div id="dropModalMetadata" class="metadata"></div>
            <div class="buttons" id="dropModalButtons">
                <button type="button" class="btn btn-secondary" id="dropModalCancel">취소</button>
                <button type="button" class="btn" id="dropModalAsVibe" style="display: none;">바이브로 추가</button>
                <button type="button" class="btn" id="dropModalPromptOnly" style="display: none;">프롬프트만</button>
                <button type="button" class="btn" id="dropModalSeedOnly" style="display: none;">시드만</button>
                <button type="button" class="btn btn-primary" id="dropModalConfirm">적용</button>
            </div>
        </div>
    </div>

    <!-- Generic Confirm Modal -->
    <div class="drop-modal" id="confirmModal">
        <div class="drop-modal-content" style="max-width: 400px;">
            <h3 id="confirmModalTitle">확인</h3>
            <div id="confirmModalMessage" class="metadata" style="margin: 16px 0;"></div>
            <div class="buttons">
                <button type="button" class="btn btn-secondary" id="confirmModalCancel">취소</button>
                <button type="button" class="btn" id="confirmModalOk">확인</button>
            </div>
        </div>
    </div>

    <!-- Input Prompt Modal -->
    <div class="drop-modal" id="inputModal">
        <div class="drop-modal-content" style="max-width: 400px;">
            <h3 id="inputModalTitle">입력</h3>
            <div id="inputModalMessage" style="margin: 12px 0; color: var(--text-dim);"></div>
            <input type="text" id="inputModalInput" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-light); color: var(--text); margin-bottom: 16px;">
            <div class="buttons">
                <button type="button" class="btn btn-secondary" id="inputModalCancel">취소</button>
                <button type="button" class="btn" id="inputModalOk">확인</button>
            </div>
        </div>
    </div>

    <!-- Mask Editor Modal -->
    <div class="mask-editor-modal" id="maskEditorModal">
        <div class="mask-editor-container">
            <div class="mask-editor-header">
                <h3>🎨 Inpaint Mask Editor</h3>
                <button class="btn btn-secondary" id="maskEditorClose" style="padding: 6px 12px;">✕</button>
            </div>
            <div class="mask-editor-toolbar">
                <div class="tool-group">
                    <button class="tool-btn active" id="maskToolBrush" title="브러시 (마스크 그리기)">🖌️ Brush</button>
                    <button class="tool-btn" id="maskToolEraser" title="지우개">◼ Eraser</button>
                </div>
                <div class="slider-group">
                    <label>Size:</label>
                    <input type="range" id="maskBrushSize" min="5" max="100" value="30">
                    <span id="maskBrushSizeValue">30</span>
                </div>
                <div class="tool-group" style="margin-left: auto;">
                    <button class="tool-btn" id="maskToolClear" title="전체 지우기">🗑️ Clear</button>
                    <button class="tool-btn" id="maskToolInvert" title="마스크 반전">🔄 Invert</button>
                </div>
            </div>
            <div class="mask-editor-canvas-wrapper">
                <canvas id="maskEditorImageCanvas"></canvas>
                <canvas id="maskEditorMaskCanvas"></canvas>
                <canvas id="maskEditorDrawCanvas" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
            </div>
            <div class="mask-editor-toolbar">
                <div class="slider-group">
                    <label>Strength:</label>
                    <input type="range" id="maskEditorStrength" min="0" max="1" step="0.05" value="0.7">
                    <span id="maskEditorStrengthValue">0.7</span>
                </div>
            </div>
            <div class="mask-editor-footer">
                <button class="btn btn-secondary" id="maskEditorCancel">취소</button>
                <button class="btn btn-primary" id="maskEditorApply">✓ 베이스 이미지로 등록</button>
            </div>
        </div>
    </div>

    <!-- Censor Quick Editor Modal -->
    <div class="censor-editor-modal" id="censorEditorModal">
        <div class="censor-editor-container">
            <div class="censor-editor-header">
                <div class="header-left">
                    <h3>🔞 Quick Editor</h3>
                    <span class="image-counter" id="censorImageCounter">1 / 10</span>
                </div>
                <div class="header-right">
                    <button class="nav-btn" id="censorPrevBtn" title="이전 이미지">◀</button>
                    <button class="nav-btn" id="censorNextBtn" title="다음 이미지">▶</button>
                    <button class="btn btn-secondary" id="censorEditorClose" style="padding: 6px 12px;">✕</button>
                </div>
            </div>
            <div class="censor-editor-toolbar">
                <div class="tool-group">
                    <button class="tool-btn active" id="censorToolRect" title="사각형 도구">▢ Rect</button>
                    <button class="tool-btn" id="censorToolBrush" title="브러시">🖌️ Brush</button>
                    <button class="tool-btn" id="censorToolMove" title="이동/선택">↔ Move</button>
                </div>
                <div class="tool-group">
                    <button class="tool-btn fill-btn active" id="censorFillBlack" title="검정 채우기" style="background: #333;">■</button>
                    <button class="tool-btn fill-btn" id="censorFillWhite" title="흰색 채우기" style="background: #fff; color: #333;">□</button>
                    <button class="tool-btn fill-btn" id="censorFillMosaic" title="모자이크">▦</button>
                </div>
                <div class="slider-group">
                    <label>Size:</label>
                    <input type="range" id="censorBrushSize" min="5" max="100" value="30">
                    <span id="censorBrushSizeValue">30</span>
                </div>
                <div class="tool-group" style="margin-left: auto;">
                    <button class="tool-btn" id="censorToolUndo" title="실행 취소">↩ Undo</button>
                    <button class="tool-btn" id="censorToolClear" title="전체 지우기">🗑️ Clear</button>
                </div>
            </div>
            <div class="censor-editor-canvas-wrapper">
                <canvas id="censorEditorCanvas"></canvas>
                <canvas id="censorEditorOverlay" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
            </div>
            <div class="censor-editor-footer">
                <div class="footer-left">
                    <button class="btn btn-secondary" id="censorMarkOk" title="이 이미지는 수정 불필요">✓ OK로 표시</button>
                    <button class="btn btn-warning" id="censorMarkNeed" title="추가 수정 필요">⚠️ 확인필요</button>
                </div>
                <div class="footer-right">
                    <button class="btn" id="censorSkipBtn">건너뛰기</button>
                    <button class="btn btn-primary" id="censorSaveNextBtn">💾 저장 & 다음</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="modal-close" onclick="closeSettings()">&times;</button>
            </div>
            
            <div class="input-group">
                <label>NAI API Token</label>
                <input type="password" id="naiToken" placeholder="NAI 토큰 입력">
                <small>Get from novelai.net → Account → API</small>
            </div>
            
            <div class="input-group">
                <label>Status</label>
                <span class="status-badge" id="naiStatus">Checking...</span>
            </div>
            
            <div class="input-group">
                <label>Checkpoints Directory</label>
                <input type="text" id="checkpointsDir" placeholder="./models/checkpoints">
            </div>
            
            <div class="input-group">
                <label>LoRA Directory</label>
                <input type="text" id="loraDir" placeholder="./models/loras">
            </div>
            
            <hr style="border: none; border-top: 1px solid var(--border); margin: 16px 0;">
            
            <div class="input-group">
                <label>Local Generation Environment</label>
                <div id="localEnvStatus" class="local-env-status">
                    <span class="status-text">Checking...</span>
                </div>
                <div id="localEnvActions" style="margin-top: 8px;">
                    <!-- 동적으로 버튼 추가됨 -->
                </div>
                <div id="localEnvProgress" class="local-env-progress" style="display: none;">
                    <div class="local-env-progress-bar">
                        <div class="local-env-progress-fill" id="localEnvProgressFill"></div>
                    </div>
                    <span class="local-env-progress-text" id="localEnvProgressText">0%</span>
                </div>
                <small style="display: block; margin-top: 12px; color: var(--text-dim);">Python + PyTorch CUDA + diffusers (~3GB, 3-5분)</small>
            </div>

            <button class="btn" onclick="saveSettings()" style="margin-top: 16px;">Save Settings</button>
        </div>
    </div>
    
    <!-- Local Install Modal -->
    <div class="modal" id="localInstallModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2>🖥️ Local Generation</h2>
                <button class="modal-close" onclick="closeLocalInstallModal()">&times;</button>
            </div>
            
            <p style="color: var(--text-dim); margin-bottom: 16px;">
                Local generation requires a one-time installation of Python environment with PyTorch CUDA.
            </p>
            
            <div class="input-group">
                <div id="installModalStatus" class="local-env-status">
                    <span class="status-text">Checking...</span>
                </div>
                <div id="installModalProgress" class="local-env-progress" style="display: none;">
                    <div class="local-env-progress-bar">
                        <div class="local-env-progress-fill" id="installModalProgressFill"></div>
                    </div>
                    <span class="local-env-progress-text" id="installModalProgressText">0%</span>
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn" id="installModalBtn" onclick="installFromModal()" style="flex: 1;">
                    ⬇️ Install (~3GB)
                </button>
                <button class="btn" onclick="closeLocalInstallModal()" style="background: var(--surface-light);">
                    Cancel
                </button>
            </div>
            
            <small style="display: block; margin-top: 12px; color: var(--text-dim);">
                Installation takes 3-5 minutes depending on your internet speed.
            </small>
        </div>
    </div>
    
    <!-- NAI Token Modal -->
    <div class="modal" id="naiTokenModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2>🔑 NovelAI API Token</h2>
                <button class="modal-close" onclick="closeNaiTokenModal()">&times;</button>
            </div>
            
            <p style="color: var(--text-dim); margin-bottom: 16px;">
                Enter your NovelAI API token to use NAI generation.
            </p>
            
            <div class="input-group">
                <label>API Token</label>
                <input type="password" id="naiTokenModalInput" placeholder="NAI 토큰 입력">
                <small>Get from <a href="https://novelai.net/settings" target="_blank" style="color: var(--primary);">novelai.net</a> → Account Settings → Get Persistent API Token</small>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn" id="naiTokenModalBtn" onclick="saveNaiTokenFromModal()" style="flex: 1;">
                    💾 Save & Continue
                </button>
                <button class="btn" onclick="closeNaiTokenModal()" style="background: var(--surface-light);">
                    Cancel
                </button>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
    
    <script>
        const API_BASE = 'http://127.0.0.1:8765';
        
        let currentProvider = 'nai';
        let currentIndex = 0;
        let totalImages = 0;
        let resetTimer = null;
        let naiTokenSet = false;  // NAI 토큰 설정 여부

        // WebSocket 연결 관리
        let ws = null;
        let wsClientId = localStorage.getItem('ws_client_id') || null;
        let wsReconnectTimer = null;
        let lastImageSeq = 0;  // 마지막으로 받은 이미지 순번 (재연결 시 동기화용)

        // Elements
        const tabs = document.querySelectorAll('.tab');
        const providerSections = document.querySelectorAll('.provider-section');
        const generateBtn = document.getElementById('generateBtn');
        const cancelCurrentBtn = document.getElementById('cancelCurrentBtn');
        const clearQueueBtn = document.getElementById('clearQueueBtn');
        const progressFill = document.getElementById('progressFill');
        const statusText = document.getElementById('statusText');
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = lightbox.querySelector('img');

        // Lightbox navigation state (for wheel navigation)
        let lightboxCurrentSlot = null;
        let lightboxCurrentCard = null;
        let lightboxCurrentGalleryItem = null;  // 갤러리 모드용
        
        // Slots
        const slotsContainer = document.getElementById('slotsContainer');
        const addSlotBtn = document.getElementById('addSlotBtn');
        let slotCounter = 0;
        
        function updateSlotNumbers() {
            const slots = slotsContainer.querySelectorAll('.slot');
            slots.forEach((slot, index) => {
                slot.querySelector('.slot-number').textContent = String(index + 1).padStart(3, '0');
            });
        }
        
        // 슬롯 너비 관리
        let currentSlotWidth = 280;
        const MIN_SLOT_WIDTH = 150;
        const MAX_SLOT_WIDTH = 1200;

        function setSlotWidth(width) {
            currentSlotWidth = Math.max(MIN_SLOT_WIDTH, Math.min(MAX_SLOT_WIDTH, width));
            document.documentElement.style.setProperty('--slot-width', currentSlotWidth + 'px');
            autoSaveSettings();
        }

        function setupSlotResize(slot) {
            const handle = slot.querySelector('.slot-resize-handle');
            if (!handle) return;

            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = currentSlotWidth;

                document.body.classList.add('resizing-slot');
                handle.classList.add('active');

                function onMouseMove(e) {
                    const deltaX = e.clientX - startX;
                    setSlotWidth(startWidth + deltaX);
                }

                function onMouseUp() {
                    document.body.classList.remove('resizing-slot');
                    handle.classList.remove('active');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // 사이드바 너비 관리
        let currentSidebarWidth = 540;
        const MIN_SIDEBAR_WIDTH = 360;
        const MAX_SIDEBAR_WIDTH = 800;

        function setSidebarWidth(width) {
            currentSidebarWidth = Math.max(MIN_SIDEBAR_WIDTH, Math.min(MAX_SIDEBAR_WIDTH, width));
            document.documentElement.style.setProperty('--sidebar-width', currentSidebarWidth + 'px');
            autoSaveSettings();
        }

        // 사이드바 리사이즈 핸들 설정
        (function setupSidebarResize() {
            const handle = document.getElementById('sidebarResizeHandle');
            if (!handle) return;

            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = currentSidebarWidth;

                document.body.classList.add('resizing-slot');
                handle.classList.add('active');

                function onMouseMove(e) {
                    const deltaX = e.clientX - startX;
                    setSidebarWidth(startWidth + deltaX);
                }

                function onMouseUp() {
                    document.body.classList.remove('resizing-slot');
                    handle.classList.remove('active');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        })();

        function createSlot(name = '', content = '') {
            const slotId = slotCounter++;
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.dataset.slotIndex = slotId;
            slot.innerHTML = `
                <div class="slot-resize-handle"></div>
                <div class="slot-prompt">
                    <div class="slot-prompt-header">
                        <span class="slot-number">001</span>
                        <input type="text" placeholder="이름 (선택)" value="${name}" class="slot-name">
                        <button type="button" class="slot-drag" title="드래그하여 순서 변경" tabindex="-1">☰</button>
                        <button type="button" class="slot-delete" tabindex="-1">×</button>
                    </div>
                    <textarea placeholder="이 슬롯에만 적용할 태그" class="slot-tags">${content}</textarea>
                </div>
                <div class="slot-images">
                    <div class="slot-empty">이미지가 여기에 표시됩니다</div>
                </div>
            `;

            // 리사이즈 핸들 설정
            setupSlotResize(slot);
            
            slot.querySelector('.slot-delete').onclick = () => {
                if (slotsContainer.querySelectorAll('.slot').length > 1) {
                    slot.remove();
                    updateSlotNumbers();
                    updateQueueButton();
                    updateAnlasCost();
                    autoSaveSettings();
                }
            };

            slot.querySelector('textarea').oninput = updateQueueButton;
            
            // 탭 키로 같은 타입 필드 간 이동
            const nameInput = slot.querySelector('.slot-name');
            const tagsInput = slot.querySelector('.slot-tags');
            
            nameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const slots = [...slotsContainer.querySelectorAll('.slot')];
                    const currentIdx = slots.indexOf(slot);
                    const nextIdx = e.shiftKey 
                        ? (currentIdx - 1 + slots.length) % slots.length 
                        : (currentIdx + 1) % slots.length;
                    slots[nextIdx].querySelector('.slot-name').focus();
                }
            });
            
            tagsInput.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const slots = [...slotsContainer.querySelectorAll('.slot')];
                    const currentIdx = slots.indexOf(slot);
                    const nextIdx = e.shiftKey 
                        ? (currentIdx - 1 + slots.length) % slots.length 
                        : (currentIdx + 1) % slots.length;
                    slots[nextIdx].querySelector('.slot-tags').focus();
                }
            });
            
            // 드래그 핸들
            const dragHandle = slot.querySelector('.slot-drag');
            dragHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startSlotDrag(slot, e);
            });
            
            return slot;
        }
        
        // 슬롯 드래그 앤 드롭
        let draggedSlot = null;
        let dragStartX = 0;
        let slotStartX = 0;
        let placeholder = null;
        
        function startSlotDrag(slot, e) {
            draggedSlot = slot;
            dragStartX = e.clientX;
            
            const rect = slot.getBoundingClientRect();
            slotStartX = rect.left;
            
            // 플레이스홀더 생성
            placeholder = document.createElement('div');
            placeholder.className = 'slot-placeholder';
            placeholder.style.width = rect.width + 'px';
            placeholder.style.height = rect.height + 'px';
            
            // 드래그 중 스타일
            slot.classList.add('dragging');
            slot.style.position = 'fixed';
            slot.style.left = rect.left + 'px';
            slot.style.top = rect.top + 'px';
            slot.style.width = rect.width + 'px';
            slot.style.zIndex = '1000';
            
            slot.parentNode.insertBefore(placeholder, slot);
            document.body.appendChild(slot);
            
            document.addEventListener('mousemove', onSlotDrag);
            document.addEventListener('mouseup', endSlotDrag);
        }
        
        function onSlotDrag(e) {
            if (!draggedSlot) return;
            
            const dx = e.clientX - dragStartX;
            draggedSlot.style.left = (slotStartX + dx) + 'px';
            
            // 플레이스홀더 위치 업데이트
            const slots = [...slotsContainer.querySelectorAll('.slot:not(.dragging)')];
            const draggedRect = draggedSlot.getBoundingClientRect();
            const draggedCenter = draggedRect.left + draggedRect.width / 2;
            
            for (let i = 0; i < slots.length; i++) {
                const slotRect = slots[i].getBoundingClientRect();
                const slotCenter = slotRect.left + slotRect.width / 2;
                
                if (draggedCenter < slotCenter) {
                    slotsContainer.insertBefore(placeholder, slots[i]);
                    return;
                }
            }
            slotsContainer.appendChild(placeholder);
        }
        
        function endSlotDrag() {
            if (!draggedSlot) return;
            
            // 플레이스홀더 위치에 슬롯 삽입
            draggedSlot.classList.remove('dragging');
            draggedSlot.style.position = '';
            draggedSlot.style.left = '';
            draggedSlot.style.top = '';
            draggedSlot.style.width = '';
            draggedSlot.style.zIndex = '';
            
            slotsContainer.insertBefore(draggedSlot, placeholder);
            placeholder.remove();
            
            draggedSlot = null;
            placeholder = null;
            
            document.removeEventListener('mousemove', onSlotDrag);
            document.removeEventListener('mouseup', endSlotDrag);

            updateSlotNumbers();
            autoSaveSettings();
        }

        function addSlot(name = '', content = '') {
            const slot = createSlot(name, content);
            slotsContainer.appendChild(slot);
            setupSlotImageScroll(slot);
            updateSlotNumbers();
            updateQueueButton();
            updateAnlasCost();
        }
        
        function getSlotList() {
            const slots = slotsContainer.querySelectorAll('.slot');
            const list = [];
            
            slots.forEach((slot, index) => {
                const name = slot.querySelector('.slot-name').value.trim();
                const content = slot.querySelector('.slot-tags').value.trim();
                // 현재 위치 기반 인덱스 사용
                list.push({ name, content, slotIndex: index });
            });
            
            return list;
        }
        
        function updateQueueButton() {
            const list = getSlotList();
            const count = list.length || 1;
            generateBtn.textContent = `Queue (${count})`;
        }
        
        function addImageToSlot(slotIndex, data) {
            // slotIndex로 슬롯 찾기
            const slots = slotsContainer.querySelectorAll('.slot');
            const slotsWrapperDisplay = slotsWrapper.style.display;
            console.log(`[addImageToSlot] slotIndex=${slotIndex}, slots.length=${slots.length}, filename=${data.filename}, slotsWrapperDisplay=${slotsWrapperDisplay}`);

            // 슬롯이 없거나 인덱스가 범위를 벗어나면 첫 번째 슬롯에 추가
            let targetSlot;
            if (slotIndex >= slots.length || slotIndex < 0) {
                console.warn(`[addImageToSlot] Invalid slotIndex ${slotIndex}, falling back to slot 0`);
                if (slots.length === 0) {
                    console.error('[addImageToSlot] No slots available!');
                    return;
                }
                targetSlot = slots[0];
            } else {
                targetSlot = slots[slotIndex];
            }

            const imagesContainer = targetSlot.querySelector('.slot-images');

            // 빈 상태 제거
            const empty = imagesContainer.querySelector('.slot-empty');
            if (empty) empty.remove();

            const card = document.createElement('div');
            card.className = 'slot-image-card';

            // image_path가 있으면 URL로, 없으면 base64로 (하위 호환)
            const imgSrc = data.image_path
                ? `${API_BASE}/api/outputs/${data.image_path}`
                : `data:image/png;base64,${data.image}`;
            card.innerHTML = `
                <img src="${imgSrc}" alt="" draggable="false">
                <button type="button" class="save-gallery-btn" title="갤러리에 저장">☆</button>
                <div class="info">
                    <div class="info-row">
                        <div class="filename" title="${data.filename}">${data.filename}</div>
                        <button type="button" class="inpaint-btn" title="Inpaint">🎨</button>
                        <button type="button" class="apply-seed-btn" title="이 시드 적용">🎲</button>
                        <button type="button" class="load-settings-btn" title="전체 설정 불러오기">📋</button>
                    </div>
                    <div class="seed">Seed: ${data.seed}</div>
                </div>
            `;

            // 이미지 데이터 저장 (갤러리 저장용 + 설정 불러오기용)
            card._imageData = {
                image_path: data.image_path || null,
                image: data.image || null,  // 하위 호환
                filename: data.filename,
                seed: data.seed,
                prompt: data.prompt || '',
                metadata: data.metadata || null  // 전체 설정 메타데이터
            };

            // 갤러리 저장/제거 토글 버튼
            const saveBtn = card.querySelector('.save-gallery-btn');
            saveBtn.onclick = async (e) => {
                e.stopPropagation();

                // 이미 저장된 경우 갤러리에서 제거
                if (saveBtn.classList.contains('saved')) {
                    try {
                        const galleryFilename = card._imageData.galleryFilename || card._imageData.filename;
                        const response = await fetch(`${API_BASE}/api/gallery/${encodeURIComponent(galleryFilename)}`, {
                            method: 'DELETE'
                        });
                        const result = await response.json();
                        if (result.success) {
                            saveBtn.classList.remove('saved');
                            saveBtn.textContent = '☆';
                            card._imageData.galleryFilename = null;
                            showToast('갤러리에서 제거됨', 'success');
                            // 갤러리 뷰 새로고침
                            if (currentMode === 'gallery') {
                                loadGallery();
                            }
                        } else {
                            showToast('제거 실패: ' + result.error, 'error');
                        }
                    } catch (err) {
                        showToast('제거 오류: ' + err.message, 'error');
                    }
                    return;
                }

                // 저장되지 않은 경우 갤러리에 저장
                try {
                    // 현재 열린 갤러리 폴더에 저장
                    const response = await fetch(`${API_BASE}/api/gallery/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image: card._imageData.image,  // base64 (하위 호환)
                            image_path: card._imageData.image_path,  // 파일 경로
                            filename: card._imageData.filename,
                            folder: currentGalleryFolder || '',  // 현재 갤러리 폴더
                            metadata: card._imageData.metadata  // 메타데이터 (JPG/WebP 저장 시 필요)
                        })
                    });
                    const result = await response.json();
                    if (result.success) {
                        saveBtn.classList.add('saved');
                        saveBtn.textContent = '★';
                        card._imageData.galleryFilename = result.filename || card._imageData.filename;
                        showToast('갤러리에 저장됨', 'success');
                    } else {
                        showToast('저장 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('저장 오류: ' + err.message, 'error');
                }
            };

            // 시드 적용 버튼
            const applySeedBtn = card.querySelector('.apply-seed-btn');
            applySeedBtn.onclick = (e) => {
                e.stopPropagation();
                const seed = card._imageData.seed;
                if (seed !== undefined && seed !== null) {
                    document.getElementById('seed').value = seed;
                    showToast(`시드 ${seed} 적용됨`, 'success');
                } else {
                    showToast('시드 정보가 없습니다', 'error');
                }
            };

            // 설정 불러오기 버튼
            const loadSettingsBtn = card.querySelector('.load-settings-btn');
            loadSettingsBtn.onclick = (e) => {
                e.stopPropagation();
                const metadata = card._imageData.metadata;
                if (!metadata) {
                    showToast('메타데이터가 없습니다', 'error');
                    return;
                }
                showLoadSettingsConfirm(metadata);
            };

            // Inpaint 버튼
            const inpaintBtn = card.querySelector('.inpaint-btn');
            inpaintBtn.onclick = async (e) => {
                e.stopPropagation();
                // 이미지 base64 가져오기
                let imageBase64 = card._imageData.image;
                if (!imageBase64 && card._imageData.image_path) {
                    // 파일 경로에서 이미지 로드 (outputs API 사용)
                    try {
                        const response = await fetch(`${API_BASE}/api/outputs/${card._imageData.image_path}`);
                        const blob = await response.blob();
                        imageBase64 = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result.split(',')[1]);
                            reader.readAsDataURL(blob);
                        });
                    } catch (err) {
                        showToast('이미지 로드 실패', 'error');
                        return;
                    }
                }
                if (imageBase64) {
                    setBaseImageForInpaint('data:image/png;base64,' + imageBase64);
                } else {
                    showToast('이미지 데이터가 없습니다', 'error');
                }
            };

            // 드래그와 클릭 구분
            const img = card.querySelector('img');
            let imgMouseDownX = 0;
            let imgMouseDownY = 0;

            img.addEventListener('mousedown', (e) => {
                imgMouseDownX = e.clientX;
                imgMouseDownY = e.clientY;
            });

            img.addEventListener('mouseup', (e) => {
                const dx = Math.abs(e.clientX - imgMouseDownX);
                const dy = Math.abs(e.clientY - imgMouseDownY);
                // 5px 이내면 클릭으로 간주
                if (dx < 5 && dy < 5) {
                    lightboxImg.src = imgSrc;  // URL 또는 base64 사용
                    lightboxCurrentSlot = targetSlot;
                    lightboxCurrentCard = card;
                    lightbox.classList.add('active');
                }
            });

            // 이미지 로드 완료 후 카드 추가 (이미지와 info가 동시에 표시되도록)
            const insertCard = () => {
                imagesContainer.insertBefore(card, imagesContainer.firstChild);
                console.log(`[addImageToSlot] Card inserted for ${data.filename}`);
            };
            img.onload = insertCard;
            img.onerror = insertCard;  // 로드 실패 시에도 카드 표시
        }

        function clearSlotImages() {
            const slots = slotsContainer.querySelectorAll('.slot');
            slots.forEach(slot => {
                const imagesContainer = slot.querySelector('.slot-images');
                imagesContainer.innerHTML = '<div class="slot-empty">이미지가 여기에 표시됩니다</div>';
            });
        }
        
        addSlotBtn.onclick = () => {
            addSlot();
            autoSaveSettings();
        };
        
        // === Preset System ===
        const presetDropdown = document.getElementById('presetDropdown');
        const presetBtn = document.getElementById('presetBtn');
        const presetMenu = document.getElementById('presetMenu');
        const presetList = document.getElementById('presetList');
        const presetNameSpan = document.getElementById('presetName');
        const newPresetBtn = document.getElementById('newPresetBtn');
        const savePresetBtn = document.getElementById('savePresetBtn');
        
        let currentPreset = null; // { filename, name }
        let presets = [];
        
        // 드롭다운 토글 (body에 붙여서 overflow 문제 해결)
        presetBtn.onclick = (e) => {
            e.stopPropagation();
            const isShowing = presetMenu.classList.contains('show');

            if (isShowing) {
                presetMenu.classList.remove('show');
                presetDropdown.appendChild(presetMenu); // 원래 위치로
            } else {
                // body에 붙이고 위치 계산
                document.body.appendChild(presetMenu);
                const btnRect = presetBtn.getBoundingClientRect();
                presetMenu.style.top = (btnRect.bottom + 4) + 'px';
                presetMenu.style.left = btnRect.left + 'px';
                presetMenu.classList.add('show');
                loadPresetList();
            }
        };

        // 외부 클릭 시 닫기
        document.addEventListener('click', (e) => {
            if (!presetDropdown.contains(e.target) && !presetMenu.contains(e.target)) {
                presetMenu.classList.remove('show');
                if (presetMenu.parentElement === document.body) {
                    presetDropdown.appendChild(presetMenu);
                }
            }
        });
        
        // 프리셋 목록 로드
        async function loadPresetList() {
            try {
                const res = await fetch(`${API_BASE}/api/presets`);
                const data = await res.json();
                presets = data.presets;
                renderPresetList();
            } catch (e) {
                console.error('Failed to load presets:', e);
            }
        }
        
        // 프리셋 목록 렌더링
        function renderPresetList() {
            if (presets.length === 0) {
                presetList.innerHTML = '<div class="preset-empty">No presets saved</div>';
                return;
            }
            
            presetList.innerHTML = presets.map(p => `
                <div class="preset-item ${currentPreset?.filename === p.filename ? 'selected' : ''}" data-filename="${p.filename}">
                    <span class="check">${currentPreset?.filename === p.filename ? '✓' : ''}</span>
                    <span class="label">${p.name}</span>
                    <button class="edit-btn" title="이름 변경">✏️</button>
                    <button class="delete-btn" title="삭제">🗑️</button>
                </div>
            `).join('');
            
            // 이벤트 바인딩
            presetList.querySelectorAll('.preset-item').forEach(item => {
                const filename = item.dataset.filename;
                
                item.querySelector('.label').onclick = () => loadPreset(filename);
                
                item.querySelector('.edit-btn').onclick = (e) => {
                    e.stopPropagation();
                    renamePreset(filename);
                };
                
                item.querySelector('.delete-btn').onclick = (e) => {
                    e.stopPropagation();
                    deletePreset(filename);
                };
            });
        }
        
        // 프리셋 로드
        async function loadPreset(filename) {
            try {
                const res = await fetch(`${API_BASE}/api/presets/${filename}`);
                const data = await res.json();
                
                // 현재 슬롯 모두 제거
                slotsContainer.innerHTML = '';
                
                // 프리셋 슬롯들로 교체
                data.slots.forEach(s => {
                    addSlot(s.name, s.content);
                });
                
                // 최소 1개 슬롯
                if (data.slots.length === 0) {
                    addSlot();
                }
                
                // 폴더 적용
                setOutputFolder(data.folder || '');
                
                currentPreset = { filename, name: data.name };
                presetNameSpan.textContent = data.name;
                presetMenu.classList.remove('show');
                
                showToast(`Loaded: ${data.name}`, 'success');
            } catch (e) {
                showToast('프리셋 로드 실패', 'error');
            }
        }
        
        // 새 프리셋 저장
        newPresetBtn.onclick = async () => {
            const name = prompt('프리셋 이름 입력:');
            if (!name) return;
            
            const slots = getSlotList().map(s => ({ name: s.name, content: s.content }));
            const folder = getOutputFolder();

            try {
                const res = await fetch(`${API_BASE}/api/presets`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, slots, folder })
                });
                const data = await res.json();
                
                currentPreset = { filename: data.filename, name: data.name };
                presetNameSpan.textContent = data.name;
                
                loadPresetList();
                showToast(`Saved: ${name}`, 'success');
            } catch (e) {
                showToast('프리셋 저장 실패', 'error');
            }
        };
        
        // 현재 프리셋에 덮어쓰기
        savePresetBtn.onclick = async () => {
            if (!currentPreset) {
                showToast('프리셋이 선택되지 않음', 'warning');
                return;
            }
            
            const slots = getSlotList().map(s => ({ name: s.name, content: s.content }));
            const folder = getOutputFolder();

            try {
                await fetch(`${API_BASE}/api/presets/${currentPreset.filename}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: currentPreset.name, slots, folder })
                });
                
                showToast(`Saved: ${currentPreset.name}`, 'success');
                presetMenu.classList.remove('show');
            } catch (e) {
                showToast('프리셋 저장 실패', 'error');
            }
        };
        
        // 프리셋 이름 변경
        async function renamePreset(filename) {
            const preset = presets.find(p => p.filename === filename);
            if (!preset) return;
            
            const newName = prompt('Enter new name:', preset.name);
            if (!newName || newName === preset.name) return;
            
            try {
                // 기존 데이터 로드
                const res = await fetch(`${API_BASE}/api/presets/${filename}`);
                const data = await res.json();
                
                // 이름만 변경해서 저장 (prefix 유지)
                await fetch(`${API_BASE}/api/presets/${filename}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName, slots: data.slots, prefix: data.prefix || 'Name_' })
                });
                
                if (currentPreset?.filename === filename) {
                    currentPreset.name = newName;
                    presetNameSpan.textContent = newName;
                }
                
                loadPresetList();
                showToast('이름 변경됨', 'success');
            } catch (e) {
                showToast('이름 변경 실패', 'error');
            }
        }
        
        // 프리셋 삭제
        async function deletePreset(filename) {
            const preset = presets.find(p => p.filename === filename);
            if (!preset) return;

            showConfirmModal(
                '🗑️ 프리셋 삭제',
                `<p>"${preset.name}" 프리셋을 삭제하시겠습니까?</p>`,
                async () => {
                    try {
                        await fetch(`${API_BASE}/api/presets/${filename}`, { method: 'DELETE' });

                        if (currentPreset?.filename === filename) {
                            currentPreset = null;
                            presetNameSpan.textContent = 'Slot Set';
                        }

                        loadPresetList();
                        showToast('삭제됨', 'success');
                    } catch (e) {
                        showToast('삭제 실패', 'error');
                    }
                },
                '삭제',
                true
            );
        }

        // ============================================================
        // Output Folder Dropdown
        // ============================================================
        const outputFolderDropdown = document.getElementById('outputFolderDropdown');
        const outputFolderBtn = document.getElementById('outputFolderBtn');
        const outputFolderMenu = document.getElementById('outputFolderMenu');
        const outputFolderList = document.getElementById('outputFolderList');
        const outputFolderName = document.getElementById('outputFolderName');
        const outputFolderIcon = outputFolderBtn.querySelector('.folder-icon');

        let currentOutputFolder = ''; // 빈 문자열 = output 루트

        // 현재 선택된 폴더 반환 (API 호출 시 사용)
        function getOutputFolder() {
            return currentOutputFolder;
        }

        // 폴더 선택 시 UI 업데이트
        function setOutputFolder(folderName) {
            currentOutputFolder = folderName;
            outputFolderName.textContent = folderName || 'output';
            outputFolderIcon.textContent = '📁';
            autoSaveSettings();
        }

        // 폴더 드롭다운 토글
        outputFolderBtn.onclick = (e) => {
            e.stopPropagation();
            const isShowing = outputFolderMenu.classList.contains('show');

            if (isShowing) {
                outputFolderMenu.classList.remove('show');
                outputFolderDropdown.appendChild(outputFolderMenu);
            } else {
                document.body.appendChild(outputFolderMenu);
                const btnRect = outputFolderBtn.getBoundingClientRect();
                outputFolderMenu.style.top = (btnRect.bottom + 4) + 'px';
                outputFolderMenu.style.right = (window.innerWidth - btnRect.right) + 'px';
                outputFolderMenu.style.left = 'auto';
                outputFolderMenu.classList.add('show');
                loadOutputFolderList();
            }
        };

        // 외부 클릭 시 닫기
        document.addEventListener('click', (e) => {
            if (!outputFolderDropdown.contains(e.target) && !outputFolderMenu.contains(e.target)) {
                outputFolderMenu.classList.remove('show');
                if (outputFolderMenu.parentElement === document.body) {
                    outputFolderDropdown.appendChild(outputFolderMenu);
                }
            }
        });

        // 폴더 목록 로드
        async function loadOutputFolderList() {
            try {
                const res = await fetch(`${API_BASE}/api/output-folders`);
                const data = await res.json();
                renderOutputFolderList(data.folders || []);
            } catch (e) {
                console.error('Failed to load output folders:', e);
                renderOutputFolderList([]);
            }
        }

        // 폴더 목록 렌더링
        function renderOutputFolderList(folders) {
            const isRootSelected = currentOutputFolder === '';

            let html = `
                <div class="folder-item root-folder ${isRootSelected ? 'active' : ''}" data-folder="">
                    <span>${isRootSelected ? '📂' : '📁'}</span>
                    <span>output</span>
                </div>
            `;

            folders.forEach(folder => {
                const isSelected = currentOutputFolder === folder.name;
                html += `
                    <div class="folder-item subfolder ${isSelected ? 'active' : ''}" data-folder="${folder.name}">
                        <span>${isSelected ? '📂' : '📁'}</span>
                        <span>${folder.name}</span>
                        <span style="margin-left: auto; opacity: 0.6; font-size: 0.75rem;">${folder.image_count}</span>
                    </div>
                `;
            });

            outputFolderList.innerHTML = html;

            // 폴더 클릭 이벤트
            outputFolderList.querySelectorAll('.folder-item').forEach(item => {
                item.onclick = () => {
                    setOutputFolder(item.dataset.folder);
                    outputFolderMenu.classList.remove('show');
                    outputFolderDropdown.appendChild(outputFolderMenu);
                };
            });
        }

        // 새 폴더 생성
        document.getElementById('newOutputFolderBtn').onclick = () => {
            outputFolderMenu.classList.remove('show');
            outputFolderDropdown.appendChild(outputFolderMenu);

            showInputModal('📁 새 폴더', '폴더 이름을 입력하세요', async (folderName) => {
                try {
                    const response = await fetch(`${API_BASE}/api/output-folders`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: folderName })
                    });
                    const result = await response.json();
                    if (result.success) {
                        setOutputFolder(result.name);
                        showToast(`폴더 생성: ${result.name}`, 'success');
                    } else {
                        showToast(result.error || '폴더 생성 실패', 'error');
                    }
                } catch (err) {
                    showToast('폴더 생성 오류', 'error');
                }
            }, '생성');
        };

        // Sync scroll 토글
        const syncScrollBtn = document.getElementById('syncScrollBtn');
        let syncScrollEnabled = false;
        let isSyncScrolling = false;
        
        syncScrollBtn.onclick = () => {
            syncScrollEnabled = !syncScrollEnabled;
            syncScrollBtn.classList.toggle('active', syncScrollEnabled);
        };
        
        function setupSlotImageScroll(slot) {
            const imagesContainer = slot.querySelector('.slot-images');
            
            imagesContainer.addEventListener('scroll', () => {
                if (!syncScrollEnabled || isSyncScrolling) return;
                
                isSyncScrolling = true;
                const scrollTop = imagesContainer.scrollTop;
                const scrollRatio = imagesContainer.scrollTop / (imagesContainer.scrollHeight - imagesContainer.clientHeight || 1);
                
                // 다른 모든 슬롯의 이미지 영역도 같이 스크롤
                slotsContainer.querySelectorAll('.slot').forEach(otherSlot => {
                    if (otherSlot === slot) return;
                    const otherImages = otherSlot.querySelector('.slot-images');
                    const maxScroll = otherImages.scrollHeight - otherImages.clientHeight;
                    otherImages.scrollTop = scrollRatio * maxScroll;
                });
                
                setTimeout(() => { isSyncScrolling = false; }, 10);
            });
        }
        
        // 스크롤 그라데이션 업데이트
        const slotsWrapper = document.getElementById('slotsWrapper');
        
        function updateScrollGradients() {
            const { scrollLeft, scrollWidth, clientWidth } = slotsContainer;
            const canScrollLeft = scrollLeft > 5;
            const canScrollRight = scrollLeft < scrollWidth - clientWidth - 5;
            
            slotsWrapper.classList.toggle('can-scroll-left', canScrollLeft);
            slotsWrapper.classList.toggle('can-scroll-right', canScrollRight);
        }
        
        slotsContainer.addEventListener('scroll', updateScrollGradients);
        // 초기화 및 슬롯 추가/삭제 시 업데이트를 위한 observer
        const resizeObserver = new ResizeObserver(updateScrollGradients);
        resizeObserver.observe(slotsContainer);
        
        // 가로 스크롤 드래그 (오버스크롤 바운스 포함)
        let isScrollDragging = false;
        let scrollStartX = 0;
        let scrollLeft = 0;
        let overscrollOffset = 0;
        
        slotsContainer.addEventListener('mousedown', (e) => {
            // 텍스트 입력란, 버튼, 드래그 핸들만 제외
            if (e.target.tagName === 'INPUT' || 
                e.target.tagName === 'TEXTAREA' || 
                e.target.tagName === 'BUTTON' ||
                e.target.classList.contains('slot-drag') ||
                e.target.classList.contains('slot-delete')) {
                return;
            }
            
            isScrollDragging = true;
            scrollStartX = e.pageX - slotsContainer.offsetLeft;
            scrollLeft = slotsContainer.scrollLeft;
            overscrollOffset = 0;
            slotsContainer.style.cursor = 'grabbing';
            slotsContainer.style.transition = 'none';
        });
        
        slotsContainer.addEventListener('mousemove', (e) => {
            if (!isScrollDragging) return;
            e.preventDefault();
            const x = e.pageX - slotsContainer.offsetLeft;
            const walk = (x - scrollStartX) * 1.5;
            
            const maxScroll = slotsContainer.scrollWidth - slotsContainer.clientWidth;
            const newScrollLeft = scrollLeft - walk;
            
            // 스크롤 가능 범위 체크
            if (maxScroll <= 0) {
                // 스크롤 불가 - 오버스크롤 효과만
                overscrollOffset = walk * 0.3; // 저항감 있게
                overscrollOffset = Math.max(-50, Math.min(50, overscrollOffset));
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else if (newScrollLeft < 0) {
                // 왼쪽 끝 넘어감
                slotsContainer.scrollLeft = 0;
                overscrollOffset = -newScrollLeft * 0.3;
                overscrollOffset = Math.min(50, overscrollOffset);
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else if (newScrollLeft > maxScroll) {
                // 오른쪽 끝 넘어감
                slotsContainer.scrollLeft = maxScroll;
                overscrollOffset = -(newScrollLeft - maxScroll) * 0.3;
                overscrollOffset = Math.max(-50, overscrollOffset);
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else {
                // 정상 스크롤
                slotsContainer.scrollLeft = newScrollLeft;
                overscrollOffset = 0;
                slotsContainer.style.transform = '';
            }
        });
        
        function endScrollDrag() {
            if (!isScrollDragging) return;
            isScrollDragging = false;
            slotsContainer.style.cursor = '';
            
            // 오버스크롤 바운스백
            if (overscrollOffset !== 0) {
                slotsContainer.style.transition = 'transform 0.3s ease-out';
                slotsContainer.style.transform = '';
                overscrollOffset = 0;
            }
        }
        
        slotsContainer.addEventListener('mouseup', endScrollDrag);
        slotsContainer.addEventListener('mouseleave', endScrollDrag);
        
        // Tab switching
        let localEnvInstalled = false;  // Local 환경 설치 여부
        
        // NAI / Local 샘플러/스케줄러 옵션
        const NAI_SAMPLERS = [
            { value: 'k_euler_ancestral', label: 'Euler Ancestral' },
            { value: 'k_euler', label: 'Euler' },
            { value: 'k_dpmpp_2s_ancestral', label: 'DPM++ 2S Ancestral' },
            { value: 'k_dpmpp_2m_sde', label: 'DPM++ 2M SDE' },
            { value: 'k_dpmpp_2m', label: 'DPM++ 2M' },
            { value: 'k_dpmpp_sde', label: 'DPM++ SDE' },
        ];
        const NAI_SCHEDULERS = [
            { value: 'karras', label: 'Karras' },
            { value: 'exponential', label: 'Exponential' },
            { value: 'polyexponential', label: 'Polyexponential' },
        ];
        const LOCAL_SAMPLERS = [
            { value: 'euler_ancestral', label: 'Euler Ancestral' },
            { value: 'euler', label: 'Euler' },
            { value: 'dpmpp_2m', label: 'DPM++ 2M' },
            { value: 'dpmpp_2m_sde', label: 'DPM++ 2M SDE' },
            { value: 'dpmpp_sde', label: 'DPM++ SDE' },
            { value: 'dpmpp_3m_sde', label: 'DPM++ 3M SDE' },
            { value: 'dpmpp_2s_ancestral', label: 'DPM++ 2S Ancestral' },
            { value: 'ddim', label: 'DDIM' },
            { value: 'uni_pc', label: 'UniPC' },
            { value: 'lcm', label: 'LCM' },
        ];
        const LOCAL_SCHEDULERS = [
            { value: 'normal', label: 'Normal' },
            { value: 'karras', label: 'Karras' },
            { value: 'exponential', label: 'Exponential' },
            { value: 'sgm_uniform', label: 'SGM Uniform' },
            { value: 'simple', label: 'Simple' },
            { value: 'ddim_uniform', label: 'DDIM Uniform' },
            { value: 'beta', label: 'Beta' },
        ];
        
        function updateSamplerSchedulerOptions(provider) {
            const samplerSelect = document.getElementById('sampler');
            const schedulerSelect = document.getElementById('scheduler');
            
            const samplers = provider === 'nai' ? NAI_SAMPLERS : LOCAL_SAMPLERS;
            const schedulers = provider === 'nai' ? NAI_SCHEDULERS : LOCAL_SCHEDULERS;
            
            // 현재 선택 저장
            const currentSampler = samplerSelect.value;
            const currentScheduler = schedulerSelect.value;
            
            // 옵션 교체
            samplerSelect.innerHTML = samplers.map(s => 
                `<option value="${s.value}">${s.label}</option>`
            ).join('');
            schedulerSelect.innerHTML = schedulers.map(s => 
                `<option value="${s.value}">${s.label}</option>`
            ).join('');
            
            // 기존 선택 복원 시도, 없으면 첫 번째
            if (samplers.some(s => s.value === currentSampler)) {
                samplerSelect.value = currentSampler;
            }
            if (schedulers.some(s => s.value === currentScheduler)) {
                schedulerSelect.value = currentScheduler;
            }
        }
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Local 탭 클릭 시 설치 안 됐으면 팝업
                if (tab.dataset.provider === 'local' && !localEnvInstalled) {
                    showLocalInstallModal();
                    return;
                }

                currentProvider = tab.dataset.provider;
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                providerSections.forEach(s => {
                    s.classList.toggle('active', s.dataset.provider === currentProvider);
                });
                updateSamplerSchedulerOptions(currentProvider);
                updateAnlasVisibility();
                updateProviderLabels();
                autoSaveSettings();
            });
        });

        // Provider별 라벨 업데이트
        function updateProviderLabels() {
            const cfgLabel = document.getElementById('cfgLabel');
            if (cfgLabel) {
                cfgLabel.textContent = currentProvider === 'nai' ? 'Prompt Guidance' : 'CFG';
            }
        }
        
        // === Prompt Presets ===
        async function loadPromptPresets(category) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}`);
                const data = await res.json();
                return data.presets;
            } catch (e) {
                console.error('Failed to load prompt presets:', e);
                return [];
            }
        }
        
        async function getPromptPreset(category, filename) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}/${filename}`);
                const data = await res.json();
                return data.content;
            } catch (e) {
                console.error('Failed to get prompt preset:', e);
                return null;
            }
        }
        
        async function savePromptPreset(category, name, content) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, content })
                });
                const data = await res.json();
                showToast(`Saved: ${name}`, 'success');
                return data;
            } catch (e) {
                showToast('저장 실패', 'error');
                return null;
            }
        }
        
        async function deletePromptPreset(category, filename) {
            try {
                await fetch(`${API_BASE}/api/prompts/${category}/${filename}`, { method: 'DELETE' });
                showToast('삭제됨', 'success');
                return true;
            } catch (e) {
                showToast('삭제 실패', 'error');
                return false;
            }
        }
        
        function setupPromptPresetDropdown(dropdown, textarea) {
            const category = dropdown.dataset.category;
            const btn = dropdown.querySelector('.prompt-preset-btn');
            const menu = dropdown.querySelector('.prompt-preset-menu');
            const list = dropdown.querySelector('.prompt-preset-list');
            const saveBtn = dropdown.querySelector('.prompt-preset-save-btn');
            
            btn.onclick = async (e) => {
                e.stopPropagation();
                // 다른 메뉴 닫기
                document.querySelectorAll('.prompt-preset-menu.show').forEach(m => {
                    if (m !== menu) m.classList.remove('show');
                });
                menu.classList.toggle('show');
                
                if (menu.classList.contains('show')) {
                    // 목록 로드
                    const presets = await loadPromptPresets(category);
                    if (presets.length === 0) {
                        list.innerHTML = '<div class="prompt-preset-empty">저장된 프리셋 없음</div>';
                    } else {
                        list.innerHTML = presets.map(p => `
                            <div class="prompt-preset-item" data-filename="${p.filename}">
                                <div class="prompt-preset-item-name" title="${p.name}">${p.name}</div>
                                <div class="prompt-preset-item-actions">
                                    <button class="add-btn">Add</button>
                                    <button class="replace-btn">Replace</button>
                                    <button class="delete-btn">🗑️</button>
                                </div>
                            </div>
                        `).join('');
                        
                        // 이벤트 바인딩
                        list.querySelectorAll('.prompt-preset-item').forEach(item => {
                            const filename = item.dataset.filename;
                            
                            item.querySelector('.add-btn').onclick = async (e) => {
                                e.stopPropagation();
                                const content = await getPromptPreset(category, filename);
                                if (content !== null) {
                                    if (textarea.value.trim()) {
                                        textarea.value = textarea.value.trim() + '\n\n' + content;
                                    } else {
                                        textarea.value = content;
                                    }
                                    menu.classList.remove('show');
                                }
                            };
                            
                            item.querySelector('.replace-btn').onclick = async (e) => {
                                e.stopPropagation();
                                const content = await getPromptPreset(category, filename);
                                if (content !== null) {
                                    textarea.value = content;
                                    menu.classList.remove('show');
                                }
                            };
                            
                            item.querySelector('.delete-btn').onclick = async (e) => {
                                e.stopPropagation();
                                showConfirmModal(
                                    '🗑️ 프리셋 삭제',
                                    '<p>이 프리셋을 삭제하시겠습니까?</p>',
                                    async () => {
                                        if (await deletePromptPreset(category, filename)) {
                                            item.remove();
                                            if (list.querySelectorAll('.prompt-preset-item').length === 0) {
                                                list.innerHTML = '<div class="prompt-preset-empty">저장된 프리셋 없음</div>';
                                            }
                                        }
                                    },
                                    '삭제',
                                    true
                                );
                            };
                        });
                    }
                }
            };
            
            saveBtn.onclick = async (e) => {
                e.stopPropagation();
                const content = textarea.value.trim();
                if (!content) {
                    showToast('저장할 내용 없음', 'warning');
                    return;
                }
                const name = prompt('프리셋 이름 입력:');
                if (!name) return;
                
                if (await savePromptPreset(category, name, content)) {
                    menu.classList.remove('show');
                }
            };
        }
        
        // Base/Negative 프롬프트 프리셋 초기화
        document.querySelectorAll('.section > .prompt-label-row .prompt-preset-dropdown').forEach(dropdown => {
            const category = dropdown.dataset.category;
            let textarea;
            if (category === 'base') {
                textarea = document.getElementById('basePrompt');
            } else if (category === 'negative') {
                textarea = document.getElementById('negativePrompt');
            }
            if (textarea) {
                setupPromptPresetDropdown(dropdown, textarea);
            }
        });
        
        // 외부 클릭 시 프롬프트 프리셋 메뉴 닫기
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.prompt-preset-dropdown')) {
                document.querySelectorAll('.prompt-preset-menu.show').forEach(m => m.classList.remove('show'));
            }
        });
        
        // === Characters ===
        const charactersList = document.getElementById('charactersList');
        const addCharBtn = document.getElementById('addCharBtn');
        
        function createCharacterItem(content = '', collapsed = false, enabled = true) {
            const item = document.createElement('div');
            item.className = 'character-item' + (enabled ? '' : ' disabled');

            // 헤더 (접기 + on/off + 번호 + 프리셋 + 삭제)
            const header = document.createElement('div');
            header.className = 'character-item-header';

            // 접기 버튼
            const collapseBtn = document.createElement('button');
            collapseBtn.type = 'button';
            collapseBtn.className = 'collapse-toggle' + (collapsed ? ' collapsed' : '');
            collapseBtn.textContent = '▼';
            collapseBtn.title = '접기/펼치기';

            // On/Off 토글
            const enableToggle = document.createElement('input');
            enableToggle.type = 'checkbox';
            enableToggle.className = 'char-enable-toggle';
            enableToggle.checked = enabled;
            enableToggle.title = enabled ? '활성화됨 (클릭하여 비활성화)' : '비활성화됨 (클릭하여 활성화)';
            enableToggle.onchange = () => {
                item.classList.toggle('disabled', !enableToggle.checked);
                enableToggle.title = enableToggle.checked ? '활성화됨 (클릭하여 비활성화)' : '비활성화됨 (클릭하여 활성화)';
                autoSaveSettings();
            };

            const charNum = document.createElement('span');
            charNum.className = 'char-num';

            // 프리셋 드롭다운
            const presetDropdown = document.createElement('div');
            presetDropdown.className = 'prompt-preset-dropdown';
            presetDropdown.dataset.category = 'character';
            presetDropdown.innerHTML = `
                <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">🔖 ▼</button>
                <div class="prompt-preset-menu">
                    <div class="prompt-preset-list"></div>
                    <div class="prompt-preset-actions">
                        <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                    </div>
                </div>
            `;

            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'delete-char-btn';
            deleteBtn.textContent = '×';
            deleteBtn.onclick = () => {
                item.remove();
                updateCharacterNumbers();
                autoSaveSettings();
            };

            header.appendChild(collapseBtn);
            header.appendChild(enableToggle);
            header.appendChild(charNum);
            header.appendChild(presetDropdown);
            header.appendChild(deleteBtn);

            // 프롬프트 입력 (접을 수 있는 영역)
            const contentDiv = document.createElement('div');
            contentDiv.className = 'collapsible-content' + (collapsed ? ' collapsed' : '');

            const textarea = document.createElement('textarea');
            textarea.value = content;
            textarea.placeholder = 'Character prompt...';
            textarea.rows = 2;

            contentDiv.appendChild(textarea);

            // 헤더 바 전체 클릭으로 접기/펴기
            header.addEventListener('click', (e) => {
                // 체크박스, 프리셋, 삭제 버튼 클릭은 무시
                if (e.target.closest('.char-enable-toggle, .prompt-preset-dropdown, .delete-char-btn')) return;
                collapseBtn.classList.toggle('collapsed');
                contentDiv.classList.toggle('collapsed');
                autoSaveSettings();
            });

            item.appendChild(header);
            item.appendChild(contentDiv);

            // 프리셋 드롭다운 이벤트 연결
            setupPromptPresetDropdown(presetDropdown, textarea);

            return item;
        }
        
        function updateCharacterNumbers() {
            const items = charactersList.querySelectorAll('.character-item');
            items.forEach((item, index) => {
                item.querySelector('.char-num').textContent = index + 1;
            });
            // 최대 6개 제한
            updateAddCharBtn();
        }
        
        function updateAddCharBtn() {
            const count = charactersList.querySelectorAll('.character-item').length;
            addCharBtn.disabled = count >= 6;
            addCharBtn.title = count >= 6 ? 'Maximum 6 characters' : 'Add character';
        }
        
        function addCharacter(content = '') {
            const count = charactersList.querySelectorAll('.character-item').length;
            if (count >= 6) {
                showToast('최대 6개의 캐릭터까지 가능', 'warning');
                return;
            }
            // Characters 섹션이 접혀있으면 펼치기
            const charactersContent = document.getElementById('charactersContent');
            if (charactersContent.classList.contains('collapsed')) {
                charactersContent.classList.remove('collapsed');
                // 토글 버튼 상태도 동기화
                const toggleBtn = document.querySelector('[data-target="charactersContent"]');
                if (toggleBtn) {
                    toggleBtn.classList.remove('collapsed');
                    localStorage.setItem('collapse_charactersContent', 'expanded');
                }
            }
            const item = createCharacterItem(content);
            charactersList.appendChild(item);
            updateCharacterNumbers();
            item.querySelector('textarea').focus();
        }
        
        function getCharacterPrompts() {
            const items = charactersList.querySelectorAll('.character-item');
            return Array.from(items)
                .filter(item => item.querySelector('.char-enable-toggle').checked)  // enabled만
                .map(item => item.querySelector('textarea').value)
                .filter(v => v.trim());
        }

        function getCharacterPromptsWithLayout() {
            const items = charactersList.querySelectorAll('.character-item');
            return Array.from(items).map(item => ({
                content: item.querySelector('textarea').value,
                collapsed: item.querySelector('.collapsible-content').classList.contains('collapsed'),
                height: item.querySelector('textarea').style.height || null,
                enabled: item.querySelector('.char-enable-toggle').checked
            }));
        }
        
        addCharBtn.onclick = () => {
            addCharacter();
            autoSaveSettings();
        };
        
        // Load resources
        async function loadResources() {
            try {
                const [modelsRes, lorasRes, upscaleRes, configRes] = await Promise.all([
                    fetch(`${API_BASE}/api/models`),
                    fetch(`${API_BASE}/api/loras`),
                    fetch(`${API_BASE}/api/upscale_models`),
                    fetch(`${API_BASE}/api/config`)
                ]);
                
                const { models } = await modelsRes.json();
                const { loras } = await lorasRes.json();
                const upscaleData = await upscaleRes.json();
                const config = await configRes.json();
                
                // Models
                const modelSelect = document.getElementById('localModel');
                modelSelect.innerHTML = '<option value="">-- Select Model --</option>';
                models.forEach(m => {
                    modelSelect.innerHTML += `<option value="${m}">${m}</option>`;
                });
                
                // LoRAs
                const loraList = document.getElementById('loraList');
                if (loras.length === 0) {
                    loraList.innerHTML = '<div style="color: var(--text-dim); font-size: 0.85rem; padding: 8px;">No LoRAs found</div>';
                } else {
                    loraList.innerHTML = loras.map(l => `
                        <div class="lora-item">
                            <input type="checkbox" data-lora="${l}">
                            <span class="lora-name" title="${l}">${l}</span>
                            <input type="number" value="1.0" step="0.1" min="0" max="2">
                        </div>
                    `).join('');
                }
                
                // Upscale Models
                const upscaleSelect = document.getElementById('upscaleModel');
                upscaleSelect.innerHTML = '<option value="">-- Select Model --</option>';
                (upscaleData.models || []).forEach(m => {
                    upscaleSelect.innerHTML += `<option value="${m}">${m}</option>`;
                });
                
                // Config
                document.getElementById('checkpointsDir').value = config.checkpoints_dir || '';
                document.getElementById('loraDir').value = config.lora_dir || '';
                updateNaiStatus(config.nai_token_set);
                
            } catch (e) {
                console.error('Failed to load:', e);
                statusText.textContent = '백엔드 실행 안됨!';
                showToast('백엔드 연결 안됨', 'error');
            }
        }
        
        function updateNaiStatus(hasToken) {
            naiTokenSet = hasToken;
            const badge = document.getElementById('naiStatus');
            if (hasToken) {
                badge.textContent = 'Connected';
                badge.className = 'status-badge success';
            } else {
                badge.textContent = 'Token not set';
                badge.className = 'status-badge warning';
            }
        }
        
        // NAI Token Modal
        function showNaiTokenModal() {
            document.getElementById('naiTokenModal').classList.add('active');
            document.getElementById('naiTokenModalInput').focus();
        }
        
        function closeNaiTokenModal() {
            document.getElementById('naiTokenModal').classList.remove('active');
        }
        
        async function saveNaiTokenFromModal() {
            const token = document.getElementById('naiTokenModalInput').value.trim();
            if (!token) {
                showToast('토큰을 입력하세요', 'error');
                return;
            }
            
            const btn = document.getElementById('naiTokenModalBtn');
            btn.textContent = '⏳ Saving...';
            btn.disabled = true;
            
            try {
                const res = await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nai_token: token })
                });
                const data = await res.json();

                if (res.ok && data.success) {
                    showToast('토큰 저장됨', 'success');
                    naiTokenSet = true;
                    updateNaiStatus(true);
                    closeNaiTokenModal();

                    // Settings 모달의 토큰 필드도 업데이트
                    document.getElementById('naiToken').value = token;

                    // 생성 진행
                    addToQueue();
                } else {
                    showToast(data.error || '토큰 저장 실패', 'error');
                }
            } catch (e) {
                showToast('토큰 저장 실패', 'error');
            }
            
            btn.textContent = '💾 Save & Continue';
            btn.disabled = false;
        }
        
        // 모달 외부 클릭 및 Enter 키
        document.getElementById('naiTokenModal').addEventListener('click', (e) => {
            if (e.target.id === 'naiTokenModal') closeNaiTokenModal();
        });
        document.getElementById('naiTokenModalInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveNaiTokenFromModal();
        });
        
        function getSelectedLoras() {
            const loras = [];
            document.querySelectorAll('.lora-item').forEach(item => {
                const cb = item.querySelector('input[type="checkbox"]');
                const scale = item.querySelector('input[type="number"]');
                if (cb.checked) {
                    loras.push({ name: cb.dataset.lora, scale: parseFloat(scale.value) });
                }
            });
            return loras;
        }
        
        // Generate
        async function addToQueue() {
            // NAI 모드인데 토큰 없으면 팝업
            if (currentProvider === 'nai' && !naiTokenSet) {
                showNaiTokenModal();
                return;
            }
            
            // Complete 후 리셋 타이머 취소
            if (resetTimer) {
                clearTimeout(resetTimer);
                resetTimer = null;
            }
            
            // Complete 상태였다면 새로 시작
            if (totalImages > 0 && totalImages === currentIndex) {
                currentIndex = 0;
                totalImages = 0;
            }
            
            const slotList = getSlotList();
            const repeatCount = parseInt(document.getElementById('repeatCount').value) || 1;

            // 모든 슬롯 등록 (빈 슬롯도 포함)
            const promptCount = slotList.length || 1;

            // 백엔드용 데이터 변환
            const promptData = slotList.length > 0
                ? slotList.map(s => ({ name: s.name, content: s.content, slotIndex: s.slotIndex }))
                : [{ name: '', content: '', slotIndex: 0 }];

            console.log(`[Queue] Adding job: slots=${slotList.length}, promptData=`, promptData);
            
            const request = {
                provider: currentProvider,
                base_prompt: document.getElementById('basePrompt').value,
                negative_prompt: document.getElementById('negativePrompt').value,
                character_prompts: getCharacterPrompts(),
                prompt_list: promptData,
                width: parseInt(document.getElementById('width').value),
                height: parseInt(document.getElementById('height').value),
                steps: parseInt(document.getElementById('steps').value),
                cfg: parseFloat(document.getElementById('cfg').value),
                seed: parseInt(document.getElementById('seed').value),
                random_seed_per_image: document.getElementById('randomSeed').checked,
                sampler: document.getElementById('sampler').value,
                scheduler: document.getElementById('scheduler').value,
                output_folder: getOutputFolder(),
            };
            
            if (currentProvider === 'nai') {
                request.nai_model = document.getElementById('naiModel').value;
                request.smea = document.getElementById('smea').value;
                request.uc_preset = document.getElementById('ucPreset').value;
                request.quality_tags = document.getElementById('qualityTags').checked;
                request.furry_mode = furryModeEnabled;
                request.cfg_rescale = parseFloat(document.getElementById('cfgRescale').value);
                request.variety_plus = document.getElementById('varietyPlus').checked;

                // Vibe Transfer
                if (document.getElementById('enableVibeTransfer').checked && vibeList.length > 0) {
                    request.vibe_transfer = vibeList.map(v => ({
                        image: v.image,
                        info_extracted: v.info_extracted,
                        strength: v.strength,
                        name: v.name || 'vibe',
                        encoded: v.encoded,
                        encoded_model: v.encoded_model
                    }));
                }

                // Character Reference (V4.5 only)
                if (document.getElementById('enableCharRef').checked && charRefData) {
                    request.character_reference = {
                        image: charRefData.image,
                        fidelity: parseFloat(document.getElementById('charRefFidelity').value),
                        style_aware: document.getElementById('charRefStyleAware').checked
                    };
                }
            } else {
                request.model = document.getElementById('localModel').value;
                request.loras = getSelectedLoras();
                if (!request.model) {
                    showToast('모델을 선택하세요', 'error');
                    return;
                }
                
                // Upscale settings
                request.enable_upscale = document.getElementById('enableUpscale').checked;
                if (request.enable_upscale) {
                    request.upscale_model = document.getElementById('upscaleModel').value;
                    request.downscale_ratio = parseFloat(document.getElementById('downscaleRatio').value);
                    request.upscale_steps = parseInt(document.getElementById('upscaleSteps').value);
                    request.upscale_cfg = parseFloat(document.getElementById('upscaleCfg').value);
                    request.upscale_denoise = parseFloat(document.getElementById('upscaleDenoise').value);
                    request.size_alignment = document.getElementById('sizeAlignment').value;
                    
                    if (!request.upscale_model) {
                        showToast('업스케일 모델을 선택하세요', 'error');
                        return;
                    }
                }
            }

            // Save options
            request.save_format = document.getElementById('saveFormat').value;
            request.jpg_quality = parseInt(document.getElementById('jpgQuality').value);
            request.strip_metadata = document.getElementById('stripMetadata').checked;

            // Base Image (img2img / inpaint)
            if (baseImageData.enabled && baseImageData.image) {
                request.base_image = baseImageData.image;
                request.base_mode = baseImageData.mode;
                request.base_strength = baseImageData.strength;
                request.base_noise = baseImageData.noise;
                if (baseImageData.mode === 'inpaint' && baseImageData.mask) {
                    request.base_mask = baseImageData.mask;
                }
            }

            // 시드 고정이 아닐 경우, 다음 큐를 위해 즉시 새 시드로 UI 갱신
            // (빠르게 여러 번 클릭해도 중복 시드 방지)
            if (!document.getElementById('lockSeed').checked) {
                document.getElementById('seed').value = Math.floor(Math.random() * 2147483647);
            }

            // N번 큐에 등록
            for (let i = 0; i < repeatCount; i++) {
                try {
                    await fetch(`${API_BASE}/api/generate/multi`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(request)
                    });
                } catch (e) {
                    showToast(`Error: ${e.message}`, 'error');
                }

                // 매번 새로운 시드
                request.seed = Math.floor(Math.random() * 2147483647);
            }

            showToast(`${repeatCount * promptCount} images queued`, 'success');
        }
        
        function updateProgress() {
            if (totalImages === 0) {
                statusText.textContent = '준비';
                progressFill.style.width = '0%';
            } else {
                statusText.textContent = `${currentIndex}/${totalImages}`;
                progressFill.style.width = `${(currentIndex / totalImages) * 100}%`;
            }
        }
        
        async function cancelCurrent() {
            try {
                const response = await fetch(`${API_BASE}/api/cancel-current`, { method: 'POST' });
                const result = await response.json();
                showToast(result.message, result.success ? 'warning' : 'error');
            } catch (e) {
                showToast(`Error: ${e.message}`, 'error');
            }
        }
        
        async function clearQueue() {
            try {
                const response = await fetch(`${API_BASE}/api/clear-queue`, { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    // 대기 이미지 수 제거
                    totalImages -= result.cleared_images;
                    if (totalImages < currentIndex) totalImages = currentIndex;
                    updateProgress();
                    showToast(`Cleared ${result.cleared_images} images`, 'warning');
                }
            } catch (e) {
                showToast(`Error: ${e.message}`, 'error');
            }
        }
        
        // ============================================================
        // WebSocket 연결 및 메시지 처리
        // ============================================================

        function connectWebSocket() {
            if (wsReconnectTimer) {
                clearTimeout(wsReconnectTimer);
                wsReconnectTimer = null;
            }

            if (ws && ws.readyState === WebSocket.OPEN) {
                return;
            }

            const wsUrl = `ws://127.0.0.1:8765/ws${wsClientId ? `?clientId=${wsClientId}` : ''}`;
            console.log('[WS] Connecting...', wsUrl);
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('[WS] Connected');
                // 재연결 시 누락된 이미지 동기화 요청
                if (lastImageSeq > 0) {
                    ws.send(JSON.stringify({ type: 'sync', last_seq: lastImageSeq }));
                }
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                } catch (e) {
                    console.error('[WS] Parse error:', e);
                }
            };

            ws.onclose = (event) => {
                console.log('[WS] Disconnected, reconnecting in 1s...', event.code);
                wsReconnectTimer = setTimeout(connectWebSocket, 1000);
            };

            ws.onerror = (error) => {
                console.error('[WS] Error:', error);
            };
        }

        function updateProgressFromServer(progress) {
            if (progress) {
                currentIndex = progress.completed;
                totalImages = progress.total;
                updateProgress();
            }
        }

        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'connected':
                    // 연결 성공, 클라이언트 ID 저장
                    wsClientId = data.client_id;
                    localStorage.setItem('ws_client_id', wsClientId);
                    console.log('[WS] Client ID:', wsClientId);
                    // 초기 상태 동기화
                    if (data.status) {
                        currentIndex = data.status.completed_images;
                        totalImages = data.status.total_images;
                        updateProgress();
                    }
                    break;

                case 'sync':
                    // 재연결 시 누락된 이미지 수신
                    console.log(`[WS] Sync: received ${data.images?.length || 0} missed images`);
                    if (data.images) {
                        data.images.forEach(img => {
                            addImageToSlot(img.slot_idx, img);
                            if (img.seq) lastImageSeq = Math.max(lastImageSeq, img.seq);
                        });
                    }
                    if (data.status) {
                        currentIndex = data.status.completed_images;
                        totalImages = data.status.total_images;
                        updateProgress();
                    }
                    break;

                case 'job_queued':
                    // 작업이 큐에 추가될 때 즉시 진행률 반영
                    console.log(`[WS] Job queued: ${data.job_id}, images: ${data.job_images}`);
                    updateProgressFromServer(data.progress);
                    break;

                case 'job_start':
                    console.log(`[WS] Job started: ${data.job_id}, total: ${data.job_total}`);
                    updateProgressFromServer(data.progress);
                    break;

                case 'image':
                    console.log(`[WS] Image received: job_id=${data.job_id}, slot_idx=${data.slot_idx}, filename=${data.filename}, seq=${data.seq}`);
                    if (data.seq) lastImageSeq = Math.max(lastImageSeq, data.seq);
                    updateProgressFromServer(data.progress);
                    addImageToSlot(data.slot_idx, data);
                    break;

                case 'job_done':
                    console.log(`[WS] Job done: ${data.job_id}`);
                    updateProgressFromServer(data.progress);

                    // Anlas 잔액 및 비용 갱신 (생성 완료 시)
                    if (currentProvider === 'nai') {
                        fetchAnlasBalance();
                        updateAnlasCost();

                        // V4+ 모델에서 바이브가 사용된 경우, vibeList의 인코딩 상태 갱신
                        // (생성 완료 후 해당 설정으로 캐시됨)
                        const currentModel = document.getElementById('naiModel').value;
                        if (currentModel.includes('diffusion-4') && vibeList.length > 0) {
                            let updated = false;
                            vibeList.forEach(v => {
                                // 현재 모델과 info_extracted가 인코딩된 값과 다르면 갱신
                                const baseModel = currentModel.replace('-inpainting', '');
                                const encodedBaseModel = (v.encoded_model || '').replace('-inpainting', '');
                                const infoMatch = Math.abs((v.info_extracted || 1.0) - (v.encoded_info_extracted || v.info_extracted || 1.0)) <= 0.001;

                                if (encodedBaseModel !== baseModel || !infoMatch) {
                                    v.encoded_model = currentModel;
                                    v.encoded_info_extracted = v.info_extracted || 1.0;
                                    updated = true;
                                }
                            });
                            if (updated) {
                                renderVibeList();
                                saveAppSettings();
                            }
                        }
                    }

                    if (data.progress?.queue_length === 0) {
                        // 모든 작업 완료
                        statusText.textContent = '완료!';
                        progressFill.style.width = '100%';
                        showToast('완료', 'success');
                        lastImageSeq = 0;  // 시퀀스 리셋

                        if (resetTimer) clearTimeout(resetTimer);
                        resetTimer = setTimeout(() => {
                            if (totalImages === currentIndex || totalImages === 0) {
                                currentIndex = 0;
                                totalImages = 0;
                                updateProgress();
                            }
                        }, 2000);
                    }
                    break;

                case 'job_cancelled':
                    console.log(`[WS] Job cancelled: ${data.job_id}`);
                    updateProgressFromServer(data.progress);
                    showToast('작업 취소됨', 'warning');
                    break;

                case 'queue_cleared':
                    console.log(`[WS] Queue cleared: ${data.cleared_images} images`);
                    updateProgressFromServer(data.progress);
                    break;

                case 'error':
                    console.error('[WS] Generation error:', data.error);
                    updateProgressFromServer(data.progress);
                    showToast(`Error: ${data.error || 'Generation failed'}`, 'error');
                    break;

                case 'pong':
                    // Heartbeat 응답
                    break;
            }
        }
        
        function clearResults() {
            clearSlotImages();
            statusText.textContent = '준비';
            progressFill.style.width = '0%';
            currentIndex = 0;
            totalImages = 0;
        }
        
        // Lightbox
        lightbox.onclick = (e) => {
            if (e.target === lightbox || e.target.classList.contains('close')) {
                lightbox.classList.remove('active');
                lightboxCurrentSlot = null;
                lightboxCurrentCard = null;
                lightboxCurrentGalleryItem = null;
            }
        };

        // Lightbox wheel navigation (slot mode & gallery mode)
        lightbox.addEventListener('wheel', (e) => {
            if (!lightbox.classList.contains('active')) return;

            // 슬롯 모드
            if (lightboxCurrentSlot && lightboxCurrentCard) {
                e.preventDefault();

                const imagesContainer = lightboxCurrentSlot.querySelector('.slot-images');
                const cards = Array.from(imagesContainer.querySelectorAll('.slot-image-card'));
                if (cards.length <= 1) return;

                const currentIndex = cards.indexOf(lightboxCurrentCard);
                if (currentIndex === -1) return;

                let newIndex;
                if (e.deltaY > 0) {
                    newIndex = currentIndex + 1;
                    if (newIndex >= cards.length) newIndex = 0;
                } else {
                    newIndex = currentIndex - 1;
                    if (newIndex < 0) newIndex = cards.length - 1;
                }

                const newCard = cards[newIndex];
                const newImg = newCard.querySelector('img');
                if (newImg) {
                    lightboxImg.src = newImg.src;
                    lightboxCurrentCard = newCard;
                }
                return;
            }

            // 갤러리/바이브 모드
            if (lightboxCurrentGalleryItem) {
                e.preventDefault();

                const items = Array.from(galleryGrid.querySelectorAll('.gallery-item'));
                if (items.length <= 1) return;

                const currentIndex = items.indexOf(lightboxCurrentGalleryItem);
                if (currentIndex === -1) return;

                let newIndex;
                if (e.deltaY > 0) {
                    newIndex = currentIndex + 1;
                    if (newIndex >= items.length) newIndex = 0;
                } else {
                    newIndex = currentIndex - 1;
                    if (newIndex < 0) newIndex = items.length - 1;
                }

                const newItem = items[newIndex];
                lightboxCurrentGalleryItem = newItem;

                // 바이브 캐시면 썸네일 직접 사용
                if (newItem._isVibe && newItem._thumbnail) {
                    lightboxImg.src = 'data:image/png;base64,' + newItem._thumbnail;
                    return;
                }

                // 갤러리 이미지 로드 (비동기)
                const filename = newItem._filename;
                const folder = newItem._folder || '';
                const folderQuery = folder ? `?folder=${encodeURIComponent(folder)}` : '';
                fetch(`${API_BASE}/api/gallery/${filename}${folderQuery}`)
                    .then(res => res.json())
                    .then(result => {
                        if (result.success) {
                            lightboxImg.src = 'data:image/png;base64,' + result.image;
                        }
                    })
                    .catch(() => {});
            }
        }, { passive: false });

        // Settings
        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
            checkLocalEnvStatus();
        }
        
        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }
        
        // 모달 외부 클릭 시 닫기
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') closeSettings();
        });
        document.getElementById('localInstallModal').addEventListener('click', (e) => {
            if (e.target.id === 'localInstallModal') closeLocalInstallModal();
        });
        
        async function saveSettings() {
            const config = {
                nai_token: document.getElementById('naiToken').value || null,
                checkpoints_dir: document.getElementById('checkpointsDir').value || null,
                lora_dir: document.getElementById('loraDir').value || null,
            };

            try {
                const res = await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                const data = await res.json();

                if (res.ok && data.success) {
                    showToast('설정 저장됨', 'success');
                    closeSettings();
                } else {
                    showToast(data.error || '저장 실패', 'error');
                }
            } catch (e) {
                showToast('저장 실패', 'error');
            }
        }
        
        // Local Environment
        let localEnvPollInterval = null;
        
        async function checkLocalEnvStatus() {
            try {
                const res = await fetch(`${API_BASE}/api/local/status`);
                const data = await res.json();
                updateLocalEnvUI(data);
                return data;
            } catch (e) {
                console.error('Failed to check local env status:', e);
                return null;
            }
        }
        
        function updateLocalEnvUI(data) {
            const statusEl = document.getElementById('localEnvStatus');
            const actionsEl = document.getElementById('localEnvActions');
            const progressEl = document.getElementById('localEnvProgress');
            const progressFillEl = document.getElementById('localEnvProgressFill');
            const progressTextEl = document.getElementById('localEnvProgressText');
            
            if (data.installing) {
                statusEl.className = 'local-env-status installing';
                statusEl.innerHTML = `<span class="status-icon">⏳</span><span class="status-text">${data.message || 'Installing...'}</span>`;
                actionsEl.innerHTML = '';
                progressEl.style.display = 'flex';
                progressFillEl.style.width = `${data.progress}%`;
                progressTextEl.textContent = `${data.progress}%`;
                
                // 폴링 시작
                if (!localEnvPollInterval) {
                    localEnvPollInterval = setInterval(checkLocalEnvStatus, 1000);
                }
            } else if (data.error) {
                statusEl.className = 'local-env-status error';
                statusEl.innerHTML = `<span class="status-icon">❌</span><span class="status-text">Error: ${data.error}</span>`;
                actionsEl.innerHTML = `<button class="btn" onclick="installLocalEnv()">Retry Install</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
            } else if (data.installed) {
                statusEl.className = 'local-env-status installed';
                statusEl.innerHTML = `<span class="status-icon">✅</span><span class="status-text">Installed</span>`;
                actionsEl.innerHTML = `<button class="btn btn-danger" onclick="uninstallLocalEnv()">Uninstall</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
                
                // Local 탭 활성화
                enableLocalTab(true);
                
                // 저장된 provider가 local이었으면 자동 전환
                if (window._pendingProvider === 'local') {
                    window._pendingProvider = null;
                    currentProvider = 'local';
                    tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === 'local'));
                    providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === 'local'));
                    // 샘플러/스케줄러도 Local 옵션으로 변경
                    updateSamplerSchedulerOptions('local');
                    // 저장된 값 복원
                    if (window._pendingSampler) {
                        const samplerSelect = document.getElementById('sampler');
                        if ([...samplerSelect.options].some(o => o.value === window._pendingSampler)) {
                            samplerSelect.value = window._pendingSampler;
                        }
                        window._pendingSampler = null;
                    }
                    if (window._pendingScheduler) {
                        const schedulerSelect = document.getElementById('scheduler');
                        if ([...schedulerSelect.options].some(o => o.value === window._pendingScheduler)) {
                            schedulerSelect.value = window._pendingScheduler;
                        }
                        window._pendingScheduler = null;
                    }
                };
            } else {
                statusEl.className = 'local-env-status not-installed';
                statusEl.innerHTML = `<span class="status-icon">⚠️</span><span class="status-text">Not installed</span>`;
                actionsEl.innerHTML = `<button class="btn" onclick="installLocalEnv()">Install Local Engine</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
                
                // Local 탭 비활성화
                enableLocalTab(false);
            }
        }
        
        function stopLocalEnvPolling() {
            if (localEnvPollInterval) {
                clearInterval(localEnvPollInterval);
                localEnvPollInterval = null;
            }
        }
        
        function enableLocalTab(enabled) {
            localEnvInstalled = enabled;
            const localTab = document.querySelector('.tab[data-provider="local"]');
            if (localTab) {
                if (enabled) {
                    localTab.classList.remove('disabled');
                    localTab.style.opacity = '1';
                } else {
                    localTab.classList.add('disabled');
                    localTab.style.opacity = '0.6';
                }
                // pointerEvents는 항상 auto로 - 클릭 감지 필요
                localTab.style.pointerEvents = 'auto';
            }
        }
        
        // Local Install Modal
        function showLocalInstallModal() {
            document.getElementById('localInstallModal').classList.add('active');
            updateInstallModalStatus();
        }
        
        function closeLocalInstallModal() {
            document.getElementById('localInstallModal').classList.remove('active');
        }
        
        function updateInstallModalStatus() {
            const statusEl = document.getElementById('installModalStatus');
            const progressEl = document.getElementById('installModalProgress');
            const btn = document.getElementById('installModalBtn');
            
            fetch(`${API_BASE}/api/local/status`)
                .then(res => res.json())
                .then(data => {
                    if (data.installed) {
                        statusEl.className = 'local-env-status installed';
                        statusEl.innerHTML = '<span class="status-text">✅ Installed</span>';
                        progressEl.style.display = 'none';
                        btn.textContent = '✓ Already Installed';
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        // 잠시 후 팝업 닫고 탭 전환
                        setTimeout(() => {
                            closeLocalInstallModal();
                            localEnvInstalled = true;
                            // Local 탭으로 전환
                            currentProvider = 'local';
                            tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === 'local'));
                            providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === 'local'));
                        }, 500);
                    } else if (data.installing) {
                        statusEl.className = 'local-env-status installing';
                        statusEl.innerHTML = `<span class="status-text">⏳ ${data.message || 'Installing...'}</span>`;
                        progressEl.style.display = 'flex';
                        document.getElementById('installModalProgressFill').style.width = `${data.progress || 0}%`;
                        document.getElementById('installModalProgressText').textContent = `${data.progress || 0}%`;
                        btn.textContent = '⏳ Installing...';
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        // 계속 폴링
                        setTimeout(updateInstallModalStatus, 1000);
                    } else if (data.error) {
                        statusEl.className = 'local-env-status error';
                        statusEl.innerHTML = `<span class="status-text">❌ ${data.error}</span>`;
                        progressEl.style.display = 'none';
                        btn.textContent = '🔄 Retry Install';
                        btn.disabled = false;
                        btn.style.opacity = '1';
                    } else {
                        statusEl.className = 'local-env-status not-installed';
                        statusEl.innerHTML = '<span class="status-text">⚠️ Not installed</span>';
                        progressEl.style.display = 'none';
                        btn.textContent = '⬇️ Install (~3GB)';
                        btn.disabled = false;
                        btn.style.opacity = '1';
                    }
                })
                .catch(() => {
                    statusEl.className = 'local-env-status error';
                    statusEl.innerHTML = '<span class="status-text">❌ Backend not connected</span>';
                });
        }
        
        async function installFromModal() {
            const btn = document.getElementById('installModalBtn');
            btn.textContent = '⏳ Starting...';
            btn.disabled = true;
            
            try {
                const res = await fetch(`${API_BASE}/api/local/install`, { method: 'POST' });
                if (res.ok) {
                    showToast('설치 시작됨', 'success');
                    updateInstallModalStatus();
                    checkLocalEnvStatus();  // Settings 모달도 업데이트
                } else {
                    const data = await res.json();
                    showToast(data.detail || 'Failed to start installation', 'error');
                    btn.textContent = '⬇️ Install (~3GB)';
                    btn.disabled = false;
                }
            } catch (e) {
                showToast('설치 시작 실패', 'error');
                btn.textContent = '⬇️ Install (~3GB)';
                btn.disabled = false;
            }
        }
        
        async function installLocalEnv() {
            try {
                const res = await fetch(`${API_BASE}/api/local/install`, { method: 'POST' });
                if (res.ok) {
                    showToast('설치 시작됨', 'success');
                    checkLocalEnvStatus();
                } else {
                    const data = await res.json();
                    showToast(data.detail || 'Failed to start installation', 'error');
                }
            } catch (e) {
                showToast('설치 시작 실패', 'error');
            }
        }
        
        async function uninstallLocalEnv() {
            showConfirmModal(
                '🗑️ 로컬 엔진 제거',
                '<p>로컬 생성 엔진을 제거하시겠습니까?</p><p style="color: var(--text-dim); font-size: 0.9rem;">약 3GB 디스크 공간이 확보됩니다.</p>',
                async () => {
                    try {
                        const res = await fetch(`${API_BASE}/api/local/uninstall`, { method: 'DELETE' });
                        if (res.ok) {
                            showToast('제거됨', 'success');
                            checkLocalEnvStatus();
                        }
                    } catch (e) {
                        showToast('제거 실패', 'error');
                    }
                },
                '제거',
                true
            );
        }
        
        // Toast
        function showToast(msg, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.className = 'toast show ' + type;
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Generic Confirm Modal
        function showConfirmModal(title, message, onConfirm, confirmText = '확인', isDanger = false) {
            const modal = document.getElementById('confirmModal');
            document.getElementById('confirmModalTitle').textContent = title;
            document.getElementById('confirmModalMessage').innerHTML = message;
            const okBtn = document.getElementById('confirmModalOk');
            okBtn.textContent = confirmText;
            okBtn.className = isDanger ? 'btn btn-danger' : 'btn';
            okBtn.style.background = isDanger ? 'var(--error)' : '';

            // 이벤트 리스너 정리 후 재설정
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            const newCancelBtn = document.getElementById('confirmModalCancel').cloneNode(true);
            document.getElementById('confirmModalCancel').parentNode.replaceChild(newCancelBtn, document.getElementById('confirmModalCancel'));

            newOkBtn.onclick = () => {
                modal.classList.remove('active');
                if (onConfirm) onConfirm();
            };
            newCancelBtn.onclick = () => {
                modal.classList.remove('active');
            };

            modal.classList.add('active');
        }

        function showInputModal(title, message, onConfirm, confirmText = '확인', defaultValue = '') {
            const modal = document.getElementById('inputModal');
            document.getElementById('inputModalTitle').textContent = title;
            document.getElementById('inputModalMessage').textContent = message;
            const input = document.getElementById('inputModalInput');
            input.value = defaultValue;

            const okBtn = document.getElementById('inputModalOk');
            okBtn.textContent = confirmText;

            // 이벤트 리스너 정리 후 재설정
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            const newCancelBtn = document.getElementById('inputModalCancel').cloneNode(true);
            document.getElementById('inputModalCancel').parentNode.replaceChild(newCancelBtn, document.getElementById('inputModalCancel'));

            newOkBtn.onclick = () => {
                const value = input.value.trim();
                if (value) {
                    modal.classList.remove('active');
                    if (onConfirm) onConfirm(value);
                }
            };
            newCancelBtn.onclick = () => {
                modal.classList.remove('active');
            };
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    newOkBtn.click();
                } else if (e.key === 'Escape') {
                    modal.classList.remove('active');
                }
            };

            modal.classList.add('active');
            setTimeout(() => input.focus(), 100);
        }

        // NAI 형식 메타데이터를 앱 내부 형식으로 변환
        function normalizeMetadata(meta) {
            if (!meta) return null;

            // 이미 앱 내부 형식이면 그대로 반환
            if (meta.negative_prompt !== undefined || meta.cfg !== undefined || meta.nai_model !== undefined) {
                return meta;
            }

            // 캐릭터 프롬프트 추출 (peropix 또는 NAI 형식)
            let charPrompts = [];
            const ppx = meta.peropix || {};
            if (ppx.character_prompts && ppx.character_prompts.length > 0) {
                charPrompts = ppx.character_prompts;
            } else if (meta.v4_prompt?.caption?.char_captions) {
                charPrompts = meta.v4_prompt.caption.char_captions.map(c => c.char_caption).filter(c => c);
            } else if (meta.characterPrompts) {
                charPrompts = meta.characterPrompts.map(c => c.prompt).filter(c => c);
            }

            // UC Preset: 숫자 → 문자열 변환
            const ucPresetMap = { 0: 'Heavy', 1: 'Light', 2: 'Human Focus', 3: 'None' };
            const ucPreset = ucPresetMap[meta.ucPreset] || meta.ucPreset || 'Heavy';
            const qualityTags = meta.qualityToggle;

            // 순수 NAI 이미지 여부 확인 (peropix 확장이 없으면 순수 NAI)
            const isPureNai = !meta.peropix;

            // 순수 NAI 이미지면 프롬프트에서 퀄리티 태그/UC 프리셋 태그 제거 (중복 방지)
            let prompt = meta.prompt || '';
            let negativePrompt = meta.uc || '';

            if (isPureNai) {
                // V4.5 Quality Tags 제거 (프롬프트 끝에 추가된 태그)
                const v45QualityTags = ", very aesthetic, masterpiece, no text";
                if (prompt.endsWith(v45QualityTags)) {
                    prompt = prompt.slice(0, -v45QualityTags.length);
                }

                // V4.5 UC 프리셋 태그 제거 (네거티브 프롬프트 앞에 추가된 태그)
                const v45UcPresets = {
                    'Heavy': 'nsfw, lowres, artistic error, film grain, scan artifacts, worst quality, bad quality, jpeg artifacts, very displeasing, chromatic aberration, dithering, halftone, screentone, multiple views, logo, too many watermarks, negative space, blank page',
                    'Light': 'nsfw, lowres, artistic error, scan artifacts, worst quality, bad quality, jpeg artifacts, multiple views, very displeasing, too many watermarks, negative space, blank page',
                    'Furry Focus': 'nsfw, {worst quality}, distracting watermark, unfinished, bad quality, {widescreen}, upscale, {sequence}, {{grandfathered content}}, blurred foreground, chromatic aberration, sketch, everyone, [sketch background], simple, [flat colors], ych (character), outline, multiple scenes, [[horror (theme)]], comic',
                    'Human Focus': 'nsfw, lowres, artistic error, film grain, scan artifacts, worst quality, bad quality, jpeg artifacts, very displeasing, chromatic aberration, dithering, halftone, screentone, multiple views, logo, too many watermarks, negative space, blank page, @_@, mismatched pupils, glowing eyes, bad anatomy'
                };

                // 현재 UC 프리셋에 해당하는 태그 제거
                const presetTags = v45UcPresets[ucPreset];
                if (presetTags && negativePrompt.startsWith(presetTags)) {
                    negativePrompt = negativePrompt.slice(presetTags.length);
                    // 앞에 ", " 가 남아있으면 제거
                    negativePrompt = negativePrompt.replace(/^,\s*/, '');
                }
            }

            // Variety+ 감지 (peropix 확장 또는 NAI skip_cfg_above_sigma)
            let varietyPlus = ppx.variety_plus || false;
            if (!varietyPlus && meta.skip_cfg_above_sigma !== undefined && meta.skip_cfg_above_sigma !== null) {
                varietyPlus = true;
            }

            // Furry Mode 감지 (peropix 확장 또는 프롬프트 시작)
            let furryMode = ppx.furry_mode || false;
            if (!furryMode && meta.prompt && meta.prompt.startsWith('fur dataset,')) {
                furryMode = true;
            }

            // NAI 형식 → 앱 내부 형식 변환
            // 모델명: request_type이 실제 모델명인지 확인 (NAI 내부 타입명 필터)
            let naiModel = '';
            if (meta.request_type && meta.request_type.startsWith('nai-diffusion')) {
                naiModel = meta.request_type;
            } else if (meta.model && meta.model.startsWith('nai-diffusion')) {
                naiModel = meta.model;
            }
            // request_type이 "PromptGenerateRequest" 같은 내부 타입이면 무시

            return {
                prompt: prompt,
                negative_prompt: negativePrompt,
                character_prompts: charPrompts,
                seed: meta.seed,
                width: meta.width,
                height: meta.height,
                steps: meta.steps,
                cfg: meta.scale,
                sampler: meta.sampler,
                scheduler: meta.noise_schedule || 'karras',
                nai_model: naiModel,
                smea: meta.sm_dyn ? 'SMEA+DYN' : (meta.sm ? 'SMEA' : 'none'),
                uc_preset: ucPreset,
                quality_tags: qualityTags,
                cfg_rescale: meta.cfg_rescale,
                variety_plus: varietyPlus,
                furry_mode: furryMode,
                provider: ppx.provider || 'nai',
                model: ppx.local_model || '',
                vibe_transfer: ppx.vibe_transfer || null
            };
        }

        // 설정 불러오기 확인 팝업 (드롭 모달 재사용)
        function showLoadSettingsConfirm(rawMetadata) {
            // NAI 형식을 앱 내부 형식으로 변환
            const metadata = normalizeMetadata(rawMetadata) || rawMetadata;

            const dropModal = document.getElementById('dropModal');
            document.getElementById('dropModalTitle').textContent = '📋 설정 불러오기';
            document.getElementById('dropModalPreview').src = '';
            document.getElementById('dropModalPreview').style.display = 'none';

            // 캐릭터 프롬프트 정보
            const charPrompts = metadata.character_prompts || [];
            const charPromptsHtml = charPrompts.length > 0
                ? `<div><strong>캐릭터 (${charPrompts.length}):</strong> ${charPrompts.map((c, i) => `[${i+1}] ${(c || '').substring(0, 30)}${(c || '').length > 30 ? '...' : ''}`).join(', ')}</div>`
                : '';

            // 바이브 정보
            const vibes = metadata.vibe_transfer || [];
            const vibeHtml = vibes.length > 0
                ? `<div><strong>Vibe (${vibes.length}):</strong> ${vibes.map(v => v.name || `S:${v.strength} I:${v.info_extracted}`).join(', ')}</div>`
                : '';

            // 순수 NAI 이미지 여부 확인 (peropix 확장이 없으면 순수 NAI)
            const isPureNaiImage = !rawMetadata.peropix;

            // 순수 NAI 이미지에 대한 경고 메시지
            const naiWarningHtml = isPureNaiImage ? `
                <div style="background: #3a3520; border: 1px solid #665c30; padding: 8px; margin-bottom: 8px; border-radius: 4px; font-size: 11px;">
                    ⚠️ <strong>순수 NAI 이미지</strong> - Vibe Transfer, Character Reference, Base Image 설정은 적용되지 않습니다.
                </div>
            ` : '';

            const metadataDiv = document.getElementById('dropModalMetadata');
            metadataDiv.innerHTML = `
                ${naiWarningHtml}
                <div><strong>Prompt:</strong> ${(metadata.prompt || '').substring(0, 100)}${(metadata.prompt || '').length > 100 ? '...' : ''}</div>
                <div><strong>Negative:</strong> ${(metadata.negative_prompt || '').substring(0, 50)}${(metadata.negative_prompt || '').length > 50 ? '...' : ''}</div>
                ${charPromptsHtml}
                ${vibeHtml}
                <div><strong>Seed:</strong> ${metadata.seed || 'N/A'}</div>
                <div><strong>Size:</strong> ${metadata.width}x${metadata.height}</div>
                <div><strong>Steps:</strong> ${metadata.steps}, <strong>CFG:</strong> ${metadata.cfg}</div>
                <div><strong>Sampler:</strong> ${metadata.sampler}</div>
                <div><strong>Model:</strong> ${metadata.nai_model || metadata.model || 'N/A'}</div>
            `;

            document.getElementById('dropModalConfirm').textContent = '전체 적용';
            document.getElementById('dropModalPromptOnly').style.display = 'inline-block';

            // 정규화된 데이터 저장
            window._pendingLoadMetadata = metadata;
            window._isPureNaiImage = isPureNaiImage;

            dropModal.classList.add('active');
        }

        // 순수 NAI 이미지 적용 시 경고 팝업
        function showPureNaiWarning(callback) {
            const msg = `⚠️ 순수 NAI 이미지입니다.

[적용되지 않는 항목]
• Vibe Transfer 설정
• Character Reference
• Base Image (img2img/inpaint)

계속하시겠습니까?`;
            if (confirm(msg)) {
                callback();
            }
        }

        // 프롬프트만 적용 (시드 포함)
        function applyPromptOnly(metadata) {
            // 프롬프트 (공란이어도 적용)
            if (metadata.prompt !== undefined) document.getElementById('basePrompt').value = metadata.prompt;
            if (metadata.negative_prompt !== undefined) document.getElementById('negativePrompt').value = metadata.negative_prompt;

            // 캐릭터 프롬프트 적용
            if (metadata.character_prompts && metadata.character_prompts.length > 0) {
                const charactersList = document.getElementById('charactersList');
                charactersList.innerHTML = '';
                metadata.character_prompts.forEach(cp => {
                    if (cp && cp.trim()) {
                        addCharacter(cp);
                    }
                });
                updateCharacterNumbers();
            }

            // 시드
            if (metadata.seed) document.getElementById('seed').value = metadata.seed;

            showToast('프롬프트와 시드가 적용되었습니다', 'success');
        }

        // 메타데이터 설정 적용
        function applyMetadataSettings(metadata) {
            // 프롬프트 (공란이어도 적용)
            if (metadata.prompt !== undefined) document.getElementById('basePrompt').value = metadata.prompt;
            if (metadata.negative_prompt !== undefined) document.getElementById('negativePrompt').value = metadata.negative_prompt;

            // 캐릭터 프롬프트 적용
            if (metadata.character_prompts && metadata.character_prompts.length > 0) {
                // 기존 캐릭터 슬롯 모두 제거
                const charactersList = document.getElementById('charactersList');
                charactersList.innerHTML = '';
                // 새 캐릭터 프롬프트 추가
                metadata.character_prompts.forEach(cp => {
                    if (cp && cp.trim()) {
                        addCharacter(cp);
                    }
                });
                updateCharacterNumbers();
            }

            // 크기
            if (metadata.width) document.getElementById('width').value = metadata.width;
            if (metadata.height) document.getElementById('height').value = metadata.height;
            // 사이즈 프리셋 체크
            const sizeValue = `${metadata.width}x${metadata.height}`;
            const sizePreset = document.getElementById('sizePreset');
            const matchingOption = [...sizePreset.options].find(o => o.value === sizeValue);
            sizePreset.value = matchingOption ? sizeValue : 'custom';

            // 생성 설정
            if (metadata.steps) document.getElementById('steps').value = metadata.steps;
            if (metadata.cfg) document.getElementById('cfg').value = metadata.cfg;
            if (metadata.seed) document.getElementById('seed').value = metadata.seed;
            if (metadata.sampler) document.getElementById('sampler').value = metadata.sampler;
            if (metadata.scheduler) document.getElementById('scheduler').value = metadata.scheduler;

            // NAI 설정
            if (metadata.nai_model) document.getElementById('naiModel').value = metadata.nai_model;
            if (metadata.smea) document.getElementById('smea').value = metadata.smea;
            if (metadata.uc_preset) document.getElementById('ucPreset').value = metadata.uc_preset;
            if (metadata.quality_tags !== undefined) document.getElementById('qualityTags').checked = metadata.quality_tags;
            if (metadata.cfg_rescale !== undefined) {
                document.getElementById('cfgRescale').value = metadata.cfg_rescale;
                document.getElementById('cfgRescaleValue').textContent = metadata.cfg_rescale;
            }
            if (metadata.variety_plus !== undefined) document.getElementById('varietyPlus').checked = metadata.variety_plus;
            if (metadata.furry_mode !== undefined) setFurryMode(metadata.furry_mode);

            // Local 설정
            if (metadata.model) document.getElementById('localModel').value = metadata.model;

            // Provider 설정
            if (metadata.provider && metadata.provider !== currentProvider) {
                // Provider 변경은 복잡하므로 알림만
                showToast(`원본 Provider: ${metadata.provider}`, 'warning');
            }

            // Vibe Transfer 설정 (캐시에서 이름 매칭)
            // 바이브 정보가 없으면 기존 설정 유지 (변경하지 않음)
            if (metadata.vibe_transfer && metadata.vibe_transfer.length > 0) {
                loadVibesFromMetadata(metadata.vibe_transfer);
            }
            // vibe_transfer가 없으면 (NAI 원본 이미지) 바이브는 건드리지 않음

            autoSaveSettings();

            // NAI 원본 이미지: 이미지 데이터가 필요한 설정은 복원 불가
            // (바이브, 캐릭터 레퍼런스, 베이스 이미지 - 메타데이터에 이미지 없음)
            const hasVibeActive = vibeList.length > 0;
            const hasCharRefActive = charRefData !== null;
            const hasBaseImageActive = baseImageData.enabled;
            const isNaiOriginal = !metadata.vibe_transfer;  // PeroPix 확장 필드 없음

            if (isNaiOriginal && (hasVibeActive || hasCharRefActive || hasBaseImageActive)) {
                showToast('설정 적용됨 (이미지 기반 설정은 유지됨)', 'warning');
            } else {
                showToast('설정을 불러왔습니다', 'success');
            }
        }

        // 메타데이터에서 바이브 로드 (캐시에서 이름 매칭)
        async function loadVibesFromMetadata(vibeInfoList) {
            if (!vibeInfoList || vibeInfoList.length === 0) return;

            try {
                // 캐시된 바이브 목록 가져오기
                const response = await fetch(`${API_BASE}/api/vibe-cache`);
                const data = await response.json();
                const cachedVibes = data.vibes || [];

                let loadedCount = 0;
                let matchedCount = 0;

                for (const vibeInfo of vibeInfoList) {
                    if (!vibeInfo.name) continue;

                    // 캐시에서 이름 매칭
                    const cached = cachedVibes.find(v => v.name === vibeInfo.name || v.filename === vibeInfo.name);
                    if (cached) {
                        // 상세 데이터 로드
                        const detailRes = await fetch(`${API_BASE}/api/vibe-cache/${cached.filename}`);
                        const detail = await detailRes.json();
                        if (detail.success && detail.vibe_data) {
                            // 기존 바이브에 같은 이름이 있으면 건너뛰기
                            const exists = vibeList.some(v => v.name === vibeInfo.name);
                            if (!exists && vibeList.length < 16) {
                                const infoExtracted = vibeInfo.info_extracted || detail.info_extracted || 1.0;
                                vibeList.push({
                                    image: detail.image,
                                    strength: vibeInfo.strength || detail.strength || 0.6,
                                    info_extracted: infoExtracted,
                                    name: vibeInfo.name,
                                    encoded: detail.vibe_data,
                                    encoded_model: cached.model,
                                    encoded_info_extracted: detail.info_extracted || 1.0  // 캐시된 인코딩 시 사용된 값
                                });
                                loadedCount++;
                            }
                        }
                        matchedCount++;
                    }
                }

                if (loadedCount > 0) {
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    showToast(`바이브 ${loadedCount}개 로드됨`, 'success');
                } else if (matchedCount === 0 && vibeInfoList.length > 0) {
                    showToast(`바이브 ${vibeInfoList.length}개: 캐시에서 찾을 수 없음`, 'warning');
                }
            } catch (err) {
                console.error('[Vibe] 메타데이터에서 로드 실패:', err);
            }
        }

        // Event listeners
        generateBtn.onclick = addToQueue;
        cancelCurrentBtn.onclick = cancelCurrent;
        clearQueueBtn.onclick = clearQueue;
        document.getElementById('clearImagesBtn').onclick = clearResults;

        // Anime/Furry Mode Toggle
        let furryModeEnabled = false;
        const modeToggle = document.getElementById('modeToggle');

        function setFurryMode(enabled) {
            furryModeEnabled = enabled;
            if (enabled) {
                modeToggle.textContent = '🐾';
                modeToggle.title = '퍼리 모드';
                modeToggle.classList.add('furry');
            } else {
                modeToggle.textContent = '🌸';
                modeToggle.title = '아니메 모드';
                modeToggle.classList.remove('furry');
            }
            autoSaveSettings();
        }

        modeToggle.onclick = () => {
            setFurryMode(!furryModeEnabled);
        };

        // Collapse toggle for prompts and sections
        document.querySelectorAll('.collapse-toggle').forEach(btn => {
            const targetId = btn.dataset.target;
            const target = document.getElementById(targetId);
            if (!target) return;

            // 토글 함수
            const toggleCollapse = (e) => {
                // 프리셋 드롭다운 버튼, 기타 컨트롤 클릭은 무시
                if (e && e.target.closest('.prompt-preset-dropdown, .add-char-btn, .section-toggle, .mode-toggle')) return;
                // 이벤트 버블링 방지
                if (e) e.stopPropagation();

                btn.classList.toggle('collapsed');
                target.classList.toggle('collapsed');
                localStorage.setItem(`collapse_${targetId}`, btn.classList.contains('collapsed') ? 'collapsed' : 'expanded');
            };

            // 저장된 상태 복원 또는 기본값 설정
            const savedState = localStorage.getItem(`collapse_${targetId}`);
            if (savedState === 'collapsed') {
                btn.classList.add('collapsed');
                target.classList.add('collapsed');
            } else if (savedState === null) {
                // 첫 실행: basePromptContent만 펼치고 나머지 접기
                if (targetId !== 'basePromptContent') {
                    btn.classList.add('collapsed');
                    target.classList.add('collapsed');
                    localStorage.setItem(`collapse_${targetId}`, 'collapsed');
                }
            }

            // 클릭 가능한 바 찾기 (prompt-label-row가 prompt-label-left보다 우선)
            let clickableBar = btn.closest('.section-title, .characters-header');
            if (!clickableBar) {
                // prompt-label-left 안에 있으면 prompt-label-row를 찾음
                const promptLabelLeft = btn.closest('.prompt-label-left');
                if (promptLabelLeft) {
                    clickableBar = promptLabelLeft.closest('.prompt-label-row');
                }
            }

            // 바 전체에 클릭 이벤트 설정
            if (clickableBar) {
                clickableBar.addEventListener('click', toggleCollapse);
            } else {
                // 바가 없으면 버튼에만 설정
                btn.onclick = toggleCollapse;
            }
        });

        // 폴더 열기 버튼 핸들러
        async function openFolder(folderType, subfolder = '') {
            try {
                const response = await fetch(`${API_BASE}/api/open-folder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder: folderType, subfolder: subfolder })
                });
                const data = await response.json();
                if (data.error) {
                    showToast(`폴더 열기 실패: ${data.error}`, 'error');
                }
            } catch (e) {
                showToast('폴더 열기 실패', 'error');
            }
        }

        document.getElementById('openOutputFolderBtn').onclick = () => {
            openFolder('outputs', getOutputFolder());
        };
        document.getElementById('openVibeFolderBtn').onclick = () => openFolder('vibe_cache');
        document.getElementById('openCheckpointsFolderBtn').onclick = () => openFolder('checkpoints');
        document.getElementById('openLorasFolderBtn').onclick = () => openFolder('loras');

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                lightbox.classList.remove('active');
                closeSettings();
            }
            if (e.ctrlKey && e.key === 'Enter') {
                addToQueue();
            }
        });
        
        // 탭 활성화 시 WebSocket 재연결 확인
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                connectWebSocket();
            }
        });
        
        // Size Preset
        const sizePreset = document.getElementById('sizePreset');
        const widthInput = document.getElementById('width');
        const heightInput = document.getElementById('height');
        
        sizePreset.onchange = () => {
            const value = sizePreset.value;
            if (value !== 'custom') {
                const [w, h] = value.split('x').map(Number);
                widthInput.value = w;
                heightInput.value = h;
            }
            updateAnlasCost();
        };
        
        // Width/Height 직접 수정 시 Custom으로 변경
        function checkCustomSize() {
            const w = widthInput.value;
            const h = heightInput.value;
            const currentValue = `${w}x${h}`;
            
            // 프리셋에 있는 값인지 확인
            const options = [...sizePreset.options];
            const match = options.find(opt => opt.value === currentValue);
            
            if (match) {
                sizePreset.value = currentValue;
            } else {
                sizePreset.value = 'custom';
            }
        }
        
        widthInput.onchange = checkCustomSize;
        heightInput.onchange = checkCustomSize;
        
        // Upscale toggle
        document.getElementById('enableUpscale').onchange = function() {
            document.getElementById('upscaleSettings').style.display = this.checked ? 'block' : 'none';
        };

        // Upscale denoise slider value display
        document.getElementById('upscaleDenoise').oninput = function() {
            document.getElementById('upscaleDenoiseValue').textContent = this.value;
        };

        // CFG Rescale slider value display
        document.getElementById('cfgRescale').oninput = function() {
            document.getElementById('cfgRescaleValue').textContent = this.value;
        };

        // ============================================================
        // Vibe Transfer
        // ============================================================
        let vibeList = []; // {image: base64, info_extracted: 1.0, strength: 0.6}

        document.getElementById('enableVibeTransfer').onchange = function() {
            document.getElementById('vibeTransferSettings').style.display = this.checked ? 'block' : 'none';
            // Vibe Transfer와 Character Reference는 동시 사용 불가
            if (this.checked && document.getElementById('enableCharRef').checked) {
                document.getElementById('enableCharRef').checked = false;
                document.getElementById('charRefSettings').style.display = 'none';
            }
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('addVibeBtn').onclick = function() {
            if (vibeList.length >= 16) {
                alert('최대 16개까지만 추가할 수 있습니다.');
                return;
            }
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const base64 = await fileToBase64(file);
                vibeList.push({
                    image: base64,
                    info_extracted: 1.0,
                    strength: 0.6,
                    name: file.name
                });
                renderVibeList();
                saveAppSettings();
                updateAnlasCost();
            };
            input.click();
        };

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    // data:image/png;base64,XXXXX -> XXXXX 만 추출
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function renderVibeList() {
            const container = document.getElementById('vibeList');
            container.innerHTML = '';
            vibeList.forEach((vibe, idx) => {
                const item = document.createElement('div');
                item.className = 'vibe-item';
                item.innerHTML = `
                    <div class="vibe-item-header">
                        <img src="data:image/png;base64,${vibe.image}" alt="vibe">
                        <span class="vibe-info">${vibe.name || 'Vibe ' + (idx + 1)}</span>
                        <button type="button" class="remove-btn" data-idx="${idx}">×</button>
                    </div>
                    <div class="vibe-sliders">
                        <div class="vibe-slider-row">
                            <label>Strength</label>
                            <input type="range" class="vibe-strength" data-idx="${idx}" value="${vibe.strength}" min="0" max="1" step="0.05">
                            <span class="value">${vibe.strength}</span>
                        </div>
                        <div class="vibe-slider-row">
                            <label>Info Extract</label>
                            <input type="range" class="vibe-info" data-idx="${idx}" value="${vibe.info_extracted}" min="0.01" max="1" step="0.01">
                            <span class="value">${vibe.info_extracted}</span>
                        </div>
                    </div>
                `;
                container.appendChild(item);
            });

            // Event listeners
            container.querySelectorAll('.remove-btn').forEach(btn => {
                btn.onclick = function() {
                    vibeList.splice(parseInt(this.dataset.idx), 1);
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                };
            });
            container.querySelectorAll('.vibe-strength').forEach(slider => {
                slider.oninput = function() {
                    const idx = parseInt(this.dataset.idx);
                    vibeList[idx].strength = parseFloat(this.value);
                    this.nextElementSibling.textContent = this.value;
                    saveAppSettings();
                };
            });
            container.querySelectorAll('.vibe-info').forEach(slider => {
                slider.oninput = function() {
                    const idx = parseInt(this.dataset.idx);
                    vibeList[idx].info_extracted = parseFloat(this.value);
                    this.nextElementSibling.textContent = this.value;
                    saveAppSettings();
                    updateAnlasCost();  // info_extracted 변경시 캐시 상태 재확인
                };
            });
        }

        // ============================================================
        // Character Reference (V4.5 only)
        // ============================================================
        let charRefData = null; // {image: base64, fidelity: 0.5, style_aware: true}

        document.getElementById('enableCharRef').onchange = function() {
            document.getElementById('charRefSettings').style.display = this.checked ? 'block' : 'none';
            // Vibe Transfer와 Character Reference는 동시 사용 불가
            if (this.checked && document.getElementById('enableVibeTransfer').checked) {
                document.getElementById('enableVibeTransfer').checked = false;
                document.getElementById('vibeTransferSettings').style.display = 'none';
            }
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('uploadCharRefBtn').onclick = function() {
            document.getElementById('charRefInput').click();
        };

        document.getElementById('charRefInput').onchange = async function() {
            const file = this.files[0];
            if (!file) return;
            const base64 = await fileToBase64(file);
            charRefData = {
                image: base64,
                fidelity: parseFloat(document.getElementById('charRefFidelity').value),
                style_aware: document.getElementById('charRefStyleAware').checked
            };
            document.getElementById('charRefImage').src = 'data:image/png;base64,' + base64;
            document.getElementById('charRefPreview').style.display = 'block';
            document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('removeCharRefBtn').onclick = function() {
            charRefData = null;
            document.getElementById('charRefPreview').style.display = 'none';
            document.getElementById('uploadCharRefBtn').textContent = '이미지 선택';
            document.getElementById('charRefInput').value = '';
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('charRefFidelity').oninput = function() {
            document.getElementById('charRefFidelityValue').textContent = this.value;
            if (charRefData) {
                charRefData.fidelity = parseFloat(this.value);
                saveAppSettings();
            }
        };

        document.getElementById('charRefStyleAware').onchange = function() {
            if (charRefData) {
                charRefData.style_aware = this.checked;
                saveAppSettings();
            }
        };

        // ============================================================
        // Anlas System
        // ============================================================
        let currentAnlas = null;
        let isOpusTier = false;

        async function fetchAnlasBalance() {
            try {
                const response = await fetch(`${API_BASE}/api/nai/subscription`);
                const data = await response.json();

                if (data.error) {
                    document.getElementById('anlasBalance').textContent = 'Error';
                    return;
                }

                currentAnlas = data.anlas;
                isOpusTier = data.tier >= 3; // Tier 3 = Opus
                console.log('[Anlas] Subscription loaded:', { tier: data.tier, isOpusTier, anlas: currentAnlas });

                document.getElementById('anlasBalance').textContent =
                    currentAnlas !== null ? currentAnlas.toLocaleString() : '--';

                updateAnlasCost();
            } catch (e) {
                console.error('[Anlas] Failed to fetch subscription:', e);
                document.getElementById('anlasBalance').textContent = '--';
            }
        }

        async function updateAnlasCost() {
            if (currentProvider !== 'nai') return;

            const width = parseInt(document.getElementById('width').value) || 832;
            const height = parseInt(document.getElementById('height').value) || 1216;
            const steps = parseInt(document.getElementById('steps').value) || 28;
            const vibeEnabled = document.getElementById('enableVibeTransfer').checked;
            const vibeCount = vibeEnabled ? vibeList.length : 0;
            const hasCharRef = document.getElementById('enableCharRef').checked && charRefData !== null;
            const repeatCount = parseInt(document.getElementById('repeatCount').value) || 1;
            const slotCount = document.querySelectorAll('.slot').length || 1;
            const totalCount = repeatCount * slotCount;
            const naiModel = document.getElementById('naiModel').value;

            // Vibe 데이터 (캐시 체크용)
            const vibes = vibeEnabled ? vibeList.map(v => ({
                image: v.image,
                info_extracted: v.info_extracted,
                encoded: !!v.encoded,  // 이미 인코딩된 바이브인지 여부
                encoded_model: v.encoded_model,  // 인코딩된 모델
                encoded_info_extracted: v.encoded_info_extracted  // 인코딩 시 사용된 info_extracted
            })) : [];

            try {
                const response = await fetch(`${API_BASE}/api/nai/calculate-cost`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        width, height, steps,
                        is_opus: isOpusTier,
                        vibe_count: vibeCount,
                        has_char_ref: hasCharRef,
                        count: totalCount,
                        vibes: vibes,
                        model: naiModel
                    })
                });
                const data = await response.json();
                console.log('[Cost Response]', data);

                if (data.is_free && data.vibe_encoding_cost === 0) {
                    document.getElementById('anlasCost').style.display = 'none';
                    document.getElementById('anlasFreeTag').style.display = 'inline';
                } else {
                    document.getElementById('anlasCost').style.display = 'inline';
                    document.getElementById('anlasFreeTag').style.display = 'none';

                    // Vibe 인코딩 비용 (일회성, 바이브 갯수만큼)
                    if (data.vibe_encoding_cost > 0) {
                        document.getElementById('anlasCost').textContent =
                            `${data.vibe_encoding_cost} (바이브 ${data.uncached_vibes}개)`;
                    }
                    // 일반 생성 비용 (CharRef 등)
                    else {
                        let costText = data.total_cost.toLocaleString();
                        if (slotCount > 1 || repeatCount > 1) {
                            let breakdown = `${data.cost_per_image}`;
                            if (slotCount > 1) breakdown += ` × ${slotCount}슬롯`;
                            if (repeatCount > 1) breakdown += ` × ${repeatCount}회`;
                            costText += ` (${breakdown})`;
                        }
                        document.getElementById('anlasCost').textContent = costText;
                    }
                }

                // Vibe 캐시 상태 표시
                const vibeCacheInfo = document.getElementById('vibeCacheInfo');
                if (vibeCacheInfo && vibes.length > 0) {
                    if (data.cached_vibes > 0 && data.uncached_vibes === 0) {
                        vibeCacheInfo.textContent = `✓ ${data.cached_vibes}개 캐시됨 (무료)`;
                        vibeCacheInfo.style.color = '#4CAF82';
                    } else if (data.uncached_vibes > 0) {
                        vibeCacheInfo.textContent = `${data.uncached_vibes}개 인코딩 필요 (+${data.vibe_encoding_cost} Anlas)`;
                        vibeCacheInfo.style.color = '#F5B942';
                    }
                    vibeCacheInfo.style.display = 'block';
                } else if (vibeCacheInfo) {
                    vibeCacheInfo.style.display = 'none';
                }
            } catch (e) {
                document.getElementById('anlasCost').textContent = '?';
            }
        }

        // Anlas UI 표시/숨김 (provider에 따라)
        function updateAnlasVisibility() {
            const anlasInfo = document.getElementById('anlasInfo');
            if (currentProvider === 'nai') {
                anlasInfo.style.display = 'block';
                fetchAnlasBalance();
            } else {
                anlasInfo.style.display = 'none';
            }
        }

        // Anlas 새로고침 버튼
        document.getElementById('refreshAnlasBtn').onclick = function() {
            this.style.transform = 'rotate(360deg)';
            setTimeout(() => this.style.transform = '', 300);
            fetchAnlasBalance();
        };

        // 설정 변경시 비용 재계산
        ['width', 'height', 'steps', 'repeatCount'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', updateAnlasCost);
            }
        });

        // Vibe/CharRef/모델 변경시 비용 재계산
        document.getElementById('enableVibeTransfer').addEventListener('change', updateAnlasCost);
        document.getElementById('enableCharRef').addEventListener('change', updateAnlasCost);
        document.getElementById('naiModel').addEventListener('change', () => {
            updateAnlasCost();
            updateSmeaVisibility();
        });

        // V4+ 모델에서 SMEA 비활성화
        function updateSmeaVisibility() {
            const model = document.getElementById('naiModel').value;
            const isV4 = model.includes('diffusion-4');
            const smeaSelect = document.getElementById('smea');
            const smeaContainer = smeaSelect.parentElement;

            if (isV4) {
                smeaSelect.value = 'none';
                smeaContainer.style.opacity = '0.5';
                smeaSelect.disabled = true;
                smeaContainer.title = 'V4+ 모델에서는 SMEA를 지원하지 않습니다';
            } else {
                smeaContainer.style.opacity = '1';
                smeaSelect.disabled = false;
                smeaContainer.title = '';
            }
        }
        updateSmeaVisibility(); // 초기 실행

        // ============================================================
        // Settings Persistence (localStorage)
        // ============================================================
        const SETTINGS_KEY = 'nai_generator_settings';
        
        function saveAppSettings() {
            const settings = {
                // Provider
                provider: currentProvider,

                // Prompts
                basePrompt: document.getElementById('basePrompt').value,
                negativePrompt: document.getElementById('negativePrompt').value,

                // Prompt layout (heights and collapse states)
                basePromptHeight: document.getElementById('basePrompt').style.height || null,
                negativePromptHeight: document.getElementById('negativePrompt').style.height || null,
                basePromptCollapsed: document.getElementById('basePromptContent').classList.contains('collapsed'),
                charactersCollapsed: document.getElementById('charactersContent').classList.contains('collapsed'),
                negativePromptCollapsed: document.getElementById('negativePromptContent').classList.contains('collapsed'),

                // Size
                sizePreset: document.getElementById('sizePreset').value,
                width: document.getElementById('width').value,
                height: document.getElementById('height').value,
                
                // Generation
                steps: document.getElementById('steps').value,
                cfg: document.getElementById('cfg').value,
                sampler: document.getElementById('sampler').value,
                scheduler: document.getElementById('scheduler').value,
                seed: document.getElementById('seed').value,
                randomSeed: document.getElementById('randomSeed').checked,
                lockSeed: document.getElementById('lockSeed').checked,

                // NAI
                naiModel: document.getElementById('naiModel').value,
                smea: document.getElementById('smea').value,
                ucPreset: document.getElementById('ucPreset').value,
                qualityTags: document.getElementById('qualityTags').checked,
                furryModeEnabled: furryModeEnabled,
                cfgRescale: document.getElementById('cfgRescale').value,
                varietyPlus: document.getElementById('varietyPlus').checked,

                // Vibe Transfer
                enableVibeTransfer: document.getElementById('enableVibeTransfer').checked,
                vibeList: vibeList,

                // Character Reference
                enableCharRef: document.getElementById('enableCharRef').checked,
                charRefData: charRefData,
                charRefFidelity: document.getElementById('charRefFidelity').value,
                charRefStyleAware: document.getElementById('charRefStyleAware').checked,

                // Local
                localModel: document.getElementById('localModel').value,
                
                // Upscale
                enableUpscale: document.getElementById('enableUpscale').checked,
                upscaleModel: document.getElementById('upscaleModel').value,
                downscaleRatio: document.getElementById('downscaleRatio').value,
                sizeAlignment: document.getElementById('sizeAlignment').value,
                upscaleSteps: document.getElementById('upscaleSteps').value,
                upscaleCfg: document.getElementById('upscaleCfg').value,
                upscaleDenoise: document.getElementById('upscaleDenoise').value,

                // Save Options
                saveFormat: document.getElementById('saveFormat').value,
                jpgQuality: document.getElementById('jpgQuality').value,
                stripMetadata: document.getElementById('stripMetadata').checked,

                // Output
                outputFolder: getOutputFolder(),
                repeatCount: document.getElementById('repeatCount').value,
                
                // Slots
                slots: getSlotList(),
                slotWidth: currentSlotWidth,
                sidebarWidth: currentSidebarWidth,

                // Preset
                currentPreset: currentPreset,

                // Character prompts (with layout)
                characterPromptsLayout: getCharacterPromptsWithLayout(),
            };
            
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        }
        
        function loadAppSettings() {
            const saved = localStorage.getItem(SETTINGS_KEY);
            if (!saved) return;
            
            try {
                const settings = JSON.parse(saved);
                
                // Provider - local은 설치 상태 확인 후 적용
                if (settings.provider) {
                    if (settings.provider === 'local') {
                        // local은 나중에 checkLocalEnvStatus에서 설치 확인 후 적용
                        window._pendingProvider = 'local';
                        // 일단 NAI로 설정
                        currentProvider = 'nai';
                    } else {
                        currentProvider = settings.provider;
                    }
                    tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === currentProvider));
                    providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === currentProvider));
                }
                
                // Prompts
                if (settings.basePrompt !== undefined) document.getElementById('basePrompt').value = settings.basePrompt;
                if (settings.negativePrompt !== undefined) document.getElementById('negativePrompt').value = settings.negativePrompt;

                // Prompt layout (heights and collapse states)
                if (settings.basePromptHeight) document.getElementById('basePrompt').style.height = settings.basePromptHeight;
                if (settings.negativePromptHeight) document.getElementById('negativePrompt').style.height = settings.negativePromptHeight;
                if (settings.basePromptCollapsed) {
                    document.getElementById('basePromptContent').classList.add('collapsed');
                    document.querySelector('[data-target="basePromptContent"]').classList.add('collapsed');
                }
                if (settings.charactersCollapsed) {
                    document.getElementById('charactersContent').classList.add('collapsed');
                    document.querySelector('[data-target="charactersContent"]').classList.add('collapsed');
                }
                if (settings.negativePromptCollapsed) {
                    document.getElementById('negativePromptContent').classList.add('collapsed');
                    document.querySelector('[data-target="negativePromptContent"]').classList.add('collapsed');
                }

                // Size
                if (settings.sizePreset) document.getElementById('sizePreset').value = settings.sizePreset;
                if (settings.width) document.getElementById('width').value = settings.width;
                if (settings.height) document.getElementById('height').value = settings.height;
                
                // Generation
                if (settings.steps) document.getElementById('steps').value = settings.steps;
                if (settings.cfg) document.getElementById('cfg').value = settings.cfg;
                
                // 샘플러/스케줄러는 provider에 따라 옵션이 다르므로 pending으로 저장
                window._pendingSampler = settings.sampler;
                window._pendingScheduler = settings.scheduler;

                if (settings.seed !== undefined && settings.seed !== '') document.getElementById('seed').value = settings.seed;
                if (settings.randomSeed !== undefined) document.getElementById('randomSeed').checked = settings.randomSeed;
                if (settings.lockSeed !== undefined) document.getElementById('lockSeed').checked = settings.lockSeed;

                // NAI
                if (settings.naiModel) document.getElementById('naiModel').value = settings.naiModel;
                if (settings.smea) document.getElementById('smea').value = settings.smea;
                if (settings.ucPreset) document.getElementById('ucPreset').value = settings.ucPreset;
                if (settings.qualityTags !== undefined) document.getElementById('qualityTags').checked = settings.qualityTags;
                if (settings.furryModeEnabled) {
                    furryModeEnabled = true;
                    modeToggle.textContent = '🐾';
                    modeToggle.title = '퍼리 모드';
                    modeToggle.classList.add('furry');
                }
                if (settings.cfgRescale !== undefined) {
                    document.getElementById('cfgRescale').value = settings.cfgRescale;
                    document.getElementById('cfgRescaleValue').textContent = settings.cfgRescale;
                }
                if (settings.varietyPlus !== undefined) document.getElementById('varietyPlus').checked = settings.varietyPlus;

                // Vibe Transfer
                if (settings.enableVibeTransfer !== undefined) {
                    document.getElementById('enableVibeTransfer').checked = settings.enableVibeTransfer;
                    document.getElementById('vibeTransferSettings').style.display = settings.enableVibeTransfer ? 'block' : 'none';
                }
                if (settings.vibeList && settings.vibeList.length > 0) {
                    vibeList = settings.vibeList;
                    renderVibeList();
                }

                // Character Reference
                if (settings.enableCharRef !== undefined) {
                    document.getElementById('enableCharRef').checked = settings.enableCharRef;
                    document.getElementById('charRefSettings').style.display = settings.enableCharRef ? 'block' : 'none';
                }
                if (settings.charRefData) {
                    charRefData = settings.charRefData;
                    document.getElementById('charRefImage').src = 'data:image/png;base64,' + charRefData.image;
                    document.getElementById('charRefPreview').style.display = 'block';
                    document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
                }
                if (settings.charRefFidelity) {
                    document.getElementById('charRefFidelity').value = settings.charRefFidelity;
                    document.getElementById('charRefFidelityValue').textContent = settings.charRefFidelity;
                }
                if (settings.charRefStyleAware !== undefined) {
                    document.getElementById('charRefStyleAware').checked = settings.charRefStyleAware;
                }

                // Local - 모델은 loadResources 후에 설정해야 함
                window._pendingLocalModel = settings.localModel;
                window._pendingUpscaleModel = settings.upscaleModel;
                
                // Upscale
                if (settings.enableUpscale !== undefined) {
                    document.getElementById('enableUpscale').checked = settings.enableUpscale;
                    document.getElementById('upscaleSettings').style.display = settings.enableUpscale ? 'block' : 'none';
                }
                if (settings.downscaleRatio) document.getElementById('downscaleRatio').value = settings.downscaleRatio;
                if (settings.sizeAlignment) document.getElementById('sizeAlignment').value = settings.sizeAlignment;
                if (settings.upscaleSteps) document.getElementById('upscaleSteps').value = settings.upscaleSteps;
                if (settings.upscaleCfg) document.getElementById('upscaleCfg').value = settings.upscaleCfg;
                if (settings.upscaleDenoise) {
                    document.getElementById('upscaleDenoise').value = settings.upscaleDenoise;
                    document.getElementById('upscaleDenoiseValue').textContent = settings.upscaleDenoise;
                }

                // Save Options
                if (settings.saveFormat) document.getElementById('saveFormat').value = settings.saveFormat;
                if (settings.jpgQuality) document.getElementById('jpgQuality').value = settings.jpgQuality;
                if (settings.stripMetadata !== undefined) document.getElementById('stripMetadata').checked = settings.stripMetadata;

                // Output
                if (settings.outputFolder !== undefined) setOutputFolder(settings.outputFolder);
                if (settings.repeatCount) document.getElementById('repeatCount').value = settings.repeatCount;
                
                // Slots - 기존 슬롯 제거 후 복원
                if (settings.slots && settings.slots.length > 0) {
                    slotsContainer.innerHTML = '';
                    settings.slots.forEach(slot => {
                        addSlot(slot.name || '', slot.content || '');
                    });
                }

                // Slot width
                if (settings.slotWidth) {
                    setSlotWidth(settings.slotWidth);
                }

                // Sidebar width
                if (settings.sidebarWidth) {
                    setSidebarWidth(settings.sidebarWidth);
                }

                // Preset 복원
                if (settings.currentPreset) {
                    currentPreset = settings.currentPreset;
                    presetNameSpan.textContent = currentPreset.name || 'Slot Set';
                }

                // Character prompts (new format with layout)
                if (settings.characterPromptsLayout && settings.characterPromptsLayout.length > 0) {
                    window._pendingCharacterPromptsLayout = settings.characterPromptsLayout;
                }
                // Legacy format (just strings)
                else if (settings.characterPrompts && settings.characterPrompts.length > 0) {
                    window._pendingCharacterPromptsLayout = settings.characterPrompts.map(c => ({ content: c, collapsed: false, height: null, enabled: true }));
                }
                
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
        }
        
        // 설정 변경 시 자동 저장 (debounce)
        let saveTimeout = null;
        function autoSaveSettings() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveAppSettings, 500);
        }
        
        // 주요 입력 요소에 자동 저장 연결
        function setupAutoSave() {
            const inputs = [
                'basePrompt', 'negativePrompt', 'width', 'height', 'steps', 'cfg',
                'sampler', 'scheduler', 'seed', 'randomSeed', 'naiModel', 'smea',
                'ucPreset', 'qualityTags', 'localModel', 'enableUpscale', 'upscaleModel',
                'downscaleRatio', 'sizeAlignment', 'upscaleSteps', 'upscaleCfg',
                'upscaleDenoise', 'repeatCount', 'sizePreset',
                'cfgRescale', 'varietyPlus', 'lockSeed'
            ];
            
            inputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', autoSaveSettings);
                    if (el.tagName === 'TEXTAREA' || el.type === 'text' || el.type === 'number') {
                        el.addEventListener('input', autoSaveSettings);
                    }
                }
            });
            
            // 슬롯 변경 감지
            slotsContainer.addEventListener('input', autoSaveSettings);
            slotsContainer.addEventListener('change', autoSaveSettings);

            // 캐릭터 프롬프트 변경 감지
            charactersList.addEventListener('input', autoSaveSettings);
            charactersList.addEventListener('change', autoSaveSettings);

            // 프롬프트 창 리사이즈 감지
            const resizeObserver = new ResizeObserver(() => autoSaveSettings());
            resizeObserver.observe(document.getElementById('basePrompt'));
            resizeObserver.observe(document.getElementById('negativePrompt'));
        }
        
        // Init
        loadAppSettings();  // 저장된 설정 먼저 로드

        // 현재 provider에 맞게 샘플러/스케줄러 옵션 설정 및 복원
        updateSamplerSchedulerOptions(currentProvider);

        // Anlas 정보 초기화 (NAI인 경우)
        updateAnlasVisibility();
        if (window._pendingSampler) {
            const samplerSelect = document.getElementById('sampler');
            // 현재 옵션에 있는 값만 복원
            if ([...samplerSelect.options].some(o => o.value === window._pendingSampler)) {
                samplerSelect.value = window._pendingSampler;
                window._pendingSampler = null;
            }
            // 없으면 pending 유지 (local 전환 시 복원)
        }
        if (window._pendingScheduler) {
            const schedulerSelect = document.getElementById('scheduler');
            if ([...schedulerSelect.options].some(o => o.value === window._pendingScheduler)) {
                schedulerSelect.value = window._pendingScheduler;
                window._pendingScheduler = null;
            }
        }
        
        loadResources().then(() => {
            // 모델 선택 복원 (loadResources 완료 후)
            if (window._pendingLocalModel) {
                document.getElementById('localModel').value = window._pendingLocalModel;
            }
            if (window._pendingUpscaleModel) {
                document.getElementById('upscaleModel').value = window._pendingUpscaleModel;
            }
            // 캐릭터 프롬프트 복원 (레이아웃 포함)
            if (window._pendingCharacterPromptsLayout) {
                window._pendingCharacterPromptsLayout.forEach(charData => {
                    const content = charData.content || '';
                    const collapsed = charData.collapsed || false;
                    const height = charData.height || null;
                    const enabled = charData.enabled !== false;  // 기본값 true (하위 호환)
                    if (content.trim() || collapsed) {
                        const item = createCharacterItem(content, collapsed, enabled);
                        if (height) {
                            item.querySelector('textarea').style.height = height;
                        }
                        charactersList.appendChild(item);
                    }
                });
                updateCharacterNumbers();
                window._pendingCharacterPromptsLayout = null;
            }

            // 모든 복원 완료 후 자동 저장 설정
            setupAutoSave();
        });
        connectWebSocket();
        checkLocalEnvStatus();
        
        // 슬롯이 없으면 하나 추가
        if (slotsContainer.children.length === 0) {
            addSlot();
        }
        
        // 시드가 비어있으면 랜덤 생성
        if (!document.getElementById('seed').value) {
            document.getElementById('seed').value = Math.floor(Math.random() * 2147483647);
        }
        
        // 초기 그라데이션 업데이트
        setTimeout(updateScrollGradients, 100);
        
        // 페이지 떠날 때 저장 및 경고
        window.addEventListener('beforeunload', (e) => {
            saveAppSettings();
            // 브라우저 기본 확인 팝업 표시
            e.preventDefault();
            e.returnValue = '';
        });

        // ============================================================
        // Gallery Mode
        // ============================================================
        const slotModeBtn = document.getElementById('slotModeBtn');
        const galleryModeBtn = document.getElementById('galleryModeBtn');
        const censorModeBtn = document.getElementById('censorModeBtn');
        const slotsToolbar = document.getElementById('slotsToolbar');
        const galleryContainer = document.getElementById('galleryContainer');
        const censorContainer = document.getElementById('censorContainer');
        const galleryGrid = document.getElementById('galleryGrid');
        const galleryEmpty = document.getElementById('galleryEmpty');
        const gallerySubfolders = document.getElementById('gallerySubfolders');
        const galleryRootBtn = document.getElementById('galleryRootBtn');

        let currentMode = 'slot'; // 'slot' | 'gallery' | 'censor'
        let currentGalleryFolder = ''; // 현재 선택된 폴더 (빈 문자열 = gallery 루트)
        let isVibeMode = false; // vibe cache mode

        slotModeBtn.onclick = () => {
            if (currentMode === 'slot') return;
            currentMode = 'slot';
            slotModeBtn.classList.add('active');
            galleryModeBtn.classList.remove('active');
            censorModeBtn.classList.remove('active');
            slotsToolbar.style.display = 'flex';
            slotsWrapper.style.display = 'flex';
            galleryContainer.style.display = 'none';
            censorContainer.style.display = 'none';
        };

        galleryModeBtn.onclick = () => {
            if (currentMode === 'gallery') return;
            currentMode = 'gallery';
            galleryModeBtn.classList.add('active');
            slotModeBtn.classList.remove('active');
            censorModeBtn.classList.remove('active');
            slotsToolbar.style.display = 'none';
            slotsWrapper.style.display = 'none';
            galleryContainer.style.display = 'flex';
            censorContainer.style.display = 'none';
            loadGalleryFolders();
            loadGallery(currentGalleryFolder);
        };

        censorModeBtn.onclick = () => {
            if (currentMode === 'censor') return;
            currentMode = 'censor';
            censorModeBtn.classList.add('active');
            slotModeBtn.classList.remove('active');
            galleryModeBtn.classList.remove('active');
            slotsToolbar.style.display = 'none';
            slotsWrapper.style.display = 'none';
            galleryContainer.style.display = 'none';
            censorContainer.style.display = 'flex';
            loadCensorFolders();
        };

        // 갤러리 폴더 열기 (현재 선택된 폴더)
        document.getElementById('openGalleryFolderBtn').onclick = async () => {
            try {
                const response = await fetch(`${API_BASE}/api/gallery/open-folder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder: currentGalleryFolder })
                });
                const result = await response.json();
                if (!result.success) {
                    showToast('폴더 열기 실패', 'error');
                }
            } catch (err) {
                showToast('폴더 열기 오류', 'error');
            }
        };

        // 새 폴더 생성
        document.getElementById('addFolderBtn').onclick = () => {
            showInputModal('📁 새 폴더', '폴더 이름을 입력하세요', async (folderName) => {
                try {
                    const response = await fetch(`${API_BASE}/api/gallery/folders`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: folderName })
                    });
                    const result = await response.json();
                    if (result.success) {
                        showToast('폴더 생성됨', 'success');
                        loadGalleryFolders();
                    } else {
                        showToast('폴더 생성 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('폴더 생성 오류: ' + err.message, 'error');
                }
            }, '생성');
        };

        // 폴더 아이콘 업데이트 (📂 선택됨 / 📁 미선택)
        function updateFolderIcons() {
            const vibeCacheBtn = document.getElementById('vibeCacheBtn');

            // vibe 폴더
            vibeCacheBtn.classList.toggle('active', isVibeMode);

            // 루트 폴더
            const isRootActive = !isVibeMode && currentGalleryFolder === '';
            galleryRootBtn.textContent = `${isRootActive ? '📂' : '📁'} gallery`;
            galleryRootBtn.classList.toggle('active', isRootActive);

            // 하위 폴더들
            gallerySubfolders.querySelectorAll('.folder-tab').forEach(tab => {
                const isActive = !isVibeMode && tab.dataset.folder === currentGalleryFolder;
                const folderName = tab.dataset.folder;
                const count = tab.dataset.count || '';
                tab.textContent = `${isActive ? '📂' : '📁'} ${folderName}${count ? ` (${count})` : ''}`;
                tab.classList.toggle('active', isActive);
            });
        }

        // 폴더 목록 로드
        async function loadGalleryFolders() {
            try {
                const response = await fetch(`${API_BASE}/api/gallery/folders`);
                const result = await response.json();

                // 기존 하위 폴더 탭 제거
                gallerySubfolders.innerHTML = '';

                if (result.success && result.folders) {
                    result.folders.forEach(folder => {
                        const tab = document.createElement('button');
                        tab.type = 'button';
                        tab.className = 'folder-tab';
                        tab.dataset.folder = folder.name;
                        tab.dataset.count = folder.image_count;
                        tab.title = `${folder.image_count}개 이미지`;
                        setupFolderTab(tab);
                        gallerySubfolders.appendChild(tab);
                    });
                }

                // 루트 폴더 탭 이벤트 설정
                setupFolderTab(galleryRootBtn);

                // 아이콘 상태 업데이트
                updateFolderIcons();
            } catch (err) {
                console.error('폴더 목록 로드 실패:', err);
            }
        }

        // Vibe 캐시 버튼 클릭
        document.getElementById('vibeCacheBtn').onclick = () => {
            if (isVibeMode) return;
            isVibeMode = true;
            updateFolderIcons();
            loadVibeCache();
        };

        // 폴더 탭 이벤트 설정
        function setupFolderTab(tab) {
            tab.onclick = () => {
                if (!isVibeMode && tab.dataset.folder === currentGalleryFolder) return;
                isVibeMode = false;  // Exit vibe mode when clicking gallery folders
                currentGalleryFolder = tab.dataset.folder;
                updateFolderIcons();
                loadGallery(currentGalleryFolder);
            };

            // 드래그 오버 이벤트 (이미지를 폴더로 이동할 때)
            tab.ondragover = (e) => {
                e.preventDefault();
                tab.classList.add('drag-over');
            };
            tab.ondragleave = () => {
                tab.classList.remove('drag-over');
            };
            tab.ondrop = async (e) => {
                e.preventDefault();
                tab.classList.remove('drag-over');
                const filename = e.dataTransfer.getData('text/plain');
                const fromFolder = e.dataTransfer.getData('application/x-gallery-folder');
                const toFolder = tab.dataset.folder;

                if (!filename || fromFolder === toFolder) return;

                try {
                    const response = await fetch(`${API_BASE}/api/gallery/${encodeURIComponent(filename)}/move`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ from_folder: fromFolder, to_folder: toFolder })
                    });
                    const result = await response.json();
                    if (result.success) {
                        showToast('이미지 이동됨', 'success');
                        loadGallery(currentGalleryFolder);
                        loadGalleryFolders();
                    } else {
                        showToast('이동 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('이동 오류: ' + err.message, 'error');
                }
            };
        }

        let galleryLoaded = false;

        async function loadGallery(folder = '') {
            // 바이브 모드면 갤러리 로드 안함
            if (isVibeMode) return;

            // 로딩 중 표시
            galleryGrid.style.display = 'none';
            galleryEmpty.innerHTML = `
                <div class="icon">⏳</div>
                <p>갤러리 로딩 중...</p>
            `;
            galleryEmpty.style.display = 'flex';

            try {
                const response = await fetch(`${API_BASE}/api/gallery?folder=${encodeURIComponent(folder)}`);
                const result = await response.json();

                // 로딩 중에 바이브 모드로 전환되었으면 렌더링 안함
                if (isVibeMode) return;

                if (result.images && result.images.length > 0) {
                    galleryEmpty.style.display = 'none';
                    galleryGrid.style.display = 'grid';
                    renderGallery(result.images, folder);
                } else {
                    galleryEmpty.innerHTML = `
                        <div class="icon">🖼️</div>
                        <p>${folder ? `'${folder}' 폴더가` : '갤러리가'} 비어있습니다</p>
                        <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                    `;
                    galleryEmpty.style.display = 'flex';
                    galleryGrid.style.display = 'none';
                    galleryGrid.innerHTML = '';
                }
                galleryLoaded = true;
            } catch (err) {
                galleryEmpty.innerHTML = `
                    <div class="icon">❌</div>
                    <p>갤러리 로드 실패</p>
                    <small>${err.message}</small>
                `;
                showToast('갤러리 로드 실패: ' + err.message, 'error');
            }
        }

        function renderGallery(images, folder = '') {
            galleryGrid.innerHTML = '';

            images.forEach(img => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                item._filename = img.filename;
                item._folder = folder;
                item.draggable = true;
                item.innerHTML = `
                    <img src="data:image/png;base64,${img.thumbnail}" alt="">
                    <div class="gallery-item-info">
                        <div class="filename-row">
                            <span class="filename" title="${img.filename}">${img.filename.replace('.png', '')}</span>
                            <button class="rename-btn" title="이름 변경">✏️</button>
                        </div>
                        <div class="seed">${img.seed ? 'Seed: ' + img.seed : '메타데이터 없음'}</div>
                    </div>
                    <div class="gallery-item-actions">
                        <button class="inpaint-btn" title="인페인트">🎨 Inpaint</button>
                        <button class="copy-seed-btn" title="시드 복사">🎲 Seed</button>
                        <button class="apply-all-btn" title="전체 설정 적용">📋 Apply</button>
                        <button class="delete-btn" title="삭제">🗑️</button>
                    </div>
                `;

                // 드래그 시작 (폴더 이동용)
                item.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', item._filename);
                    e.dataTransfer.setData('application/x-gallery-folder', item._folder);
                    e.dataTransfer.effectAllowed = 'move';

                    // 커스텀 드래그 고스트 생성
                    const ghost = document.createElement('div');
                    ghost.id = 'dragGhost';
                    ghost.style.cssText = 'position: fixed; top: -100px; left: -100px; width: 60px; height: 60px; background: var(--accent); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: none; z-index: 10000;';
                    ghost.textContent = '📁';
                    document.body.appendChild(ghost);
                    e.dataTransfer.setDragImage(ghost, 30, 30);

                    item.classList.add('dragging');
                };
                item.ondragend = () => {
                    item.classList.remove('dragging');
                    // 드래그 고스트 제거
                    const ghost = document.getElementById('dragGhost');
                    if (ghost) ghost.remove();
                };

                // 이미지 자체의 기본 드래그 동작 방지 (부모 item의 드래그로 대체)
                const imgEl = item.querySelector('img');
                if (imgEl) {
                    imgEl.draggable = false;
                }

                // 라이트박스 표시 함수
                const folderQuery = folder ? `?folder=${encodeURIComponent(folder)}` : '';
                const showLightbox = async () => {
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success) {
                            lightboxImg.src = 'data:image/png;base64,' + result.image;
                            lightboxCurrentGalleryItem = item;  // 휠 네비게이션용
                            lightbox.classList.add('active');
                        }
                    } catch (err) {
                        showToast('이미지 로드 실패', 'error');
                    }
                };

                // 카드 클릭 - 라이트박스 (버튼 제외)
                item.onclick = (e) => {
                    // 버튼이나 입력 필드 클릭시 무시
                    if (e.target.closest('.gallery-item-actions') || e.target.closest('.rename-btn') || e.target.tagName === 'INPUT') {
                        return;
                    }
                    showLightbox();
                };

                // 이름 변경
                item.querySelector('.rename-btn').onclick = (e) => {
                    e.stopPropagation();
                    const filenameRow = item.querySelector('.filename-row');
                    const filenameSpan = item.querySelector('.filename');
                    const currentName = item._filename.replace('.png', '');

                    // 입력 필드로 교체
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'filename-input';
                    input.value = currentName;

                    filenameSpan.style.display = 'none';
                    filenameRow.insertBefore(input, filenameRow.querySelector('.rename-btn'));
                    input.focus();
                    input.select();

                    const saveRename = async () => {
                        const newName = input.value.trim();
                        if (!newName || newName === currentName) {
                            // 취소
                            input.remove();
                            filenameSpan.style.display = '';
                            return;
                        }

                        try {
                            const response = await fetch(`${API_BASE}/api/gallery/${item._filename}`, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ new_name: newName, folder: item._folder })
                            });
                            const result = await response.json();
                            if (result.success) {
                                item._filename = result.new_filename;
                                filenameSpan.textContent = newName;
                                filenameSpan.title = result.new_filename;
                                showToast('이름 변경됨', 'success');
                            } else {
                                showToast(result.error || '이름 변경 실패', 'error');
                            }
                        } catch (err) {
                            showToast('이름 변경 오류', 'error');
                        }

                        input.remove();
                        filenameSpan.style.display = '';
                    };

                    input.onblur = saveRename;
                    input.onkeydown = (ke) => {
                        if (ke.key === 'Enter') {
                            ke.preventDefault();
                            input.blur();
                        } else if (ke.key === 'Escape') {
                            input.value = currentName;
                            input.blur();
                        }
                    };
                };

                // 시드 적용 (확인 팝업)
                item.querySelector('.copy-seed-btn').onclick = async (e) => {
                    e.stopPropagation();
                    if (img.seed) {
                        showConfirmModal(
                            '🎲 시드 적용',
                            `<p>이 시드를 적용하시겠습니까?</p><div class="metadata" style="font-size: 0.9rem; margin-top: 8px;"><strong>Seed:</strong> ${img.seed}</div>`,
                            async () => {
                                document.getElementById('seed').value = img.seed;
                                await navigator.clipboard.writeText(String(img.seed));
                                showToast('시드 적용 및 복사됨', 'success');
                            },
                            '적용'
                        );
                    } else {
                        showToast('시드 정보 없음', 'warning');
                    }
                };

                // 전체 설정 적용 (확인 팝업)
                item.querySelector('.apply-all-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success && result.metadata) {
                            // showLoadSettingsConfirm 내부에서 normalizeMetadata 호출
                            showLoadSettingsConfirm(result.metadata);
                        } else {
                            showToast('메타데이터 없음', 'warning');
                        }
                    } catch (err) {
                        showToast('적용 실패: ' + err.message, 'error');
                    }
                };

                // 인페인트
                item.querySelector('.inpaint-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success && result.image) {
                            setBaseImageForInpaint(result.image);
                            showToast('인페인트 모드로 전환', 'success');
                        } else {
                            showToast('이미지 로드 실패', 'error');
                        }
                    } catch (err) {
                        showToast('인페인트 오류: ' + err.message, 'error');
                    }
                };

                // 삭제
                item.querySelector('.delete-btn').onclick = async (e) => {
                    e.stopPropagation();
                    showConfirmModal(
                        '🗑️ 이미지 삭제',
                        '<p>이 이미지를 갤러리에서 삭제하시겠습니까?</p>',
                        async () => {
                            try {
                                const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`, {
                                    method: 'DELETE'
                                });
                                const result = await response.json();
                                if (result.success) {
                                    item.remove();
                                    showToast('삭제됨', 'success');
                                    // 갤러리가 비었는지 확인
                                    if (galleryGrid.children.length === 0) {
                                        galleryEmpty.innerHTML = `
                                            <div class="icon">🖼️</div>
                                            <p>갤러리가 비어있습니다</p>
                                            <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                                        `;
                                        galleryEmpty.style.display = 'flex';
                                        galleryGrid.style.display = 'none';
                                    }
                                } else {
                                    showToast('삭제 실패', 'error');
                                }
                            } catch (err) {
                                showToast('삭제 오류: ' + err.message, 'error');
                            }
                        },
                        '삭제',
                        true
                    );
                };

                galleryGrid.appendChild(item);
            });
        }

        // ============================================================
        // Vibe Cache Loading
        // ============================================================
        async function loadVibeCache() {
            // 로딩 중 표시
            galleryGrid.style.display = 'none';
            galleryEmpty.innerHTML = `
                <div class="icon">⏳</div>
                <p>바이브 캐시 로딩 중...</p>
            `;
            galleryEmpty.style.display = 'flex';

            try {
                const response = await fetch(`${API_BASE}/api/vibe-cache`);
                const result = await response.json();

                if (result.vibes && result.vibes.length > 0) {
                    galleryEmpty.style.display = 'none';
                    galleryGrid.style.display = 'grid';
                    renderVibeCache(result.vibes);
                } else {
                    galleryEmpty.innerHTML = `
                        <div class="icon">🎨</div>
                        <p>바이브 캐시가 비어있습니다</p>
                        <small>이미지 생성 시 바이브가 자동으로 캐시됩니다</small>
                    `;
                    galleryEmpty.style.display = 'flex';
                    galleryGrid.style.display = 'none';
                    galleryGrid.innerHTML = '';
                }
            } catch (err) {
                galleryEmpty.innerHTML = `
                    <div class="icon">❌</div>
                    <p>바이브 캐시 로드 실패</p>
                    <small>${err.message}</small>
                `;
                showToast('바이브 캐시 로드 실패: ' + err.message, 'error');
            }
        }

        function renderVibeCache(vibes) {
            galleryGrid.innerHTML = '';

            vibes.forEach(vibe => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                item._filename = vibe.filename;
                item._isVibe = true;  // 바이브 캐시 아이템 마커
                item._thumbnail = vibe.thumbnail;  // 휠 네비게이션용
                item.draggable = false;  // Vibe items are not draggable

                // 파일명에서 이름 추출 (예: name_0.6_1.0_0000001.png → name)
                const displayName = vibe.filename.replace(/\.png$/i, '').replace(/_[\d.]+_[\d.]+_\d+$/, '');

                item.innerHTML = `
                    <img src="data:image/png;base64,${vibe.thumbnail}" alt="">
                    <div class="gallery-item-info">
                        <div class="filename-row">
                            <span class="filename" title="${vibe.filename}">${displayName}</span>
                        </div>
                        <div class="seed">S:${vibe.strength} IE:${vibe.info_extracted}</div>
                    </div>
                    <div class="gallery-item-actions">
                        <button class="apply-vibe-btn" title="바이브 적용">🎨 Vibe</button>
                        <button class="delete-btn" title="삭제">🗑️</button>
                    </div>
                `;

                // 이미지 클릭 시 라이트박스
                const imgEl = item.querySelector('img');
                imgEl.onclick = () => {
                    lightboxImg.src = `data:image/png;base64,${vibe.thumbnail}`;
                    lightboxCurrentGalleryItem = item;  // 휠 네비게이션용
                    lightbox.classList.add('active');
                };

                // 바이브 적용 버튼
                item.querySelector('.apply-vibe-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/vibe-cache/${vibe.filename}`);
                        const result = await response.json();
                        if (result.success && result.vibe_data) {
                            // vibeList에 추가
                            if (vibeList.length >= 16) {
                                showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                                return;
                            }

                            vibeList.push({
                                image: result.image,
                                strength: result.strength,
                                info_extracted: result.info_extracted,
                                name: displayName,
                                encoded: result.vibe_data,  // Pre-encoded vibe data
                                encoded_model: result.model,  // Model used for encoding
                                encoded_info_extracted: result.info_extracted  // Info extracted used for encoding
                            });
                            renderVibeList();
                            saveAppSettings();
                            updateAnlasCost();

                            // Vibe Transfer 활성화
                            document.getElementById('enableVibeTransfer').checked = true;
                            document.getElementById('vibeTransferSettings').style.display = 'block';

                            showToast('바이브가 추가되었습니다', 'success');
                        } else {
                            showToast('바이브 데이터 없음', 'warning');
                        }
                    } catch (err) {
                        showToast('바이브 적용 실패: ' + err.message, 'error');
                    }
                };

                // 삭제 버튼
                item.querySelector('.delete-btn').onclick = async (e) => {
                    e.stopPropagation();
                    showConfirmModal(
                        '🗑️ 바이브 삭제',
                        '<p>이 바이브 캐시를 삭제하시겠습니까?</p>',
                        async () => {
                            try {
                                const response = await fetch(`${API_BASE}/api/vibe-cache/${vibe.filename}`, {
                                    method: 'DELETE'
                                });
                                const result = await response.json();
                                if (result.success) {
                                    item.remove();
                                    showToast('삭제됨', 'success');
                                    // 캐시가 비었는지 확인
                                    if (galleryGrid.children.length === 0) {
                                        galleryEmpty.innerHTML = `
                                            <div class="icon">🎨</div>
                                            <p>바이브 캐시가 비어있습니다</p>
                                            <small>이미지 생성 시 바이브가 자동으로 캐시됩니다</small>
                                        `;
                                        galleryEmpty.style.display = 'flex';
                                        galleryGrid.style.display = 'none';
                                    }
                                } else {
                                    showToast('삭제 실패', 'error');
                                }
                            } catch (err) {
                                showToast('삭제 오류: ' + err.message, 'error');
                            }
                        },
                        '삭제',
                        true
                    );
                };

                galleryGrid.appendChild(item);
            });
        }

        // ============================================================
        // 외부 이미지 드롭 처리
        // ============================================================
        const dropOverlay = document.getElementById('dropOverlay');
        const dropModal = document.getElementById('dropModal');
        let pendingDropData = null;

        // 드래그 이벤트 처리
        let dragCounter = 0;
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            if (e.dataTransfer.types.includes('Files')) {
                dropOverlay.classList.add('active');
            }
        });

        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dropOverlay.classList.remove('active');
            }
        });

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropOverlay.classList.remove('active');

            const files = e.dataTransfer.files;
            if (files.length === 0) return;

            const file = files[0];
            if (!file.type.startsWith('image/')) {
                showToast('이미지 파일만 드롭할 수 있습니다', 'error');
                return;
            }

            // 이미지를 base64로 변환
            const base64 = await fileToBase64(file);

            // 서버에서 메타데이터 추출
            try {
                const response = await fetch(`${API_BASE}/api/extract-metadata`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: base64 })
                });
                const result = await response.json();

                if (!result.success) {
                    showToast('메타데이터 추출 실패: ' + result.error, 'error');
                    return;
                }

                // 모달 표시 준비
                document.getElementById('dropModalPreview').src = 'data:image/png;base64,' + base64;
                const metadataDiv = document.getElementById('dropModalMetadata');

                if (result.is_vibe) {
                    // 바이브 캐시 파일
                    const hasCache = result.vibe_data && result.vibe_model;
                    document.getElementById('dropModalTitle').textContent = hasCache ? '🎨 바이브 캐시 파일' : '🎨 바이브 파일';
                    metadataDiv.innerHTML = `
                        <div><strong>Strength:</strong> ${result.vibe_strength}</div>
                        <div><strong>Info Extracted:</strong> ${result.vibe_info_extracted}</div>
                        ${hasCache ? `<div><strong>Model:</strong> ${result.vibe_model}</div><div style="color:#4ade80">✓ 인코딩 캐시 있음 (Anlas 무료)</div>` : ''}
                    `;
                    document.getElementById('dropModalConfirm').textContent = '바이브에 추가';
                    pendingDropData = {
                        type: 'vibe',
                        image: base64,
                        strength: result.vibe_strength,
                        info_extracted: result.vibe_info_extracted,
                        name: file.name,
                        encoded: result.vibe_data || null,
                        encoded_model: result.vibe_model || null,
                        encoded_info_extracted: result.vibe_data ? result.vibe_info_extracted : null  // 캐시된 경우 인코딩 시 사용된 info_extracted
                    };
                } else if (result.is_nai && result.nai_metadata) {
                    // NAI 생성 이미지 - 정규화된 메타데이터로 표시
                    const meta = normalizeMetadata(result.nai_metadata);
                    const isPureNai = !result.nai_metadata.peropix;
                    document.getElementById('dropModalTitle').textContent = isPureNai ? '🖼️ NAI 원본 이미지' : '🖼️ PeroPix 이미지';

                    metadataDiv.innerHTML = `
                        <div><strong>Prompt:</strong> ${(meta.prompt || '').substring(0, 100)}${(meta.prompt || '').length > 100 ? '...' : ''}</div>
                        <div><strong>Negative:</strong> ${(meta.negative_prompt || '').substring(0, 50)}${(meta.negative_prompt || '').length > 50 ? '...' : ''}</div>
                        <div><strong>Seed:</strong> ${meta.seed || 'N/A'}</div>
                        <div><strong>Size:</strong> ${meta.width}x${meta.height}</div>
                        <div><strong>Steps:</strong> ${meta.steps}, <strong>CFG:</strong> ${meta.cfg}, <strong>Rescale:</strong> ${meta.cfg_rescale || 0}</div>
                        <div><strong>Sampler:</strong> ${meta.sampler}, <strong>Scheduler:</strong> ${meta.scheduler}</div>
                        <div><strong>SMEA:</strong> ${meta.smea}, <strong>Variety+:</strong> ${meta.variety_plus ? 'On' : 'Off'}</div>
                        <div><strong>Model:</strong> ${meta.nai_model || 'N/A'}</div>
                        ${isPureNai ? '<div style="color:#4ade80; margin-top:8px;">✓ NAI 원본: 퀄리티 태그/UC 프리셋 자동 분리됨</div>' : ''}
                    `;
                    document.getElementById('dropModalConfirm').textContent = '전체 적용';
                    document.getElementById('dropModalPromptOnly').style.display = 'inline-block';
                    document.getElementById('dropModalSeedOnly').style.display = 'inline-block';
                    document.getElementById('dropModalAsVibe').style.display = 'inline-block';
                    pendingDropData = {
                        type: 'nai',
                        metadata: result.nai_metadata,  // 원본 저장 (적용 시 다시 정규화)
                        image: base64,
                        name: file.name
                    };
                    window._isPureNaiImage = isPureNai;
                } else {
                    // 일반 이미지 - 바이브로 추가 제안
                    document.getElementById('dropModalTitle').textContent = '📷 일반 이미지';
                    metadataDiv.innerHTML = '<div>메타데이터가 없습니다. 바이브로 추가할 수 있습니다.</div>';
                    document.getElementById('dropModalConfirm').textContent = '바이브에 추가';
                    pendingDropData = {
                        type: 'plain',
                        image: base64,
                        name: file.name
                    };
                }

                dropModal.classList.add('active');

            } catch (err) {
                showToast('메타데이터 추출 오류: ' + err.message, 'error');
            }
        });

        // 모달 닫기 헬퍼
        function closeDropModal() {
            dropModal.classList.remove('active');
            pendingDropData = null;
            window._pendingLoadMetadata = null;
            window._isPureNaiImage = false;
            document.getElementById('dropModalPreview').style.display = '';
            document.getElementById('dropModalPromptOnly').style.display = 'none';
            document.getElementById('dropModalSeedOnly').style.display = 'none';
            document.getElementById('dropModalAsVibe').style.display = 'none';
            document.getElementById('dropModalConfirm').textContent = '확인';
        }

        // 모달 버튼 이벤트
        document.getElementById('dropModalCancel').onclick = () => {
            closeDropModal();
        };

        // 프롬프트만 적용 버튼
        document.getElementById('dropModalPromptOnly').onclick = () => {
            const doApply = () => {
                if (window._pendingLoadMetadata) {
                    applyPromptOnly(window._pendingLoadMetadata);
                    closeDropModal();
                } else if (pendingDropData && pendingDropData.type === 'nai') {
                    // 정규화된 메타데이터로 applyPromptOnly 호출 (캐릭터 프롬프트 포함)
                    const normalized = normalizeMetadata(pendingDropData.metadata);
                    applyPromptOnly(normalized);
                    closeDropModal();
                }
            };

            // 순수 NAI 이미지면 경고 팝업 표시
            if (window._isPureNaiImage) {
                showPureNaiWarning(doApply);
            } else {
                doApply();
            }
        };

        // 시드만 적용 버튼
        document.getElementById('dropModalSeedOnly').onclick = () => {
            if (pendingDropData && pendingDropData.type === 'nai') {
                const meta = pendingDropData.metadata;
                if (meta.seed) {
                    document.getElementById('seed').value = meta.seed;
                    saveAppSettings();
                    showToast(`시드 ${meta.seed} 적용됨`, 'success');
                }
                closeDropModal();
            }
        };

        // 바이브로 추가 버튼
        document.getElementById('dropModalAsVibe').onclick = () => {
            if (pendingDropData && pendingDropData.image) {
                if (vibeList.length >= 16) {
                    showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                } else {
                    vibeList.push({
                        image: pendingDropData.image,
                        strength: 0.6,
                        info_extracted: 1.0,
                        name: pendingDropData.name
                    });
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    showToast('바이브에 추가됨', 'success');
                }
                closeDropModal();
            }
        };

        document.getElementById('dropModalConfirm').onclick = () => {
            // 설정 불러오기 처리
            if (window._pendingLoadMetadata) {
                const doApply = () => {
                    applyMetadataSettings(window._pendingLoadMetadata);
                    closeDropModal();
                };

                // 순수 NAI 이미지면 경고 팝업 표시
                if (window._isPureNaiImage) {
                    showPureNaiWarning(doApply);
                } else {
                    doApply();
                }
                return;
            }

            if (!pendingDropData) return;

            if (pendingDropData.type === 'vibe') {
                // 바이브 리스트에 추가 (캐시 데이터 포함)
                if (vibeList.length >= 16) {
                    showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                } else {
                    const vibeEntry = {
                        image: pendingDropData.image,
                        strength: pendingDropData.strength || 0.6,
                        info_extracted: pendingDropData.info_extracted || 1.0,
                        name: pendingDropData.name
                    };
                    // 캐시된 인코딩 데이터가 있으면 포함
                    if (pendingDropData.encoded) {
                        vibeEntry.encoded = pendingDropData.encoded;
                        vibeEntry.encoded_model = pendingDropData.encoded_model;
                        vibeEntry.encoded_info_extracted = pendingDropData.encoded_info_extracted || vibeEntry.info_extracted;  // 인코딩 시 사용된 값
                    }
                    vibeList.push(vibeEntry);
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    // Vibe Transfer 활성화
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    const msg = pendingDropData.encoded ? '바이브 추가됨 (캐시 사용)' : '바이브에 추가됨';
                    showToast(msg, 'success');
                }
            } else if (pendingDropData.type === 'nai') {
                // NAI 메타데이터 적용 - 정규화 후 applyMetadataSettings 사용
                const doApply = () => {
                    const normalized = normalizeMetadata(pendingDropData.metadata);
                    applyMetadataSettings(normalized);
                    closeDropModal();
                };

                // 순수 NAI 이미지면 경고 팝업 표시
                if (window._isPureNaiImage) {
                    showPureNaiWarning(doApply);
                    return;  // closeDropModal은 doApply 안에서 호출
                } else {
                    doApply();
                    return;
                }
            } else if (pendingDropData.type === 'plain') {
                // 일반 이미지를 바이브로 추가
                if (vibeList.length >= 16) {
                    showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                } else {
                    vibeList.push({
                        image: pendingDropData.image,
                        strength: 0.6,
                        info_extracted: 1.0,
                        name: pendingDropData.name
                    });
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    showToast('바이브에 추가됨', 'success');
                }
            }

            closeDropModal();
        };

        // ============================================================
        // Mask Editor & Base Image (Inpaint/Img2Img)
        // ============================================================

        // Base Image 데이터
        let baseImageData = {
            enabled: false,
            image: null,        // base64
            mask: null,         // base64 (white = inpaint area)
            mode: 'inpaint',    // 'inpaint' | 'img2img'
            strength: 0.7,
            noise: 0,
            width: 0,
            height: 0
        };

        // Mask Editor 상태
        const maskEditor = {
            isDrawing: false,
            tool: 'brush',  // 'brush' | 'eraser'
            brushSize: 30,
            imageCanvas: null,
            maskCanvas: null,
            drawCanvas: null,
            imageCtx: null,
            maskCtx: null,
            drawCtx: null,
            originalImage: null,
            scale: 1
        };

        // Mask Editor 열기
        function openMaskEditor(imageBase64, existingMask = null) {
            const modal = document.getElementById('maskEditorModal');
            const img = new Image();

            img.onload = () => {
                maskEditor.originalImage = img;

                // 캔버스 크기 계산 (최대 70vh, 95vw 내에서)
                const maxWidth = window.innerWidth * 0.9;
                const maxHeight = window.innerHeight * 0.65;
                let scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
                maskEditor.scale = scale;

                const canvasWidth = Math.round(img.width * scale);
                const canvasHeight = Math.round(img.height * scale);

                // 캔버스 초기화
                maskEditor.imageCanvas = document.getElementById('maskEditorImageCanvas');
                maskEditor.maskCanvas = document.getElementById('maskEditorMaskCanvas');
                maskEditor.drawCanvas = document.getElementById('maskEditorDrawCanvas');

                [maskEditor.imageCanvas, maskEditor.maskCanvas, maskEditor.drawCanvas].forEach(c => {
                    c.width = canvasWidth;
                    c.height = canvasHeight;
                    c.style.width = canvasWidth + 'px';
                    c.style.height = canvasHeight + 'px';
                });

                maskEditor.imageCtx = maskEditor.imageCanvas.getContext('2d');
                maskEditor.maskCtx = maskEditor.maskCanvas.getContext('2d');
                maskEditor.drawCtx = maskEditor.drawCanvas.getContext('2d');

                // 이미지 그리기
                maskEditor.imageCtx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

                // 기존 마스크 로드 또는 클리어 (검정 배경)
                maskEditor.maskCtx.fillStyle = 'black';
                maskEditor.maskCtx.fillRect(0, 0, canvasWidth, canvasHeight);
                if (existingMask) {
                    const maskImg = new Image();
                    maskImg.onload = () => {
                        maskEditor.maskCtx.drawImage(maskImg, 0, 0, canvasWidth, canvasHeight);
                    };
                    maskImg.src = existingMask;
                }

                // 설정 복원 (인페인트 모드 고정)
                document.getElementById('maskEditorStrength').value = baseImageData.strength;
                document.getElementById('maskEditorStrengthValue').textContent = baseImageData.strength;

                modal.classList.add('active');
            };

            img.src = imageBase64.startsWith('data:') ? imageBase64 : 'data:image/png;base64,' + imageBase64;
        }

        // Mask Editor 닫기
        function closeMaskEditor() {
            document.getElementById('maskEditorModal').classList.remove('active');
        }

        // 마스크 그리기 이벤트
        function setupMaskEditorEvents() {
            const drawCanvas = document.getElementById('maskEditorDrawCanvas');

            function getPos(e) {
                const rect = drawCanvas.getBoundingClientRect();
                const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
                const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
                return { x, y };
            }

            function draw(e) {
                if (!maskEditor.isDrawing) return;
                const pos = getPos(e);
                const ctx = maskEditor.maskCtx;
                const size = maskEditor.brushSize;

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size / 2, 0, Math.PI * 2);
                ctx.fillStyle = maskEditor.tool === 'brush' ? 'white' : 'black';
                ctx.fill();
            }

            // 브러시 커서 미리보기
            function drawCursor(e) {
                const pos = getPos(e);
                const ctx = maskEditor.drawCtx;
                const size = maskEditor.brushSize;

                // 이전 커서 지우기
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

                // 커서 원 그리기
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size / 2, 0, Math.PI * 2);
                ctx.strokeStyle = maskEditor.tool === 'brush' ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // 내부 점선 테두리 (대비용)
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size / 2, 0, Math.PI * 2);
                ctx.strokeStyle = maskEditor.tool === 'brush' ? 'rgba(0, 0, 0, 0.5)' : 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            function clearCursor() {
                maskEditor.drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            }

            drawCanvas.addEventListener('mousedown', (e) => {
                maskEditor.isDrawing = true;
                draw(e);
            });
            drawCanvas.addEventListener('mousemove', (e) => {
                draw(e);
                drawCursor(e);
            });
            drawCanvas.addEventListener('mouseup', () => maskEditor.isDrawing = false);
            drawCanvas.addEventListener('mouseleave', () => {
                maskEditor.isDrawing = false;
                clearCursor();
            });

            // Touch support
            drawCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                maskEditor.isDrawing = true;
                draw(e);
            });
            drawCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                draw(e);
            });
            drawCanvas.addEventListener('touchend', () => maskEditor.isDrawing = false);

            // 도구 버튼
            document.getElementById('maskToolBrush').onclick = () => {
                maskEditor.tool = 'brush';
                document.getElementById('maskToolBrush').classList.add('active');
                document.getElementById('maskToolEraser').classList.remove('active');
            };
            document.getElementById('maskToolEraser').onclick = () => {
                maskEditor.tool = 'eraser';
                document.getElementById('maskToolEraser').classList.add('active');
                document.getElementById('maskToolBrush').classList.remove('active');
            };

            // 브러시 크기
            document.getElementById('maskBrushSize').oninput = function() {
                maskEditor.brushSize = parseInt(this.value);
                document.getElementById('maskBrushSizeValue').textContent = this.value;
            };

            // Clear (검정으로 채우기 = 마스크 없음)
            document.getElementById('maskToolClear').onclick = () => {
                maskEditor.maskCtx.fillStyle = 'black';
                maskEditor.maskCtx.fillRect(0, 0, maskEditor.maskCanvas.width, maskEditor.maskCanvas.height);
            };

            // Invert (검정 ↔ 흰색 반전)
            document.getElementById('maskToolInvert').onclick = () => {
                const ctx = maskEditor.maskCtx;
                const imageData = ctx.getImageData(0, 0, maskEditor.maskCanvas.width, maskEditor.maskCanvas.height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];       // R
                    data[i + 1] = 255 - data[i + 1]; // G
                    data[i + 2] = 255 - data[i + 2]; // B
                    data[i + 3] = 255;             // A (항상 불투명)
                }
                ctx.putImageData(imageData, 0, 0);
            };

            // Strength slider
            document.getElementById('maskEditorStrength').oninput = function() {
                document.getElementById('maskEditorStrengthValue').textContent = this.value;
            };

            // Cancel
            document.getElementById('maskEditorCancel').onclick = closeMaskEditor;
            document.getElementById('maskEditorClose').onclick = closeMaskEditor;

            // Apply
            document.getElementById('maskEditorApply').onclick = () => {
                // 원본 크기로 마스크 생성
                const fullMaskCanvas = document.createElement('canvas');
                fullMaskCanvas.width = maskEditor.originalImage.width;
                fullMaskCanvas.height = maskEditor.originalImage.height;
                const fullCtx = fullMaskCanvas.getContext('2d');

                // 스케일 업
                fullCtx.drawImage(maskEditor.maskCanvas, 0, 0, fullMaskCanvas.width, fullMaskCanvas.height);

                // Base Image 데이터 설정
                baseImageData.enabled = true;
                baseImageData.image = maskEditor.imageCanvas.toDataURL('image/png').split(',')[1];

                // 원본 크기 이미지
                const fullImageCanvas = document.createElement('canvas');
                fullImageCanvas.width = maskEditor.originalImage.width;
                fullImageCanvas.height = maskEditor.originalImage.height;
                fullImageCanvas.getContext('2d').drawImage(maskEditor.originalImage, 0, 0);
                baseImageData.image = fullImageCanvas.toDataURL('image/png').split(',')[1];

                baseImageData.mask = fullMaskCanvas.toDataURL('image/png').split(',')[1];
                baseImageData.mode = 'inpaint';  // 마스크 에디터는 항상 인페인트
                baseImageData.strength = parseFloat(document.getElementById('maskEditorStrength').value);
                baseImageData.noise = 0;  // 인페인트는 noise 미사용
                baseImageData.width = maskEditor.originalImage.width;
                baseImageData.height = maskEditor.originalImage.height;

                // UI 업데이트
                updateBaseImageUI();
                closeMaskEditor();
                showToast('베이스 이미지로 등록됨', 'success');
            };
        }

        // Base Image UI 업데이트
        function updateBaseImageUI() {
            const section = document.getElementById('baseImageSection');
            const preview = document.getElementById('baseImageImg');
            const maskOverlay = document.getElementById('baseImageMaskOverlay');

            if (baseImageData.enabled && baseImageData.image) {
                section.style.display = 'block';
                preview.src = 'data:image/png;base64,' + baseImageData.image;

                if (baseImageData.mask) {
                    maskOverlay.style.backgroundImage = `url(data:image/png;base64,${baseImageData.mask})`;
                    maskOverlay.style.backgroundSize = 'contain';
                    maskOverlay.style.backgroundPosition = 'center';
                    maskOverlay.style.backgroundRepeat = 'no-repeat';
                } else {
                    maskOverlay.style.backgroundImage = 'none';
                }

                document.getElementById('baseImageMode').value = baseImageData.mode;
                document.getElementById('baseImageStrength').value = baseImageData.strength;
                document.getElementById('baseImageStrengthValue').textContent = baseImageData.strength;
                document.getElementById('baseImageNoise').value = baseImageData.noise;
                document.getElementById('baseImageNoiseValue').textContent = baseImageData.noise;
                updateBaseImageNoiseVisibility();

                // 사이즈 동기화
                document.getElementById('width').value = baseImageData.width;
                document.getElementById('height').value = baseImageData.height;
            } else {
                section.style.display = 'none';
            }
        }

        // Base Image 섹션 이벤트
        function setupBaseImageEvents() {
            // Clear 버튼
            document.getElementById('clearBaseImage').onclick = () => {
                baseImageData = {
                    enabled: false,
                    image: null,
                    mask: null,
                    mode: 'inpaint',
                    strength: 0.7,
                    noise: 0,
                    width: 0,
                    height: 0
                };
                updateBaseImageUI();
                showToast('Base Image 제거됨', 'success');
            };

            // Edit Mask 버튼
            document.getElementById('editMaskBtn').onclick = () => {
                if (baseImageData.image) {
                    openMaskEditor('data:image/png;base64,' + baseImageData.image,
                        baseImageData.mask ? 'data:image/png;base64,' + baseImageData.mask : null);
                }
            };

            // Sliders
            document.getElementById('baseImageStrength').oninput = function() {
                baseImageData.strength = parseFloat(this.value);
                document.getElementById('baseImageStrengthValue').textContent = this.value;
            };
            document.getElementById('baseImageNoise').oninput = function() {
                baseImageData.noise = parseFloat(this.value);
                document.getElementById('baseImageNoiseValue').textContent = this.value;
            };
            document.getElementById('baseImageMode').onchange = function() {
                baseImageData.mode = this.value;
                updateBaseImageNoiseVisibility();
            };
        }

        // Noise 슬라이더 가시성 업데이트 (인페인트는 noise 없음)
        function updateBaseImageNoiseVisibility() {
            const noiseContainer = document.getElementById('baseImageNoiseContainer');
            const mode = document.getElementById('baseImageMode').value;
            noiseContainer.style.display = mode === 'inpaint' ? 'none' : 'block';
        }

        // Inpaint용 이미지 설정 함수 (외부에서 호출)
        function setBaseImageForInpaint(imageBase64) {
            // 슬롯 모드로 전환 (생성은 슬롯 모드에서만 가능)
            if (currentMode !== 'slot') {
                document.getElementById('slotModeBtn').click();
            }
            openMaskEditor(imageBase64);
        }

        // 초기화
        setupMaskEditorEvents();
        setupBaseImageEvents();
        updateBaseImageNoiseVisibility();
        updateProviderLabels();

        // ============================================================
        // Censor Mode
        // ============================================================
        const censorGrid = document.getElementById('censorGrid');
        const censorEmpty = document.getElementById('censorEmpty');
        let censorImages = []; // [{filename, path, status: 'pending'|'ok'|'warning', edited: false}]
        let currentCensorIndex = 0;

        // 폴더 목록 로드
        async function loadCensorFolders() {
            const sourceSelect = document.getElementById('censorSourceFolder');
            const outputSelect = document.getElementById('censorOutputFolder');

            // outputs 폴더 목록 로드
            try {
                const response = await fetch(`${API_BASE}/api/output-folders`);
                const result = await response.json();
                if (result.folders) {
                    sourceSelect.innerHTML = '<option value="">📂 outputs</option>';
                    result.folders.forEach(folder => {
                        sourceSelect.innerHTML += `<option value="${folder}">📁 ${folder}</option>`;
                    });
                }
            } catch (err) {
                console.error('Failed to load output folders:', err);
            }

            // censored 폴더 옵션 (기본값)
            outputSelect.innerHTML = `
                <option value="censored">📁 censored</option>
                <option value="censored_ok">📁 censored_ok</option>
            `;
        }

        // 이미지 그리드 렌더링
        function renderCensorGrid() {
            censorGrid.innerHTML = '';
            if (censorImages.length === 0) {
                censorEmpty.style.display = 'flex';
                censorGrid.style.display = 'none';
                return;
            }

            censorEmpty.style.display = 'none';
            censorGrid.style.display = 'grid';

            censorImages.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = `censor-grid-item status-${img.status}`;
                item.innerHTML = `
                    <img src="${API_BASE}/api/image?path=${encodeURIComponent(img.path)}" alt="">
                    ${img.status !== 'pending' ? `<span class="status-badge ${img.status}">${img.status === 'ok' ? '✓ OK' : '⚠️'}</span>` : ''}
                    <div class="filename">${img.filename}</div>
                `;
                item.onclick = () => openCensorEditor(index);
                censorGrid.appendChild(item);
            });

            updateCensorStats();
        }

        // 통계 업데이트
        function updateCensorStats() {
            document.getElementById('censorOkCount').textContent = censorImages.filter(i => i.status === 'ok').length;
            document.getElementById('censorWarningCount').textContent = censorImages.filter(i => i.status === 'warning').length;
            document.getElementById('censorTotalCount').textContent = censorImages.length;
        }

        // Quick Editor 열기
        function openCensorEditor(index) {
            currentCensorIndex = index;
            const modal = document.getElementById('censorEditorModal');
            modal.classList.add('active');
            updateCensorEditorUI();
            // TODO: 캔버스에 이미지 로드
        }

        // Quick Editor 닫기
        function closeCensorEditor() {
            document.getElementById('censorEditorModal').classList.remove('active');
        }

        // Editor UI 업데이트
        function updateCensorEditorUI() {
            document.getElementById('censorImageCounter').textContent = `${currentCensorIndex + 1} / ${censorImages.length}`;
        }

        // 자동 검열 실행 (스텁)
        document.getElementById('runAutoCensorBtn').onclick = async () => {
            const sourceFolder = document.getElementById('censorSourceFolder').value;
            showToast('자동 검열 기능은 아직 구현되지 않았습니다', 'warning');

            // TODO: 백엔드 API 호출하여 이미지 목록 가져오기
            // 현재는 데모용 빈 목록
            censorImages = [];
            renderCensorGrid();
        };

        // 승인된 이미지 내보내기 (스텁)
        document.getElementById('exportApprovedBtn').onclick = () => {
            const okCount = censorImages.filter(i => i.status === 'ok').length;
            if (okCount === 0) {
                showToast('내보낼 이미지가 없습니다', 'warning');
                return;
            }
            showToast('내보내기 기능은 아직 구현되지 않았습니다', 'warning');
        };

        // Quick Editor 버튼들
        document.getElementById('censorEditorClose').onclick = closeCensorEditor;
        document.getElementById('censorPrevBtn').onclick = () => {
            if (currentCensorIndex > 0) {
                currentCensorIndex--;
                updateCensorEditorUI();
            }
        };
        document.getElementById('censorNextBtn').onclick = () => {
            if (currentCensorIndex < censorImages.length - 1) {
                currentCensorIndex++;
                updateCensorEditorUI();
            }
        };
        document.getElementById('censorSkipBtn').onclick = () => {
            if (currentCensorIndex < censorImages.length - 1) {
                currentCensorIndex++;
                updateCensorEditorUI();
            } else {
                closeCensorEditor();
            }
        };
        document.getElementById('censorSaveNextBtn').onclick = () => {
            // TODO: 현재 이미지 저장
            censorImages[currentCensorIndex].status = 'ok';
            censorImages[currentCensorIndex].edited = true;
            if (currentCensorIndex < censorImages.length - 1) {
                currentCensorIndex++;
                updateCensorEditorUI();
            } else {
                closeCensorEditor();
                renderCensorGrid();
            }
        };
        document.getElementById('censorMarkOk').onclick = () => {
            censorImages[currentCensorIndex].status = 'ok';
            renderCensorGrid();
        };
        document.getElementById('censorMarkNeed').onclick = () => {
            censorImages[currentCensorIndex].status = 'warning';
            renderCensorGrid();
        };

        // Tool 버튼들 (스텁)
        const censorToolBtns = ['censorToolRect', 'censorToolBrush', 'censorToolMove'];
        censorToolBtns.forEach(id => {
            document.getElementById(id).onclick = function() {
                censorToolBtns.forEach(bid => document.getElementById(bid).classList.remove('active'));
                this.classList.add('active');
            };
        });

        const censorFillBtns = ['censorFillBlack', 'censorFillWhite', 'censorFillMosaic'];
        censorFillBtns.forEach(id => {
            document.getElementById(id).onclick = function() {
                censorFillBtns.forEach(bid => document.getElementById(bid).classList.remove('active'));
                this.classList.add('active');
            };
        });

        document.getElementById('censorBrushSize').oninput = function() {
            document.getElementById('censorBrushSizeValue').textContent = this.value;
        };

        document.getElementById('censorToolUndo').onclick = () => {
            showToast('Undo 기능은 아직 구현되지 않았습니다', 'warning');
        };
        document.getElementById('censorToolClear').onclick = () => {
            showToast('Clear 기능은 아직 구현되지 않았습니다', 'warning');
        };
    </script>
</body>
</html>
