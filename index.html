<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PeroPix</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        :root {
            /* Background - Deep Navy */
            --bg: #0C1219;
            --bg-light: #141C26;
            --bg-lighter: #1C2530;
            /* Accent - Navy Blue */
            --accent: #4A7AB8;
            --accent-hover: #5B98D4;
            --accent-dim: #2D4A6F;
            /* Accent - Gold (CTA, 강조) */
            --accent-gold: #F5B942;
            --accent-gold-hover: #FFD06A;
            --accent-gold-dim: #9A7A35;
            /* Text */
            --text: #FFFFFF;
            --text-dim: #7A8BA0;
            /* Border */
            --border: #243044;
            /* Semantic */
            --success: #4CAF82;
            --error: #E57373;
            --warning: #F5B942;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
        }
        
        /* Layout */
        .app {
            display: flex;
            height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width, 540px);
            min-width: 360px;
            max-width: 800px;
            background: var(--bg-light);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
        }

        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.active {
            opacity: 1;
            background: var(--accent-gold-dim);
        }
        
        .sidebar-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .logo {
            font-size: 1.8rem;
            font-weight: 700;
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }
        .logo img {
            vertical-align: bottom;
        }
        
        .settings-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .settings-btn:hover {
            background: var(--bg-lighter);
            color: var(--text);
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }

        .sidebar-content::-webkit-scrollbar {
            width: 8px;
        }
        .sidebar-content::-webkit-scrollbar-track {
            background: transparent;
        }
        .sidebar-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        .sidebar-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
        }
        
        /* Sections */
        .section {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }
        
        .section:last-child,
        .sidebar-content > .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .section-title {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
        }
        
        .section-title .section-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: none;
            letter-spacing: 0;
            color: var(--text);
            cursor: pointer;
        }
        
        .section-title .section-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            cursor: pointer;
        }
        
        /* Form */
        label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 4px;
            color: var(--text);
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 0.9rem;
            margin-bottom: 12px;
            transition: border-color 0.2s;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        textarea {
            resize: vertical;
            min-height: 70px;
            font-family: inherit;
        }

        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-track {
            background: transparent;
        }
        textarea::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        textarea::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        
        .size-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .size-preset {
            flex: 1;
        }

        .size-inputs {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .size-inputs input {
            flex: 1;
            min-width: 0;
            text-align: center;
            padding: 10px 8px;
        }

        .size-x {
            color: var(--text-dim);
            font-size: 0.85rem;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }
        
        .tab {
            flex: 1;
            padding: 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-dim);
            cursor: pointer;
            text-align: center;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .tab:hover:not(.active) {
            border-color: var(--accent);
        }
        
        .provider-section { display: none; }
        .provider-section.active { 
            display: block;
            padding-bottom: 16px;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }
        .provider-section .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        /* Checkbox */
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .checkbox-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin: 0;
            accent-color: var(--accent);
        }
        
        .checkbox-row label {
            margin: 0;
            color: var(--text);
            font-size: 0.9rem;
        }
        
        /* Characters */
        .characters-section {
            margin: 12px 0;
        }
        
        .characters-header {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 8px;
        }

        .characters-header label {
            color: var(--text-dim);
            font-size: 0.85rem;
            flex: 1;
        }
        
        .add-char-btn {
            background: var(--accent);
            border: none;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .add-char-btn:hover {
            background: var(--accent-hover);
        }
        
        .add-char-btn:disabled {
            background: var(--bg-lighter);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .characters-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .character-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: var(--bg);
            border-radius: 6px;
            padding: 6px 8px;
        }
        
        .character-item-header {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .character-item .char-num {
            color: var(--accent-gold);
            font-size: 0.75rem;
            font-weight: bold;
            font-family: monospace;
            min-width: 18px;
        }
        
        .character-item .char-label {
            flex: 1;
            color: var(--text-dim);
            font-size: 0.75rem;
        }
        
        .character-item .prompt-preset-btn {
            padding: 1px 4px;
            font-size: 0.65rem;
        }
        
        .character-item textarea {
            width: 100%;
            min-height: 40px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 6px;
            color: var(--text);
            font-size: 0.85rem;
            font-family: inherit;
            resize: vertical;
        }
        
        .character-item textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .character-item .delete-char-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 0.9rem;
            opacity: 0.5;
        }
        
        .character-item .delete-char-btn:hover {
            opacity: 1;
            color: var(--error);
        }
        
        /* Prompt Preset Dropdown */
        .prompt-label-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .prompt-label-left {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mode-toggle {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            line-height: 1;
        }

        .mode-toggle:hover {
            border-color: var(--accent);
            background: var(--bg);
        }

        .mode-toggle.furry {
            background: var(--bg);
            border-color: var(--accent);
        }

        /* Collapsible prompts */
        .collapse-toggle {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        .collapse-toggle:hover {
            color: var(--text);
        }
        .collapse-toggle.collapsed {
            transform: rotate(-90deg);
        }
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
        }
        .collapsible-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            margin: 0;
            padding: 0;
        }
        /* Characters 섹션만 드롭다운이 밖으로 나올 수 있도록 */
        #charactersContent:not(.collapsed) {
            overflow: visible;
        }

        .prompt-preset-dropdown {
            position: relative;
        }
        
        .prompt-preset-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .prompt-preset-btn:hover {
            background: var(--bg-light);
            border-color: var(--text-dim);
        }
        
        .prompt-preset-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            min-width: 200px;
            max-width: 280px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 100;
            overflow: hidden;
        }
        
        .prompt-preset-menu.show {
            display: block;
        }
        
        .prompt-preset-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .prompt-preset-item {
            padding: 6px 10px;
            border-bottom: 1px solid var(--border);
        }
        
        .prompt-preset-item:last-child {
            border-bottom: none;
        }
        
        .prompt-preset-item-name {
            font-size: 0.85rem;
            color: var(--text);
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .prompt-preset-item-actions {
            display: flex;
            gap: 4px;
        }
        
        .prompt-preset-item-actions button {
            flex: 1;
            padding: 3px 8px;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            background: var(--bg);
            color: var(--text);
        }
        
        .prompt-preset-item-actions button:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .prompt-preset-item-actions .delete-btn {
            flex: 0;
            padding: 3px 6px;
            color: var(--text-dim);
        }
        
        .prompt-preset-item-actions .delete-btn:hover {
            background: var(--error);
            border-color: var(--error);
            color: white;
        }
        
        .prompt-preset-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
        }
        
        .prompt-preset-save-btn {
            width: 100%;
            padding: 6px 10px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        .prompt-preset-save-btn:hover {
            background: var(--bg);
            border-color: var(--text-dim);
        }
        
        .prompt-preset-empty {
            padding: 12px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.8rem;
        }
        
        /* LoRA */
        .lora-list {
            max-height: 120px;
            overflow-y: auto;
        }
        
        .lora-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: var(--bg);
            border-radius: 6px;
            margin-bottom: 4px;
        }
        
        .lora-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
        }
        
        .lora-item .lora-name {
            flex: 1;
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .lora-item input[type="number"] {
            width: 55px;
            padding: 4px 6px;
            margin: 0;
            font-size: 0.8rem;
        }

        /* Vibe Transfer */
        .vibe-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .vibe-item {
            background: var(--bg);
            border-radius: 8px;
            padding: 10px;
        }

        .vibe-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .vibe-item-header img {
            width: 48px;
            height: 48px;
            object-fit: cover;
            border-radius: 6px;
        }

        .vibe-item-header .vibe-info {
            flex: 1;
            font-size: 0.8rem;
            color: var(--text-dim);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .vibe-item-header .remove-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255,100,100,0.2);
            color: var(--error);
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }

        .vibe-item-header .remove-btn:hover {
            background: rgba(255,100,100,0.4);
        }

        .vibe-sliders {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .vibe-slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
        }

        .vibe-slider-row label {
            width: 70px;
            color: var(--text-dim);
        }

        .vibe-slider-row input[type="range"] {
            flex: 1;
        }

        .vibe-slider-row .value {
            width: 35px;
            text-align: right;
            color: var(--text);
        }

        /* Character Reference */
        .char-ref-preview {
            position: relative;
            margin-bottom: 8px;
            text-align: center;
        }

        .char-ref-preview img {
            max-width: 100%;
            max-height: 150px;
            border-radius: 8px;
            object-fit: contain;
        }

        .char-ref-preview .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(0,0,0,0.7);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }

        .char-ref-preview .remove-btn:hover {
            background: rgba(255,100,100,0.8);
        }

        /* Anlas Info - Single line */
        .anlas-info {
            display: flex;
            align-items: center;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 6px;
            gap: 5px;
        }

        .anlas-info .anlas-icon { font-size: 0.8rem; }
        .anlas-info #anlasBalance { font-weight: 600; color: var(--text); }
        .anlas-info .anlas-separator { opacity: 0.3; margin: 0 2px; }
        .anlas-info .anlas-cost-label { opacity: 0.7; }
        .anlas-info #anlasCost { color: var(--accent-gold); font-weight: 600; }

        .anlas-refresh {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 0.7rem;
            padding: 0 2px;
            opacity: 0.6;
        }
        .anlas-refresh:hover { opacity: 1; color: var(--text); }

        .free-tag {
            background: #22c55e;
            color: white;
            font-size: 0.75rem;
            font-weight: 700;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 4px;
        }

        /* Button */
        .btn {
            width: 100%;
            padding: 14px;
            background: var(--accent);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .btn:hover { background: var(--accent-hover); }
        .btn:disabled { background: var(--border); cursor: not-allowed; }
        .btn:active { transform: scale(0.98); }

        /* Queue button - Gold accent */
        #generateBtn { background: var(--accent-gold); color: #1a1a2e; }
        #generateBtn:hover { background: var(--accent-gold-hover); }

        .btn-secondary {
            background: var(--bg);
            border: 1px solid var(--border);
            margin-top: 8px;
        }

        .btn-secondary:hover { background: var(--bg-lighter); }

        /* Inline button row (for vibe buttons, etc.) */
        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .btn-row .btn {
            width: auto;
            margin-top: 0;
            padding: 10px 16px;
        }
        .btn-row .btn-icon {
            padding: 10px 12px;
            flex-shrink: 0;
        }
        
        /* Main Area */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Slots Layout */
        .slots-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            color: var(--text-dim);
            font-size: 0.9rem;
            flex-shrink: 0;
            overflow: visible;
            gap: 12px;
            position: relative;
            z-index: 100;
        }
        .slots-header::-webkit-scrollbar {
            height: 6px;
        }
        .slots-header::-webkit-scrollbar-track {
            background: transparent;
        }
        .slots-header::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }
        .slots-header::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }
        
        .add-slot-btn {
            background: var(--accent);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.3rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .add-slot-btn:hover {
            background: var(--accent-hover);
        }
        
        .header-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-dim);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .header-btn:hover {
            background: var(--bg-light);
            border-color: var(--text-dim);
        }
        
        .header-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        /* Prefix Input */
        .prefix-input-wrapper {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
        }
        
        .prefix-label {
            color: var(--text-dim);
            font-size: 0.8rem;
        }
        
        .prefix-input {
            width: 60px;
            background: transparent;
            border: none;
            padding: 0;
            margin: 0;
            font-size: 0.8rem;
            color: var(--text);
        }
        
        .prefix-input:focus {
            outline: none;
        }
        
        /* Preset Dropdown */
        .preset-dropdown {
            position: relative;
        }
        
        .preset-btn {
            min-width: 120px;
        }
        
        .preset-btn .preset-name {
            flex: 1;
            text-align: left;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .preset-btn .dropdown-arrow {
            font-size: 0.6rem;
            margin-left: 4px;
        }
        
        .preset-menu {
            display: none;
            position: fixed;
            min-width: 220px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 99999;
            overflow: hidden;
        }
        
        .preset-menu.show {
            display: block;
        }
        
        .preset-list {
            max-height: 250px;
            overflow-y: auto;
        }
        
        .preset-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.15s;
            gap: 8px;
        }
        
        .preset-item:hover {
            background: var(--bg-lighter);
        }
        
        .preset-item.selected {
            background: var(--accent);
            color: white;
        }
        
        .preset-item .check {
            width: 16px;
            font-size: 0.8rem;
        }
        
        .preset-item .label {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .preset-item .edit-btn,
        .preset-item .delete-btn {
            background: none;
            border: none;
            padding: 2px 4px;
            cursor: pointer;
            opacity: 0.5;
            font-size: 0.85rem;
            border-radius: 4px;
        }
        
        .preset-item .edit-btn:hover,
        .preset-item .delete-btn:hover {
            opacity: 1;
            background: var(--bg);
        }
        
        .preset-item.selected .edit-btn:hover,
        .preset-item.selected .delete-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .preset-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .preset-action-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.85rem;
            cursor: pointer;
            text-align: left;
            transition: all 0.15s;
        }
        
        .preset-action-btn:hover {
            background: var(--bg);
            border-color: var(--text-dim);
        }
        
        .preset-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.85rem;
        }
        
        .slots-container-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .slots-container-wrapper::before,
        .slots-container-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 40px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .slots-container-wrapper::before {
            left: 0;
            background: linear-gradient(to right, var(--bg) 0%, transparent 100%);
        }
        
        .slots-container-wrapper::after {
            right: 0;
            background: linear-gradient(to left, var(--bg) 0%, transparent 100%);
        }
        
        .slots-container-wrapper.can-scroll-left::before {
            opacity: 1;
        }
        
        .slots-container-wrapper.can-scroll-right::after {
            opacity: 1;
        }
        
        .slots-container {
            height: 100%;
            display: flex;
            gap: 16px;
            padding: 16px;
            overflow-x: auto;
            overflow-y: hidden;
            align-items: stretch;
            user-select: none;
        }
        
        .slots-container::-webkit-scrollbar {
            height: 8px;
        }
        
        .slots-container::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        
        .slots-container::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }
        
        .slot {
            width: var(--slot-width, 280px);
            min-width: 150px;
            max-width: 1200px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            overflow: visible;  /* 리사이즈 핸들이 바깥에 표시되도록 */
            flex-shrink: 0;
            transition: box-shadow 0.2s;
            position: relative;
        }

        /* 슬롯 리사이즈 핸들 (오른쪽만) */
        .slot-resize-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
            right: -8px;
            border-radius: 0 10px 10px 0;
        }

        .slot-resize-handle:hover,
        .slot-resize-handle.active {
            opacity: 1;
            background: var(--accent-gold-dim);
        }

        body.resizing-slot {
            cursor: ew-resize !important;
            user-select: none !important;
        }

        body.resizing-slot * {
            cursor: ew-resize !important;
        }
        
        /* input, textarea는 선택 가능 */
        .slot input, .slot textarea {
            user-select: text;
        }
        
        .slot.dragging {
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            opacity: 0.9;
        }
        
        .slot-placeholder {
            background: var(--bg-lighter);
            border: 2px dashed var(--border);
            border-radius: 10px;
            flex-shrink: 0;
        }
        
        .slot-prompt {
            flex-shrink: 0;
            border-bottom: 1px solid var(--border);
        }
        
        .slot-prompt-header {
            display: flex;
            align-items: center;
            background: var(--bg-lighter);
            padding: 6px 8px;
            gap: 6px;
        }
        
        .slot-number {
            font-size: 0.75rem;
            color: var(--accent-gold);
            font-weight: bold;
            font-family: monospace;
            background: var(--bg);
            padding: 2px 6px;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .slot-prompt-header input {
            flex: 1;
            background: transparent;
            border: none;
            padding: 4px;
            margin: 0;
            font-size: 0.85rem;
            color: var(--text);
            min-width: 0;
        }
        
        .slot-prompt-header input::placeholder {
            color: var(--text-dim);
        }
        
        .slot-prompt-header input:focus {
            outline: none;
        }
        
        .slot-drag {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: grab;
            padding: 2px 4px;
            font-size: 0.9rem;
            line-height: 1;
            border-radius: 4px;
        }
        
        .slot-drag:hover {
            background: var(--bg);
            color: var(--text);
        }
        
        .slot-drag:active {
            cursor: grabbing;
        }
        
        .slot-delete {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 1.1rem;
            line-height: 1;
            border-radius: 4px;
        }
        
        .slot-delete:hover {
            background: var(--error);
            color: white;
        }
        
        .slot-prompt textarea {
            width: 100%;
            border: none;
            background: var(--bg-light);
            padding: 10px;
            margin: 0;
            min-height: 70px;
            resize: vertical;
            font-size: 0.85rem;
            color: var(--text);
        }
        
        .slot-prompt textarea:focus {
            outline: none;
        }
        
        .slot-images {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .slot-images::-webkit-scrollbar {
            width: 5px;
        }
        
        .slot-images::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }
        
        .slot-image-card {
            position: relative;
            background: var(--bg);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            transition: border-color 0.2s;
            flex-shrink: 0;
        }
        
        .slot-image-card:hover {
            border-color: var(--accent);
        }
        
        .slot-image-card img {
            width: 100%;
            height: auto;
            cursor: pointer;
            display: block;
            user-select: none;
            -webkit-user-drag: none;
        }
        
        .slot-image-card .info {
            padding: 6px 8px;
            font-size: 0.7rem;
        }
        
        .slot-image-card .filename {
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .slot-image-card .seed {
            color: var(--text-dim);
            margin-top: 2px;
        }
        
        .slot-empty {
            color: var(--text-dim);
            font-size: 0.8rem;
            text-align: center;
            padding: 20px 10px;
        }
        
        .progress-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-lighter);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s;
        }
        
        .status-text {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        
        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-dim);
            text-align: center;
        }
        
        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        
        .empty-state p {
            font-size: 1.1rem;
            margin-bottom: 8px;
        }
        
        .empty-state small {
            opacity: 0.7;
        }
        
        /* Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .lightbox.active { display: flex; }
        
        .lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
        }
        
        .lightbox .close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 2.5rem;
            color: white;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .lightbox .close:hover { opacity: 1; }

        /* Drop Overlay */
        .drop-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(59, 130, 246, 0.15);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            border: 4px dashed var(--accent);
            pointer-events: none;
        }
        .drop-overlay.active { display: flex; }
        .drop-overlay-content {
            background: var(--bg-light);
            padding: 40px 60px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        .drop-overlay-content .icon { font-size: 48px; margin-bottom: 16px; }
        .drop-overlay-content h3 { margin: 0 0 8px 0; font-size: 1.5rem; }
        .drop-overlay-content p { margin: 0; color: var(--text-dim); }

        /* Drop Confirm Modal */
        .drop-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .drop-modal.active { display: flex; }
        .drop-modal-content {
            background: var(--bg-light);
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
        }
        .drop-modal-content h3 { margin: 0 0 16px 0; }
        .drop-modal-content .preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        .drop-modal-content .metadata {
            background: var(--bg);
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            margin-bottom: 16px;
            max-height: 200px;
            overflow-y: auto;
        }
        .drop-modal-content .metadata::-webkit-scrollbar {
            width: 8px;
        }
        .drop-modal-content .metadata::-webkit-scrollbar-track {
            background: transparent;
        }
        .drop-modal-content .metadata::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        .drop-modal-content .metadata::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }
        .drop-modal-content .metadata div { margin-bottom: 4px; }
        .drop-modal-content .buttons { display: flex; gap: 12px; justify-content: flex-end; }
        .drop-modal-content .buttons .btn {
            width: auto;
            flex: 1;
            padding: 10px 16px;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: var(--bg);
            border-radius: 10px;
            padding: 4px;
            gap: 4px;
            border: 1px solid var(--border);
        }
        .mode-btn {
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .mode-btn:hover {
            color: var(--text);
            background: var(--bg-light);
        }
        .mode-btn.active {
            background: var(--accent);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Gallery */
        .gallery-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            overflow: hidden;
        }
        .gallery-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
            flex-shrink: 0;
            gap: 12px;
        }
        .gallery-folders {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            flex: 1;
            overflow-x: auto;
        }
        .folder-tab {
            padding: 6px 12px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .folder-tab:hover {
            background: var(--bg-lighter);
        }
        .folder-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        .folder-tab.drag-over {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: black;
        }
        .gallery-header-buttons {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }
        .add-folder-btn {
            width: 32px;
            height: 32px;
            padding: 0;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
        }
        .add-folder-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .gallery-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
        }
        .gallery-content::-webkit-scrollbar {
            width: 8px;
        }
        .gallery-content::-webkit-scrollbar-track {
            background: transparent;
        }
        .gallery-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        .gallery-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }
        .gallery-folder-btn {
            padding: 6px 10px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }
        .gallery-folder-btn:hover {
            background: var(--bg-lighter);
            border-color: var(--accent-gold);
        }
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 20px;
            width: 100%;
            align-items: start;
            align-content: start;
            padding-bottom: 8px;
        }
        .gallery-item {
            background: var(--bg-light);
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            height: fit-content;
            position: relative;
            max-width: 520px;
        }
        .gallery-item:hover {
            transform: translateY(-4px);
            z-index: 1;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        .gallery-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .gallery-item img {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            display: block;
        }
        .gallery-item-info {
            padding: 12px;
        }
        .gallery-item-info .filename-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }
        .gallery-item-info .filename {
            font-size: 0.85rem;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }
        .gallery-item-info .filename-input {
            flex: 1;
            min-width: 0;
            font-size: 0.85rem;
            padding: 2px 6px;
            border: 1px solid var(--accent-gold);
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
        }
        .gallery-item-info .rename-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .gallery-item-info .rename-btn:hover {
            opacity: 1;
        }
        .gallery-item-info .seed {
            font-size: 0.75rem;
            color: var(--text-dim);
        }
        .gallery-item-actions {
            display: flex;
            gap: 8px;
            padding: 8px 12px 12px;
        }
        .gallery-item-actions button {
            flex: 1;
            padding: 6px 8px;
            font-size: 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
        }
        .gallery-item-actions button:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }
        .gallery-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            min-height: 300px;
            color: var(--text-dim);
            text-align: center;
        }
        .gallery-empty .icon { font-size: 64px; margin-bottom: 16px; opacity: 0.5; }
        .gallery-empty p { margin: 0 0 8px 0; font-size: 1.1rem; }
        .gallery-empty small { opacity: 0.7; }

        /* Slot image save button */
        .slot-image-card .save-gallery-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 14px;
        }
        .slot-image-card:hover .save-gallery-btn { opacity: 1; }
        .slot-image-card .save-gallery-btn:hover { background: rgba(0,0,0,0.9); opacity: 1; }
        .slot-image-card .save-gallery-btn.saved { color: gold; opacity: 1; }

        /* Info row layout */
        .slot-image-card .info-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .slot-image-card .info-row .filename {
            flex: 1;
            min-width: 0;
        }

        /* Load settings button */
        .slot-image-card .load-settings-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        .slot-image-card .load-settings-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Settings Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 900;
            justify-content: center;
            align-items: center;
        }
        
        .modal.active { display: flex; }
        
        .modal-content {
            background: var(--bg-light);
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-header h2 {
            font-size: 1.25rem;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .input-group {
            margin-bottom: 16px;
        }
        
        .input-group label {
            margin-bottom: 6px;
        }
        
        .input-group small {
            display: block;
            margin-top: -8px;
            margin-bottom: 12px;
            color: var(--text-dim);
            font-size: 0.8rem;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .status-badge.success {
            background: rgba(34, 197, 94, 0.2);
            color: var(--success);
        }
        
        .status-badge.warning {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }
        
        /* Local Environment */
        .local-env-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border-radius: 6px;
            margin-top: 6px;
        }
        
        .local-env-status .status-icon {
            font-size: 1.2rem;
        }
        
        .local-env-status.installed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }
        
        .local-env-status.not-installed {
            background: rgba(245, 158, 11, 0.15);
            color: var(--warning);
        }
        
        .local-env-status.installing {
            background: rgba(111, 41, 222, 0.15);
            color: var(--accent);
        }
        
        .local-env-status.error {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }
        
        .local-env-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }
        
        .local-env-progress-bar {
            flex: 1;
            height: 8px;
            background: var(--bg-lighter);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .local-env-progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .local-env-progress-text {
            font-size: 0.8rem;
            color: var(--text-dim);
            min-width: 40px;
        }
        
        #localEnvActions .btn {
            margin-right: 8px;
        }
        
        #localEnvActions .btn-danger {
            background: rgba(239, 68, 68, 0.2);
            color: var(--error);
        }
        
        #localEnvActions .btn-danger:hover {
            background: rgba(239, 68, 68, 0.3);
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            padding: 12px 24px;
            border-radius: 8px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1100;
        }
        
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .toast.success { border-color: var(--success); }
        .toast.error { border-color: var(--error); }
        .toast.warning { border-color: var(--warning); }
    </style>
</head>
<body>
    <div class="app">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="logo"><img src="assets/icon.png" alt="" style="width: 42px; height: 42px;"> PeroPix</div>
                <button class="settings-btn" onclick="openSettings()">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                </button>
            </div>
            
            <div class="sidebar-content">
                <!-- Provider Tabs -->
                <div class="section">
                    <div class="tabs">
                        <div class="tab active" data-provider="nai">NAI</div>
                        <div class="tab" data-provider="local">Local</div>
                    </div>
                </div>
                
                <!-- Prompts -->
                <div class="section">
                    <div class="prompt-label-row">
                        <div class="prompt-label-left">
                            <button type="button" class="collapse-toggle" data-target="basePromptContent" title="접기/펼치기">▼</button>
                            <button type="button" id="modeToggle" class="mode-toggle" title="아니메 모드">🌸</button>
                            <label for="basePrompt">Base Prompt</label>
                        </div>
                        <div class="prompt-preset-dropdown" data-category="base">
                            <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">📁 ▼</button>
                            <div class="prompt-preset-menu">
                                <div class="prompt-preset-list"></div>
                                <div class="prompt-preset-actions">
                                    <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="basePromptContent" class="collapsible-content">
                        <textarea id="basePrompt" placeholder="1girl, solo, masterpiece..."></textarea>
                    </div>

                    <!-- Characters -->
                    <div class="characters-section">
                        <div class="characters-header">
                            <button type="button" class="collapse-toggle" data-target="charactersContent" title="접기/펼치기">▼</button>
                            <label>Characters</label>
                            <button type="button" class="add-char-btn" id="addCharBtn" title="캐릭터 추가">+</button>
                        </div>
                        <div id="charactersContent" class="collapsible-content">
                            <div class="characters-list" id="charactersList">
                                <!-- 캐릭터들이 여기에 추가됨 -->
                            </div>
                        </div>
                    </div>

                    <div class="prompt-label-row">
                        <div class="prompt-label-left">
                            <button type="button" class="collapse-toggle" data-target="negativePromptContent" title="접기/펼치기">▼</button>
                            <label for="negativePrompt">Negative Prompt</label>
                        </div>
                        <div class="prompt-preset-dropdown" data-category="negative">
                            <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">📁 ▼</button>
                            <div class="prompt-preset-menu">
                                <div class="prompt-preset-list"></div>
                                <div class="prompt-preset-actions">
                                    <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="negativePromptContent" class="collapsible-content">
                        <textarea id="negativePrompt" rows="2" placeholder="lowres, bad quality..."></textarea>
                    </div>
                </div>
                
                <!-- NAI Settings -->
                <div class="provider-section active" data-provider="nai">
                    <div class="section">
                        <div class="section-title">
                            <button type="button" class="collapse-toggle" data-target="naiSettingsContent" title="접기/펼치기">▼</button>
                            <span>NAI Settings</span>
                        </div>
                        <div id="naiSettingsContent" class="collapsible-content">
                            <label>Model</label>
                            <select id="naiModel">
                                <option value="nai-diffusion-4-5-full">V4.5 Full</option>
                                <option value="nai-diffusion-4-curated-preview">V4 Curated</option>
                                <option value="nai-diffusion-3">V3</option>
                            </select>

                            <div class="row">
                                <div>
                                    <label>UC Preset</label>
                                    <select id="ucPreset">
                                        <option value="Heavy">Heavy</option>
                                        <option value="Light">Light</option>
                                        <option value="Human Focus">Human Focus</option>
                                        <option value="Furry Focus">Furry Focus</option>
                                        <option value="None">None</option>
                                    </select>
                                </div>
                                <div>
                                    <label>SMEA</label>
                                    <select id="smea">
                                        <option value="none">None</option>
                                        <option value="SMEA">SMEA</option>
                                        <option value="SMEA+DYN">SMEA+DYN</option>
                                    </select>
                                </div>
                            </div>

                            <div class="checkbox-row">
                                <input type="checkbox" id="qualityTags" checked>
                                <label for="qualityTags">Add Quality Tags</label>
                            </div>
                        </div>
                    </div>

                    <!-- Vibe Transfer -->
                    <div class="section">
                        <div class="section-title">
                            <span>Vibe Transfer</span>
                            <label class="section-toggle">
                                <input type="checkbox" id="enableVibeTransfer">
                                <span>Active</span>
                            </label>
                        </div>

                        <div id="vibeTransferSettings" style="display: none;">
                            <small style="color: var(--text-dim); display: block; margin-bottom: 8px;">
                                최대 16개 이미지. 강도 합계가 1.0 이하가 되도록 권장.
                            </small>

                            <div id="vibeCacheInfo" style="display: none; font-size: 12px; margin-bottom: 8px; padding: 4px 8px; background: rgba(0,0,0,0.2); border-radius: 4px;"></div>

                            <div id="vibeList" class="vibe-list"></div>

                            <div class="btn-row">
                                <button type="button" class="btn btn-secondary" id="addVibeBtn" style="flex: 1;">
                                    + 바이브 추가
                                </button>
                                <button type="button" class="btn btn-secondary btn-icon" id="openVibeFolderBtn" title="바이브 캐시 폴더 열기">
                                    📁
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Character Reference (V4.5 only) -->
                    <div class="section" id="charRefSection">
                        <div class="section-title">
                            <span>Character Reference</span>
                            <label class="section-toggle">
                                <input type="checkbox" id="enableCharRef">
                                <span>Active</span>
                            </label>
                        </div>

                        <div id="charRefSettings" style="display: none;">
                            <small style="color: var(--text-dim); display: block; margin-bottom: 8px;">
                                V4.5 전용. Vibe Transfer와 동시 사용 불가.
                            </small>

                            <div id="charRefPreview" class="char-ref-preview" style="display: none;">
                                <img id="charRefImage" src="" alt="Character Reference">
                                <button type="button" class="remove-btn" id="removeCharRefBtn">×</button>
                            </div>

                            <button type="button" class="btn btn-secondary" id="uploadCharRefBtn" style="width: 100%;">
                                이미지 선택
                            </button>
                            <input type="file" id="charRefInput" accept="image/*" style="display: none;">

                            <div class="row" style="margin-top: 12px;">
                                <div style="flex: 1;">
                                    <label>Fidelity</label>
                                    <input type="range" id="charRefFidelity" value="0.5" min="0" max="1" step="0.05" style="width: 100%;">
                                    <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim);">
                                        <span>유연</span>
                                        <span id="charRefFidelityValue">0.5</span>
                                        <span>정밀</span>
                                    </div>
                                </div>
                            </div>

                            <div class="checkbox-row" style="margin-top: 8px;">
                                <input type="checkbox" id="charRefStyleAware" checked>
                                <label for="charRefStyleAware">Style Aware (스타일도 복사)</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Local Settings -->
                <div class="provider-section" data-provider="local">
                    <div class="section">
                        <div class="section-title">Local Settings</div>
                        
                        <label>Model</label>
                        <div style="display: flex; gap: 8px;">
                            <select id="localModel" style="flex: 1;">
                                <option value="">-- Select Model --</option>
                            </select>
                            <button type="button" class="btn btn-secondary" id="openCheckpointsFolderBtn" title="체크포인트 폴더 열기" style="padding: 8px 12px;">
                                📁
                            </button>
                        </div>

                        <label>LoRAs</label>
                        <div class="lora-list" id="loraList">
                            <div style="color: var(--text-dim); font-size: 0.85rem; padding: 8px;">Loading...</div>
                        </div>
                        <button type="button" class="btn btn-secondary" id="openLorasFolderBtn" title="LoRA 폴더 열기" style="width: 100%; margin-top: 8px;">
                            📁 LoRA 폴더 열기
                        </button>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">
                            <span>Upscale</span>
                            <label class="section-toggle">
                                <input type="checkbox" id="enableUpscale">
                                <span>Active</span>
                            </label>
                        </div>
                        
                        <div id="upscaleSettings" style="display: none;">
                            <label>Upscale Model</label>
                            <select id="upscaleModel">
                                <option value="">-- Select Model --</option>
                            </select>
                            <small>Place .pth files in models/upscale_models/</small>
                            
                            <div class="row" style="margin-top: 8px;">
                                <div>
                                    <label>Final Scale</label>
                                    <input type="number" id="downscaleRatio" value="0.7" step="0.05" min="0.3" max="1.0">
                                    <small>×2 upscale × ratio</small>
                                </div>
                                <div>
                                    <label>Alignment</label>
                                    <select id="sizeAlignment">
                                        <option value="none">None</option>
                                        <option value="8">8px</option>
                                        <option value="64" selected>64px</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="row">
                                <div>
                                    <label>Steps</label>
                                    <input type="number" id="upscaleSteps" value="15" min="5" max="50">
                                </div>
                                <div>
                                    <label>CFG</label>
                                    <input type="number" id="upscaleCfg" value="5.0" step="0.1" min="1" max="20">
                                </div>
                            </div>
                            
                            <div class="row">
                                <div style="flex: 1;">
                                    <label>Denoise</label>
                                    <input type="range" id="upscaleDenoise" value="0.5" min="0.1" max="1.0" step="0.05" style="width: 100%;">
                                    <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim);">
                                        <span>0.1</span>
                                        <span id="upscaleDenoiseValue">0.5</span>
                                        <span>1.0</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Generation Settings -->
                <div class="section">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="generationContent" title="접기/펼치기">▼</button>
                        <span>Generation</span>
                    </div>
                    <div id="generationContent" class="collapsible-content">
                        <div class="row">
                            <div>
                                <label>Size</label>
                                <select id="sizePreset">
                                    <optgroup label="Landscape">
                                        <option value="1536x640">1536 × 640</option>
                                        <option value="1344x768">1344 × 768</option>
                                        <option value="1216x832">1216 × 832</option>
                                        <option value="1152x896">1152 × 896</option>
                                    </optgroup>
                                    <optgroup label="Square">
                                        <option value="1024x1024">1024 × 1024</option>
                                    </optgroup>
                                    <optgroup label="Portrait">
                                        <option value="896x1152">896 × 1152</option>
                                        <option value="832x1216" selected>832 × 1216</option>
                                        <option value="768x1344">768 × 1344</option>
                                        <option value="640x1536">640 × 1536</option>
                                    </optgroup>
                                    <option value="custom">Custom</option>
                                </select>
                            </div>
                            <div>
                                <label>W × H</label>
                                <div class="size-inputs">
                                    <input type="number" id="width" value="832" step="64">
                                    <span class="size-x">×</span>
                                    <input type="number" id="height" value="1216" step="64">
                                </div>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Steps</label>
                                <input type="number" id="steps" value="28">
                            </div>
                            <div>
                                <label>CFG</label>
                                <input type="number" id="cfg" value="5.0" step="0.1">
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Sampler</label>
                                <select id="sampler">
                                    <option value="k_euler_ancestral">Euler Ancestral</option>
                                    <option value="k_euler">Euler</option>
                                    <option value="k_dpmpp_2s_ancestral">DPM++ 2S Ancestral</option>
                                    <option value="k_dpmpp_2m_sde">DPM++ 2M SDE</option>
                                    <option value="k_dpmpp_2m">DPM++ 2M</option>
                                    <option value="k_dpmpp_sde">DPM++ SDE</option>
                                </select>
                            </div>
                            <div>
                                <label>Scheduler</label>
                                <select id="scheduler">
                                    <option value="karras">Karras</option>
                                    <option value="exponential">Exponential</option>
                                    <option value="polyexponential">Polyexponential</option>
                                </select>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Seed</label>
                                <input type="number" id="seed" value="-1">
                            </div>
                        </div>

                        <div class="checkbox-row">
                            <input type="checkbox" id="randomSeed">
                            <label for="randomSeed">매 슬롯마다 랜덤 시드</label>
                        </div>
                        <div class="checkbox-row">
                            <input type="checkbox" id="lockSeed">
                            <label for="lockSeed">시드 고정</label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="sidebar-footer">
                <!-- Anlas Info (NAI only) - Single line -->
                <div id="anlasInfo" class="anlas-info" style="display: none;">
                    <span class="anlas-icon">💎</span>
                    <span id="anlasBalance">--</span>
                    <button type="button" class="anlas-refresh" id="refreshAnlasBtn" title="새로고침">↻</button>
                    <span class="anlas-separator">│</span>
                    <span class="anlas-cost-label">-</span>
                    <span id="anlasCost">0</span>
                    <span id="anlasFreeTag" class="free-tag" style="display: none;">FREE</span>
                </div>

                <div class="status-text" id="statusText" style="text-align: left; margin-bottom: 4px;">준비</div>
                <div class="progress-bar" style="margin-bottom: 12px;">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <div style="display: flex; margin-bottom: 8px; align-items: center; gap: 8px;">
                    <div style="flex: 1;">
                        <button class="btn" id="generateBtn">Queue (0)</button>
                    </div>
                    <span style="color: var(--text-dim); font-size: 0.9rem;">×</span>
                    <div style="width: 60px;">
                        <input type="number" id="repeatCount" value="1" min="1" style="margin: 0; height: 100%; text-align: center;" title="반복 횟수">
                    </div>
                </div>
                <div class="row" style="gap: 6px;">
                    <button class="btn btn-secondary" id="cancelCurrentBtn" title="현재 작업 취소 (진행중인 이미지 완료 후)">Cancel</button>
                    <button class="btn btn-secondary" id="clearQueueBtn" title="대기열 비우기">Clear Q</button>
                </div>
            </div>
            <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>
        </aside>

        <!-- Main -->
        <main class="main">
            <div class="slots-header">
                <div class="mode-toggle">
                    <button type="button" class="mode-btn active" id="slotModeBtn">🎰 슬롯 모드</button>
                    <button type="button" class="mode-btn" id="galleryModeBtn">🖼️ 갤러리</button>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <div class="preset-dropdown" id="presetDropdown">
                        <button type="button" class="header-btn preset-btn" id="presetBtn">
                            <span>🔖</span>
                            <span class="preset-name" id="presetName">Presets</span>
                            <span class="dropdown-arrow">▼</span>
                        </button>
                        <div class="preset-menu" id="presetMenu">
                            <div class="preset-list" id="presetList">
                                <!-- 프리셋 목록 -->
                            </div>
                            <div class="preset-actions">
                                <button type="button" class="preset-action-btn" id="newPresetBtn">+ New Preset</button>
                                <button type="button" class="preset-action-btn" id="savePresetBtn">💾 Save</button>
                            </div>
                        </div>
                    </div>
                    <div class="prefix-input-wrapper">
                        <span class="prefix-label">📁 Sub Folder:</span>
                        <input type="text" id="outputFolder" value="" placeholder="선택사항" class="prefix-input">
                    </div>
                    <button type="button" class="header-btn" id="openOutputFolderBtn" title="출력 폴더 열기">
                        <span>📁</span>
                        <span>Open Folder</span>
                    </button>
                    <button type="button" class="header-btn" id="syncScrollBtn" title="전체 슬롯 스크롤 동기화">
                        <span>🔗</span>
                        <span>Scroll Sync</span>
                    </button>
                    <button type="button" class="header-btn" id="clearImagesBtn" title="미리보기 이미지 지우기 (파일은 삭제되지 않음)">
                        <span>🧹</span>
                        <span>Clear Preview</span>
                    </button>
                    <button type="button" class="add-slot-btn" id="addSlotBtn" title="슬롯 추가">+</button>
                </div>
            </div>
            <div class="slots-container-wrapper" id="slotsWrapper">
                <div class="slots-container" id="slotsContainer">
                    <!-- 슬롯들이 가로로 배치됨 -->
                </div>
            </div>
            <div class="gallery-container" id="galleryContainer" style="display: none;">
                <div class="gallery-header">
                    <div class="gallery-folders" id="galleryFolders">
                        <button type="button" class="folder-tab active" data-folder="">📁 gallery</button>
                        <!-- 하위 폴더 탭들이 여기에 추가됨 -->
                    </div>
                    <div class="gallery-header-buttons">
                        <button type="button" class="add-folder-btn" id="addFolderBtn" title="새 폴더">+</button>
                        <button type="button" class="gallery-folder-btn" id="openGalleryFolderBtn" title="갤러리 폴더 열기">📂</button>
                    </div>
                </div>
                <div class="gallery-content">
                    <div class="gallery-grid" id="galleryGrid">
                        <!-- 갤러리 이미지들 -->
                    </div>
                    <div class="gallery-empty" id="galleryEmpty">
                        <div class="icon">🖼️</div>
                        <p>갤러리가 비어있습니다</p>
                        <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <span class="close">&times;</span>
        <img src="" alt="">
    </div>

    <!-- Drop Overlay -->
    <div class="drop-overlay" id="dropOverlay">
        <div class="drop-overlay-content">
            <div class="icon">📥</div>
            <h3>이미지 드롭</h3>
            <p>바이브 또는 생성 이미지를 드롭하세요</p>
        </div>
    </div>

    <!-- Drop Confirm Modal -->
    <div class="drop-modal" id="dropModal">
        <div class="drop-modal-content">
            <h3 id="dropModalTitle">이미지 가져오기</h3>
            <img id="dropModalPreview" class="preview" src="" alt="">
            <div id="dropModalMetadata" class="metadata"></div>
            <div class="buttons">
                <button type="button" class="btn btn-secondary" id="dropModalCancel">취소</button>
                <button type="button" class="btn btn-primary" id="dropModalConfirm">적용</button>
            </div>
        </div>
    </div>

    <!-- Generic Confirm Modal -->
    <div class="drop-modal" id="confirmModal">
        <div class="drop-modal-content" style="max-width: 400px;">
            <h3 id="confirmModalTitle">확인</h3>
            <div id="confirmModalMessage" class="metadata" style="margin: 16px 0;"></div>
            <div class="buttons">
                <button type="button" class="btn btn-secondary" id="confirmModalCancel">취소</button>
                <button type="button" class="btn" id="confirmModalOk">확인</button>
            </div>
        </div>
    </div>

    <!-- Input Prompt Modal -->
    <div class="drop-modal" id="inputModal">
        <div class="drop-modal-content" style="max-width: 400px;">
            <h3 id="inputModalTitle">입력</h3>
            <div id="inputModalMessage" style="margin: 12px 0; color: var(--text-dim);"></div>
            <input type="text" id="inputModalInput" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-light); color: var(--text); margin-bottom: 16px;">
            <div class="buttons">
                <button type="button" class="btn btn-secondary" id="inputModalCancel">취소</button>
                <button type="button" class="btn" id="inputModalOk">확인</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="modal-close" onclick="closeSettings()">&times;</button>
            </div>
            
            <div class="input-group">
                <label>NAI API Token</label>
                <input type="password" id="naiToken" placeholder="NAI 토큰 입력">
                <small>Get from novelai.net → Account → API</small>
            </div>
            
            <div class="input-group">
                <label>Status</label>
                <span class="status-badge" id="naiStatus">Checking...</span>
            </div>
            
            <div class="input-group">
                <label>Checkpoints Directory</label>
                <input type="text" id="checkpointsDir" placeholder="./models/checkpoints">
            </div>
            
            <div class="input-group">
                <label>LoRA Directory</label>
                <input type="text" id="loraDir" placeholder="./models/loras">
            </div>
            
            <hr style="border: none; border-top: 1px solid var(--border); margin: 16px 0;">
            
            <div class="input-group">
                <label>Local Generation Environment</label>
                <div id="localEnvStatus" class="local-env-status">
                    <span class="status-text">Checking...</span>
                </div>
                <div id="localEnvActions" style="margin-top: 8px;">
                    <!-- 동적으로 버튼 추가됨 -->
                </div>
                <div id="localEnvProgress" class="local-env-progress" style="display: none;">
                    <div class="local-env-progress-bar">
                        <div class="local-env-progress-fill" id="localEnvProgressFill"></div>
                    </div>
                    <span class="local-env-progress-text" id="localEnvProgressText">0%</span>
                </div>
                <small style="display: block; margin-top: 12px; color: var(--text-dim);">Python + PyTorch CUDA + diffusers (~3GB, 3-5분)</small>
            </div>

            <button class="btn" onclick="saveSettings()" style="margin-top: 16px;">Save Settings</button>
        </div>
    </div>
    
    <!-- Local Install Modal -->
    <div class="modal" id="localInstallModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2>🖥️ Local Generation</h2>
                <button class="modal-close" onclick="closeLocalInstallModal()">&times;</button>
            </div>
            
            <p style="color: var(--text-dim); margin-bottom: 16px;">
                Local generation requires a one-time installation of Python environment with PyTorch CUDA.
            </p>
            
            <div class="input-group">
                <div id="installModalStatus" class="local-env-status">
                    <span class="status-text">Checking...</span>
                </div>
                <div id="installModalProgress" class="local-env-progress" style="display: none;">
                    <div class="local-env-progress-bar">
                        <div class="local-env-progress-fill" id="installModalProgressFill"></div>
                    </div>
                    <span class="local-env-progress-text" id="installModalProgressText">0%</span>
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn" id="installModalBtn" onclick="installFromModal()" style="flex: 1;">
                    ⬇️ Install (~3GB)
                </button>
                <button class="btn" onclick="closeLocalInstallModal()" style="background: var(--surface-light);">
                    Cancel
                </button>
            </div>
            
            <small style="display: block; margin-top: 12px; color: var(--text-dim);">
                Installation takes 3-5 minutes depending on your internet speed.
            </small>
        </div>
    </div>
    
    <!-- NAI Token Modal -->
    <div class="modal" id="naiTokenModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2>🔑 NovelAI API Token</h2>
                <button class="modal-close" onclick="closeNaiTokenModal()">&times;</button>
            </div>
            
            <p style="color: var(--text-dim); margin-bottom: 16px;">
                Enter your NovelAI API token to use NAI generation.
            </p>
            
            <div class="input-group">
                <label>API Token</label>
                <input type="password" id="naiTokenModalInput" placeholder="NAI 토큰 입력">
                <small>Get from <a href="https://novelai.net/settings" target="_blank" style="color: var(--primary);">novelai.net</a> → Account Settings → Get Persistent API Token</small>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn" id="naiTokenModalBtn" onclick="saveNaiTokenFromModal()" style="flex: 1;">
                    💾 Save & Continue
                </button>
                <button class="btn" onclick="closeNaiTokenModal()" style="background: var(--surface-light);">
                    Cancel
                </button>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
    
    <script>
        const API_BASE = 'http://127.0.0.1:8765';
        
        let currentProvider = 'nai';
        let eventSource = null;
        let currentIndex = 0;
        let totalImages = 0;
        let resetTimer = null;
        let naiTokenSet = false;  // NAI 토큰 설정 여부
        
        // Elements
        const tabs = document.querySelectorAll('.tab');
        const providerSections = document.querySelectorAll('.provider-section');
        const generateBtn = document.getElementById('generateBtn');
        const cancelCurrentBtn = document.getElementById('cancelCurrentBtn');
        const clearQueueBtn = document.getElementById('clearQueueBtn');
        const progressFill = document.getElementById('progressFill');
        const statusText = document.getElementById('statusText');
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = lightbox.querySelector('img');
        
        // Slots
        const slotsContainer = document.getElementById('slotsContainer');
        const addSlotBtn = document.getElementById('addSlotBtn');
        let slotCounter = 0;
        
        function updateSlotNumbers() {
            const slots = slotsContainer.querySelectorAll('.slot');
            slots.forEach((slot, index) => {
                slot.querySelector('.slot-number').textContent = String(index + 1).padStart(3, '0');
            });
        }
        
        // 슬롯 너비 관리
        let currentSlotWidth = 280;
        const MIN_SLOT_WIDTH = 150;
        const MAX_SLOT_WIDTH = 1200;

        function setSlotWidth(width) {
            currentSlotWidth = Math.max(MIN_SLOT_WIDTH, Math.min(MAX_SLOT_WIDTH, width));
            document.documentElement.style.setProperty('--slot-width', currentSlotWidth + 'px');
            autoSaveSettings();
        }

        function setupSlotResize(slot) {
            const handle = slot.querySelector('.slot-resize-handle');
            if (!handle) return;

            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = currentSlotWidth;

                document.body.classList.add('resizing-slot');
                handle.classList.add('active');

                function onMouseMove(e) {
                    const deltaX = e.clientX - startX;
                    setSlotWidth(startWidth + deltaX);
                }

                function onMouseUp() {
                    document.body.classList.remove('resizing-slot');
                    handle.classList.remove('active');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // 사이드바 너비 관리
        let currentSidebarWidth = 540;
        const MIN_SIDEBAR_WIDTH = 360;
        const MAX_SIDEBAR_WIDTH = 800;

        function setSidebarWidth(width) {
            currentSidebarWidth = Math.max(MIN_SIDEBAR_WIDTH, Math.min(MAX_SIDEBAR_WIDTH, width));
            document.documentElement.style.setProperty('--sidebar-width', currentSidebarWidth + 'px');
            autoSaveSettings();
        }

        // 사이드바 리사이즈 핸들 설정
        (function setupSidebarResize() {
            const handle = document.getElementById('sidebarResizeHandle');
            if (!handle) return;

            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = currentSidebarWidth;

                document.body.classList.add('resizing-slot');
                handle.classList.add('active');

                function onMouseMove(e) {
                    const deltaX = e.clientX - startX;
                    setSidebarWidth(startWidth + deltaX);
                }

                function onMouseUp() {
                    document.body.classList.remove('resizing-slot');
                    handle.classList.remove('active');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        })();

        function createSlot(name = '', content = '') {
            const slotId = slotCounter++;
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.dataset.slotIndex = slotId;
            slot.innerHTML = `
                <div class="slot-resize-handle"></div>
                <div class="slot-prompt">
                    <div class="slot-prompt-header">
                        <span class="slot-number">001</span>
                        <input type="text" placeholder="이름 (선택)" value="${name}" class="slot-name">
                        <button type="button" class="slot-drag" title="드래그하여 순서 변경" tabindex="-1">☰</button>
                        <button type="button" class="slot-delete" tabindex="-1">×</button>
                    </div>
                    <textarea placeholder="이 슬롯에만 적용할 태그" class="slot-tags">${content}</textarea>
                </div>
                <div class="slot-images">
                    <div class="slot-empty">이미지가 여기에 표시됩니다</div>
                </div>
            `;

            // 리사이즈 핸들 설정
            setupSlotResize(slot);
            
            slot.querySelector('.slot-delete').onclick = () => {
                if (slotsContainer.querySelectorAll('.slot').length > 1) {
                    slot.remove();
                    updateSlotNumbers();
                    updateQueueButton();
                    updateAnlasCost();
                    autoSaveSettings();
                }
            };
            
            slot.querySelector('textarea').oninput = updateQueueButton;
            
            // 탭 키로 같은 타입 필드 간 이동
            const nameInput = slot.querySelector('.slot-name');
            const tagsInput = slot.querySelector('.slot-tags');
            
            nameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const slots = [...slotsContainer.querySelectorAll('.slot')];
                    const currentIdx = slots.indexOf(slot);
                    const nextIdx = e.shiftKey 
                        ? (currentIdx - 1 + slots.length) % slots.length 
                        : (currentIdx + 1) % slots.length;
                    slots[nextIdx].querySelector('.slot-name').focus();
                }
            });
            
            tagsInput.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const slots = [...slotsContainer.querySelectorAll('.slot')];
                    const currentIdx = slots.indexOf(slot);
                    const nextIdx = e.shiftKey 
                        ? (currentIdx - 1 + slots.length) % slots.length 
                        : (currentIdx + 1) % slots.length;
                    slots[nextIdx].querySelector('.slot-tags').focus();
                }
            });
            
            // 드래그 핸들
            const dragHandle = slot.querySelector('.slot-drag');
            dragHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startSlotDrag(slot, e);
            });
            
            return slot;
        }
        
        // 슬롯 드래그 앤 드롭
        let draggedSlot = null;
        let dragStartX = 0;
        let slotStartX = 0;
        let placeholder = null;
        
        function startSlotDrag(slot, e) {
            draggedSlot = slot;
            dragStartX = e.clientX;
            
            const rect = slot.getBoundingClientRect();
            slotStartX = rect.left;
            
            // 플레이스홀더 생성
            placeholder = document.createElement('div');
            placeholder.className = 'slot-placeholder';
            placeholder.style.width = rect.width + 'px';
            placeholder.style.height = rect.height + 'px';
            
            // 드래그 중 스타일
            slot.classList.add('dragging');
            slot.style.position = 'fixed';
            slot.style.left = rect.left + 'px';
            slot.style.top = rect.top + 'px';
            slot.style.width = rect.width + 'px';
            slot.style.zIndex = '1000';
            
            slot.parentNode.insertBefore(placeholder, slot);
            document.body.appendChild(slot);
            
            document.addEventListener('mousemove', onSlotDrag);
            document.addEventListener('mouseup', endSlotDrag);
        }
        
        function onSlotDrag(e) {
            if (!draggedSlot) return;
            
            const dx = e.clientX - dragStartX;
            draggedSlot.style.left = (slotStartX + dx) + 'px';
            
            // 플레이스홀더 위치 업데이트
            const slots = [...slotsContainer.querySelectorAll('.slot:not(.dragging)')];
            const draggedRect = draggedSlot.getBoundingClientRect();
            const draggedCenter = draggedRect.left + draggedRect.width / 2;
            
            for (let i = 0; i < slots.length; i++) {
                const slotRect = slots[i].getBoundingClientRect();
                const slotCenter = slotRect.left + slotRect.width / 2;
                
                if (draggedCenter < slotCenter) {
                    slotsContainer.insertBefore(placeholder, slots[i]);
                    return;
                }
            }
            slotsContainer.appendChild(placeholder);
        }
        
        function endSlotDrag() {
            if (!draggedSlot) return;
            
            // 플레이스홀더 위치에 슬롯 삽입
            draggedSlot.classList.remove('dragging');
            draggedSlot.style.position = '';
            draggedSlot.style.left = '';
            draggedSlot.style.top = '';
            draggedSlot.style.width = '';
            draggedSlot.style.zIndex = '';
            
            slotsContainer.insertBefore(draggedSlot, placeholder);
            placeholder.remove();
            
            draggedSlot = null;
            placeholder = null;
            
            document.removeEventListener('mousemove', onSlotDrag);
            document.removeEventListener('mouseup', endSlotDrag);
            
            updateSlotNumbers();
            autoSaveSettings();
        }
        
        function addSlot(name = '', content = '') {
            const slot = createSlot(name, content);
            slotsContainer.appendChild(slot);
            setupSlotImageScroll(slot);
            updateSlotNumbers();
            updateQueueButton();
            updateAnlasCost();
        }
        
        function getSlotList() {
            const slots = slotsContainer.querySelectorAll('.slot');
            const list = [];
            
            slots.forEach((slot, index) => {
                const name = slot.querySelector('.slot-name').value.trim();
                const content = slot.querySelector('.slot-tags').value.trim();
                // 현재 위치 기반 인덱스 사용
                list.push({ name, content, slotIndex: index });
            });
            
            return list;
        }
        
        function updateQueueButton() {
            const list = getSlotList();
            const count = list.length || 1;
            generateBtn.textContent = `Queue (${count})`;
        }
        
        function addImageToSlot(slotIndex, data) {
            // slotIndex로 슬롯 찾기
            const slots = slotsContainer.querySelectorAll('.slot');
            const slotsWrapperDisplay = slotsWrapper.style.display;
            console.log(`[addImageToSlot] slotIndex=${slotIndex}, slots.length=${slots.length}, filename=${data.filename}, slotsWrapperDisplay=${slotsWrapperDisplay}`);

            // 슬롯이 없거나 인덱스가 범위를 벗어나면 첫 번째 슬롯에 추가
            let targetSlot;
            if (slotIndex >= slots.length || slotIndex < 0) {
                console.warn(`[addImageToSlot] Invalid slotIndex ${slotIndex}, falling back to slot 0`);
                if (slots.length === 0) {
                    console.error('[addImageToSlot] No slots available!');
                    return;
                }
                targetSlot = slots[0];
            } else {
                targetSlot = slots[slotIndex];
            }

            const imagesContainer = targetSlot.querySelector('.slot-images');

            // 빈 상태 제거
            const empty = imagesContainer.querySelector('.slot-empty');
            if (empty) empty.remove();

            const card = document.createElement('div');
            card.className = 'slot-image-card';
            // image_path가 있으면 URL로, 없으면 base64로 (하위 호환)
            const imgSrc = data.image_path
                ? `${API_BASE}/api/outputs/${data.image_path}`
                : `data:image/png;base64,${data.image}`;
            card.innerHTML = `
                <img src="${imgSrc}" alt="" draggable="false">
                <button type="button" class="save-gallery-btn" title="갤러리에 저장">☆</button>
                <div class="info">
                    <div class="info-row">
                        <div class="filename" title="${data.filename}">${data.filename}</div>
                        <button type="button" class="load-settings-btn" title="이 이미지의 설정 불러오기">📋</button>
                    </div>
                    <div class="seed">Seed: ${data.seed}</div>
                </div>
            `;

            // 이미지 데이터 저장 (갤러리 저장용 + 설정 불러오기용)
            card._imageData = {
                image_path: data.image_path || null,
                image: data.image || null,  // 하위 호환
                filename: data.filename,
                seed: data.seed,
                prompt: data.prompt || '',
                metadata: data.metadata || null  // 전체 설정 메타데이터
            };

            // 갤러리 저장/제거 토글 버튼
            const saveBtn = card.querySelector('.save-gallery-btn');
            saveBtn.onclick = async (e) => {
                e.stopPropagation();

                // 이미 저장된 경우 갤러리에서 제거
                if (saveBtn.classList.contains('saved')) {
                    try {
                        const galleryFilename = card._imageData.galleryFilename || card._imageData.filename;
                        const response = await fetch(`${API_BASE}/api/gallery/${encodeURIComponent(galleryFilename)}`, {
                            method: 'DELETE'
                        });
                        const result = await response.json();
                        if (result.success) {
                            saveBtn.classList.remove('saved');
                            saveBtn.textContent = '☆';
                            card._imageData.galleryFilename = null;
                            showToast('갤러리에서 제거됨', 'success');
                            // 갤러리 뷰 새로고침
                            if (currentMode === 'gallery') {
                                loadGallery();
                            }
                        } else {
                            showToast('제거 실패: ' + result.error, 'error');
                        }
                    } catch (err) {
                        showToast('제거 오류: ' + err.message, 'error');
                    }
                    return;
                }

                // 저장되지 않은 경우 갤러리에 저장
                try {
                    // 백엔드에서 원본 파일의 메타데이터를 직접 읽음
                    // 현재 열린 갤러리 폴더에 저장
                    const response = await fetch(`${API_BASE}/api/gallery/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image: card._imageData.image,  // base64 (하위 호환)
                            image_path: card._imageData.image_path,  // 파일 경로
                            filename: card._imageData.filename,
                            folder: currentGalleryFolder || ''  // 현재 갤러리 폴더
                        })
                    });
                    const result = await response.json();
                    if (result.success) {
                        saveBtn.classList.add('saved');
                        saveBtn.textContent = '★';
                        card._imageData.galleryFilename = result.filename || card._imageData.filename;
                        showToast('갤러리에 저장됨', 'success');
                    } else {
                        showToast('저장 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('저장 오류: ' + err.message, 'error');
                }
            };

            // 설정 불러오기 버튼
            const loadSettingsBtn = card.querySelector('.load-settings-btn');
            loadSettingsBtn.onclick = (e) => {
                e.stopPropagation();
                const metadata = card._imageData.metadata;
                if (!metadata) {
                    showToast('메타데이터가 없습니다', 'error');
                    return;
                }
                showLoadSettingsConfirm(metadata);
            };

            // 드래그와 클릭 구분
            const img = card.querySelector('img');
            let imgMouseDownX = 0;
            let imgMouseDownY = 0;

            img.addEventListener('mousedown', (e) => {
                imgMouseDownX = e.clientX;
                imgMouseDownY = e.clientY;
            });

            img.addEventListener('mouseup', (e) => {
                const dx = Math.abs(e.clientX - imgMouseDownX);
                const dy = Math.abs(e.clientY - imgMouseDownY);
                // 5px 이내면 클릭으로 간주
                if (dx < 5 && dy < 5) {
                    lightboxImg.src = imgSrc;  // URL 또는 base64 사용
                    lightbox.classList.add('active');
                }
            });

            // 이미지 로드 완료 후 카드 추가 (이미지와 info가 동시에 표시되도록)
            const insertCard = () => {
                imagesContainer.insertBefore(card, imagesContainer.firstChild);
                console.log(`[addImageToSlot] Card inserted for ${data.filename}`);
            };
            img.onload = insertCard;
            img.onerror = insertCard;  // 로드 실패 시에도 카드 표시
        }

        function clearSlotImages() {
            const slots = slotsContainer.querySelectorAll('.slot');
            slots.forEach(slot => {
                const imagesContainer = slot.querySelector('.slot-images');
                imagesContainer.innerHTML = '<div class="slot-empty">이미지가 여기에 표시됩니다</div>';
            });
        }
        
        addSlotBtn.onclick = () => {
            addSlot();
            autoSaveSettings();
        };
        
        // === Preset System ===
        const presetDropdown = document.getElementById('presetDropdown');
        const presetBtn = document.getElementById('presetBtn');
        const presetMenu = document.getElementById('presetMenu');
        const presetList = document.getElementById('presetList');
        const presetNameSpan = document.getElementById('presetName');
        const newPresetBtn = document.getElementById('newPresetBtn');
        const savePresetBtn = document.getElementById('savePresetBtn');
        
        let currentPreset = null; // { filename, name }
        let presets = [];
        
        // 드롭다운 토글 (body에 붙여서 overflow 문제 해결)
        presetBtn.onclick = (e) => {
            e.stopPropagation();
            const isShowing = presetMenu.classList.contains('show');

            if (isShowing) {
                presetMenu.classList.remove('show');
                presetDropdown.appendChild(presetMenu); // 원래 위치로
            } else {
                // body에 붙이고 위치 계산
                document.body.appendChild(presetMenu);
                const btnRect = presetBtn.getBoundingClientRect();
                presetMenu.style.top = (btnRect.bottom + 4) + 'px';
                presetMenu.style.left = btnRect.left + 'px';
                presetMenu.classList.add('show');
                loadPresetList();
            }
        };

        // 외부 클릭 시 닫기
        document.addEventListener('click', (e) => {
            if (!presetDropdown.contains(e.target) && !presetMenu.contains(e.target)) {
                presetMenu.classList.remove('show');
                if (presetMenu.parentElement === document.body) {
                    presetDropdown.appendChild(presetMenu);
                }
            }
        });
        
        // 프리셋 목록 로드
        async function loadPresetList() {
            try {
                const res = await fetch(`${API_BASE}/api/presets`);
                const data = await res.json();
                presets = data.presets;
                renderPresetList();
            } catch (e) {
                console.error('Failed to load presets:', e);
            }
        }
        
        // 프리셋 목록 렌더링
        function renderPresetList() {
            if (presets.length === 0) {
                presetList.innerHTML = '<div class="preset-empty">No presets saved</div>';
                return;
            }
            
            presetList.innerHTML = presets.map(p => `
                <div class="preset-item ${currentPreset?.filename === p.filename ? 'selected' : ''}" data-filename="${p.filename}">
                    <span class="check">${currentPreset?.filename === p.filename ? '✓' : ''}</span>
                    <span class="label">${p.name}</span>
                    <button class="edit-btn" title="이름 변경">✏️</button>
                    <button class="delete-btn" title="삭제">🗑️</button>
                </div>
            `).join('');
            
            // 이벤트 바인딩
            presetList.querySelectorAll('.preset-item').forEach(item => {
                const filename = item.dataset.filename;
                
                item.querySelector('.label').onclick = () => loadPreset(filename);
                
                item.querySelector('.edit-btn').onclick = (e) => {
                    e.stopPropagation();
                    renamePreset(filename);
                };
                
                item.querySelector('.delete-btn').onclick = (e) => {
                    e.stopPropagation();
                    deletePreset(filename);
                };
            });
        }
        
        // 프리셋 로드
        async function loadPreset(filename) {
            try {
                const res = await fetch(`${API_BASE}/api/presets/${filename}`);
                const data = await res.json();
                
                // 현재 슬롯 모두 제거
                slotsContainer.innerHTML = '';
                
                // 프리셋 슬롯들로 교체
                data.slots.forEach(s => {
                    addSlot(s.name, s.content);
                });
                
                // 최소 1개 슬롯
                if (data.slots.length === 0) {
                    addSlot();
                }
                
                // Prefix 적용
                document.getElementById('outputFolder').value = data.folder || '';
                
                currentPreset = { filename, name: data.name };
                presetNameSpan.textContent = data.name;
                presetMenu.classList.remove('show');
                
                showToast(`Loaded: ${data.name}`, 'success');
            } catch (e) {
                showToast('프리셋 로드 실패', 'error');
            }
        }
        
        // 새 프리셋 저장
        newPresetBtn.onclick = async () => {
            const name = prompt('프리셋 이름 입력:');
            if (!name) return;
            
            const slots = getSlotList().map(s => ({ name: s.name, content: s.content }));
            const folder = document.getElementById('outputFolder').value || '';

            try {
                const res = await fetch(`${API_BASE}/api/presets`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, slots, folder })
                });
                const data = await res.json();
                
                currentPreset = { filename: data.filename, name: data.name };
                presetNameSpan.textContent = data.name;
                
                loadPresetList();
                showToast(`Saved: ${name}`, 'success');
            } catch (e) {
                showToast('프리셋 저장 실패', 'error');
            }
        };
        
        // 현재 프리셋에 덮어쓰기
        savePresetBtn.onclick = async () => {
            if (!currentPreset) {
                showToast('프리셋이 선택되지 않음', 'warning');
                return;
            }
            
            const slots = getSlotList().map(s => ({ name: s.name, content: s.content }));
            const folder = document.getElementById('outputFolder').value || '';

            try {
                await fetch(`${API_BASE}/api/presets/${currentPreset.filename}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: currentPreset.name, slots, folder })
                });
                
                showToast(`Saved: ${currentPreset.name}`, 'success');
                presetMenu.classList.remove('show');
            } catch (e) {
                showToast('프리셋 저장 실패', 'error');
            }
        };
        
        // 프리셋 이름 변경
        async function renamePreset(filename) {
            const preset = presets.find(p => p.filename === filename);
            if (!preset) return;
            
            const newName = prompt('Enter new name:', preset.name);
            if (!newName || newName === preset.name) return;
            
            try {
                // 기존 데이터 로드
                const res = await fetch(`${API_BASE}/api/presets/${filename}`);
                const data = await res.json();
                
                // 이름만 변경해서 저장 (prefix 유지)
                await fetch(`${API_BASE}/api/presets/${filename}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName, slots: data.slots, prefix: data.prefix || 'Name_' })
                });
                
                if (currentPreset?.filename === filename) {
                    currentPreset.name = newName;
                    presetNameSpan.textContent = newName;
                }
                
                loadPresetList();
                showToast('이름 변경됨', 'success');
            } catch (e) {
                showToast('이름 변경 실패', 'error');
            }
        }
        
        // 프리셋 삭제
        async function deletePreset(filename) {
            const preset = presets.find(p => p.filename === filename);
            if (!preset) return;

            showConfirmModal(
                '🗑️ 프리셋 삭제',
                `<p>"${preset.name}" 프리셋을 삭제하시겠습니까?</p>`,
                async () => {
                    try {
                        await fetch(`${API_BASE}/api/presets/${filename}`, { method: 'DELETE' });

                        if (currentPreset?.filename === filename) {
                            currentPreset = null;
                            presetNameSpan.textContent = 'Presets';
                        }

                        loadPresetList();
                        showToast('삭제됨', 'success');
                    } catch (e) {
                        showToast('삭제 실패', 'error');
                    }
                },
                '삭제',
                true
            );
        }
        
        // Sync scroll 토글
        const syncScrollBtn = document.getElementById('syncScrollBtn');
        let syncScrollEnabled = false;
        let isSyncScrolling = false;
        
        syncScrollBtn.onclick = () => {
            syncScrollEnabled = !syncScrollEnabled;
            syncScrollBtn.classList.toggle('active', syncScrollEnabled);
        };
        
        function setupSlotImageScroll(slot) {
            const imagesContainer = slot.querySelector('.slot-images');
            
            imagesContainer.addEventListener('scroll', () => {
                if (!syncScrollEnabled || isSyncScrolling) return;
                
                isSyncScrolling = true;
                const scrollTop = imagesContainer.scrollTop;
                const scrollRatio = imagesContainer.scrollTop / (imagesContainer.scrollHeight - imagesContainer.clientHeight || 1);
                
                // 다른 모든 슬롯의 이미지 영역도 같이 스크롤
                slotsContainer.querySelectorAll('.slot').forEach(otherSlot => {
                    if (otherSlot === slot) return;
                    const otherImages = otherSlot.querySelector('.slot-images');
                    const maxScroll = otherImages.scrollHeight - otherImages.clientHeight;
                    otherImages.scrollTop = scrollRatio * maxScroll;
                });
                
                setTimeout(() => { isSyncScrolling = false; }, 10);
            });
        }
        
        // 스크롤 그라데이션 업데이트
        const slotsWrapper = document.getElementById('slotsWrapper');
        
        function updateScrollGradients() {
            const { scrollLeft, scrollWidth, clientWidth } = slotsContainer;
            const canScrollLeft = scrollLeft > 5;
            const canScrollRight = scrollLeft < scrollWidth - clientWidth - 5;
            
            slotsWrapper.classList.toggle('can-scroll-left', canScrollLeft);
            slotsWrapper.classList.toggle('can-scroll-right', canScrollRight);
        }
        
        slotsContainer.addEventListener('scroll', updateScrollGradients);
        // 초기화 및 슬롯 추가/삭제 시 업데이트를 위한 observer
        const resizeObserver = new ResizeObserver(updateScrollGradients);
        resizeObserver.observe(slotsContainer);
        
        // 가로 스크롤 드래그 (오버스크롤 바운스 포함)
        let isScrollDragging = false;
        let scrollStartX = 0;
        let scrollLeft = 0;
        let overscrollOffset = 0;
        
        slotsContainer.addEventListener('mousedown', (e) => {
            // 텍스트 입력란, 버튼, 드래그 핸들만 제외
            if (e.target.tagName === 'INPUT' || 
                e.target.tagName === 'TEXTAREA' || 
                e.target.tagName === 'BUTTON' ||
                e.target.classList.contains('slot-drag') ||
                e.target.classList.contains('slot-delete')) {
                return;
            }
            
            isScrollDragging = true;
            scrollStartX = e.pageX - slotsContainer.offsetLeft;
            scrollLeft = slotsContainer.scrollLeft;
            overscrollOffset = 0;
            slotsContainer.style.cursor = 'grabbing';
            slotsContainer.style.transition = 'none';
        });
        
        slotsContainer.addEventListener('mousemove', (e) => {
            if (!isScrollDragging) return;
            e.preventDefault();
            const x = e.pageX - slotsContainer.offsetLeft;
            const walk = (x - scrollStartX) * 1.5;
            
            const maxScroll = slotsContainer.scrollWidth - slotsContainer.clientWidth;
            const newScrollLeft = scrollLeft - walk;
            
            // 스크롤 가능 범위 체크
            if (maxScroll <= 0) {
                // 스크롤 불가 - 오버스크롤 효과만
                overscrollOffset = walk * 0.3; // 저항감 있게
                overscrollOffset = Math.max(-50, Math.min(50, overscrollOffset));
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else if (newScrollLeft < 0) {
                // 왼쪽 끝 넘어감
                slotsContainer.scrollLeft = 0;
                overscrollOffset = -newScrollLeft * 0.3;
                overscrollOffset = Math.min(50, overscrollOffset);
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else if (newScrollLeft > maxScroll) {
                // 오른쪽 끝 넘어감
                slotsContainer.scrollLeft = maxScroll;
                overscrollOffset = -(newScrollLeft - maxScroll) * 0.3;
                overscrollOffset = Math.max(-50, overscrollOffset);
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else {
                // 정상 스크롤
                slotsContainer.scrollLeft = newScrollLeft;
                overscrollOffset = 0;
                slotsContainer.style.transform = '';
            }
        });
        
        function endScrollDrag() {
            if (!isScrollDragging) return;
            isScrollDragging = false;
            slotsContainer.style.cursor = '';
            
            // 오버스크롤 바운스백
            if (overscrollOffset !== 0) {
                slotsContainer.style.transition = 'transform 0.3s ease-out';
                slotsContainer.style.transform = '';
                overscrollOffset = 0;
            }
        }
        
        slotsContainer.addEventListener('mouseup', endScrollDrag);
        slotsContainer.addEventListener('mouseleave', endScrollDrag);
        
        // Tab switching
        let localEnvInstalled = false;  // Local 환경 설치 여부
        
        // NAI / Local 샘플러/스케줄러 옵션
        const NAI_SAMPLERS = [
            { value: 'k_euler_ancestral', label: 'Euler Ancestral' },
            { value: 'k_euler', label: 'Euler' },
            { value: 'k_dpmpp_2s_ancestral', label: 'DPM++ 2S Ancestral' },
            { value: 'k_dpmpp_2m_sde', label: 'DPM++ 2M SDE' },
            { value: 'k_dpmpp_2m', label: 'DPM++ 2M' },
            { value: 'k_dpmpp_sde', label: 'DPM++ SDE' },
        ];
        const NAI_SCHEDULERS = [
            { value: 'karras', label: 'Karras' },
            { value: 'exponential', label: 'Exponential' },
            { value: 'polyexponential', label: 'Polyexponential' },
        ];
        const LOCAL_SAMPLERS = [
            { value: 'euler_ancestral', label: 'Euler Ancestral' },
            { value: 'euler', label: 'Euler' },
            { value: 'dpmpp_2m', label: 'DPM++ 2M' },
            { value: 'dpmpp_2m_sde', label: 'DPM++ 2M SDE' },
            { value: 'dpmpp_sde', label: 'DPM++ SDE' },
            { value: 'dpmpp_3m_sde', label: 'DPM++ 3M SDE' },
            { value: 'dpmpp_2s_ancestral', label: 'DPM++ 2S Ancestral' },
            { value: 'ddim', label: 'DDIM' },
            { value: 'uni_pc', label: 'UniPC' },
            { value: 'lcm', label: 'LCM' },
        ];
        const LOCAL_SCHEDULERS = [
            { value: 'normal', label: 'Normal' },
            { value: 'karras', label: 'Karras' },
            { value: 'exponential', label: 'Exponential' },
            { value: 'sgm_uniform', label: 'SGM Uniform' },
            { value: 'simple', label: 'Simple' },
            { value: 'ddim_uniform', label: 'DDIM Uniform' },
            { value: 'beta', label: 'Beta' },
        ];
        
        function updateSamplerSchedulerOptions(provider) {
            const samplerSelect = document.getElementById('sampler');
            const schedulerSelect = document.getElementById('scheduler');
            
            const samplers = provider === 'nai' ? NAI_SAMPLERS : LOCAL_SAMPLERS;
            const schedulers = provider === 'nai' ? NAI_SCHEDULERS : LOCAL_SCHEDULERS;
            
            // 현재 선택 저장
            const currentSampler = samplerSelect.value;
            const currentScheduler = schedulerSelect.value;
            
            // 옵션 교체
            samplerSelect.innerHTML = samplers.map(s => 
                `<option value="${s.value}">${s.label}</option>`
            ).join('');
            schedulerSelect.innerHTML = schedulers.map(s => 
                `<option value="${s.value}">${s.label}</option>`
            ).join('');
            
            // 기존 선택 복원 시도, 없으면 첫 번째
            if (samplers.some(s => s.value === currentSampler)) {
                samplerSelect.value = currentSampler;
            }
            if (schedulers.some(s => s.value === currentScheduler)) {
                schedulerSelect.value = currentScheduler;
            }
        }
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Local 탭 클릭 시 설치 안 됐으면 팝업
                if (tab.dataset.provider === 'local' && !localEnvInstalled) {
                    showLocalInstallModal();
                    return;
                }
                
                currentProvider = tab.dataset.provider;
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                providerSections.forEach(s => {
                    s.classList.toggle('active', s.dataset.provider === currentProvider);
                });
                updateSamplerSchedulerOptions(currentProvider);
                updateAnlasVisibility();
                autoSaveSettings();
            });
        });
        
        // === Prompt Presets ===
        async function loadPromptPresets(category) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}`);
                const data = await res.json();
                return data.presets;
            } catch (e) {
                console.error('Failed to load prompt presets:', e);
                return [];
            }
        }
        
        async function getPromptPreset(category, filename) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}/${filename}`);
                const data = await res.json();
                return data.content;
            } catch (e) {
                console.error('Failed to get prompt preset:', e);
                return null;
            }
        }
        
        async function savePromptPreset(category, name, content) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, content })
                });
                const data = await res.json();
                showToast(`Saved: ${name}`, 'success');
                return data;
            } catch (e) {
                showToast('저장 실패', 'error');
                return null;
            }
        }
        
        async function deletePromptPreset(category, filename) {
            try {
                await fetch(`${API_BASE}/api/prompts/${category}/${filename}`, { method: 'DELETE' });
                showToast('삭제됨', 'success');
                return true;
            } catch (e) {
                showToast('삭제 실패', 'error');
                return false;
            }
        }
        
        function setupPromptPresetDropdown(dropdown, textarea) {
            const category = dropdown.dataset.category;
            const btn = dropdown.querySelector('.prompt-preset-btn');
            const menu = dropdown.querySelector('.prompt-preset-menu');
            const list = dropdown.querySelector('.prompt-preset-list');
            const saveBtn = dropdown.querySelector('.prompt-preset-save-btn');
            
            btn.onclick = async (e) => {
                e.stopPropagation();
                // 다른 메뉴 닫기
                document.querySelectorAll('.prompt-preset-menu.show').forEach(m => {
                    if (m !== menu) m.classList.remove('show');
                });
                menu.classList.toggle('show');
                
                if (menu.classList.contains('show')) {
                    // 목록 로드
                    const presets = await loadPromptPresets(category);
                    if (presets.length === 0) {
                        list.innerHTML = '<div class="prompt-preset-empty">저장된 프리셋 없음</div>';
                    } else {
                        list.innerHTML = presets.map(p => `
                            <div class="prompt-preset-item" data-filename="${p.filename}">
                                <div class="prompt-preset-item-name" title="${p.name}">${p.name}</div>
                                <div class="prompt-preset-item-actions">
                                    <button class="add-btn">Add</button>
                                    <button class="replace-btn">Replace</button>
                                    <button class="delete-btn">🗑️</button>
                                </div>
                            </div>
                        `).join('');
                        
                        // 이벤트 바인딩
                        list.querySelectorAll('.prompt-preset-item').forEach(item => {
                            const filename = item.dataset.filename;
                            
                            item.querySelector('.add-btn').onclick = async (e) => {
                                e.stopPropagation();
                                const content = await getPromptPreset(category, filename);
                                if (content !== null) {
                                    if (textarea.value.trim()) {
                                        textarea.value = textarea.value.trim() + '\n\n' + content;
                                    } else {
                                        textarea.value = content;
                                    }
                                    menu.classList.remove('show');
                                }
                            };
                            
                            item.querySelector('.replace-btn').onclick = async (e) => {
                                e.stopPropagation();
                                const content = await getPromptPreset(category, filename);
                                if (content !== null) {
                                    textarea.value = content;
                                    menu.classList.remove('show');
                                }
                            };
                            
                            item.querySelector('.delete-btn').onclick = async (e) => {
                                e.stopPropagation();
                                showConfirmModal(
                                    '🗑️ 프리셋 삭제',
                                    '<p>이 프리셋을 삭제하시겠습니까?</p>',
                                    async () => {
                                        if (await deletePromptPreset(category, filename)) {
                                            item.remove();
                                            if (list.querySelectorAll('.prompt-preset-item').length === 0) {
                                                list.innerHTML = '<div class="prompt-preset-empty">저장된 프리셋 없음</div>';
                                            }
                                        }
                                    },
                                    '삭제',
                                    true
                                );
                            };
                        });
                    }
                }
            };
            
            saveBtn.onclick = async (e) => {
                e.stopPropagation();
                const content = textarea.value.trim();
                if (!content) {
                    showToast('저장할 내용 없음', 'warning');
                    return;
                }
                const name = prompt('프리셋 이름 입력:');
                if (!name) return;
                
                if (await savePromptPreset(category, name, content)) {
                    menu.classList.remove('show');
                }
            };
        }
        
        // Base/Negative 프롬프트 프리셋 초기화
        document.querySelectorAll('.section > .prompt-label-row .prompt-preset-dropdown').forEach(dropdown => {
            const category = dropdown.dataset.category;
            let textarea;
            if (category === 'base') {
                textarea = document.getElementById('basePrompt');
            } else if (category === 'negative') {
                textarea = document.getElementById('negativePrompt');
            }
            if (textarea) {
                setupPromptPresetDropdown(dropdown, textarea);
            }
        });
        
        // 외부 클릭 시 프롬프트 프리셋 메뉴 닫기
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.prompt-preset-dropdown')) {
                document.querySelectorAll('.prompt-preset-menu.show').forEach(m => m.classList.remove('show'));
            }
        });
        
        // === Characters ===
        const charactersList = document.getElementById('charactersList');
        const addCharBtn = document.getElementById('addCharBtn');
        
        function createCharacterItem(content = '', collapsed = false) {
            const item = document.createElement('div');
            item.className = 'character-item';

            // 헤더 (접기 + 번호 + 라벨 + 프리셋 + 삭제)
            const header = document.createElement('div');
            header.className = 'character-item-header';

            // 접기 버튼
            const collapseBtn = document.createElement('button');
            collapseBtn.type = 'button';
            collapseBtn.className = 'collapse-toggle' + (collapsed ? ' collapsed' : '');
            collapseBtn.textContent = '▼';
            collapseBtn.title = '접기/펼치기';

            const charNum = document.createElement('span');
            charNum.className = 'char-num';

            const charLabel = document.createElement('span');
            charLabel.className = 'char-label';
            charLabel.textContent = 'Character';

            // 프리셋 드롭다운
            const presetDropdown = document.createElement('div');
            presetDropdown.className = 'prompt-preset-dropdown';
            presetDropdown.dataset.category = 'character';
            presetDropdown.innerHTML = `
                <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">📁 ▼</button>
                <div class="prompt-preset-menu">
                    <div class="prompt-preset-list"></div>
                    <div class="prompt-preset-actions">
                        <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                    </div>
                </div>
            `;

            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'delete-char-btn';
            deleteBtn.textContent = '×';
            deleteBtn.onclick = () => {
                item.remove();
                updateCharacterNumbers();
                autoSaveSettings();
            };

            header.appendChild(collapseBtn);
            header.appendChild(charNum);
            header.appendChild(charLabel);
            header.appendChild(presetDropdown);
            header.appendChild(deleteBtn);

            // 프롬프트 입력 (접을 수 있는 영역)
            const contentDiv = document.createElement('div');
            contentDiv.className = 'collapsible-content' + (collapsed ? ' collapsed' : '');

            const textarea = document.createElement('textarea');
            textarea.value = content;
            textarea.placeholder = 'Character prompt...';
            textarea.rows = 2;

            contentDiv.appendChild(textarea);

            // 접기 버튼 이벤트
            collapseBtn.onclick = () => {
                collapseBtn.classList.toggle('collapsed');
                contentDiv.classList.toggle('collapsed');
                autoSaveSettings();
            };

            item.appendChild(header);
            item.appendChild(contentDiv);

            // 프리셋 드롭다운 이벤트 연결
            setupPromptPresetDropdown(presetDropdown, textarea);

            return item;
        }
        
        function updateCharacterNumbers() {
            const items = charactersList.querySelectorAll('.character-item');
            items.forEach((item, index) => {
                item.querySelector('.char-num').textContent = index + 1;
            });
            // 최대 6개 제한
            updateAddCharBtn();
        }
        
        function updateAddCharBtn() {
            const count = charactersList.querySelectorAll('.character-item').length;
            addCharBtn.disabled = count >= 6;
            addCharBtn.title = count >= 6 ? 'Maximum 6 characters' : 'Add character';
        }
        
        function addCharacter(content = '') {
            const count = charactersList.querySelectorAll('.character-item').length;
            if (count >= 6) {
                showToast('최대 6개의 캐릭터까지 가능', 'warning');
                return;
            }
            // Characters 섹션이 접혀있으면 펼치기
            const charactersContent = document.getElementById('charactersContent');
            if (charactersContent.classList.contains('collapsed')) {
                charactersContent.classList.remove('collapsed');
                // 토글 버튼 상태도 동기화
                const toggleBtn = document.querySelector('[data-target="charactersContent"]');
                if (toggleBtn) {
                    toggleBtn.classList.remove('collapsed');
                    localStorage.setItem('collapse_charactersContent', 'expanded');
                }
            }
            const item = createCharacterItem(content);
            charactersList.appendChild(item);
            updateCharacterNumbers();
            item.querySelector('textarea').focus();
        }
        
        function getCharacterPrompts() {
            const items = charactersList.querySelectorAll('.character-item');
            return Array.from(items).map(item => item.querySelector('textarea').value).filter(v => v.trim());
        }

        function getCharacterPromptsWithLayout() {
            const items = charactersList.querySelectorAll('.character-item');
            return Array.from(items).map(item => ({
                content: item.querySelector('textarea').value,
                collapsed: item.querySelector('.collapsible-content').classList.contains('collapsed'),
                height: item.querySelector('textarea').style.height || null
            }));
        }
        
        addCharBtn.onclick = () => {
            addCharacter();
            autoSaveSettings();
        };
        
        // Load resources
        async function loadResources() {
            try {
                const [modelsRes, lorasRes, upscaleRes, configRes] = await Promise.all([
                    fetch(`${API_BASE}/api/models`),
                    fetch(`${API_BASE}/api/loras`),
                    fetch(`${API_BASE}/api/upscale_models`),
                    fetch(`${API_BASE}/api/config`)
                ]);
                
                const { models } = await modelsRes.json();
                const { loras } = await lorasRes.json();
                const upscaleData = await upscaleRes.json();
                const config = await configRes.json();
                
                // Models
                const modelSelect = document.getElementById('localModel');
                modelSelect.innerHTML = '<option value="">-- Select Model --</option>';
                models.forEach(m => {
                    modelSelect.innerHTML += `<option value="${m}">${m}</option>`;
                });
                
                // LoRAs
                const loraList = document.getElementById('loraList');
                if (loras.length === 0) {
                    loraList.innerHTML = '<div style="color: var(--text-dim); font-size: 0.85rem; padding: 8px;">No LoRAs found</div>';
                } else {
                    loraList.innerHTML = loras.map(l => `
                        <div class="lora-item">
                            <input type="checkbox" data-lora="${l}">
                            <span class="lora-name" title="${l}">${l}</span>
                            <input type="number" value="1.0" step="0.1" min="0" max="2">
                        </div>
                    `).join('');
                }
                
                // Upscale Models
                const upscaleSelect = document.getElementById('upscaleModel');
                upscaleSelect.innerHTML = '<option value="">-- Select Model --</option>';
                (upscaleData.models || []).forEach(m => {
                    upscaleSelect.innerHTML += `<option value="${m}">${m}</option>`;
                });
                
                // Config
                document.getElementById('checkpointsDir').value = config.checkpoints_dir || '';
                document.getElementById('loraDir').value = config.lora_dir || '';
                updateNaiStatus(config.nai_token_set);
                
            } catch (e) {
                console.error('Failed to load:', e);
                statusText.textContent = '백엔드 실행 안됨!';
                showToast('백엔드 연결 안됨', 'error');
            }
        }
        
        function updateNaiStatus(hasToken) {
            naiTokenSet = hasToken;
            const badge = document.getElementById('naiStatus');
            if (hasToken) {
                badge.textContent = 'Connected';
                badge.className = 'status-badge success';
            } else {
                badge.textContent = 'Token not set';
                badge.className = 'status-badge warning';
            }
        }
        
        // NAI Token Modal
        function showNaiTokenModal() {
            document.getElementById('naiTokenModal').classList.add('active');
            document.getElementById('naiTokenModalInput').focus();
        }
        
        function closeNaiTokenModal() {
            document.getElementById('naiTokenModal').classList.remove('active');
        }
        
        async function saveNaiTokenFromModal() {
            const token = document.getElementById('naiTokenModalInput').value.trim();
            if (!token) {
                showToast('토큰을 입력하세요', 'error');
                return;
            }
            
            const btn = document.getElementById('naiTokenModalBtn');
            btn.textContent = '⏳ Saving...';
            btn.disabled = true;
            
            try {
                const res = await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nai_token: token })
                });
                
                if (res.ok) {
                    showToast('토큰 저장됨', 'success');
                    naiTokenSet = true;
                    updateNaiStatus(true);
                    closeNaiTokenModal();
                    
                    // Settings 모달의 토큰 필드도 업데이트
                    document.getElementById('naiToken').value = token;
                    
                    // 생성 진행
                    addToQueue();
                } else {
                    showToast('토큰 저장 실패', 'error');
                }
            } catch (e) {
                showToast('토큰 저장 실패', 'error');
            }
            
            btn.textContent = '💾 Save & Continue';
            btn.disabled = false;
        }
        
        // 모달 외부 클릭 및 Enter 키
        document.getElementById('naiTokenModal').addEventListener('click', (e) => {
            if (e.target.id === 'naiTokenModal') closeNaiTokenModal();
        });
        document.getElementById('naiTokenModalInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveNaiTokenFromModal();
        });
        
        function getSelectedLoras() {
            const loras = [];
            document.querySelectorAll('.lora-item').forEach(item => {
                const cb = item.querySelector('input[type="checkbox"]');
                const scale = item.querySelector('input[type="number"]');
                if (cb.checked) {
                    loras.push({ name: cb.dataset.lora, scale: parseFloat(scale.value) });
                }
            });
            return loras;
        }
        
        // Generate
        async function addToQueue() {
            // NAI 모드인데 토큰 없으면 팝업
            if (currentProvider === 'nai' && !naiTokenSet) {
                showNaiTokenModal();
                return;
            }
            
            // Complete 후 리셋 타이머 취소
            if (resetTimer) {
                clearTimeout(resetTimer);
                resetTimer = null;
            }
            
            // Complete 상태였다면 새로 시작
            if (totalImages > 0 && totalImages === currentIndex) {
                currentIndex = 0;
                totalImages = 0;
            }
            
            const slotList = getSlotList();
            const repeatCount = parseInt(document.getElementById('repeatCount').value) || 1;

            // 모든 슬롯 등록 (빈 슬롯도 포함)
            const promptCount = slotList.length || 1;

            // 백엔드용 데이터 변환
            const promptData = slotList.length > 0
                ? slotList.map(s => ({ name: s.name, content: s.content, slotIndex: s.slotIndex }))
                : [{ name: '', content: '', slotIndex: 0 }];

            console.log(`[Queue] Adding job: slots=${slotList.length}, promptData=`, promptData);
            
            const request = {
                provider: currentProvider,
                base_prompt: document.getElementById('basePrompt').value,
                negative_prompt: document.getElementById('negativePrompt').value,
                character_prompts: getCharacterPrompts(),
                prompt_list: promptData,
                width: parseInt(document.getElementById('width').value),
                height: parseInt(document.getElementById('height').value),
                steps: parseInt(document.getElementById('steps').value),
                cfg: parseFloat(document.getElementById('cfg').value),
                seed: parseInt(document.getElementById('seed').value),
                random_seed_per_image: document.getElementById('randomSeed').checked,
                sampler: document.getElementById('sampler').value,
                scheduler: document.getElementById('scheduler').value,
                output_folder: document.getElementById('outputFolder').value || '',
            };
            
            if (currentProvider === 'nai') {
                request.nai_model = document.getElementById('naiModel').value;
                request.smea = document.getElementById('smea').value;
                request.uc_preset = document.getElementById('ucPreset').value;
                request.quality_tags = document.getElementById('qualityTags').checked;
                request.furry_mode = furryModeEnabled;

                // Vibe Transfer
                if (document.getElementById('enableVibeTransfer').checked && vibeList.length > 0) {
                    request.vibe_transfer = vibeList.map(v => ({
                        image: v.image,
                        info_extracted: v.info_extracted,
                        strength: v.strength,
                        name: v.name || 'vibe'
                    }));
                }

                // Character Reference (V4.5 only)
                if (document.getElementById('enableCharRef').checked && charRefData) {
                    request.character_reference = {
                        image: charRefData.image,
                        fidelity: parseFloat(document.getElementById('charRefFidelity').value),
                        style_aware: document.getElementById('charRefStyleAware').checked
                    };
                }
            } else {
                request.model = document.getElementById('localModel').value;
                request.loras = getSelectedLoras();
                if (!request.model) {
                    showToast('모델을 선택하세요', 'error');
                    return;
                }
                
                // Upscale settings
                request.enable_upscale = document.getElementById('enableUpscale').checked;
                if (request.enable_upscale) {
                    request.upscale_model = document.getElementById('upscaleModel').value;
                    request.downscale_ratio = parseFloat(document.getElementById('downscaleRatio').value);
                    request.upscale_steps = parseInt(document.getElementById('upscaleSteps').value);
                    request.upscale_cfg = parseFloat(document.getElementById('upscaleCfg').value);
                    request.upscale_denoise = parseFloat(document.getElementById('upscaleDenoise').value);
                    request.size_alignment = document.getElementById('sizeAlignment').value;
                    
                    if (!request.upscale_model) {
                        showToast('업스케일 모델을 선택하세요', 'error');
                        return;
                    }
                }
            }
            
            // 시드 고정이 아닐 경우, 다음 큐를 위해 즉시 새 시드로 UI 갱신
            // (빠르게 여러 번 클릭해도 중복 시드 방지)
            if (!document.getElementById('lockSeed').checked) {
                document.getElementById('seed').value = Math.floor(Math.random() * 2147483647);
            }

            // N번 큐에 등록
            for (let i = 0; i < repeatCount; i++) {
                // 즉시 UI 업데이트
                totalImages += promptCount;
                updateProgress();

                try {
                    await fetch(`${API_BASE}/api/generate/multi`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(request)
                    });
                } catch (e) {
                    totalImages -= promptCount; // 실패 시 롤백
                    updateProgress();
                    showToast(`Error: ${e.message}`, 'error');
                }

                // 매번 새로운 시드
                request.seed = Math.floor(Math.random() * 2147483647);
            }

            showToast(`${repeatCount * promptCount} images queued`, 'success');
        }
        
        function updateProgress() {
            if (totalImages === 0) {
                statusText.textContent = '준비';
                progressFill.style.width = '0%';
            } else {
                statusText.textContent = `${currentIndex}/${totalImages}`;
                progressFill.style.width = `${(currentIndex / totalImages) * 100}%`;
            }
        }
        
        async function cancelCurrent() {
            try {
                const response = await fetch(`${API_BASE}/api/cancel-current`, { method: 'POST' });
                const result = await response.json();
                showToast(result.message, result.success ? 'warning' : 'error');
            } catch (e) {
                showToast(`Error: ${e.message}`, 'error');
            }
        }
        
        async function clearQueue() {
            try {
                const response = await fetch(`${API_BASE}/api/clear-queue`, { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    // 대기 이미지 수 제거
                    totalImages -= result.cleared_images;
                    if (totalImages < currentIndex) totalImages = currentIndex;
                    updateProgress();
                    showToast(`Cleared ${result.cleared_images} images`, 'warning');
                }
            } catch (e) {
                showToast(`Error: ${e.message}`, 'error');
            }
        }
        
        let lastSSETime = Date.now();
        let sseHealthCheckInterval = null;

        function connectSSE() {
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource(`${API_BASE}/api/stream`);
            lastSSETime = Date.now();

            eventSource.onmessage = (event) => {
                lastSSETime = Date.now();
                try {
                    const data = JSON.parse(event.data);
                    console.log(`[SSE Raw] type=${data.type}`, data.type === 'image' ? `prompt_idx=${data.prompt_idx}` : '');
                    handleSSEMessage(data);
                } catch (e) {
                    console.error('SSE parse error:', e);
                }
            };

            eventSource.onerror = () => {
                console.warn('SSE connection error, reconnecting...');
                setTimeout(connectSSE, 2000);
            };

            // SSE 헬스체크 - 30초간 메시지 없으면 재연결
            if (sseHealthCheckInterval) clearInterval(sseHealthCheckInterval);
            sseHealthCheckInterval = setInterval(() => {
                const timeSinceLastMessage = Date.now() - lastSSETime;
                if (timeSinceLastMessage > 30000) {
                    console.warn('SSE stale, reconnecting...');
                    connectSSE();
                }
            }, 10000);
        }
        
        // 서버 진행 상황 동기화 함수
        function syncProgressFromServer(data) {
            if (data.global_completed !== undefined && data.global_total !== undefined) {
                // 서버에서 보낸 전역 진행률로 동기화
                const serverCompleted = data.global_completed;
                const serverTotal = data.global_total;

                // 로컬 값이 서버보다 뒤처졌으면 동기화 (각 값 독립적으로)
                if (currentIndex < serverCompleted) {
                    currentIndex = serverCompleted;
                }
                if (totalImages < serverTotal) {
                    totalImages = serverTotal;
                }
                updateProgress();
            }
        }

        function handleSSEMessage(data) {
            switch (data.type) {
                case 'status':
                case 'heartbeat':
                    // 하트비트/상태로 프로그레스 동기화
                    syncProgressFromServer(data);
                    break;

                case 'job_start':
                    // 작업 시작 시 전역 total 동기화
                    if (data.global_total !== undefined) {
                        totalImages = data.global_total;
                        updateProgress();
                    }
                    break;

                case 'image':
                    console.log(`[SSE] Image received: prompt_idx=${data.prompt_idx}, filename=${data.filename}`);
                    // 서버 전역 진행률 사용 (SSE 누락 방지)
                    if (data.global_completed !== undefined) {
                        currentIndex = data.global_completed;
                    } else {
                        currentIndex++;
                    }
                    if (data.global_total !== undefined) {
                        totalImages = data.global_total;
                    }
                    updateProgress();
                    addImageToSlot(data.prompt_idx, data);
                    break;

                case 'job_done':
                    // Anlas 잔액 및 비용 갱신 (생성 완료 시)
                    if (currentProvider === 'nai') {
                        fetchAnlasBalance();
                        updateAnlasCost();  // Vibe 캐시 상태 갱신
                    }
                    // 서버 진행률로 동기화
                    if (data.global_completed !== undefined) {
                        currentIndex = data.global_completed;
                    }
                    if (data.global_total !== undefined) {
                        totalImages = data.global_total;
                    }
                    updateProgress();

                    if (data.queue_length === 0) {
                        // 완료 처리
                        statusText.textContent = '완료!';
                        progressFill.style.width = '100%';
                        showToast('완료', 'success');
                        // 기존 타이머 취소 후 새 타이머 설정
                        if (resetTimer) clearTimeout(resetTimer);
                        resetTimer = setTimeout(() => {
                            // 새 작업이 추가되지 않았을 때만 리셋
                            if (totalImages === currentIndex || totalImages === 0) {
                                currentIndex = 0;
                                totalImages = 0;
                                updateProgress();
                            }
                        }, 2000);
                    }
                    break;

                case 'job_cancelled':
                    syncProgressFromServer(data);
                    totalImages -= data.cancelled_images;
                    if (totalImages < currentIndex) totalImages = currentIndex;
                    updateProgress();
                    showToast('작업 취소됨', 'warning');
                    break;

                case 'queue_cleared':
                    syncProgressFromServer(data);
                    totalImages -= data.cleared_images;
                    if (totalImages < currentIndex) totalImages = currentIndex;
                    updateProgress();
                    break;

                case 'error':
                    // 서버 전역 진행률 사용
                    if (data.global_completed !== undefined) {
                        currentIndex = data.global_completed;
                    } else {
                        currentIndex++;
                    }
                    if (data.global_total !== undefined) {
                        totalImages = data.global_total;
                    }
                    updateProgress();
                    showToast(`Error: ${data.error || 'Generation failed'}`, 'error');
                    console.error('Generation error:', data.error);
                    break;
            }
        }
        
        function clearResults() {
            clearSlotImages();
            statusText.textContent = '준비';
            progressFill.style.width = '0%';
            currentIndex = 0;
            totalImages = 0;
        }
        
        // Lightbox
        lightbox.onclick = (e) => {
            if (e.target === lightbox || e.target.classList.contains('close')) {
                lightbox.classList.remove('active');
            }
        };
        
        // Settings
        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
            checkLocalEnvStatus();
        }
        
        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }
        
        // 모달 외부 클릭 시 닫기
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') closeSettings();
        });
        document.getElementById('localInstallModal').addEventListener('click', (e) => {
            if (e.target.id === 'localInstallModal') closeLocalInstallModal();
        });
        
        async function saveSettings() {
            const config = {
                nai_token: document.getElementById('naiToken').value || null,
                checkpoints_dir: document.getElementById('checkpointsDir').value || null,
                lora_dir: document.getElementById('loraDir').value || null,
            };
            
            try {
                const res = await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                if (res.ok) {
                    showToast('설정 저장됨', 'success');
                    closeSettings();
                }
            } catch (e) {
                showToast('저장 실패', 'error');
            }
        }
        
        // Local Environment
        let localEnvPollInterval = null;
        
        async function checkLocalEnvStatus() {
            try {
                const res = await fetch(`${API_BASE}/api/local/status`);
                const data = await res.json();
                updateLocalEnvUI(data);
                return data;
            } catch (e) {
                console.error('Failed to check local env status:', e);
                return null;
            }
        }
        
        function updateLocalEnvUI(data) {
            const statusEl = document.getElementById('localEnvStatus');
            const actionsEl = document.getElementById('localEnvActions');
            const progressEl = document.getElementById('localEnvProgress');
            const progressFillEl = document.getElementById('localEnvProgressFill');
            const progressTextEl = document.getElementById('localEnvProgressText');
            
            if (data.installing) {
                statusEl.className = 'local-env-status installing';
                statusEl.innerHTML = `<span class="status-icon">⏳</span><span class="status-text">${data.message || 'Installing...'}</span>`;
                actionsEl.innerHTML = '';
                progressEl.style.display = 'flex';
                progressFillEl.style.width = `${data.progress}%`;
                progressTextEl.textContent = `${data.progress}%`;
                
                // 폴링 시작
                if (!localEnvPollInterval) {
                    localEnvPollInterval = setInterval(checkLocalEnvStatus, 1000);
                }
            } else if (data.error) {
                statusEl.className = 'local-env-status error';
                statusEl.innerHTML = `<span class="status-icon">❌</span><span class="status-text">Error: ${data.error}</span>`;
                actionsEl.innerHTML = `<button class="btn" onclick="installLocalEnv()">Retry Install</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
            } else if (data.installed) {
                statusEl.className = 'local-env-status installed';
                statusEl.innerHTML = `<span class="status-icon">✅</span><span class="status-text">Installed</span>`;
                actionsEl.innerHTML = `<button class="btn btn-danger" onclick="uninstallLocalEnv()">Uninstall</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
                
                // Local 탭 활성화
                enableLocalTab(true);
                
                // 저장된 provider가 local이었으면 자동 전환
                if (window._pendingProvider === 'local') {
                    window._pendingProvider = null;
                    currentProvider = 'local';
                    tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === 'local'));
                    providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === 'local'));
                    // 샘플러/스케줄러도 Local 옵션으로 변경
                    updateSamplerSchedulerOptions('local');
                    // 저장된 값 복원
                    if (window._pendingSampler) {
                        const samplerSelect = document.getElementById('sampler');
                        if ([...samplerSelect.options].some(o => o.value === window._pendingSampler)) {
                            samplerSelect.value = window._pendingSampler;
                        }
                        window._pendingSampler = null;
                    }
                    if (window._pendingScheduler) {
                        const schedulerSelect = document.getElementById('scheduler');
                        if ([...schedulerSelect.options].some(o => o.value === window._pendingScheduler)) {
                            schedulerSelect.value = window._pendingScheduler;
                        }
                        window._pendingScheduler = null;
                    }
                };
            } else {
                statusEl.className = 'local-env-status not-installed';
                statusEl.innerHTML = `<span class="status-icon">⚠️</span><span class="status-text">Not installed</span>`;
                actionsEl.innerHTML = `<button class="btn" onclick="installLocalEnv()">Install Local Engine</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
                
                // Local 탭 비활성화
                enableLocalTab(false);
            }
        }
        
        function stopLocalEnvPolling() {
            if (localEnvPollInterval) {
                clearInterval(localEnvPollInterval);
                localEnvPollInterval = null;
            }
        }
        
        function enableLocalTab(enabled) {
            localEnvInstalled = enabled;
            const localTab = document.querySelector('.tab[data-provider="local"]');
            if (localTab) {
                if (enabled) {
                    localTab.classList.remove('disabled');
                    localTab.style.opacity = '1';
                } else {
                    localTab.classList.add('disabled');
                    localTab.style.opacity = '0.6';
                }
                // pointerEvents는 항상 auto로 - 클릭 감지 필요
                localTab.style.pointerEvents = 'auto';
            }
        }
        
        // Local Install Modal
        function showLocalInstallModal() {
            document.getElementById('localInstallModal').classList.add('active');
            updateInstallModalStatus();
        }
        
        function closeLocalInstallModal() {
            document.getElementById('localInstallModal').classList.remove('active');
        }
        
        function updateInstallModalStatus() {
            const statusEl = document.getElementById('installModalStatus');
            const progressEl = document.getElementById('installModalProgress');
            const btn = document.getElementById('installModalBtn');
            
            fetch(`${API_BASE}/api/local/status`)
                .then(res => res.json())
                .then(data => {
                    if (data.installed) {
                        statusEl.className = 'local-env-status installed';
                        statusEl.innerHTML = '<span class="status-text">✅ Installed</span>';
                        progressEl.style.display = 'none';
                        btn.textContent = '✓ Already Installed';
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        // 잠시 후 팝업 닫고 탭 전환
                        setTimeout(() => {
                            closeLocalInstallModal();
                            localEnvInstalled = true;
                            // Local 탭으로 전환
                            currentProvider = 'local';
                            tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === 'local'));
                            providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === 'local'));
                        }, 500);
                    } else if (data.installing) {
                        statusEl.className = 'local-env-status installing';
                        statusEl.innerHTML = `<span class="status-text">⏳ ${data.message || 'Installing...'}</span>`;
                        progressEl.style.display = 'flex';
                        document.getElementById('installModalProgressFill').style.width = `${data.progress || 0}%`;
                        document.getElementById('installModalProgressText').textContent = `${data.progress || 0}%`;
                        btn.textContent = '⏳ Installing...';
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        // 계속 폴링
                        setTimeout(updateInstallModalStatus, 1000);
                    } else if (data.error) {
                        statusEl.className = 'local-env-status error';
                        statusEl.innerHTML = `<span class="status-text">❌ ${data.error}</span>`;
                        progressEl.style.display = 'none';
                        btn.textContent = '🔄 Retry Install';
                        btn.disabled = false;
                        btn.style.opacity = '1';
                    } else {
                        statusEl.className = 'local-env-status not-installed';
                        statusEl.innerHTML = '<span class="status-text">⚠️ Not installed</span>';
                        progressEl.style.display = 'none';
                        btn.textContent = '⬇️ Install (~3GB)';
                        btn.disabled = false;
                        btn.style.opacity = '1';
                    }
                })
                .catch(() => {
                    statusEl.className = 'local-env-status error';
                    statusEl.innerHTML = '<span class="status-text">❌ Backend not connected</span>';
                });
        }
        
        async function installFromModal() {
            const btn = document.getElementById('installModalBtn');
            btn.textContent = '⏳ Starting...';
            btn.disabled = true;
            
            try {
                const res = await fetch(`${API_BASE}/api/local/install`, { method: 'POST' });
                if (res.ok) {
                    showToast('설치 시작됨', 'success');
                    updateInstallModalStatus();
                    checkLocalEnvStatus();  // Settings 모달도 업데이트
                } else {
                    const data = await res.json();
                    showToast(data.detail || 'Failed to start installation', 'error');
                    btn.textContent = '⬇️ Install (~3GB)';
                    btn.disabled = false;
                }
            } catch (e) {
                showToast('설치 시작 실패', 'error');
                btn.textContent = '⬇️ Install (~3GB)';
                btn.disabled = false;
            }
        }
        
        async function installLocalEnv() {
            try {
                const res = await fetch(`${API_BASE}/api/local/install`, { method: 'POST' });
                if (res.ok) {
                    showToast('설치 시작됨', 'success');
                    checkLocalEnvStatus();
                } else {
                    const data = await res.json();
                    showToast(data.detail || 'Failed to start installation', 'error');
                }
            } catch (e) {
                showToast('설치 시작 실패', 'error');
            }
        }
        
        async function uninstallLocalEnv() {
            showConfirmModal(
                '🗑️ 로컬 엔진 제거',
                '<p>로컬 생성 엔진을 제거하시겠습니까?</p><p style="color: var(--text-dim); font-size: 0.9rem;">약 3GB 디스크 공간이 확보됩니다.</p>',
                async () => {
                    try {
                        const res = await fetch(`${API_BASE}/api/local/uninstall`, { method: 'DELETE' });
                        if (res.ok) {
                            showToast('제거됨', 'success');
                            checkLocalEnvStatus();
                        }
                    } catch (e) {
                        showToast('제거 실패', 'error');
                    }
                },
                '제거',
                true
            );
        }
        
        // Toast
        function showToast(msg, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.className = 'toast show ' + type;
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Generic Confirm Modal
        function showConfirmModal(title, message, onConfirm, confirmText = '확인', isDanger = false) {
            const modal = document.getElementById('confirmModal');
            document.getElementById('confirmModalTitle').textContent = title;
            document.getElementById('confirmModalMessage').innerHTML = message;
            const okBtn = document.getElementById('confirmModalOk');
            okBtn.textContent = confirmText;
            okBtn.className = isDanger ? 'btn btn-danger' : 'btn';
            okBtn.style.background = isDanger ? 'var(--error)' : '';

            // 이벤트 리스너 정리 후 재설정
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            const newCancelBtn = document.getElementById('confirmModalCancel').cloneNode(true);
            document.getElementById('confirmModalCancel').parentNode.replaceChild(newCancelBtn, document.getElementById('confirmModalCancel'));

            newOkBtn.onclick = () => {
                modal.classList.remove('active');
                if (onConfirm) onConfirm();
            };
            newCancelBtn.onclick = () => {
                modal.classList.remove('active');
            };

            modal.classList.add('active');
        }

        function showInputModal(title, message, onConfirm, confirmText = '확인', defaultValue = '') {
            const modal = document.getElementById('inputModal');
            document.getElementById('inputModalTitle').textContent = title;
            document.getElementById('inputModalMessage').textContent = message;
            const input = document.getElementById('inputModalInput');
            input.value = defaultValue;

            const okBtn = document.getElementById('inputModalOk');
            okBtn.textContent = confirmText;

            // 이벤트 리스너 정리 후 재설정
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            const newCancelBtn = document.getElementById('inputModalCancel').cloneNode(true);
            document.getElementById('inputModalCancel').parentNode.replaceChild(newCancelBtn, document.getElementById('inputModalCancel'));

            newOkBtn.onclick = () => {
                const value = input.value.trim();
                if (value) {
                    modal.classList.remove('active');
                    if (onConfirm) onConfirm(value);
                }
            };
            newCancelBtn.onclick = () => {
                modal.classList.remove('active');
            };
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    newOkBtn.click();
                } else if (e.key === 'Escape') {
                    modal.classList.remove('active');
                }
            };

            modal.classList.add('active');
            setTimeout(() => input.focus(), 100);
        }

        // 설정 불러오기 확인 팝업 (드롭 모달 재사용)
        function showLoadSettingsConfirm(metadata) {
            const dropModal = document.getElementById('dropModal');
            document.getElementById('dropModalTitle').textContent = '📋 설정 불러오기';
            document.getElementById('dropModalPreview').src = '';
            document.getElementById('dropModalPreview').style.display = 'none';

            // 캐릭터 프롬프트 정보
            const charPrompts = metadata.character_prompts || [];
            const charPromptsHtml = charPrompts.length > 0
                ? `<div><strong>캐릭터 (${charPrompts.length}):</strong> ${charPrompts.map((c, i) => `[${i+1}] ${(c || '').substring(0, 30)}${(c || '').length > 30 ? '...' : ''}`).join(', ')}</div>`
                : '';

            const metadataDiv = document.getElementById('dropModalMetadata');
            metadataDiv.innerHTML = `
                <div><strong>Prompt:</strong> ${(metadata.prompt || '').substring(0, 100)}${(metadata.prompt || '').length > 100 ? '...' : ''}</div>
                <div><strong>Negative:</strong> ${(metadata.negative_prompt || '').substring(0, 50)}${(metadata.negative_prompt || '').length > 50 ? '...' : ''}</div>
                ${charPromptsHtml}
                <div><strong>Seed:</strong> ${metadata.seed || 'N/A'}</div>
                <div><strong>Size:</strong> ${metadata.width}x${metadata.height}</div>
                <div><strong>Steps:</strong> ${metadata.steps}, <strong>CFG:</strong> ${metadata.cfg}</div>
                <div><strong>Sampler:</strong> ${metadata.sampler}</div>
                <div><strong>Model:</strong> ${metadata.nai_model || metadata.model || 'N/A'}</div>
            `;

            document.getElementById('dropModalConfirm').textContent = '설정 적용';

            // 임시 데이터 저장
            window._pendingLoadMetadata = metadata;

            dropModal.classList.add('active');
        }

        // 메타데이터 설정 적용
        function applyMetadataSettings(metadata) {
            // 프롬프트
            if (metadata.prompt) document.getElementById('basePrompt').value = metadata.prompt;
            if (metadata.negative_prompt) document.getElementById('negativePrompt').value = metadata.negative_prompt;

            // 캐릭터 프롬프트 적용
            if (metadata.character_prompts && metadata.character_prompts.length > 0) {
                // 기존 캐릭터 슬롯 모두 제거
                const charactersList = document.getElementById('charactersList');
                charactersList.innerHTML = '';
                // 새 캐릭터 프롬프트 추가
                metadata.character_prompts.forEach(cp => {
                    if (cp && cp.trim()) {
                        addCharacter(cp);
                    }
                });
                updateCharacterNumbers();
            }

            // 크기
            if (metadata.width) document.getElementById('width').value = metadata.width;
            if (metadata.height) document.getElementById('height').value = metadata.height;
            // 사이즈 프리셋 체크
            const sizeValue = `${metadata.width}x${metadata.height}`;
            const sizePreset = document.getElementById('sizePreset');
            const matchingOption = [...sizePreset.options].find(o => o.value === sizeValue);
            sizePreset.value = matchingOption ? sizeValue : 'custom';

            // 생성 설정
            if (metadata.steps) document.getElementById('steps').value = metadata.steps;
            if (metadata.cfg) document.getElementById('cfg').value = metadata.cfg;
            if (metadata.seed) document.getElementById('seed').value = metadata.seed;
            if (metadata.sampler) document.getElementById('sampler').value = metadata.sampler;
            if (metadata.scheduler) document.getElementById('scheduler').value = metadata.scheduler;

            // NAI 설정
            if (metadata.nai_model) document.getElementById('naiModel').value = metadata.nai_model;
            if (metadata.smea) document.getElementById('smea').value = metadata.smea;
            if (metadata.uc_preset) document.getElementById('ucPreset').value = metadata.uc_preset;
            if (metadata.quality_tags !== undefined) document.getElementById('qualityTags').checked = metadata.quality_tags;

            // Local 설정
            if (metadata.model) document.getElementById('localModel').value = metadata.model;

            // Provider 설정
            if (metadata.provider && metadata.provider !== currentProvider) {
                // Provider 변경은 복잡하므로 알림만
                showToast(`원본 Provider: ${metadata.provider}`, 'warning');
            }

            autoSaveSettings();
            showToast('설정을 불러왔습니다', 'success');
        }

        // Event listeners
        generateBtn.onclick = addToQueue;
        cancelCurrentBtn.onclick = cancelCurrent;
        clearQueueBtn.onclick = clearQueue;
        document.getElementById('clearImagesBtn').onclick = clearResults;

        // Anime/Furry Mode Toggle
        let furryModeEnabled = false;
        const modeToggle = document.getElementById('modeToggle');

        function setFurryMode(enabled) {
            furryModeEnabled = enabled;
            if (enabled) {
                modeToggle.textContent = '🐾';
                modeToggle.title = '퍼리 모드';
                modeToggle.classList.add('furry');
            } else {
                modeToggle.textContent = '🌸';
                modeToggle.title = '아니메 모드';
                modeToggle.classList.remove('furry');
            }
            autoSaveSettings();
        }

        modeToggle.onclick = () => {
            setFurryMode(!furryModeEnabled);
        };

        // Collapse toggle for prompts and sections
        document.querySelectorAll('.collapse-toggle').forEach(btn => {
            const targetId = btn.dataset.target;
            const target = document.getElementById(targetId);

            // Restore collapse state from localStorage
            const savedState = localStorage.getItem(`collapse_${targetId}`);
            if (savedState === 'collapsed' && target) {
                btn.classList.add('collapsed');
                target.classList.add('collapsed');
            }

            btn.onclick = () => {
                if (target) {
                    btn.classList.toggle('collapsed');
                    target.classList.toggle('collapsed');
                    // Save state to localStorage
                    localStorage.setItem(`collapse_${targetId}`, btn.classList.contains('collapsed') ? 'collapsed' : 'expanded');
                }
            };
        });

        // 폴더 열기 버튼 핸들러
        async function openFolder(folderType, subfolder = '') {
            try {
                const response = await fetch(`${API_BASE}/api/open-folder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder: folderType, subfolder: subfolder })
                });
                const data = await response.json();
                if (data.error) {
                    showToast(`폴더 열기 실패: ${data.error}`, 'error');
                }
            } catch (e) {
                showToast('폴더 열기 실패', 'error');
            }
        }

        document.getElementById('openOutputFolderBtn').onclick = () => {
            const subfolder = document.getElementById('outputFolder').value.trim();
            openFolder('outputs', subfolder);
        };
        document.getElementById('openVibeFolderBtn').onclick = () => openFolder('vibe_cache');
        document.getElementById('openCheckpointsFolderBtn').onclick = () => openFolder('checkpoints');
        document.getElementById('openLorasFolderBtn').onclick = () => openFolder('loras');

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                lightbox.classList.remove('active');
                closeSettings();
            }
            if (e.ctrlKey && e.key === 'Enter') {
                addToQueue();
            }
        });
        
        // 탭 활성화 시 SSE 재연결 (백그라운드 throttling 대응)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                connectSSE();
            }
        });
        
        // Size Preset
        const sizePreset = document.getElementById('sizePreset');
        const widthInput = document.getElementById('width');
        const heightInput = document.getElementById('height');
        
        sizePreset.onchange = () => {
            const value = sizePreset.value;
            if (value !== 'custom') {
                const [w, h] = value.split('x').map(Number);
                widthInput.value = w;
                heightInput.value = h;
            }
            updateAnlasCost();
        };
        
        // Width/Height 직접 수정 시 Custom으로 변경
        function checkCustomSize() {
            const w = widthInput.value;
            const h = heightInput.value;
            const currentValue = `${w}x${h}`;
            
            // 프리셋에 있는 값인지 확인
            const options = [...sizePreset.options];
            const match = options.find(opt => opt.value === currentValue);
            
            if (match) {
                sizePreset.value = currentValue;
            } else {
                sizePreset.value = 'custom';
            }
        }
        
        widthInput.onchange = checkCustomSize;
        heightInput.onchange = checkCustomSize;
        
        // Upscale toggle
        document.getElementById('enableUpscale').onchange = function() {
            document.getElementById('upscaleSettings').style.display = this.checked ? 'block' : 'none';
        };

        // Upscale denoise slider value display
        document.getElementById('upscaleDenoise').oninput = function() {
            document.getElementById('upscaleDenoiseValue').textContent = this.value;
        };

        // ============================================================
        // Vibe Transfer
        // ============================================================
        let vibeList = []; // {image: base64, info_extracted: 1.0, strength: 0.6}

        document.getElementById('enableVibeTransfer').onchange = function() {
            document.getElementById('vibeTransferSettings').style.display = this.checked ? 'block' : 'none';
            // Vibe Transfer와 Character Reference는 동시 사용 불가
            if (this.checked && document.getElementById('enableCharRef').checked) {
                document.getElementById('enableCharRef').checked = false;
                document.getElementById('charRefSettings').style.display = 'none';
            }
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('addVibeBtn').onclick = function() {
            if (vibeList.length >= 16) {
                alert('최대 16개까지만 추가할 수 있습니다.');
                return;
            }
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const base64 = await fileToBase64(file);
                vibeList.push({
                    image: base64,
                    info_extracted: 1.0,
                    strength: 0.6,
                    name: file.name
                });
                renderVibeList();
                saveAppSettings();
                updateAnlasCost();
            };
            input.click();
        };

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    // data:image/png;base64,XXXXX -> XXXXX 만 추출
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function renderVibeList() {
            const container = document.getElementById('vibeList');
            container.innerHTML = '';
            vibeList.forEach((vibe, idx) => {
                const item = document.createElement('div');
                item.className = 'vibe-item';
                item.innerHTML = `
                    <div class="vibe-item-header">
                        <img src="data:image/png;base64,${vibe.image}" alt="vibe">
                        <span class="vibe-info">${vibe.name || 'Vibe ' + (idx + 1)}</span>
                        <button type="button" class="remove-btn" data-idx="${idx}">×</button>
                    </div>
                    <div class="vibe-sliders">
                        <div class="vibe-slider-row">
                            <label>Strength</label>
                            <input type="range" class="vibe-strength" data-idx="${idx}" value="${vibe.strength}" min="0" max="1" step="0.05">
                            <span class="value">${vibe.strength}</span>
                        </div>
                        <div class="vibe-slider-row">
                            <label>Info Extract</label>
                            <input type="range" class="vibe-info" data-idx="${idx}" value="${vibe.info_extracted}" min="0.01" max="1" step="0.01">
                            <span class="value">${vibe.info_extracted}</span>
                        </div>
                    </div>
                `;
                container.appendChild(item);
            });

            // Event listeners
            container.querySelectorAll('.remove-btn').forEach(btn => {
                btn.onclick = function() {
                    vibeList.splice(parseInt(this.dataset.idx), 1);
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                };
            });
            container.querySelectorAll('.vibe-strength').forEach(slider => {
                slider.oninput = function() {
                    const idx = parseInt(this.dataset.idx);
                    vibeList[idx].strength = parseFloat(this.value);
                    this.nextElementSibling.textContent = this.value;
                    saveAppSettings();
                };
            });
            container.querySelectorAll('.vibe-info').forEach(slider => {
                slider.oninput = function() {
                    const idx = parseInt(this.dataset.idx);
                    vibeList[idx].info_extracted = parseFloat(this.value);
                    this.nextElementSibling.textContent = this.value;
                    saveAppSettings();
                    updateAnlasCost();  // info_extracted 변경시 캐시 상태 재확인
                };
            });
        }

        // ============================================================
        // Character Reference (V4.5 only)
        // ============================================================
        let charRefData = null; // {image: base64, fidelity: 0.5, style_aware: true}

        document.getElementById('enableCharRef').onchange = function() {
            document.getElementById('charRefSettings').style.display = this.checked ? 'block' : 'none';
            // Vibe Transfer와 Character Reference는 동시 사용 불가
            if (this.checked && document.getElementById('enableVibeTransfer').checked) {
                document.getElementById('enableVibeTransfer').checked = false;
                document.getElementById('vibeTransferSettings').style.display = 'none';
            }
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('uploadCharRefBtn').onclick = function() {
            document.getElementById('charRefInput').click();
        };

        document.getElementById('charRefInput').onchange = async function() {
            const file = this.files[0];
            if (!file) return;
            const base64 = await fileToBase64(file);
            charRefData = {
                image: base64,
                fidelity: parseFloat(document.getElementById('charRefFidelity').value),
                style_aware: document.getElementById('charRefStyleAware').checked
            };
            document.getElementById('charRefImage').src = 'data:image/png;base64,' + base64;
            document.getElementById('charRefPreview').style.display = 'block';
            document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('removeCharRefBtn').onclick = function() {
            charRefData = null;
            document.getElementById('charRefPreview').style.display = 'none';
            document.getElementById('uploadCharRefBtn').textContent = '이미지 선택';
            document.getElementById('charRefInput').value = '';
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('charRefFidelity').oninput = function() {
            document.getElementById('charRefFidelityValue').textContent = this.value;
            if (charRefData) {
                charRefData.fidelity = parseFloat(this.value);
                saveAppSettings();
            }
        };

        document.getElementById('charRefStyleAware').onchange = function() {
            if (charRefData) {
                charRefData.style_aware = this.checked;
                saveAppSettings();
            }
        };

        // ============================================================
        // Anlas System
        // ============================================================
        let currentAnlas = null;
        let isOpusTier = false;

        async function fetchAnlasBalance() {
            try {
                const response = await fetch(`${API_BASE}/api/nai/subscription`);
                const data = await response.json();

                if (data.error) {
                    document.getElementById('anlasBalance').textContent = 'Error';
                    return;
                }

                currentAnlas = data.anlas;
                isOpusTier = data.tier >= 3; // Tier 3 = Opus
                console.log('[Anlas] Subscription loaded:', { tier: data.tier, isOpusTier, anlas: currentAnlas });

                document.getElementById('anlasBalance').textContent =
                    currentAnlas !== null ? currentAnlas.toLocaleString() : '--';

                updateAnlasCost();
            } catch (e) {
                console.error('[Anlas] Failed to fetch subscription:', e);
                document.getElementById('anlasBalance').textContent = '--';
            }
        }

        async function updateAnlasCost() {
            if (currentProvider !== 'nai') return;

            const width = parseInt(document.getElementById('width').value) || 832;
            const height = parseInt(document.getElementById('height').value) || 1216;
            const steps = parseInt(document.getElementById('steps').value) || 28;
            const vibeEnabled = document.getElementById('enableVibeTransfer').checked;
            const vibeCount = vibeEnabled ? vibeList.length : 0;
            const hasCharRef = document.getElementById('enableCharRef').checked && charRefData !== null;
            const repeatCount = parseInt(document.getElementById('repeatCount').value) || 1;
            const slotCount = document.querySelectorAll('.slot').length || 1;
            const totalCount = repeatCount * slotCount;
            const naiModel = document.getElementById('naiModel').value;

            // Vibe 데이터 (캐시 체크용)
            const vibes = vibeEnabled ? vibeList.map(v => ({
                image: v.image,
                info_extracted: v.info_extracted
            })) : [];

            try {
                const response = await fetch(`${API_BASE}/api/nai/calculate-cost`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        width, height, steps,
                        is_opus: isOpusTier,
                        vibe_count: vibeCount,
                        has_char_ref: hasCharRef,
                        count: totalCount,
                        vibes: vibes,
                        model: naiModel
                    })
                });
                const data = await response.json();
                console.log('[Cost Response]', data);

                if (data.is_free && data.vibe_encoding_cost === 0) {
                    document.getElementById('anlasCost').style.display = 'none';
                    document.getElementById('anlasFreeTag').style.display = 'inline';
                } else {
                    document.getElementById('anlasCost').style.display = 'inline';
                    document.getElementById('anlasFreeTag').style.display = 'none';

                    // Vibe 인코딩 비용 (일회성, 바이브 갯수만큼)
                    if (data.vibe_encoding_cost > 0) {
                        document.getElementById('anlasCost').textContent =
                            `${data.vibe_encoding_cost} (바이브 ${data.uncached_vibes}개)`;
                    }
                    // 일반 생성 비용 (CharRef 등)
                    else {
                        let costText = data.total_cost.toLocaleString();
                        if (slotCount > 1 || repeatCount > 1) {
                            let breakdown = `${data.cost_per_image}`;
                            if (slotCount > 1) breakdown += ` × ${slotCount}슬롯`;
                            if (repeatCount > 1) breakdown += ` × ${repeatCount}회`;
                            costText += ` (${breakdown})`;
                        }
                        document.getElementById('anlasCost').textContent = costText;
                    }
                }

                // Vibe 캐시 상태 표시
                const vibeCacheInfo = document.getElementById('vibeCacheInfo');
                if (vibeCacheInfo && vibes.length > 0) {
                    if (data.cached_vibes > 0 && data.uncached_vibes === 0) {
                        vibeCacheInfo.textContent = `✓ ${data.cached_vibes}개 캐시됨 (무료)`;
                        vibeCacheInfo.style.color = '#4CAF82';
                    } else if (data.uncached_vibes > 0) {
                        vibeCacheInfo.textContent = `${data.uncached_vibes}개 인코딩 필요 (+${data.vibe_encoding_cost} Anlas)`;
                        vibeCacheInfo.style.color = '#F5B942';
                    }
                    vibeCacheInfo.style.display = 'block';
                } else if (vibeCacheInfo) {
                    vibeCacheInfo.style.display = 'none';
                }
            } catch (e) {
                document.getElementById('anlasCost').textContent = '?';
            }
        }

        // Anlas UI 표시/숨김 (provider에 따라)
        function updateAnlasVisibility() {
            const anlasInfo = document.getElementById('anlasInfo');
            if (currentProvider === 'nai') {
                anlasInfo.style.display = 'block';
                fetchAnlasBalance();
            } else {
                anlasInfo.style.display = 'none';
            }
        }

        // Anlas 새로고침 버튼
        document.getElementById('refreshAnlasBtn').onclick = function() {
            this.style.transform = 'rotate(360deg)';
            setTimeout(() => this.style.transform = '', 300);
            fetchAnlasBalance();
        };

        // 설정 변경시 비용 재계산
        ['width', 'height', 'steps', 'repeatCount'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', updateAnlasCost);
            }
        });

        // Vibe/CharRef/모델 변경시 비용 재계산
        document.getElementById('enableVibeTransfer').addEventListener('change', updateAnlasCost);
        document.getElementById('enableCharRef').addEventListener('change', updateAnlasCost);
        document.getElementById('naiModel').addEventListener('change', () => {
            updateAnlasCost();
            updateSmeaVisibility();
        });

        // V4+ 모델에서 SMEA 비활성화
        function updateSmeaVisibility() {
            const model = document.getElementById('naiModel').value;
            const isV4 = model.includes('diffusion-4');
            const smeaSelect = document.getElementById('smea');
            const smeaContainer = smeaSelect.parentElement;

            if (isV4) {
                smeaSelect.value = 'none';
                smeaContainer.style.opacity = '0.5';
                smeaSelect.disabled = true;
                smeaContainer.title = 'V4+ 모델에서는 SMEA를 지원하지 않습니다';
            } else {
                smeaContainer.style.opacity = '1';
                smeaSelect.disabled = false;
                smeaContainer.title = '';
            }
        }
        updateSmeaVisibility(); // 초기 실행

        // ============================================================
        // Settings Persistence (localStorage)
        // ============================================================
        const SETTINGS_KEY = 'nai_generator_settings';
        
        function saveAppSettings() {
            const settings = {
                // Provider
                provider: currentProvider,

                // Prompts
                basePrompt: document.getElementById('basePrompt').value,
                negativePrompt: document.getElementById('negativePrompt').value,

                // Prompt layout (heights and collapse states)
                basePromptHeight: document.getElementById('basePrompt').style.height || null,
                negativePromptHeight: document.getElementById('negativePrompt').style.height || null,
                basePromptCollapsed: document.getElementById('basePromptContent').classList.contains('collapsed'),
                charactersCollapsed: document.getElementById('charactersContent').classList.contains('collapsed'),
                negativePromptCollapsed: document.getElementById('negativePromptContent').classList.contains('collapsed'),

                // Size
                sizePreset: document.getElementById('sizePreset').value,
                width: document.getElementById('width').value,
                height: document.getElementById('height').value,
                
                // Generation
                steps: document.getElementById('steps').value,
                cfg: document.getElementById('cfg').value,
                sampler: document.getElementById('sampler').value,
                scheduler: document.getElementById('scheduler').value,
                randomSeed: document.getElementById('randomSeed').checked,
                lockSeed: document.getElementById('lockSeed').checked,

                // NAI
                naiModel: document.getElementById('naiModel').value,
                smea: document.getElementById('smea').value,
                ucPreset: document.getElementById('ucPreset').value,
                qualityTags: document.getElementById('qualityTags').checked,
                furryModeEnabled: furryModeEnabled,

                // Vibe Transfer
                enableVibeTransfer: document.getElementById('enableVibeTransfer').checked,
                vibeList: vibeList,

                // Character Reference
                enableCharRef: document.getElementById('enableCharRef').checked,
                charRefData: charRefData,
                charRefFidelity: document.getElementById('charRefFidelity').value,
                charRefStyleAware: document.getElementById('charRefStyleAware').checked,

                // Local
                localModel: document.getElementById('localModel').value,
                
                // Upscale
                enableUpscale: document.getElementById('enableUpscale').checked,
                upscaleModel: document.getElementById('upscaleModel').value,
                downscaleRatio: document.getElementById('downscaleRatio').value,
                sizeAlignment: document.getElementById('sizeAlignment').value,
                upscaleSteps: document.getElementById('upscaleSteps').value,
                upscaleCfg: document.getElementById('upscaleCfg').value,
                upscaleDenoise: document.getElementById('upscaleDenoise').value,
                
                // Output
                outputFolder: document.getElementById('outputFolder').value,
                repeatCount: document.getElementById('repeatCount').value,
                
                // Slots
                slots: getSlotList(),
                slotWidth: currentSlotWidth,
                sidebarWidth: currentSidebarWidth,

                // Character prompts (with layout)
                characterPromptsLayout: getCharacterPromptsWithLayout(),
            };
            
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        }
        
        function loadAppSettings() {
            const saved = localStorage.getItem(SETTINGS_KEY);
            if (!saved) return;
            
            try {
                const settings = JSON.parse(saved);
                
                // Provider - local은 설치 상태 확인 후 적용
                if (settings.provider) {
                    if (settings.provider === 'local') {
                        // local은 나중에 checkLocalEnvStatus에서 설치 확인 후 적용
                        window._pendingProvider = 'local';
                        // 일단 NAI로 설정
                        currentProvider = 'nai';
                    } else {
                        currentProvider = settings.provider;
                    }
                    tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === currentProvider));
                    providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === currentProvider));
                }
                
                // Prompts
                if (settings.basePrompt !== undefined) document.getElementById('basePrompt').value = settings.basePrompt;
                if (settings.negativePrompt !== undefined) document.getElementById('negativePrompt').value = settings.negativePrompt;

                // Prompt layout (heights and collapse states)
                if (settings.basePromptHeight) document.getElementById('basePrompt').style.height = settings.basePromptHeight;
                if (settings.negativePromptHeight) document.getElementById('negativePrompt').style.height = settings.negativePromptHeight;
                if (settings.basePromptCollapsed) {
                    document.getElementById('basePromptContent').classList.add('collapsed');
                    document.querySelector('[data-target="basePromptContent"]').classList.add('collapsed');
                }
                if (settings.charactersCollapsed) {
                    document.getElementById('charactersContent').classList.add('collapsed');
                    document.querySelector('[data-target="charactersContent"]').classList.add('collapsed');
                }
                if (settings.negativePromptCollapsed) {
                    document.getElementById('negativePromptContent').classList.add('collapsed');
                    document.querySelector('[data-target="negativePromptContent"]').classList.add('collapsed');
                }

                // Size
                if (settings.sizePreset) document.getElementById('sizePreset').value = settings.sizePreset;
                if (settings.width) document.getElementById('width').value = settings.width;
                if (settings.height) document.getElementById('height').value = settings.height;
                
                // Generation
                if (settings.steps) document.getElementById('steps').value = settings.steps;
                if (settings.cfg) document.getElementById('cfg').value = settings.cfg;
                
                // 샘플러/스케줄러는 provider에 따라 옵션이 다르므로 pending으로 저장
                window._pendingSampler = settings.sampler;
                window._pendingScheduler = settings.scheduler;
                
                if (settings.randomSeed !== undefined) document.getElementById('randomSeed').checked = settings.randomSeed;
                if (settings.lockSeed !== undefined) document.getElementById('lockSeed').checked = settings.lockSeed;

                // NAI
                if (settings.naiModel) document.getElementById('naiModel').value = settings.naiModel;
                if (settings.smea) document.getElementById('smea').value = settings.smea;
                if (settings.ucPreset) document.getElementById('ucPreset').value = settings.ucPreset;
                if (settings.qualityTags !== undefined) document.getElementById('qualityTags').checked = settings.qualityTags;
                if (settings.furryModeEnabled) {
                    furryModeEnabled = true;
                    modeToggle.textContent = '🐾';
                    modeToggle.title = '퍼리 모드';
                    modeToggle.classList.add('furry');
                }

                // Vibe Transfer
                if (settings.enableVibeTransfer !== undefined) {
                    document.getElementById('enableVibeTransfer').checked = settings.enableVibeTransfer;
                    document.getElementById('vibeTransferSettings').style.display = settings.enableVibeTransfer ? 'block' : 'none';
                }
                if (settings.vibeList && settings.vibeList.length > 0) {
                    vibeList = settings.vibeList;
                    renderVibeList();
                }

                // Character Reference
                if (settings.enableCharRef !== undefined) {
                    document.getElementById('enableCharRef').checked = settings.enableCharRef;
                    document.getElementById('charRefSettings').style.display = settings.enableCharRef ? 'block' : 'none';
                }
                if (settings.charRefData) {
                    charRefData = settings.charRefData;
                    document.getElementById('charRefImage').src = 'data:image/png;base64,' + charRefData.image;
                    document.getElementById('charRefPreview').style.display = 'block';
                    document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
                }
                if (settings.charRefFidelity) {
                    document.getElementById('charRefFidelity').value = settings.charRefFidelity;
                    document.getElementById('charRefFidelityValue').textContent = settings.charRefFidelity;
                }
                if (settings.charRefStyleAware !== undefined) {
                    document.getElementById('charRefStyleAware').checked = settings.charRefStyleAware;
                }

                // Local - 모델은 loadResources 후에 설정해야 함
                window._pendingLocalModel = settings.localModel;
                window._pendingUpscaleModel = settings.upscaleModel;
                
                // Upscale
                if (settings.enableUpscale !== undefined) {
                    document.getElementById('enableUpscale').checked = settings.enableUpscale;
                    document.getElementById('upscaleSettings').style.display = settings.enableUpscale ? 'block' : 'none';
                }
                if (settings.downscaleRatio) document.getElementById('downscaleRatio').value = settings.downscaleRatio;
                if (settings.sizeAlignment) document.getElementById('sizeAlignment').value = settings.sizeAlignment;
                if (settings.upscaleSteps) document.getElementById('upscaleSteps').value = settings.upscaleSteps;
                if (settings.upscaleCfg) document.getElementById('upscaleCfg').value = settings.upscaleCfg;
                if (settings.upscaleDenoise) {
                    document.getElementById('upscaleDenoise').value = settings.upscaleDenoise;
                    document.getElementById('upscaleDenoiseValue').textContent = settings.upscaleDenoise;
                }
                
                // Output
                if (settings.outputFolder !== undefined) document.getElementById('outputFolder').value = settings.outputFolder;
                if (settings.repeatCount) document.getElementById('repeatCount').value = settings.repeatCount;
                
                // Slots - 기존 슬롯 제거 후 복원
                if (settings.slots && settings.slots.length > 0) {
                    slotsContainer.innerHTML = '';
                    settings.slots.forEach(slot => {
                        addSlot(slot.name || '', slot.content || '');
                    });
                }

                // Slot width
                if (settings.slotWidth) {
                    setSlotWidth(settings.slotWidth);
                }

                // Sidebar width
                if (settings.sidebarWidth) {
                    setSidebarWidth(settings.sidebarWidth);
                }

                // Character prompts (new format with layout)
                if (settings.characterPromptsLayout && settings.characterPromptsLayout.length > 0) {
                    window._pendingCharacterPromptsLayout = settings.characterPromptsLayout;
                }
                // Legacy format (just strings)
                else if (settings.characterPrompts && settings.characterPrompts.length > 0) {
                    window._pendingCharacterPromptsLayout = settings.characterPrompts.map(c => ({ content: c, collapsed: false, height: null }));
                }
                
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
        }
        
        // 설정 변경 시 자동 저장 (debounce)
        let saveTimeout = null;
        function autoSaveSettings() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveAppSettings, 500);
        }
        
        // 주요 입력 요소에 자동 저장 연결
        function setupAutoSave() {
            const inputs = [
                'basePrompt', 'negativePrompt', 'width', 'height', 'steps', 'cfg',
                'sampler', 'scheduler', 'seed', 'randomSeed', 'naiModel', 'smea',
                'ucPreset', 'qualityTags', 'localModel', 'enableUpscale', 'upscaleModel',
                'downscaleRatio', 'sizeAlignment', 'upscaleSteps', 'upscaleCfg',
                'upscaleDenoise', 'outputFolder', 'repeatCount', 'sizePreset'
            ];
            
            inputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', autoSaveSettings);
                    if (el.tagName === 'TEXTAREA' || el.type === 'text' || el.type === 'number') {
                        el.addEventListener('input', autoSaveSettings);
                    }
                }
            });
            
            // 슬롯 변경 감지
            slotsContainer.addEventListener('input', autoSaveSettings);
            slotsContainer.addEventListener('change', autoSaveSettings);
            
            // 캐릭터 프롬프트 변경 감지
            charactersList.addEventListener('input', autoSaveSettings);
            charactersList.addEventListener('change', autoSaveSettings);

            // 프롬프트 창 리사이즈 감지
            const resizeObserver = new ResizeObserver(() => autoSaveSettings());
            resizeObserver.observe(document.getElementById('basePrompt'));
            resizeObserver.observe(document.getElementById('negativePrompt'));
        }
        
        // Init
        loadAppSettings();  // 저장된 설정 먼저 로드

        // 현재 provider에 맞게 샘플러/스케줄러 옵션 설정 및 복원
        updateSamplerSchedulerOptions(currentProvider);

        // Anlas 정보 초기화 (NAI인 경우)
        updateAnlasVisibility();
        if (window._pendingSampler) {
            const samplerSelect = document.getElementById('sampler');
            // 현재 옵션에 있는 값만 복원
            if ([...samplerSelect.options].some(o => o.value === window._pendingSampler)) {
                samplerSelect.value = window._pendingSampler;
                window._pendingSampler = null;
            }
            // 없으면 pending 유지 (local 전환 시 복원)
        }
        if (window._pendingScheduler) {
            const schedulerSelect = document.getElementById('scheduler');
            if ([...schedulerSelect.options].some(o => o.value === window._pendingScheduler)) {
                schedulerSelect.value = window._pendingScheduler;
                window._pendingScheduler = null;
            }
        }
        
        loadResources().then(() => {
            // 모델 선택 복원 (loadResources 완료 후)
            if (window._pendingLocalModel) {
                document.getElementById('localModel').value = window._pendingLocalModel;
            }
            if (window._pendingUpscaleModel) {
                document.getElementById('upscaleModel').value = window._pendingUpscaleModel;
            }
            // 캐릭터 프롬프트 복원 (레이아웃 포함)
            if (window._pendingCharacterPromptsLayout) {
                window._pendingCharacterPromptsLayout.forEach(charData => {
                    const content = charData.content || '';
                    const collapsed = charData.collapsed || false;
                    const height = charData.height || null;
                    if (content.trim() || collapsed) {
                        const item = createCharacterItem(content, collapsed);
                        if (height) {
                            item.querySelector('textarea').style.height = height;
                        }
                        charactersList.appendChild(item);
                    }
                });
                updateCharacterNumbers();
                window._pendingCharacterPromptsLayout = null;
            }
        });
        connectSSE();
        checkLocalEnvStatus();
        setupAutoSave();
        
        // 슬롯이 없으면 하나 추가
        if (slotsContainer.children.length === 0) {
            addSlot();
        }
        
        // 시드가 비어있으면 랜덤 생성
        if (!document.getElementById('seed').value) {
            document.getElementById('seed').value = Math.floor(Math.random() * 2147483647);
        }
        
        // 초기 그라데이션 업데이트
        setTimeout(updateScrollGradients, 100);
        
        // 페이지 떠날 때 저장 및 경고
        window.addEventListener('beforeunload', (e) => {
            saveAppSettings();
            // 브라우저 기본 확인 팝업 표시
            e.preventDefault();
            e.returnValue = '';
        });

        // ============================================================
        // Gallery Mode
        // ============================================================
        const slotModeBtn = document.getElementById('slotModeBtn');
        const galleryModeBtn = document.getElementById('galleryModeBtn');
        const galleryContainer = document.getElementById('galleryContainer');
        const galleryGrid = document.getElementById('galleryGrid');
        const galleryEmpty = document.getElementById('galleryEmpty');
        const galleryFolders = document.getElementById('galleryFolders');

        let currentMode = 'slot'; // 'slot' or 'gallery'
        let currentGalleryFolder = ''; // 현재 선택된 폴더 (빈 문자열 = gallery 루트)

        slotModeBtn.onclick = () => {
            if (currentMode === 'slot') return;
            currentMode = 'slot';
            slotModeBtn.classList.add('active');
            galleryModeBtn.classList.remove('active');
            slotsWrapper.style.display = 'flex';
            galleryContainer.style.display = 'none';
        };

        galleryModeBtn.onclick = () => {
            if (currentMode === 'gallery') return;
            currentMode = 'gallery';
            galleryModeBtn.classList.add('active');
            slotModeBtn.classList.remove('active');
            slotsWrapper.style.display = 'none';
            galleryContainer.style.display = 'flex';
            loadGalleryFolders();
            loadGallery(currentGalleryFolder);
        };

        // 갤러리 폴더 열기 (현재 선택된 폴더)
        document.getElementById('openGalleryFolderBtn').onclick = async () => {
            try {
                const response = await fetch(`${API_BASE}/api/gallery/open-folder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder: currentGalleryFolder })
                });
                const result = await response.json();
                if (!result.success) {
                    showToast('폴더 열기 실패', 'error');
                }
            } catch (err) {
                showToast('폴더 열기 오류', 'error');
            }
        };

        // 새 폴더 생성
        document.getElementById('addFolderBtn').onclick = () => {
            showInputModal('📁 새 폴더', '폴더 이름을 입력하세요', async (folderName) => {
                try {
                    const response = await fetch(`${API_BASE}/api/gallery/folders`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: folderName })
                    });
                    const result = await response.json();
                    if (result.success) {
                        showToast('폴더 생성됨', 'success');
                        loadGalleryFolders();
                    } else {
                        showToast('폴더 생성 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('폴더 생성 오류: ' + err.message, 'error');
                }
            }, '생성');
        };

        // 폴더 목록 로드
        async function loadGalleryFolders() {
            try {
                const response = await fetch(`${API_BASE}/api/gallery/folders`);
                const result = await response.json();

                // 기존 폴더 탭 제거 (gallery 루트 제외)
                const existingTabs = galleryFolders.querySelectorAll('.folder-tab:not([data-folder=""])');
                existingTabs.forEach(tab => tab.remove());

                if (result.success && result.folders) {
                    result.folders.forEach(folder => {
                        const tab = document.createElement('button');
                        tab.type = 'button';
                        tab.className = 'folder-tab' + (currentGalleryFolder === folder.name ? ' active' : '');
                        tab.dataset.folder = folder.name;
                        tab.textContent = `📁 ${folder.name} (${folder.image_count})`;
                        tab.title = `${folder.image_count}개 이미지`;
                        setupFolderTab(tab);
                        galleryFolders.appendChild(tab);
                    });
                }

                // 루트 폴더 탭 active 상태 업데이트
                const rootTab = galleryFolders.querySelector('[data-folder=""]');
                if (rootTab) {
                    rootTab.classList.toggle('active', currentGalleryFolder === '');
                    setupFolderTab(rootTab);
                }
            } catch (err) {
                console.error('폴더 목록 로드 실패:', err);
            }
        }

        // 폴더 탭 이벤트 설정
        function setupFolderTab(tab) {
            tab.onclick = () => {
                if (tab.dataset.folder === currentGalleryFolder) return;
                currentGalleryFolder = tab.dataset.folder;
                // 모든 탭 active 해제
                galleryFolders.querySelectorAll('.folder-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                loadGallery(currentGalleryFolder);
            };

            // 드래그 오버 이벤트 (이미지를 폴더로 이동할 때)
            tab.ondragover = (e) => {
                e.preventDefault();
                tab.classList.add('drag-over');
            };
            tab.ondragleave = () => {
                tab.classList.remove('drag-over');
            };
            tab.ondrop = async (e) => {
                e.preventDefault();
                tab.classList.remove('drag-over');
                const filename = e.dataTransfer.getData('text/plain');
                const fromFolder = e.dataTransfer.getData('application/x-gallery-folder');
                const toFolder = tab.dataset.folder;

                if (!filename || fromFolder === toFolder) return;

                try {
                    const response = await fetch(`${API_BASE}/api/gallery/${encodeURIComponent(filename)}/move`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ from_folder: fromFolder, to_folder: toFolder })
                    });
                    const result = await response.json();
                    if (result.success) {
                        showToast('이미지 이동됨', 'success');
                        loadGallery(currentGalleryFolder);
                        loadGalleryFolders();
                    } else {
                        showToast('이동 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('이동 오류: ' + err.message, 'error');
                }
            };
        }

        let galleryLoaded = false;

        async function loadGallery(folder = '') {
            // 로딩 중 표시
            galleryGrid.style.display = 'none';
            galleryEmpty.innerHTML = `
                <div class="icon">⏳</div>
                <p>갤러리 로딩 중...</p>
            `;
            galleryEmpty.style.display = 'flex';

            try {
                const response = await fetch(`${API_BASE}/api/gallery?folder=${encodeURIComponent(folder)}`);
                const result = await response.json();

                if (result.images && result.images.length > 0) {
                    galleryEmpty.style.display = 'none';
                    galleryGrid.style.display = 'grid';
                    renderGallery(result.images, folder);
                } else {
                    galleryEmpty.innerHTML = `
                        <div class="icon">🖼️</div>
                        <p>${folder ? `'${folder}' 폴더가` : '갤러리가'} 비어있습니다</p>
                        <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                    `;
                    galleryEmpty.style.display = 'flex';
                    galleryGrid.style.display = 'none';
                    galleryGrid.innerHTML = '';
                }
                galleryLoaded = true;
            } catch (err) {
                galleryEmpty.innerHTML = `
                    <div class="icon">❌</div>
                    <p>갤러리 로드 실패</p>
                    <small>${err.message}</small>
                `;
                showToast('갤러리 로드 실패: ' + err.message, 'error');
            }
        }

        function renderGallery(images, folder = '') {
            galleryGrid.innerHTML = '';

            images.forEach(img => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                item._filename = img.filename;
                item._folder = folder;
                item.draggable = true;
                item.innerHTML = `
                    <img src="data:image/png;base64,${img.thumbnail}" alt="">
                    <div class="gallery-item-info">
                        <div class="filename-row">
                            <span class="filename" title="${img.filename}">${img.filename.replace('.png', '')}</span>
                            <button class="rename-btn" title="이름 변경">✏️</button>
                        </div>
                        <div class="seed">${img.seed ? 'Seed: ' + img.seed : '메타데이터 없음'}</div>
                    </div>
                    <div class="gallery-item-actions">
                        <button class="copy-prompt-btn" title="프롬프트 복사">📋 Prompt</button>
                        <button class="copy-seed-btn" title="시드 복사">🎲 Seed</button>
                        <button class="apply-all-btn" title="전체 설정 적용">📥 Apply</button>
                        <button class="delete-btn" title="삭제">🗑️</button>
                    </div>
                `;

                // 드래그 시작 (폴더 이동용)
                item.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', item._filename);
                    e.dataTransfer.setData('application/x-gallery-folder', item._folder);
                    e.dataTransfer.effectAllowed = 'move';

                    // 커스텀 드래그 고스트 생성
                    const ghost = document.createElement('div');
                    ghost.id = 'dragGhost';
                    ghost.style.cssText = 'position: fixed; top: -100px; left: -100px; width: 60px; height: 60px; background: var(--accent); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: none; z-index: 10000;';
                    ghost.textContent = '📁';
                    document.body.appendChild(ghost);
                    e.dataTransfer.setDragImage(ghost, 30, 30);

                    item.classList.add('dragging');
                };
                item.ondragend = () => {
                    item.classList.remove('dragging');
                    // 드래그 고스트 제거
                    const ghost = document.getElementById('dragGhost');
                    if (ghost) ghost.remove();
                };

                // 이미지 자체의 기본 드래그 동작 방지 (부모 item의 드래그로 대체)
                const imgEl = item.querySelector('img');
                if (imgEl) {
                    imgEl.draggable = false;
                }

                // 라이트박스 표시 함수
                const folderQuery = folder ? `?folder=${encodeURIComponent(folder)}` : '';
                const showLightbox = async () => {
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success) {
                            lightboxImg.src = 'data:image/png;base64,' + result.image;
                            lightbox.classList.add('active');
                        }
                    } catch (err) {
                        showToast('이미지 로드 실패', 'error');
                    }
                };

                // 카드 클릭 - 라이트박스 (버튼 제외)
                item.onclick = (e) => {
                    // 버튼이나 입력 필드 클릭시 무시
                    if (e.target.closest('.gallery-item-actions') || e.target.closest('.rename-btn') || e.target.tagName === 'INPUT') {
                        return;
                    }
                    showLightbox();
                };

                // 이름 변경
                item.querySelector('.rename-btn').onclick = (e) => {
                    e.stopPropagation();
                    const filenameRow = item.querySelector('.filename-row');
                    const filenameSpan = item.querySelector('.filename');
                    const currentName = item._filename.replace('.png', '');

                    // 입력 필드로 교체
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'filename-input';
                    input.value = currentName;

                    filenameSpan.style.display = 'none';
                    filenameRow.insertBefore(input, filenameRow.querySelector('.rename-btn'));
                    input.focus();
                    input.select();

                    const saveRename = async () => {
                        const newName = input.value.trim();
                        if (!newName || newName === currentName) {
                            // 취소
                            input.remove();
                            filenameSpan.style.display = '';
                            return;
                        }

                        try {
                            const response = await fetch(`${API_BASE}/api/gallery/${item._filename}`, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ new_name: newName, folder: item._folder })
                            });
                            const result = await response.json();
                            if (result.success) {
                                item._filename = result.new_filename;
                                filenameSpan.textContent = newName;
                                filenameSpan.title = result.new_filename;
                                showToast('이름 변경됨', 'success');
                            } else {
                                showToast(result.error || '이름 변경 실패', 'error');
                            }
                        } catch (err) {
                            showToast('이름 변경 오류', 'error');
                        }

                        input.remove();
                        filenameSpan.style.display = '';
                    };

                    input.onblur = saveRename;
                    input.onkeydown = (ke) => {
                        if (ke.key === 'Enter') {
                            ke.preventDefault();
                            input.blur();
                        } else if (ke.key === 'Escape') {
                            input.value = currentName;
                            input.blur();
                        }
                    };
                };

                // 프롬프트 적용 (확인 팝업)
                item.querySelector('.copy-prompt-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success && result.metadata && result.metadata.prompt) {
                            const meta = result.metadata;
                            const prompt = meta.prompt;

                            // 캐릭터 프롬프트 추출
                            let charPrompts = meta.character_prompts || [];
                            if (charPrompts.length === 0 && meta.v4_prompt?.caption?.char_captions) {
                                charPrompts = meta.v4_prompt.caption.char_captions.map(c => c.char_caption).filter(c => c);
                            }
                            if (charPrompts.length === 0 && meta.characterPrompts) {
                                charPrompts = meta.characterPrompts.map(c => c.prompt).filter(c => c);
                            }

                            const charPromptsInfo = charPrompts.length > 0
                                ? `<div style="margin-top: 8px;"><strong>캐릭터 (${charPrompts.length}):</strong> ${charPrompts.map((c, i) => `[${i+1}]`).join(' ')}</div>`
                                : '';

                            showConfirmModal(
                                '📋 프롬프트 적용',
                                `<p>이 프롬프트를 적용하시겠습니까?</p><div style="white-space: pre-wrap; word-break: break-word; margin-top: 8px;">${prompt}</div>${charPromptsInfo}`,
                                async () => {
                                    document.getElementById('basePrompt').value = prompt;

                                    // 캐릭터 프롬프트 적용
                                    if (charPrompts.length > 0) {
                                        const charactersList = document.getElementById('charactersList');
                                        charactersList.innerHTML = '';
                                        charPrompts.forEach(cp => {
                                            if (cp && cp.trim()) {
                                                addCharacter(cp);
                                            }
                                        });
                                        updateCharacterNumbers();
                                    }

                                    await navigator.clipboard.writeText(prompt);
                                    showToast('프롬프트 적용 및 복사됨', 'success');
                                    autoSaveSettings();
                                },
                                '적용'
                            );
                        } else {
                            showToast('프롬프트 없음', 'warning');
                        }
                    } catch (err) {
                        showToast('복사 실패', 'error');
                    }
                };

                // 시드 적용 (확인 팝업)
                item.querySelector('.copy-seed-btn').onclick = async (e) => {
                    e.stopPropagation();
                    if (img.seed) {
                        showConfirmModal(
                            '🎲 시드 적용',
                            `<p>이 시드를 적용하시겠습니까?</p><div class="metadata" style="font-size: 0.9rem; margin-top: 8px;"><strong>Seed:</strong> ${img.seed}</div>`,
                            async () => {
                                document.getElementById('seed').value = img.seed;
                                await navigator.clipboard.writeText(String(img.seed));
                                showToast('시드 적용 및 복사됨', 'success');
                            },
                            '적용'
                        );
                    } else {
                        showToast('시드 정보 없음', 'warning');
                    }
                };

                // 전체 설정 적용 (확인 팝업)
                item.querySelector('.apply-all-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success && result.metadata) {
                            const meta = result.metadata;
                            // 캐릭터 프롬프트 추출 (peropix 또는 NAI 형식)
                            let charPrompts = meta.character_prompts || [];
                            if (charPrompts.length === 0 && meta.v4_prompt?.caption?.char_captions) {
                                charPrompts = meta.v4_prompt.caption.char_captions.map(c => c.char_caption).filter(c => c);
                            }
                            if (charPrompts.length === 0 && meta.characterPrompts) {
                                charPrompts = meta.characterPrompts.map(c => c.prompt).filter(c => c);
                            }
                            // 메타데이터 형식 변환 (showLoadSettingsConfirm 호환)
                            const normalizedMeta = {
                                prompt: meta.prompt || '',
                                negative_prompt: meta.negative_prompt || meta.uc || '',
                                character_prompts: charPrompts,
                                seed: meta.seed,
                                width: meta.width,
                                height: meta.height,
                                steps: meta.steps,
                                cfg: meta.cfg || meta.scale,
                                sampler: meta.sampler,
                                scheduler: meta.scheduler || meta.noise_schedule || 'native',
                                nai_model: meta.nai_model || meta.request_type || '',
                                smea: meta.smea || (meta.sm_dyn ? 'SMEA+DYN' : (meta.sm ? 'SMEA' : 'none')),
                                uc_preset: meta.uc_preset || meta.ucPreset || '',
                                quality_tags: meta.quality_tags
                            };
                            showLoadSettingsConfirm(normalizedMeta);
                        } else {
                            showToast('메타데이터 없음', 'warning');
                        }
                    } catch (err) {
                        showToast('적용 실패: ' + err.message, 'error');
                    }
                };

                // 삭제
                item.querySelector('.delete-btn').onclick = async (e) => {
                    e.stopPropagation();
                    showConfirmModal(
                        '🗑️ 이미지 삭제',
                        '<p>이 이미지를 갤러리에서 삭제하시겠습니까?</p>',
                        async () => {
                            try {
                                const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`, {
                                    method: 'DELETE'
                                });
                                const result = await response.json();
                                if (result.success) {
                                    item.remove();
                                    showToast('삭제됨', 'success');
                                    // 갤러리가 비었는지 확인
                                    if (galleryGrid.children.length === 0) {
                                        galleryEmpty.innerHTML = `
                                            <div class="icon">🖼️</div>
                                            <p>갤러리가 비어있습니다</p>
                                            <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                                        `;
                                        galleryEmpty.style.display = 'flex';
                                        galleryGrid.style.display = 'none';
                                    }
                                } else {
                                    showToast('삭제 실패', 'error');
                                }
                            } catch (err) {
                                showToast('삭제 오류: ' + err.message, 'error');
                            }
                        },
                        '삭제',
                        true
                    );
                };

                galleryGrid.appendChild(item);
            });
        }

        // ============================================================
        // 외부 이미지 드롭 처리
        // ============================================================
        const dropOverlay = document.getElementById('dropOverlay');
        const dropModal = document.getElementById('dropModal');
        let pendingDropData = null;

        // 드래그 이벤트 처리
        let dragCounter = 0;
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            if (e.dataTransfer.types.includes('Files')) {
                dropOverlay.classList.add('active');
            }
        });

        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dropOverlay.classList.remove('active');
            }
        });

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropOverlay.classList.remove('active');

            const files = e.dataTransfer.files;
            if (files.length === 0) return;

            const file = files[0];
            if (!file.type.startsWith('image/')) {
                showToast('이미지 파일만 드롭할 수 있습니다', 'error');
                return;
            }

            // 이미지를 base64로 변환
            const base64 = await fileToBase64(file);

            // 서버에서 메타데이터 추출
            try {
                const response = await fetch(`${API_BASE}/api/extract-metadata`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: base64 })
                });
                const result = await response.json();

                if (!result.success) {
                    showToast('메타데이터 추출 실패: ' + result.error, 'error');
                    return;
                }

                // 모달 표시 준비
                document.getElementById('dropModalPreview').src = 'data:image/png;base64,' + base64;
                const metadataDiv = document.getElementById('dropModalMetadata');

                if (result.is_vibe) {
                    // 바이브 파일
                    document.getElementById('dropModalTitle').textContent = '🎨 바이브 파일 감지됨';
                    metadataDiv.innerHTML = `
                        <div><strong>Strength:</strong> ${result.vibe_strength}</div>
                        <div><strong>Info Extracted:</strong> ${result.vibe_info_extracted}</div>
                    `;
                    document.getElementById('dropModalConfirm').textContent = '바이브에 추가';
                    pendingDropData = {
                        type: 'vibe',
                        image: base64,
                        strength: result.vibe_strength,
                        info_extracted: result.vibe_info_extracted,
                        name: file.name
                    };
                } else if (result.is_nai && result.nai_metadata) {
                    // NAI 생성 이미지
                    const meta = result.nai_metadata;
                    document.getElementById('dropModalTitle').textContent = '🖼️ 생성 이미지 메타데이터';
                    metadataDiv.innerHTML = `
                        <div><strong>Prompt:</strong> ${(meta.prompt || '').substring(0, 100)}${(meta.prompt || '').length > 100 ? '...' : ''}</div>
                        <div><strong>Negative:</strong> ${(meta.uc || '').substring(0, 50)}${(meta.uc || '').length > 50 ? '...' : ''}</div>
                        <div><strong>Seed:</strong> ${meta.seed || 'N/A'}</div>
                        <div><strong>Size:</strong> ${meta.width}x${meta.height}</div>
                        <div><strong>Steps:</strong> ${meta.steps}, <strong>CFG:</strong> ${meta.scale}</div>
                        <div><strong>Sampler:</strong> ${meta.sampler}</div>
                    `;
                    document.getElementById('dropModalConfirm').textContent = '설정에 적용';
                    pendingDropData = {
                        type: 'nai',
                        metadata: meta,
                        image: base64,
                        name: file.name
                    };
                } else {
                    // 일반 이미지 - 바이브로 추가 제안
                    document.getElementById('dropModalTitle').textContent = '📷 일반 이미지';
                    metadataDiv.innerHTML = '<div>메타데이터가 없습니다. 바이브로 추가할 수 있습니다.</div>';
                    document.getElementById('dropModalConfirm').textContent = '바이브에 추가';
                    pendingDropData = {
                        type: 'plain',
                        image: base64,
                        name: file.name
                    };
                }

                dropModal.classList.add('active');

            } catch (err) {
                showToast('메타데이터 추출 오류: ' + err.message, 'error');
            }
        });

        // 모달 버튼 이벤트
        document.getElementById('dropModalCancel').onclick = () => {
            dropModal.classList.remove('active');
            pendingDropData = null;
            window._pendingLoadMetadata = null;
            document.getElementById('dropModalPreview').style.display = '';
        };

        document.getElementById('dropModalConfirm').onclick = () => {
            // 설정 불러오기 처리
            if (window._pendingLoadMetadata) {
                applyMetadataSettings(window._pendingLoadMetadata);
                window._pendingLoadMetadata = null;
                dropModal.classList.remove('active');
                document.getElementById('dropModalPreview').style.display = '';
                return;
            }

            if (!pendingDropData) return;

            if (pendingDropData.type === 'vibe') {
                // 바이브 리스트에 추가
                if (vibeList.length >= 16) {
                    showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                } else {
                    vibeList.push({
                        image: pendingDropData.image,
                        strength: pendingDropData.strength || 0.6,
                        info_extracted: pendingDropData.info_extracted || 1.0,
                        name: pendingDropData.name
                    });
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    // Vibe Transfer 활성화
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    showToast('바이브에 추가됨', 'success');
                }
            } else if (pendingDropData.type === 'nai') {
                // NAI 메타데이터 적용
                const meta = pendingDropData.metadata;
                if (meta.prompt) document.getElementById('basePrompt').value = meta.prompt;
                if (meta.uc) document.getElementById('negativePrompt').value = meta.uc;
                if (meta.seed) document.getElementById('seed').value = meta.seed;
                if (meta.width) document.getElementById('width').value = meta.width;
                if (meta.height) document.getElementById('height').value = meta.height;
                if (meta.steps) document.getElementById('steps').value = meta.steps;
                if (meta.scale) document.getElementById('cfg').value = meta.scale;
                if (meta.sampler) {
                    const samplerSelect = document.getElementById('sampler');
                    if ([...samplerSelect.options].some(o => o.value === meta.sampler)) {
                        samplerSelect.value = meta.sampler;
                    }
                }
                saveAppSettings();
                showToast('설정이 적용됨', 'success');
            } else if (pendingDropData.type === 'plain') {
                // 일반 이미지를 바이브로 추가
                if (vibeList.length >= 16) {
                    showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                } else {
                    vibeList.push({
                        image: pendingDropData.image,
                        strength: 0.6,
                        info_extracted: 1.0,
                        name: pendingDropData.name
                    });
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    showToast('바이브에 추가됨', 'success');
                }
            }

            dropModal.classList.remove('active');
            pendingDropData = null;
        };
    </script>
</body>
</html>
