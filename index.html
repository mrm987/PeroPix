<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PeroPix</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        :root {
            /* Background - Deep Navy */
            --bg: #0C1219;
            --bg-light: #141C26;
            --bg-lighter: #1C2530;
            /* Accent - Navy Blue */
            --accent: #4A7AB8;
            --accent-hover: #5B98D4;
            --accent-dim: #2D4A6F;
            /* Accent - Gold (CTA, 강조) */
            --accent-gold: #F5B942;
            --accent-gold-hover: #FFD06A;
            --accent-gold-dim: #9A7A35;
            /* Text */
            --text: #FFFFFF;
            --text-dim: #7A8BA0;
            /* Border */
            --border: #243044;
            /* Semantic */
            --success: #4CAF82;
            --error: #E57373;
            --warning: #F5B942;

            /* Spacing System - 일관된 간격 */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 12px;
            --space-lg: 16px;
            --space-xl: 20px;
            --space-2xl: 24px;

            /* Border Radius - 통일 */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 14px;
            --radius-xl: 18px;

            /* Shadow - 깊이감 */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.25);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.3);

            /* Transition */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.2s ease;
        }

        /* Global Scrollbar Styles */
        *::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        *::-webkit-scrollbar-track {
            background: transparent;
        }
        *::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: var(--radius-sm);
        }
        *::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        /* Firefox scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
        }
        
        /* Layout */
        .app {
            display: flex;
            height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width, 540px);
            min-width: 360px;
            max-width: 800px;
            background: var(--bg-light);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
        }

        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.active {
            opacity: 1;
            background: var(--accent-gold-dim);
        }
        
        .sidebar-header {
            padding: var(--space-lg) var(--space-xl);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-light);
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            letter-spacing: -0.02em;
        }
        .logo img {
            width: 32px;
            height: 32px;
            border-radius: var(--radius-sm);
        }

        .settings-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            cursor: pointer;
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-btn:hover {
            background: var(--bg);
            border-color: var(--accent);
            color: var(--text);
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }


        .sidebar-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
        }
        
        /* Sections */
        .section {
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-lg);
            border-bottom: 1px solid var(--border);
        }

        .section:last-child,
        .sidebar-content > .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: var(--space-md);
            padding: var(--space-sm) var(--space-md);
            margin-left: calc(var(--space-md) * -1);
            margin-right: calc(var(--space-md) * -1);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: var(--transition-fast);
            user-select: none;
        }
        .section-title:hover {
            background: var(--bg-lighter);
            color: var(--accent-hover);
        }

        .section-title .collapse-toggle {
            font-size: 0.65rem;
            opacity: 0.6;
            transition: transform var(--transition-fast);
        }

        .section-title:hover .collapse-toggle {
            opacity: 1;
        }
        
        .section-title .section-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: none;
            letter-spacing: 0;
            color: var(--text);
            cursor: pointer;
        }
        
        .section-title .section-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            cursor: pointer;
        }

        .subsection {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .subsection:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .subsection-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .subsection-title .section-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text);
            cursor: pointer;
        }

        .subsection-title .section-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            cursor: pointer;
        }

        /* Form */
        label {
            display: block;
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: var(--space-xs);
            color: var(--text-dim);
        }

        label.prompt-label {
            color: var(--text);
            font-weight: 600;
        }

        input, select, textarea {
            width: 100%;
            padding: var(--space-md) var(--space-md);
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text);
            font-size: 0.875rem;
            margin-bottom: var(--space-md);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }

        input:hover, select:hover, textarea:hover {
            border-color: var(--accent-dim);
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(74, 122, 184, 0.15);
        }

        textarea {
            resize: vertical;
            min-height: 80px;
            line-height: 1.5;
            font-family: inherit;
            overflow-y: auto;
            overflow-x: hidden;
        }


        /* Prompt Weight Highlighting */
        .prompt-highlight-container {
            position: relative;
            width: 100%;
        }

        .prompt-highlight-overlay {
            position: absolute;
            top: 1px;
            left: 1px;
            right: 1px;
            bottom: 1px;
            padding: var(--space-md) var(--space-md);
            margin: 0;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-family: inherit;
            line-height: 1.5;
            letter-spacing: normal;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: hidden;
            pointer-events: none;
            z-index: 1;
            color: var(--text);
            background: var(--bg);
            box-sizing: border-box;
        }

        .prompt-highlight-overlay::-webkit-scrollbar {
            display: none;
        }

        .prompt-highlight-container textarea {
            position: relative;
            z-index: 2;
            background: transparent !important;
            color: var(--text) !important;
            caret-color: var(--text);
            margin: 0 !important;
            padding: var(--space-md) var(--space-md);
            border: 1px solid var(--border) !important;
            border-radius: var(--radius-sm) !important;
            font-size: 0.875rem;
            line-height: 1.5;
            letter-spacing: normal;
            -webkit-text-fill-color: transparent;
            text-fill-color: transparent;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .prompt-highlight-container textarea::selection {
            background: rgba(74, 122, 184, 0.3);
            -webkit-text-fill-color: var(--text);
            text-fill-color: var(--text);
        }

        /* Character prompt의 overlay는 bg-light 사용 */
        .character-item .prompt-highlight-overlay {
            background: var(--bg-light);
        }

        .prompt-highlight-overlay span {
            border-radius: 3px;
        }

        .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        
        .size-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .size-preset {
            flex: 1;
        }

        .size-inputs {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .size-inputs input {
            flex: 1;
            min-width: 0;
            text-align: center;
            padding: 10px 8px;
        }

        .size-x {
            color: var(--text-dim);
            font-size: 0.85rem;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: var(--space-xs);
            margin-bottom: var(--space-lg);
            background: var(--bg);
            padding: var(--space-xs);
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
        }

        .tab {
            flex: 1;
            padding: var(--space-md) var(--space-lg);
            background: transparent;
            border: none;
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            font-size: 0.85rem;
            transition: var(--transition-fast);
        }

        .tab:hover:not(.active) {
            background: var(--bg-lighter);
            color: var(--text);
        }

        .tab.active {
            background: var(--accent);
            color: white;
            box-shadow: var(--shadow-sm);
        }
        
        .provider-section { display: none; }
        .provider-section.active { 
            display: block;
            padding-bottom: 16px;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }
        .provider-section .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        /* Checkbox */
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .checkbox-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin: 0;
            accent-color: var(--accent);
        }
        
        .checkbox-row label {
            margin: 0;
            color: var(--text);
            font-size: 0.9rem;
        }
        
        /* Characters */
        .characters-section {
            margin: 12px 0;
        }
        
        .characters-header {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 8px;
            padding: 8px 10px;
            margin: 0 -10px 8px -10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .characters-header:hover {
            background: var(--bg-lighter);
        }

        .characters-header label {
            font-size: 0.85rem;
            flex: 1;
        }

        .characters-header label.prompt-label {
            color: var(--text);
        }
        
        .add-char-btn {
            background: var(--accent);
            border: none;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .add-char-btn:hover {
            background: var(--accent-hover);
        }
        
        .add-char-btn:disabled {
            background: var(--bg-lighter);
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .characters-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .character-item {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            transition: var(--transition-fast);
        }

        .character-item:hover {
            border-color: var(--accent-dim);
        }

        .character-item-header {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-xs) 0;
        }

        .character-item .char-num {
            color: var(--accent-gold);
            font-size: 0.75rem;
            font-weight: 700;
            font-family: 'SF Mono', 'Consolas', monospace;
            background: rgba(245, 185, 66, 0.1);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            min-width: 28px;
            text-align: center;
        }
        
        .character-item .prompt-preset-dropdown {
            margin-left: auto;
        }

        .character-item .prompt-preset-btn {
            padding: 2px 6px;
            font-size: 0.7rem;
        }

        .character-item textarea {
            background: var(--bg-light);
            margin-bottom: 0;
            min-height: 50px;
        }

        .character-item .delete-char-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: var(--space-xs) var(--space-sm);
            font-size: 1rem;
            opacity: 0.4;
            transition: var(--transition-fast);
            border-radius: var(--radius-sm);
        }

        .character-item .delete-char-btn:hover {
            opacity: 1;
            color: var(--error);
            background: rgba(229, 115, 115, 0.1);
        }

        .char-enable-toggle {
            width: 14px;
            height: 14px;
            margin: 0 4px 0 0;
            cursor: pointer;
            accent-color: var(--accent);
            vertical-align: middle;
        }

        .character-item.disabled {
            opacity: 0.5;
        }

        .character-item.disabled textarea {
            background: var(--bg-tertiary);
            color: var(--text-dim);
        }

        /* 캐릭터 드래그 핸들 */
        .char-drag {
            color: var(--text-dim);
            cursor: grab;
            padding: var(--space-xs);
            font-size: 0.85rem;
            opacity: 0.3;
            transition: var(--transition-fast);
            border-radius: var(--radius-sm);
        }

        .char-drag:hover {
            opacity: 0.8;
            background: var(--bg-lighter);
        }

        .char-drag:active {
            cursor: grabbing;
        }

        .character-item.dragging {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            opacity: 0.9;
        }

        .char-placeholder {
            background: var(--bg-lighter);
            border: 2px dashed var(--border);
            border-radius: 6px;
            margin: 3px 0;
        }

        /* Prompt Preset Dropdown */
        .prompt-label-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            padding: 8px 10px;
            margin: 0 -10px 4px -10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .prompt-label-row:hover {
            background: var(--bg-lighter);
        }

        .prompt-label-left {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mode-toggle {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            line-height: 1;
        }

        .mode-toggle:hover {
            border-color: var(--accent);
            background: var(--bg);
        }

        .mode-toggle.furry {
            background: var(--bg);
            border-color: var(--accent);
        }

        /* Collapsible prompts */
        .collapse-toggle {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        .collapse-toggle:hover {
            color: var(--text);
        }
        .collapse-toggle.collapsed {
            transform: rotate(-90deg);
        }
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
        }
        .collapsible-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            margin: 0;
            padding: 0;
        }
        /* Characters 섹션만 드롭다운이 밖으로 나올 수 있도록 */
        #charactersContent:not(.collapsed) {
            overflow: visible;
        }

        .prompt-preset-dropdown {
            position: relative;
        }
        
        .prompt-preset-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .prompt-preset-btn:hover {
            background: var(--bg-light);
            border-color: var(--text-dim);
        }
        
        .prompt-preset-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: var(--space-xs);
            min-width: 200px;
            max-width: 280px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            z-index: 100;
            overflow: hidden;
        }
        
        .prompt-preset-menu.show {
            display: block;
        }
        
        .prompt-preset-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .prompt-preset-item {
            padding: var(--space-sm) var(--space-md);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: background var(--transition-fast);
        }

        .prompt-preset-item:hover {
            background: var(--bg-lighter);
        }

        .prompt-preset-item:last-child {
            border-bottom: none;
        }

        .prompt-preset-item-name {
            font-size: 0.85rem;
            color: var(--text);
            margin-bottom: var(--space-xs);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .prompt-preset-item-actions {
            display: flex;
            gap: var(--space-xs);
        }
        
        .prompt-preset-item-actions button {
            flex: 1;
            padding: 3px 8px;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            background: var(--bg);
            color: var(--text);
        }
        
        .prompt-preset-item-actions button:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .prompt-preset-item-actions .delete-btn {
            flex: 0;
            padding: 3px 6px;
            color: var(--text-dim);
        }
        
        .prompt-preset-item-actions .delete-btn:hover {
            background: var(--error);
            border-color: var(--error);
            color: white;
        }
        
        .prompt-preset-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
        }
        
        .prompt-preset-save-btn {
            width: 100%;
            padding: 6px 10px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        .prompt-preset-save-btn:hover {
            background: var(--bg);
            border-color: var(--text-dim);
        }
        
        .prompt-preset-empty {
            padding: 12px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        /* Tag Autocomplete Dropdown */
        .tag-autocomplete-dropdown {
            position: fixed;
            display: none;
            min-width: 250px;
            max-width: 450px;
            max-height: 300px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .tag-autocomplete-dropdown.show {
            display: block;
        }

        .tag-autocomplete-item {
            padding: 6px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid var(--border-dim);
            transition: background 0.15s;
        }

        .tag-autocomplete-item:last-child {
            border-bottom: none;
        }

        .tag-autocomplete-item:hover,
        .tag-autocomplete-item.selected {
            background: var(--bg);
        }

        .tag-autocomplete-item-name {
            flex: 1;
            font-size: 0.85rem;
            color: var(--text);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tag-autocomplete-item-count {
            flex-shrink: 0;
            width: 42px;
            font-size: 0.7rem;
            font-family: monospace;
            color: var(--text-dim);
            text-align: right;
        }

        .tag-autocomplete-item-badge {
            flex-shrink: 0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 600;
            text-align: center;
            line-height: 1;
        }

        .tag-autocomplete-item-badge.general {
            background: var(--bg-tertiary);
            color: var(--text-dim);
        }

        .tag-autocomplete-item-badge.artist {
            background: #4a3520;
            color: #f4a261;
        }

        .tag-autocomplete-item-badge.character {
            background: #1f4037;
            color: #70e1a8;
        }

        .tag-autocomplete-item-badge.copyright {
            background: #3d2f5b;
            color: #b794f4;
        }

        .tag-autocomplete-item-badge.meta {
            background: #2d3748;
            color: #90cdf4;
        }

        .tag-autocomplete-empty {
            padding: 12px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        .tag-autocomplete-loading {
            padding: 12px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            margin-right: var(--space-md);
            vertical-align: middle;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            transition: background-color var(--transition-normal), border-color var(--transition-normal);
            border-radius: 24px;
            border: 1px solid var(--border);
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: var(--text-dim);
            transition: transform var(--transition-normal), background-color var(--transition-normal);
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent-gold);
            border-color: var(--accent-gold);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
            background-color: #fff;
        }

        .toggle-switch input:focus + .toggle-slider {
            box-shadow: 0 0 0 2px var(--accent-gold-dim);
        }

        /* 폴더 열기 아이콘 버튼 (작은 크기) */
        .folder-btn {
            padding: 4px 8px !important;
            margin: 0 !important;
            font-size: 0.9rem !important;
            line-height: 1;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
        }
        .folder-btn:hover {
            background: var(--bg-lighter);
        }
        
        /* LoRA */
        .lora-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .lora-header label {
            flex: 1;
            margin-bottom: 0;
        }
        
        .lora-add-btn {
            padding: 4px 10px;
            font-size: 0.8rem;
            background: var(--accent-gold);
            color: var(--bg-dark);
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .lora-add-btn:hover {
            background: var(--accent-gold-hover);
        }
        
        .lora-list {
            max-height: 150px;
            overflow-y: auto;
        }
        
        .lora-slot {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: var(--bg);
            border-radius: 6px;
            margin-bottom: 4px;
        }
        
        .lora-slot select {
            flex: 1;
            min-width: 0;
            padding: 4px 6px;
            font-size: 0.8rem;
        }
        
        .lora-slot input[type="number"] {
            width: 50px;
            padding: 4px 6px;
            margin: 0;
            font-size: 0.8rem;
        }
        
        .lora-slot .lora-remove-btn {
            padding: 2px 6px;
            font-size: 0.75rem;
            background: transparent;
            color: var(--text-dim);
            border: none;
            cursor: pointer;
            opacity: 0.6;
        }
        
        .lora-slot .lora-remove-btn:hover {
            opacity: 1;
            color: #ff6b6b;
        }
        
        .lora-empty {
            color: var(--text-dim);
            font-size: 0.85rem;
            padding: 8px;
            text-align: center;
        }

        /* Vibe Transfer */
        .vibe-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .vibe-item {
            background: var(--bg);
            border-radius: 8px;
            padding: 10px;
        }

        .vibe-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .vibe-item-header img {
            width: 48px;
            height: 48px;
            object-fit: cover;
            border-radius: 6px;
        }

        .vibe-item-header .vibe-info {
            flex: 1;
            font-size: 0.8rem;
            color: var(--text-dim);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .vibe-item-header .remove-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255,100,100,0.2);
            color: var(--error);
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }

        .vibe-item-header .remove-btn:hover {
            background: rgba(255,100,100,0.4);
        }

        .nai-vibe-placeholder {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
        }

        .vibe-cached-badge {
            color: #4ade80;
            font-size: 0.7rem;
            margin-left: 4px;
        }

        .vibe-sliders {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .vibe-slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
        }

        .vibe-slider-row label {
            width: 70px;
            color: var(--text-dim);
        }

        .vibe-slider-row input[type="range"] {
            flex: 1;
        }

        .vibe-slider-row .value {
            width: 35px;
            text-align: right;
            color: var(--text);
        }

        /* Character Reference */
        .char-ref-preview {
            position: relative;
            margin-bottom: 8px;
            text-align: center;
        }

        .char-ref-preview img {
            max-width: 100%;
            max-height: 150px;
            border-radius: 8px;
            object-fit: contain;
        }

        .char-ref-preview .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(0,0,0,0.7);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }

        .char-ref-preview .remove-btn:hover {
            background: rgba(255,100,100,0.8);
        }

        /* Anlas Info - Single line */
        .anlas-info {
            display: flex;
            align-items: center;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: var(--space-sm);
            gap: var(--space-sm);
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: var(--space-sm) var(--space-md);
        }

        .anlas-info .anlas-icon { font-size: 0.8rem; }
        .anlas-info #anlasBalance { font-weight: 600; color: var(--text); }
        .anlas-info .anlas-separator { opacity: 0.3; margin: 0 var(--space-xs); }
        .anlas-info .anlas-cost-label { opacity: 0.7; }
        .anlas-info #anlasCost { color: var(--accent-gold); font-weight: 600; }

        .anlas-refresh {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 0.7rem;
            padding: 0 2px;
            opacity: 0.6;
        }
        .anlas-refresh:hover { opacity: 1; color: var(--text); }

        .free-tag {
            background: #22c55e;
            color: white;
            font-size: 0.75rem;
            font-weight: 700;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 4px;
        }

        /* Button */
        .btn {
            width: 100%;
            padding: var(--space-md) var(--space-lg);
            background: var(--accent);
            border: none;
            border-radius: var(--radius-md);
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
        }

        .btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        .btn:disabled {
            background: var(--bg-lighter);
            color: var(--text-dim);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Queue button - Gold accent */
        #generateBtn {
            background: var(--accent-gold);
            color: var(--bg);
            font-size: 0.95rem;
            padding: var(--space-lg);
        }

        #generateBtn:hover {
            background: var(--accent-gold-hover);
        }

        .btn-secondary {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
        }

        .btn-secondary:hover {
            background: var(--bg-lighter);
            border-color: var(--text-dim);
            transform: none;
            box-shadow: none;
        }

        .btn-success {
            background: #22c55e;
        }
        .btn-success:hover { background: #16a34a; }

        /* Inline button row (for vibe buttons, etc.) */
        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .btn-row .btn {
            width: auto;
            margin-top: 0;
            padding: 10px 16px;
        }
        .btn-row .btn-icon {
            padding: 10px 12px;
            flex-shrink: 0;
        }
        
        /* Main Area */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Mode Header (공통) */
        .mode-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            color: var(--text-dim);
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        /* Slots Toolbar */
        .slots-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) var(--space-lg);
            border-bottom: 1px solid var(--border);
            background: var(--bg);
            flex-shrink: 0;
            gap: var(--space-md);
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-label {
            color: var(--text-muted);
            font-size: 0.8rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .add-slot-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .add-slot-btn:hover {
            background: var(--accent-hover);
        }

        /* 슬롯 사이즈 프리셋 */
        .slot-size-presets {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0 4px;
        }

        .slot-size-preset-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: monospace;
            min-width: 50px;
            text-align: center;
            transition: all 0.2s;
        }

        .slot-size-preset-btn:hover {
            background: var(--bg-light);
            border-color: var(--accent-gold);
        }

        .slot-size-preset-btn.active {
            color: var(--accent-gold);
            font-weight: bold;
        }

        .header-btn.icon-only {
            padding: 6px 8px;
            font-size: 1rem;
        }
        
        .header-btn {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            padding: var(--space-sm) var(--space-md);
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-fast);
            white-space: nowrap;
        }

        .header-btn:hover {
            background: var(--bg-light);
            border-color: var(--accent-dim);
            color: var(--text);
        }

        .header-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        /* 검열중 탭 버튼 - 골드 색상 */
        #censorTabProcessing {
            border-color: var(--accent-gold-dim);
            color: var(--accent-gold);
        }
        #censorTabProcessing:hover {
            background: var(--accent-gold-dim);
            border-color: var(--accent-gold);
            color: white;
        }
        #censorTabProcessing.active {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: #1a1a1a;
        }

        .header-btn.icon-only {
            padding: var(--space-sm) var(--space-sm);
            font-size: 1rem;
        }
        
        /* Preset Dropdown */
        .preset-dropdown {
            position: relative;
        }
        
        .preset-btn {
            min-width: 120px;
        }
        
        .preset-btn .preset-name {
            flex: 1;
            text-align: left;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .preset-btn .dropdown-arrow {
            font-size: 0.6rem;
            margin-left: 4px;
        }
        
        .preset-menu {
            display: none;
            position: fixed;
            min-width: 220px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            z-index: 99999;
            overflow: hidden;
        }
        
        .preset-menu.show {
            display: block;
        }
        
        .preset-list {
            max-height: 250px;
            overflow-y: auto;
        }
        
        .preset-item {
            display: flex;
            align-items: center;
            padding: var(--space-sm) var(--space-md);
            cursor: pointer;
            transition: background var(--transition-fast);
            gap: var(--space-sm);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .preset-item:last-child {
            border-bottom: none;
        }

        .preset-item:hover {
            background: var(--bg-lighter);
        }
        
        .preset-item.selected {
            background: var(--accent);
            color: white;
        }
        
        .preset-item .check {
            width: 16px;
            font-size: 0.8rem;
        }
        
        .preset-item .label {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .preset-item .edit-btn,
        .preset-item .delete-btn {
            background: none;
            border: none;
            padding: 2px 4px;
            cursor: pointer;
            opacity: 0.5;
            font-size: 0.85rem;
            border-radius: 4px;
        }
        
        .preset-item .edit-btn:hover,
        .preset-item .delete-btn:hover {
            opacity: 1;
            background: var(--bg);
        }
        
        .preset-item.selected .edit-btn:hover,
        .preset-item.selected .delete-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .preset-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .preset-action-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.85rem;
            cursor: pointer;
            text-align: left;
            transition: all 0.15s;
        }
        
        .preset-action-btn:hover {
            background: var(--bg);
            border-color: var(--text-dim);
        }
        
        .preset-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        /* Output Folder Dropdown */
        .folder-dropdown {
            position: relative;
        }

        .folder-btn {
            min-width: 100px;
        }

        .folder-btn .folder-name {
            flex: 1;
            text-align: left;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .folder-btn .dropdown-arrow {
            font-size: 0.6rem;
            margin-left: 4px;
        }

        .folder-menu {
            display: none;
            position: fixed;
            min-width: 180px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            z-index: 99999;
            overflow: hidden;
        }

        .folder-menu.show {
            display: block;
        }

        .folder-list {
            max-height: 250px;
            overflow-y: auto;
        }

        .folder-item {
            display: flex;
            align-items: center;
            padding: var(--space-sm) var(--space-md);
            cursor: pointer;
            transition: background var(--transition-fast);
            gap: var(--space-sm);
            font-size: 0.85rem;
            color: var(--text);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .folder-item:last-child {
            border-bottom: none;
        }

        .folder-item:hover {
            background: var(--bg-lighter);
        }

        .folder-item.active {
            background: var(--accent);
            color: white;
        }

        .folder-item.root-folder {
            font-weight: 500;
            border-bottom: 1px solid var(--border);
        }

        .folder-item.subfolder {
            padding-left: 24px;
        }

        .folder-actions {
            border-top: 1px solid var(--border);
            padding: 8px;
        }

        .folder-action-btn {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.85rem;
            cursor: pointer;
            text-align: left;
            transition: all 0.15s;
        }

        .folder-action-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .slots-container-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .slots-container-wrapper::before,
        .slots-container-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 40px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .slots-container-wrapper::before {
            left: 0;
            background: linear-gradient(to right, var(--bg) 0%, transparent 100%);
        }
        
        .slots-container-wrapper::after {
            right: 0;
            background: linear-gradient(to left, var(--bg) 0%, transparent 100%);
        }
        
        .slots-container-wrapper.can-scroll-left::before {
            opacity: 1;
        }
        
        .slots-container-wrapper.can-scroll-right::after {
            opacity: 1;
        }
        
        .slots-container {
            height: 100%;
            display: flex;
            gap: 16px;
            padding: 16px;
            overflow-x: auto;
            overflow-y: hidden;
            align-items: stretch;
            user-select: none;
        }
        
        .slot {
            width: var(--slot-width, 280px);
            min-width: 150px;
            max-width: 1200px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            overflow: visible;  /* 리사이즈 핸들이 바깥에 표시되도록 */
            flex-shrink: 0;
            transition: box-shadow 0.2s;
            position: relative;
        }

        /* 슬롯 리사이즈 핸들 (오른쪽만) */
        .slot-resize-handle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
            right: -8px;
            border-radius: 0 10px 10px 0;
        }

        .slot-resize-handle:hover,
        .slot-resize-handle.active {
            opacity: 1;
            background: var(--accent-gold-dim);
        }

        body.resizing-slot {
            cursor: ew-resize !important;
            user-select: none !important;
        }

        body.resizing-slot * {
            cursor: ew-resize !important;
        }
        
        /* input, textarea는 선택 가능 */
        .slot input, .slot textarea {
            user-select: text;
        }
        
        .slot.dragging {
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            opacity: 0.9;
        }
        
        .slot-placeholder {
            background: var(--bg-lighter);
            border: 2px dashed var(--border);
            border-radius: 10px;
            flex-shrink: 0;
        }
        
        .slot-prompt {
            flex-shrink: 0;
            border-bottom: 1px solid var(--border);
        }
        
        .slot-prompt-header {
            display: flex;
            align-items: center;
            background: var(--bg-lighter);
            padding: 6px 8px;
            gap: 6px;
        }
        
        .slot-number {
            font-size: 0.75rem;
            color: var(--accent-gold);
            font-weight: bold;
            font-family: monospace;
            background: var(--bg);
            padding: 4px 6px;
            border-radius: 4px;
            flex-shrink: 0;
            line-height: 1;
            display: flex;
            align-items: center;
        }
        
        .slot-prompt-header input {
            flex: 1;
            background: transparent;
            border: none;
            padding: 4px;
            margin: 0;
            font-size: 0.85rem;
            color: var(--text);
            min-width: 0;
        }
        
        .slot-prompt-header input::placeholder {
            color: var(--text-dim);
        }
        
        .slot-prompt-header input:focus {
            outline: none;
        }
        
        .slot-drag {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: grab;
            padding: 2px 4px;
            font-size: 0.9rem;
            line-height: 1;
            border-radius: 4px;
        }
        
        .slot-drag:hover {
            background: var(--bg);
            color: var(--text);
        }
        
        .slot-drag:active {
            cursor: grabbing;
        }
        
        .slot-delete {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 1.1rem;
            line-height: 1;
            border-radius: 4px;
        }
        
        .slot-delete:hover {
            background: var(--error);
            color: white;
        }
        
        .slot-prompt textarea {
            width: 100%;
            border: none;
            background: var(--bg-light);
            padding: 10px;
            margin: 0;
            min-height: 70px;
            resize: vertical;
            font-size: 0.85rem;
            color: var(--text);
        }
        
        .slot-prompt textarea:focus {
            outline: none;
        }
        
        .slot-images {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .slot-image-card {
            position: relative;
            background: var(--bg);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            transition: border-color 0.2s;
            flex-shrink: 0;
        }
        
        .slot-image-card:hover {
            border-color: var(--accent);
        }
        
        .slot-image-card img {
            width: 100%;
            height: auto;
            cursor: pointer;
            display: block;
            user-select: none;
            -webkit-user-drag: none;
        }
        
        .slot-image-card .info {
            padding: 6px 8px;
            font-size: 0.7rem;
        }
        
        .slot-image-card .filename {
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .slot-image-card .seed {
            color: var(--text-dim);
            margin-top: 2px;
        }
        
        .slot-empty {
            color: var(--text-dim);
            font-size: 0.8rem;
            text-align: center;
            padding: 20px 10px;
        }
        
        .progress-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-lighter);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s;
        }
        
        .status-text {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        
        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-dim);
            text-align: center;
        }
        
        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        
        .empty-state p {
            font-size: 1.1rem;
            margin-bottom: 8px;
        }
        
        .empty-state small {
            opacity: 0.7;
        }
        
        /* Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .lightbox.active { display: flex; }
        
        .lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
        }
        
        .lightbox .close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 2.5rem;
            color: white;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .lightbox .close:hover { opacity: 1; }

        /* Drop Overlay */
        .drop-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(59, 130, 246, 0.15);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            border: 4px dashed var(--accent);
            pointer-events: none;
        }
        .drop-overlay.active { display: flex; }
        .drop-overlay-content {
            background: var(--bg-light);
            padding: 40px 60px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        .drop-overlay-content .icon { font-size: 48px; margin-bottom: 16px; }
        .drop-overlay-content h3 { margin: 0 0 8px 0; font-size: 1.5rem; }
        .drop-overlay-content p { margin: 0; color: var(--text-dim); }

        /* Drop Confirm Modal */
        .drop-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .drop-modal.active { display: flex; }
        .drop-modal-content {
            background: var(--bg-light);
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
        }
        .drop-modal-content h3 { margin: 0 0 16px 0; }
        .drop-modal-content .preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        .drop-modal-content .metadata {
            background: var(--bg);
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            margin-bottom: 16px;
            max-height: 200px;
            overflow-y: auto;
        }
        .drop-modal-content .metadata div { margin-bottom: 4px; }
        .drop-modal-content .buttons { display: flex; gap: 12px; justify-content: flex-end; }
        .drop-modal-content .buttons .btn {
            width: auto;
            flex: 1;
            padding: 10px 16px;
        }

        /* Mask Editor Modal */
        .mask-editor-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .mask-editor-modal.active { display: flex; }
        .mask-editor-container {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 20px;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .mask-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .mask-editor-header h3 { margin: 0; }
        .mask-editor-canvas-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
        }
        .mask-editor-canvas-wrapper canvas {
            max-width: 100%;
            max-height: 70vh;
        }
        #maskEditorMaskCanvas {
            position: absolute;
            top: 0; left: 0;
            opacity: 0.5;
            pointer-events: none;
        }
        .mask-editor-toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .mask-editor-toolbar .tool-group {
            display: flex;
            gap: 4px;
            background: var(--bg);
            padding: 4px;
            border-radius: 8px;
        }
        .mask-editor-toolbar .tool-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
        }
        .mask-editor-toolbar .tool-btn:hover { background: var(--border); }
        .mask-editor-toolbar .tool-btn.active { background: var(--primary); color: white; }
        .mask-editor-toolbar .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .mask-editor-toolbar .slider-group label {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        .mask-editor-toolbar .slider-group input[type="range"] {
            width: 100px;
        }
        .mask-editor-footer {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        .mask-editor-footer .btn { padding: 10px 20px; }

        /* Censor Mode Container - New Design */
        .censor-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: var(--bg);
        }
        
        /* 썸네일 가로 슬라이드 */
        .censor-thumbnails-wrapper {
            background: var(--bg-light);
            border-bottom: 1px solid var(--border);
            padding: 16px;
            overflow: hidden;
        }
        .censor-thumbnails {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 8px 0;
            scroll-behavior: smooth;
        }
        .censor-thumbnail {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .censor-thumbnail:hover { border-color: var(--text-dim); }
        .censor-thumbnail.active {
            border-width: 3px;
            border-color: var(--accent-gold);
        }
        .censor-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .censor-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            color: var(--text-dim);
            font-size: 0.9rem;
            padding: 20px;
        }
        
        /* 큰 프리뷰 영역 */
        .censor-preview-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 16px;
            overflow: visible;  /* 회전 핸들이 밖으로 나갈 수 있도록 */
            background: var(--bg);
            position: relative;
            transition: background 0.3s ease;
        }
        /* 검열중 탭일 때 배경 구분 - 골드 강조 */
        .censor-preview-area.processing {
            background: color-mix(in srgb, var(--bg) 75%, var(--accent-gold-dim) 25%);
            border: 1px solid var(--accent-gold-dim);
        }
        .censor-preview-container {
            position: relative;
            display: inline-block;
            overflow: visible;  /* 회전 핸들이 밖으로 나갈 수 있도록 */
        }
        .censor-preview-container canvas {
            display: block;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .censor-preview-hint {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            color: #ffd700;
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 0.85rem;
            z-index: 100;
            pointer-events: none;
            white-space: nowrap;
        }
        .censor-preview-hint strong {
            color: #fff;
        }
        #censorPreviewCanvas {
            position: relative;
        }
        #censorOverlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: auto;
            cursor: default;
        }
        .censor-preview-empty {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            text-align: center;
            padding: 40px;
            pointer-events: none;
        }
        .censor-preview-empty .icon { font-size: 4rem; margin-bottom: 16px; opacity: 0.5; }
        .censor-preview-empty p { font-size: 1.1rem; }
        
        /* 스캔 로딩 인디케이터 */
        .censor-scan-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            color: var(--text-dim);
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 15;
            background: rgba(0, 0, 0, 0.6);
            padding: 16px 24px;
            border-radius: 8px;
        }
        .censor-scan-loading.active { display: flex; }
        .scan-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid var(--text-dim);
            border-top-color: var(--accent-gold);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* 이미지 네비게이션 화살표 */
        .censor-nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: none; /* 초기에는 숨김 */
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.2s ease;
            backdrop-filter: blur(8px);
        }
        .censor-nav-arrow:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.7);
            transform: translateY(-50%) scale(1.1);
        }
        .censor-nav-arrow:active {
            transform: translateY(-50%) scale(0.95);
        }
        .censor-nav-arrow:disabled {
            opacity: 0.2;
            cursor: not-allowed;
        }
        .censor-nav-left {
            left: 24px;
        }
        .censor-nav-right {
            right: 24px;
        }

        /* 이미지 번호 표시 */
        .censor-image-counter {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 6px 16px;
            border-radius: 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            font-weight: 500;
            backdrop-filter: blur(8px);
            pointer-events: none;
            user-select: none;
            display: none; /* 초기에는 숨김 */
        }

        /* 단축키 안내 */
        .censor-shortcuts-guide {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            align-items: center;
            padding: 8px 0;
            color: var(--text-dim);
            font-size: 0.9rem;
        }
        .shortcut-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .censor-shortcuts-guide kbd {
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            color: var(--text);
        }
        
        /* 하단 옵션 패널 - 고정 높이 */
        .censor-options-panel {
            background: var(--bg-light);
            border-top: 1px solid var(--border);
            padding: 0;
            height: 150px;
            flex-shrink: 0;
            display: flex;
            align-items: stretch;
        }
        .censor-options-before, .censor-options-processing, .censor-options-after {
            display: flex;
            align-items: stretch;
            width: 100%;
            height: 100%;
        }
        
        /* 좌측 컨텐츠 영역 */
        .censor-panel-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 16px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        /* 구분선 */
        .censor-panel-divider {
            width: 1px;
            background: var(--border);
            flex-shrink: 0;
        }
        
        /* 우측 액션 영역 (고정) */
        .censor-panel-right {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            padding: 12px 20px;
            min-width: 160px;
        }
        .censor-panel-right .btn-lg {
            width: 100%;
            padding: 12px 16px;
            font-size: 0.95rem;
            font-weight: 500;
        }
        
        /* 검열 전 탭 - 모델 선택 행 */
        .censor-model-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .censor-model-row > label,
        .censor-model-row select {
            font-size: 0.85rem;
            height: 32px;
            line-height: 32px;
            box-sizing: border-box;
        }
        .censor-model-row > label {
            color: var(--text-dim);
            white-space: nowrap;
            min-width: 60px;
        }
        .censor-model-row select {
            padding: 0 10px;
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            min-width: 180px;
        }
        
        /* 검열 전 탭 - 감지 대상 행 */
        .censor-targets-row {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            flex: 1;
        }
        .censor-targets-row > label {
            font-size: 0.85rem;
            color: var(--text-dim);
            white-space: nowrap;
            min-width: 60px;
            height: 28px;
            line-height: 28px;
        }
        
        /* 검열 대상 (동적 클래스) - 가로 플렉스 */
        .censor-targets {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            align-content: flex-start;
            flex: 1;
        }
        .censor-target-item {
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--bg);
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid var(--border);
            font-size: 0.8rem;
            height: 28px;
            transition: border-color 0.15s;
        }
        .censor-target-item:hover {
            border-color: var(--text-dim);
        }
        .censor-target-item input[type="checkbox"] {
            width: 14px;
            height: 14px;
            margin: 0;
            flex-shrink: 0;
            cursor: pointer;
        }
        .censor-target-item label {
            font-size: 0.8rem;
            cursor: pointer;
            white-space: nowrap;
        }
        .censor-target-item input[type="range"] {
            --slider-percent: 30%;
            width: 100px;
            height: 14px;
            margin: 4px 0;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            transition: opacity 0.2s;
        }
        .censor-target-item input[type="range"]:hover {
            opacity: 0.9;
        }
        /* 검열 대상 슬라이더 - 트랙 (Chrome, Safari, Edge) */
        .censor-target-item input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, 
                var(--accent-gold, #d4a853) 0%, 
                var(--accent-gold, #d4a853) var(--slider-percent, 30%), 
                var(--bg-darker, #1a1a1a) var(--slider-percent, 30%), 
                var(--bg-darker, #1a1a1a) 100%);
            border-radius: 2px;
            border: none;
        }
        /* 검열 대상 슬라이더 - 썸 (Chrome, Safari, Edge) */
        .censor-target-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--text, #fff);
            border-radius: 50%;
            border: 2px solid var(--accent-gold, #d4a853);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            margin-top: -5px;
        }
        .censor-target-item input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--accent-gold, #d4a853);
            border-color: var(--accent-gold-bright, #e6b85a);
            transform: scale(1.1);
        }
        /* 검열 대상 슬라이더 - 트랙 (Firefox) */
        .censor-target-item input[type="range"]::-moz-range-track {
            width: 100%;
            height: 4px;
            background: var(--bg-darker, #1a1a1a);
            border-radius: 2px;
            border: none;
        }
        /* 검열 대상 슬라이더 - 썸 (Firefox) */
        .censor-target-item input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--text, #fff);
            border-radius: 50%;
            border: 2px solid var(--accent-gold, #d4a853);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .censor-target-item input[type="range"]::-moz-range-thumb:hover {
            background: var(--accent-gold, #d4a853);
            border-color: var(--accent-gold-bright, #e6b85a);
            transform: scale(1.1);
        }
        /* Firefox 진행 바 채움 */
        .censor-target-item input[type="range"]::-moz-range-progress {
            background: var(--accent-gold, #d4a853);
            height: 4px;
            border-radius: 2px;
        }
        .censor-target-item .conf-value {
            font-size: 0.75rem;
            color: var(--text-dim);
            min-width: 22px;
            text-align: right;
            font-family: monospace;
        }
        .censor-target-loading {
            color: var(--text-dim);
            font-size: 0.85rem;
            font-style: italic;
        }
        
        /* 검열 방식 선택 */
        .censor-method-select {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 6px;
            width: 100%;
        }
        .censor-method-select label {
            font-size: 0.8rem;
            color: var(--text-dim);
            white-space: nowrap;
            height: 16px;
            line-height: 16px;
        }
        .censor-method-select select {
            height: 32px;
            padding: 0 10px;
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            width: 100%;
            line-height: 30px;
        }
        
        /* 검열중/검열후 탭 - 컨텐츠 레이아웃 */
        .censor-proc-content,
        .censor-after-content {
            display: flex;
            align-items: center;
            gap: 24px;
            height: 100%;
        }
        
        /* 이미지 네비게이션 */
        .censor-nav-info {
            display: flex;
            align-items: center;
            gap: 10px;
            height: 32px;
        }
        .censor-nav-info .nav-label,
        .nav-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            white-space: nowrap;
            height: 32px;
            line-height: 32px;
        }
        .censor-nav-info .nav-buttons {
            display: flex;
            align-items: center;
            gap: 0;
            height: 32px;
        }
        .censor-nav-info .nav-btn,
        .nav-btn {
            height: 32px;
            padding: 0 12px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            line-height: 30px;
            transition: all 0.15s;
        }
        .censor-nav-info .nav-btn:hover,
        .nav-btn:hover {
            border-color: var(--primary);
            background: var(--bg-light);
        }
        .censor-nav-info .nav-btn:disabled,
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .nav-progress {
            font-size: 0.9rem;
            color: var(--text);
            height: 32px;
            line-height: 32px;
            min-width: 50px;
            text-align: center;
            font-family: monospace;
        }
        
        /* 검열중 탭 - 도구 버튼 */
        .censor-proc-tools {
            display: flex;
            gap: 6px;
            height: 32px;
        }
        .censor-proc-tools .tool-btn {
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            height: 32px;
            line-height: 18px;
        }
        .censor-proc-tools .tool-btn:hover {
            border-color: var(--primary);
        }
        .censor-proc-tools .tool-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        /* 검열중 탭 - 방식 선택 */
        .censor-proc-method {
            display: flex;
            align-items: center;
            gap: 10px;
            height: 32px;
        }
        .censor-proc-method .method-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            white-space: nowrap;
            height: 32px;
            line-height: 32px;
        }
        .censor-proc-method select {
            height: 32px;
            padding: 0 10px;
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            line-height: 32px;
            vertical-align: middle;
        }
        
        /* 검열중 탭 - 팁 */
        .censor-proc-tip {
            color: var(--text-dim);
            font-size: 0.8rem;
            height: 32px;
            line-height: 32px;
        }
        
        /* 검열 후 탭 - 액션 (deprecated) */
        .censor-after-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* 편집 모달 (더 이상 사용 안함 - 검열후 탭에서 직접 편집) */
        .censor-edit-modal {
            display: none !important;
        }
        .censor-edit-modal.show {
            display: none !important;
        }
        .censor-edit-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--bg-light);
            border-bottom: 1px solid var(--border);
        }
        .censor-edit-modal-header h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--text);
        }
        .censor-edit-modal-close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 4px 8px;
        }
        .censor-edit-modal-close:hover {
            color: var(--text);
        }
        .censor-edit-modal-body {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
        }
        .censor-edit-modal-canvas-container {
            position: relative;
            display: inline-block;
        }
        .censor-edit-modal-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--bg-light);
            border-top: 1px solid var(--border);
            gap: 16px;
        }
        .censor-edit-modal-tools {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .censor-edit-modal-tools .tool-btn {
            padding: 8px 14px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .censor-edit-modal-tools .tool-btn:hover {
            border-color: var(--primary);
        }
        .censor-edit-modal-tools .tool-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .censor-edit-modal-actions {
            display: flex;
            gap: 8px;
        }
        
        /* 감지 박스 스타일 */
        .censor-box {
            position: absolute;
            border: 2px dashed rgba(255, 0, 0, 0.8);
            background: rgba(255, 0, 0, 0.1);
            cursor: move;
        }
        .censor-box.selected {
            border: 2px solid var(--primary);
            background: rgba(0, 122, 255, 0.1);
        }
        .censor-box .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border: 1px solid var(--primary);
        }
        .censor-box .resize-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .censor-box .resize-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .censor-box .resize-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .censor-box .resize-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }

        /* Censor Quick Editor Modal */
        .censor-editor-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .censor-editor-modal.active { display: flex; }
        .censor-editor-container {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 20px;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .censor-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .censor-editor-header .header-left,
        .censor-editor-header .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .censor-editor-header h3 { margin: 0; }
        .censor-editor-header .image-counter {
            font-size: 0.9rem;
            color: var(--text-dim);
            padding: 4px 12px;
            background: var(--bg);
            border-radius: 4px;
        }
        .censor-editor-header .nav-btn {
            padding: 8px 16px;
            border: none;
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
        }
        .censor-editor-header .nav-btn:hover { background: var(--border); }
        .censor-editor-toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .censor-editor-toolbar .tool-group {
            display: flex;
            gap: 4px;
            background: var(--bg);
            padding: 4px;
            border-radius: 8px;
        }
        .censor-editor-toolbar .tool-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .censor-editor-toolbar .tool-btn:hover { background: var(--border); }
        .censor-editor-toolbar .tool-btn.active { background: var(--primary); color: white; }
        .censor-editor-toolbar .tool-btn.fill-btn {
            width: 36px;
            padding: 8px;
            text-align: center;
        }
        .censor-editor-toolbar .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .censor-editor-toolbar .slider-group label {
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        .censor-editor-toolbar .slider-group input[type="range"] {
            width: 100px;
        }
        .censor-editor-canvas-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
        }
        .censor-editor-canvas-wrapper canvas {
            max-width: 100%;
            max-height: 70vh;
        }
        .censor-editor-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .censor-editor-footer .footer-left,
        .censor-editor-footer .footer-right {
            display: flex;
            gap: 8px;
        }
        .censor-editor-footer .btn { padding: 10px 16px; }
        .btn-warning {
            background: #FF9800 !important;
            color: white !important;
        }
        .btn-warning:hover {
            background: #F57C00 !important;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: var(--bg);
            border-radius: var(--radius-lg);
            padding: var(--space-xs);
            gap: var(--space-xs);
            border: 1px solid var(--border);
        }
        .mode-btn {
            padding: var(--space-md) var(--space-xl);
            border: none;
            background: transparent;
            color: var(--text-dim);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        .mode-btn:hover:not(.active) {
            color: var(--text);
            background: var(--bg-lighter);
        }
        .mode-btn.active {
            background: var(--accent);
            color: white;
            box-shadow: var(--shadow-md);
        }

        /* Gallery */
        .gallery-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            overflow: hidden;
        }
        /* Gallery Toolbar */
        .gallery-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-sm) var(--space-lg);
            border-bottom: 1px solid var(--border);
            background: var(--bg);
            flex-shrink: 0;
            gap: var(--space-md);
        }

        /* Gallery Subfolders Row */
        .gallery-subfolders {
            display: flex;
            gap: var(--space-sm);
            flex-wrap: wrap;
        }

        .folder-separator {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 4px;
            align-self: center;
        }
        .folder-separator.double {
            width: 4px;
            background: linear-gradient(90deg, var(--border) 0%, var(--border) 40%, transparent 40%, transparent 60%, var(--border) 60%, var(--border) 100%);
            margin: 0 8px;
        }
        .folder-tab.vibe-folder {
            background: var(--bg-light);
            border-color: var(--accent-gold);
        }
        .folder-tab.vibe-folder:hover {
            background: var(--bg-lighter);
        }
        .folder-tab.vibe-folder.active {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: black;
        }

        .folder-tab {
            padding: 6px 12px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .folder-tab:hover {
            background: var(--bg-lighter);
        }
        .folder-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        .folder-tab.root-folder {
            font-weight: 500;
        }
        .folder-tab.drag-over {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: black;
        }

        .add-folder-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }
        .add-folder-btn:hover {
            background: var(--accent-hover);
        }
        .gallery-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
        }
        .gallery-folder-btn {
            padding: 6px 10px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }
        .gallery-folder-btn:hover {
            background: var(--bg-lighter);
            border-color: var(--accent-gold);
        }
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 20px;
            width: 100%;
            align-items: start;
            align-content: start;
            padding-bottom: 8px;
        }
        .gallery-item {
            background: var(--bg-light);
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            overflow: hidden;
            transition: transform var(--transition-normal), box-shadow var(--transition-normal), border-color var(--transition-normal);
            cursor: pointer;
            height: fit-content;
            position: relative;
            max-width: 520px;
        }
        .gallery-item:hover {
            transform: translateY(-2px);
            z-index: 1;
            box-shadow: var(--shadow-lg);
            border-color: var(--accent-dim);
        }
        .gallery-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .gallery-item img {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            display: block;
        }
        .gallery-item-info {
            padding: 12px;
        }
        .gallery-item-info .filename-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }
        .gallery-item-info .filename {
            font-size: 0.85rem;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }
        .gallery-item-info .filename-input {
            flex: 1;
            min-width: 0;
            font-size: 0.85rem;
            padding: 2px 6px;
            border: 1px solid var(--accent-gold);
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
        }
        .gallery-item-info .rename-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .gallery-item-info .rename-btn:hover {
            opacity: 1;
        }
        .gallery-item-info .seed {
            font-size: 0.75rem;
            color: var(--text-dim);
        }
        .gallery-item-actions {
            display: flex;
            gap: 8px;
            padding: 8px 12px 12px;
        }
        .gallery-item-actions button {
            flex: 1;
            padding: 6px 8px;
            font-size: 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
        }
        .gallery-item-actions button:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }
        .gallery-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            min-height: 300px;
            color: var(--text-dim);
            text-align: center;
        }
        .gallery-empty .icon { font-size: 64px; margin-bottom: 16px; opacity: 0.5; }
        .gallery-empty p { margin: 0 0 8px 0; font-size: 1.1rem; }
        .gallery-empty small { opacity: 0.7; }

        /* Slot image save button */
        .slot-image-card .save-gallery-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 14px;
        }
        .slot-image-card:hover .save-gallery-btn { opacity: 1; }
        .slot-image-card .save-gallery-btn:hover { background: rgba(0,0,0,0.9); opacity: 1; }
        .slot-image-card .save-gallery-btn.saved { color: gold; opacity: 1; }

        /* Info row layout */
        .slot-image-card .info-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .slot-image-card .info-row .filename {
            flex: 1;
            min-width: 0;
        }

        /* Load settings button */
        .slot-image-card .load-settings-btn,
        .slot-image-card .apply-seed-btn,
        .slot-image-card .inpaint-btn,
        .slot-image-card .clear-card-btn {
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        .slot-image-card .load-settings-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .slot-image-card .apply-seed-btn:hover {
            background: var(--accent-gold);
            color: black;
            border-color: var(--accent-gold);
        }
        .slot-image-card .inpaint-btn:hover {
            background: #9b59b6;
            color: white;
            border-color: #9b59b6;
        }
        .slot-image-card .clear-card-btn:hover {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        /* Settings Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 900;
            justify-content: center;
            align-items: center;
        }
        
        .modal.active { display: flex; }
        
        .modal-content {
            background: var(--bg-light);
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-header h2 {
            font-size: 1.25rem;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .input-group {
            margin-bottom: 16px;
        }
        
        .input-group label {
            margin-bottom: 6px;
        }
        
        .input-group small {
            display: block;
            margin-top: -8px;
            margin-bottom: 12px;
            color: var(--text-dim);
            font-size: 0.8rem;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .status-badge.success {
            background: rgba(34, 197, 94, 0.2);
            color: var(--success);
        }
        
        .status-badge.warning {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }
        
        /* Local Environment */
        .local-env-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-lighter);
            border-radius: 6px;
            margin-top: 6px;
        }
        
        .local-env-status .status-icon {
            font-size: 1.2rem;
        }
        
        .local-env-status.installed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }
        
        .local-env-status.not-installed {
            background: rgba(245, 158, 11, 0.15);
            color: var(--warning);
        }
        
        .local-env-status.installing {
            background: rgba(111, 41, 222, 0.15);
            color: var(--accent);
        }
        
        .local-env-status.error {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }
        
        .local-env-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }
        
        .local-env-progress-bar {
            flex: 1;
            height: 8px;
            background: var(--bg-lighter);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .local-env-progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .local-env-progress-text {
            font-size: 0.8rem;
            color: var(--text-dim);
            min-width: 40px;
        }
        
        #localEnvActions .btn {
            margin-right: 8px;
        }
        
        #localEnvActions .btn-danger {
            background: rgba(239, 68, 68, 0.2);
            color: var(--error);
        }
        
        #localEnvActions .btn-danger:hover {
            background: rgba(239, 68, 68, 0.3);
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            padding: 12px 24px;
            border-radius: 8px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1100;
        }
        
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .toast.success { border-color: var(--success); }
        .toast.error { border-color: var(--error); }
        .toast.warning { border-color: var(--warning); }
    </style>
</head>
<body>
    <div class="app">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="logo"><img src="assets/icon.png" alt="" style="width: 42px; height: 42px;"> PeroPix</div>
                <button class="settings-btn" onclick="openSettings()">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                </button>
            </div>
            
            <div class="sidebar-content">
                <!-- Provider Tabs -->
                <div class="section">
                    <div class="tabs">
                        <div class="tab active" data-provider="nai">NAI</div>
                        <div class="tab" data-provider="local">Local</div>
                    </div>
                </div>
                
                <!-- Prompts -->
                <div class="section">
                    <div class="prompt-label-row">
                        <div class="prompt-label-left">
                            <button type="button" class="collapse-toggle" data-target="basePromptContent" title="접기/펼치기">▼</button>
                            <button type="button" id="modeToggle" class="mode-toggle" title="아니메 모드">🌸</button>
                            <label for="basePrompt" class="prompt-label">Base Prompt</label>
                        </div>
                        <div class="prompt-preset-dropdown" data-category="base">
                            <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">🔖 ▼</button>
                            <div class="prompt-preset-menu">
                                <div class="prompt-preset-list"></div>
                                <div class="prompt-preset-actions">
                                    <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="basePromptContent" class="collapsible-content">
                        <textarea id="basePrompt" placeholder="1girl, solo, masterpiece..."></textarea>
                    </div>

                    <!-- Characters -->
                    <div class="characters-section">
                        <div class="characters-header">
                            <button type="button" class="collapse-toggle" data-target="charactersContent" title="접기/펼치기">▼</button>
                            <label class="prompt-label">Characters</label>
                            <button type="button" class="add-char-btn" id="addCharBtn" title="캐릭터 추가">+</button>
                        </div>
                        <div id="charactersContent" class="collapsible-content">
                            <div class="characters-list" id="charactersList">
                                <!-- 캐릭터들이 여기에 추가됨 -->
                            </div>
                        </div>
                    </div>

                    <div class="prompt-label-row">
                        <div class="prompt-label-left">
                            <button type="button" class="collapse-toggle" data-target="negativePromptContent" title="접기/펼치기">▼</button>
                            <label for="negativePrompt" class="prompt-label">Negative Prompt</label>
                        </div>
                        <div class="prompt-preset-dropdown" data-category="negative">
                            <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">🔖 ▼</button>
                            <div class="prompt-preset-menu">
                                <div class="prompt-preset-list"></div>
                                <div class="prompt-preset-actions">
                                    <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="negativePromptContent" class="collapsible-content">
                        <textarea id="negativePrompt" rows="2" placeholder="lowres, bad quality..."></textarea>
                    </div>
                </div>
                
                <!-- NAI Settings -->
                <div class="provider-section active" data-provider="nai">
                    <div class="section">
                        <div class="section-title">
                            <button type="button" class="collapse-toggle" data-target="naiSettingsContent" title="접기/펼치기">▼</button>
                            <span>NAI Settings</span>
                        </div>
                        <div id="naiSettingsContent" class="collapsible-content">
                            <label>Model</label>
                            <select id="naiModel">
                                <option value="nai-diffusion-4-5-full">V4.5 Full</option>
                                <option value="nai-diffusion-4-curated-preview">V4 Curated</option>
                                <option value="nai-diffusion-3">V3</option>
                            </select>

                            <div class="row">
                                <div>
                                    <label>Undesired Content Preset</label>
                                    <select id="ucPreset">
                                        <option value="Heavy">Heavy</option>
                                        <option value="Light">Light</option>
                                        <option value="Human Focus">Human Focus</option>
                                        <option value="Furry Focus">Furry Focus</option>
                                        <option value="None">None</option>
                                    </select>
                                </div>
                                <div>
                                    <label>SMEA</label>
                                    <select id="smea">
                                        <option value="none">None</option>
                                        <option value="SMEA">SMEA</option>
                                        <option value="SMEA+DYN">SMEA+DYN</option>
                                    </select>
                                </div>
                            </div>

                            <div class="checkbox-row">
                                <input type="checkbox" id="qualityTags" checked>
                                <label for="qualityTags">Add Quality Tags</label>
                            </div>
                        </div>
                    </div>

                    <!-- Vibe / Character Reference -->
                    <div class="section">
                        <div class="section-title">
                            <button type="button" class="collapse-toggle" data-target="vibeCharRefContent" title="접기/펼치기">▼</button>
                            <span>Vibe / Character Ref</span>
                            <small style="font-weight: normal; text-transform: none; letter-spacing: 0; opacity: 0.7;">(택1)</small>
                        </div>
                        <div id="vibeCharRefContent" class="collapsible-content">
                            <!-- Vibe Transfer -->
                            <div class="subsection">
                                <div class="subsection-title">
                                    <span>Vibe Transfer</span>
                                    <label class="section-toggle">
                                        <input type="checkbox" id="enableVibeTransfer">
                                        <span>Active</span>
                                    </label>
                                </div>

                                <div id="vibeTransferSettings" style="display: none;">
                                    <small style="color: var(--text-dim); display: block; margin-bottom: 8px;">
                                        최대 16개 이미지. 강도 합계가 1.0 이하가 되도록 권장.
                                    </small>

                                    <div id="vibeCacheInfo" style="display: none; font-size: 12px; margin-bottom: 8px; padding: 4px 8px; background: rgba(0,0,0,0.2); border-radius: 4px;"></div>

                                    <div id="vibeList" class="vibe-list"></div>

                                    <div class="btn-row">
                                        <button type="button" class="btn btn-secondary" id="addVibeBtn" style="flex: 1;">
                                            + 바이브 추가
                                        </button>
                                        <button type="button" class="btn btn-secondary btn-icon" id="openVibeFolderBtn" title="바이브 캐시 폴더 열기">
                                            📁
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Character Reference (V4.5 only) -->
                            <div class="subsection" id="charRefSection">
                                <div class="subsection-title">
                                    <span>Character Reference</span>
                                    <label class="section-toggle">
                                        <input type="checkbox" id="enableCharRef">
                                        <span>Active</span>
                                    </label>
                                </div>

                                <div id="charRefSettings" style="display: none;">
                                    <small style="color: var(--text-dim); display: block; margin-bottom: 8px;">
                                        V4.5 전용. Vibe Transfer와 동시 사용 불가.
                                    </small>

                                    <div id="charRefPreview" class="char-ref-preview" style="display: none;">
                                        <img id="charRefImage" src="" alt="Character Reference">
                                        <button type="button" class="remove-btn" id="removeCharRefBtn">×</button>
                                    </div>

                                    <button type="button" class="btn btn-secondary" id="uploadCharRefBtn" style="width: 100%;">
                                        이미지 선택
                                    </button>
                                    <input type="file" id="charRefInput" accept="image/*" style="display: none;">

                                    <div class="row" style="margin-top: 12px;">
                                        <div style="flex: 1;">
                                            <label>Fidelity</label>
                                            <input type="range" id="charRefFidelity" value="0.5" min="0" max="1" step="0.05" style="width: 100%;">
                                            <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim);">
                                                <span>유연</span>
                                                <span id="charRefFidelityValue">0.5</span>
                                                <span>정밀</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="checkbox-row" style="margin-top: 8px;">
                                        <input type="checkbox" id="charRefStyleAware" checked>
                                        <label for="charRefStyleAware">Style Aware (스타일도 복사)</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Local Settings -->
                <div class="provider-section" data-provider="local">
                    <div class="section">
                        <div class="section-title">Local Settings</div>
                        
                        <div class="lora-header">
                            <label>Model</label>
                            <button type="button" class="folder-btn" id="openCheckpointsFolderBtn" title="체크포인트 폴더 열기">📁</button>
                        </div>
                        <select id="localModel" style="width: 100%; margin-bottom: 12px;">
                            <option value="">-- Select Model --</option>
                        </select>

                        <div class="lora-header">
                            <label>LoRAs</label>
                            <button type="button" class="lora-add-btn" id="addLoraSlotBtn" title="LoRA 슬롯 추가">+ Add</button>
                            <button type="button" class="folder-btn" id="openLorasFolderBtn" title="LoRA 폴더 열기">📁</button>
                        </div>
                        <div class="lora-list" id="loraList">
                            <div class="lora-empty">+ 버튼으로 LoRA 추가</div>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">
                            <span>Upscale</span>
                            <label class="section-toggle">
                                <input type="checkbox" id="enableUpscale">
                                <span>Active</span>
                            </label>
                        </div>
                        
                        <div id="upscaleSettings" style="display: none;">
                            <label>Upscale Model</label>
                            <select id="upscaleModel">
                                <option value="">-- Select Model --</option>
                            </select>
                            <small>Place .pth files in models/upscale_models/</small>
                            
                            <div class="row" style="margin-top: 8px;">
                                <div>
                                    <label>Final Scale</label>
                                    <input type="number" id="downscaleRatio" value="0.7" step="0.05" min="0.3" max="1.0">
                                    <small>×2 upscale × ratio</small>
                                </div>
                                <div>
                                    <label>Alignment</label>
                                    <select id="sizeAlignment">
                                        <option value="none">None</option>
                                        <option value="8">8px</option>
                                        <option value="64" selected>64px</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="row">
                                <div>
                                    <label>Steps</label>
                                    <input type="number" id="upscaleSteps" value="15" min="5" max="50">
                                </div>
                                <div>
                                    <label>CFG</label>
                                    <input type="number" id="upscaleCfg" value="5.0" step="0.1" min="1" max="20">
                                </div>
                            </div>
                            
                            <div class="row">
                                <div style="flex: 1;">
                                    <label>Denoise</label>
                                    <input type="range" id="upscaleDenoise" value="0.5" min="0.1" max="1.0" step="0.05" style="width: 100%;">
                                    <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim);">
                                        <span>0.1</span>
                                        <span id="upscaleDenoiseValue">0.5</span>
                                        <span>1.0</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Base Image (Inpaint/Img2Img) -->
                <div class="section" id="baseImageSection" style="display: none;">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="baseImageContent" title="접기/펼치기">▼</button>
                        <span>Base Image</span>
                        <button type="button" class="btn btn-secondary" id="clearBaseImage" style="margin-left: auto; padding: 4px 8px; font-size: 0.8rem;">✕ Clear</button>
                    </div>
                    <div id="baseImageContent" class="collapsible-content">
                        <div style="display: flex; gap: 12px; align-items: flex-start;">
                            <div id="baseImagePreview" style="flex: 0 0 120px; height: 120px; background: var(--bg); border-radius: 8px; overflow: hidden; display: flex; align-items: center; justify-content: center; position: relative;">
                                <img id="baseImageImg" src="" style="max-width: 100%; max-height: 100%; object-fit: contain;">
                                <div id="baseImageMaskOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.5; pointer-events: none;"></div>
                            </div>
                            <div style="flex: 1;">
                                <div class="row" style="margin-bottom: 8px;">
                                    <div style="flex: 1;">
                                        <label>Mode</label>
                                        <select id="baseImageMode">
                                            <option value="inpaint">Inpaint</option>
                                            <option value="img2img">Img2Img</option>
                                        </select>
                                    </div>
                                </div>
                                <div style="margin-bottom: 8px;">
                                    <label>Strength: <span id="baseImageStrengthValue">0.7</span></label>
                                    <input type="range" id="baseImageStrength" min="0" max="1" step="0.05" value="0.7" style="width: 100%;">
                                </div>
                                <div id="baseImageNoiseContainer">
                                    <label>Noise: <span id="baseImageNoiseValue">0</span></label>
                                    <input type="range" id="baseImageNoise" min="0" max="1" step="0.05" value="0" style="width: 100%;">
                                </div>
                                <button type="button" class="btn" id="editMaskBtn" style="margin-top: 8px; width: 100%;">🎨 Edit Mask</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Generation Settings -->
                <div class="section">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="generationContent" title="접기/펼치기">▼</button>
                        <span>Generation</span>
                    </div>
                    <div id="generationContent" class="collapsible-content">
                        <div class="row">
                            <div>
                                <label>Size</label>
                                <select id="sizePreset">
                                    <optgroup label="Landscape">
                                        <option value="1536x640">1536 × 640</option>
                                        <option value="1344x768">1344 × 768</option>
                                        <option value="1216x832">1216 × 832</option>
                                        <option value="1152x896">1152 × 896</option>
                                    </optgroup>
                                    <optgroup label="Square">
                                        <option value="1024x1024">1024 × 1024</option>
                                    </optgroup>
                                    <optgroup label="Portrait">
                                        <option value="896x1152">896 × 1152</option>
                                        <option value="832x1216" selected>832 × 1216</option>
                                        <option value="768x1344">768 × 1344</option>
                                        <option value="640x1536">640 × 1536</option>
                                    </optgroup>
                                    <option value="custom">Custom</option>
                                </select>
                            </div>
                            <div>
                                <label>W × H</label>
                                <div class="size-inputs">
                                    <input type="number" id="width" value="832" step="64">
                                    <span class="size-x">×</span>
                                    <input type="number" id="height" value="1216" step="64">
                                </div>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Steps</label>
                                <input type="number" id="steps" value="28">
                            </div>
                            <div>
                                <label id="cfgLabel">CFG</label>
                                <input type="number" id="cfg" value="5.0" step="0.1">
                            </div>
                        </div>

                        <!-- NAI Advanced Settings -->
                        <div id="naiAdvancedSettings" class="provider-section" data-provider="nai">
                            <div class="row">
                                <div style="flex: 1;">
                                    <label style="display: flex; justify-content: space-between; align-items: center;">
                                        <span>Prompt Guidance Rescale</span>
                                        <span id="cfgRescaleValue" style="font-weight: 500;">0</span>
                                    </label>
                                    <input type="range" id="cfgRescale" value="0" min="0" max="1" step="0.02" style="width: 100%;">
                                </div>
                            </div>
                            <div class="checkbox-row">
                                <input type="checkbox" id="varietyPlus">
                                <label for="varietyPlus">Variety+</label>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Sampler</label>
                                <select id="sampler">
                                    <option value="k_euler_ancestral">Euler Ancestral</option>
                                    <option value="k_euler">Euler</option>
                                    <option value="k_dpmpp_2s_ancestral">DPM++ 2S Ancestral</option>
                                    <option value="k_dpmpp_2m_sde">DPM++ 2M SDE</option>
                                    <option value="k_dpmpp_2m">DPM++ 2M</option>
                                    <option value="k_dpmpp_sde">DPM++ SDE</option>
                                </select>
                            </div>
                            <div>
                                <label>Scheduler</label>
                                <select id="scheduler">
                                    <option value="karras">Karras</option>
                                    <option value="exponential">Exponential</option>
                                    <option value="polyexponential">Polyexponential</option>
                                </select>
                            </div>
                        </div>

                        <div class="row">
                            <div>
                                <label>Seed</label>
                                <input type="number" id="seed" value="-1">
                            </div>
                        </div>

                        <div class="checkbox-row">
                            <input type="checkbox" id="randomSeed">
                            <label for="randomSeed">매 슬롯마다 랜덤 시드</label>
                        </div>
                        <div class="checkbox-row">
                            <input type="checkbox" id="lockSeed">
                            <label for="lockSeed">시드 고정</label>
                        </div>
                    </div>
                </div>

                <!-- Save Options -->
                <div class="section">
                    <div class="section-title">
                        <button type="button" class="collapse-toggle" data-target="saveOptionsContent" title="접기/펼치기">▼</button>
                        <span>Save Options</span>
                    </div>
                    <div id="saveOptionsContent" class="collapsible-content">
                        <div class="row">
                            <div>
                                <label>Format</label>
                                <select id="saveFormat">
                                    <option value="png" selected>PNG</option>
                                    <option value="jpg">JPG</option>
                                    <option value="webp">WebP</option>
                                </select>
                            </div>
                            <div>
                                <label>JPG Quality</label>
                                <input type="number" id="jpgQuality" value="95" min="1" max="100" step="1">
                            </div>
                        </div>
                        <div class="checkbox-row">
                            <input type="checkbox" id="stripMetadata">
                            <label for="stripMetadata">메타데이터 제거</label>
                        </div>
                        <small style="color: var(--text-dim);">체크 시 이미지에서 생성 정보가 제거됩니다</small>
                    </div>
                </div>
            </div>

            <div class="sidebar-footer">
                <!-- Anlas Info (NAI only) - Single line -->
                <div id="anlasInfo" class="anlas-info" style="display: none;">
                    <span class="anlas-icon">💎</span>
                    <span id="anlasBalance">--</span>
                    <button type="button" class="anlas-refresh" id="refreshAnlasBtn" title="새로고침">↻</button>
                    <span class="anlas-separator">│</span>
                    <span class="anlas-cost-label">-</span>
                    <span id="anlasCost">0</span>
                    <span id="anlasFreeTag" class="free-tag" style="display: none;">FREE</span>
                </div>

                <div class="status-text" id="statusText" style="text-align: left; margin-bottom: 4px;">준비</div>
                <div class="progress-bar" style="margin-bottom: 12px;">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <div style="display: flex; margin-bottom: 8px; align-items: center; gap: 8px;">
                    <div style="flex: 1;">
                        <button class="btn" id="generateBtn">Queue (0)</button>
                    </div>
                    <span style="color: var(--text-dim); font-size: 0.9rem;">×</span>
                    <div style="width: 60px;">
                        <input type="number" id="repeatCount" value="1" min="1" style="margin: 0; height: 100%; text-align: center;" title="반복 횟수">
                    </div>
                </div>
                <div class="row" style="gap: 6px;">
                    <button class="btn btn-secondary" id="cancelCurrentBtn" title="현재 작업 취소 (진행중인 이미지 완료 후)">Cancel</button>
                    <button class="btn btn-secondary" id="clearQueueBtn" title="대기열 비우기">Clear Q</button>
                </div>
            </div>
            <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>
        </aside>

        <!-- Main -->
        <main class="main">
            <!-- 모드 토글 (공통) -->
            <div class="mode-header">
                <div class="mode-toggle">
                    <button type="button" class="mode-btn active" id="slotModeBtn">🎰 슬롯 모드</button>
                    <button type="button" class="mode-btn" id="galleryModeBtn">🖼️ 갤러리</button>
                    <button type="button" class="mode-btn" id="censorModeBtn">🔍 자동검열</button>
                </div>
            </div>

            <!-- 슬롯 모드 툴바 -->
            <div class="slots-toolbar" id="slotsToolbar">
                <div class="toolbar-left">
                    <button type="button" class="add-slot-btn" id="addSlotBtn" title="슬롯 추가">+🎰</button>
                    <div class="slot-size-presets">
                        <button type="button" class="slot-size-preset-btn" id="slotSizePreset1" title="좌클릭: 프리셋 1 적용 | 우클릭: 현재 크기 저장">150</button>
                        <button type="button" class="slot-size-preset-btn" id="slotSizePreset2" title="좌클릭: 프리셋 2 적용 | 우클릭: 현재 크기 저장">675</button>
                        <button type="button" class="slot-size-preset-btn" id="slotSizePreset3" title="좌클릭: 프리셋 3 적용 | 우클릭: 현재 크기 저장">1200</button>
                    </div>
                    <button type="button" class="header-btn" id="clearImagesBtn" title="미리보기 이미지 지우기 (파일은 삭제되지 않음)">
                        <span>🧹</span>
                        <span>Clear</span>
                    </button>
                    <div class="preset-dropdown" id="presetDropdown">
                        <button type="button" class="header-btn preset-btn" id="presetBtn">
                            <span>🔖</span>
                            <span class="preset-name" id="presetName">Slot Set</span>
                            <span class="dropdown-arrow">▼</span>
                        </button>
                        <div class="preset-menu" id="presetMenu">
                            <div class="preset-list" id="presetList">
                                <!-- 프리셋 목록 -->
                            </div>
                            <div class="preset-actions">
                                <button type="button" class="preset-action-btn" id="newPresetBtn">+ New Set</button>
                                <button type="button" class="preset-action-btn" id="savePresetBtn">💾 Save</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="header-btn" id="syncScrollBtn" title="전체 슬롯 스크롤 동기화">
                        <span>🔗</span>
                        <span>Sync</span>
                    </button>
                    <button type="button" class="header-btn" id="saveImageSetBtn" title="현재 슬롯 이미지들을 폴더에 저장">
                        <span>💾</span>
                        <span>세트 저장</span>
                    </button>
                </div>
                <div class="toolbar-right">
                    <span class="toolbar-label">Save to:</span>
                    <div class="folder-dropdown" id="outputFolderDropdown">
                        <button type="button" class="header-btn folder-btn" id="outputFolderBtn">
                            <span class="folder-icon">📁</span>
                            <span class="folder-name" id="outputFolderName">output</span>
                            <span class="dropdown-arrow">▼</span>
                        </button>
                        <div class="folder-menu" id="outputFolderMenu">
                            <div class="folder-list" id="outputFolderList">
                                <!-- 폴더 목록 -->
                            </div>
                            <div class="folder-actions">
                                <button type="button" class="folder-action-btn" id="newOutputFolderBtn">+ 새 폴더</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="header-btn icon-only" id="openOutputFolderBtn" title="출력 폴더 열기">📂</button>
                </div>
            </div>

            <div class="slots-container-wrapper" id="slotsWrapper">
                <div class="slots-container" id="slotsContainer">
                    <!-- 슬롯들이 가로로 배치됨 -->
                </div>
            </div>

            <!-- 갤러리 모드 -->
            <div class="gallery-container" id="galleryContainer" style="display: none;">
                <div class="gallery-toolbar">
                    <div class="toolbar-left">
                        <button type="button" class="folder-tab vibe-folder" id="vibeCacheBtn" data-folder="vibe">🎨 vibe</button>
                        <span class="folder-separator double"></span>
                        <button type="button" class="folder-tab root-folder active" id="galleryRootBtn" data-folder="">📂 gallery</button>
                        <span class="folder-separator"></span>
                        <button type="button" class="add-folder-btn" id="addFolderBtn" title="새 폴더 추가">+📁</button>
                        <div class="gallery-subfolders" id="gallerySubfolders">
                            <!-- 하위 폴더 탭들이 여기에 추가됨 -->
                        </div>
                    </div>
                    <div class="toolbar-right">
                        <button type="button" class="header-btn icon-only" id="openGalleryFolderBtn" title="갤러리 폴더 열기">📂</button>
                    </div>
                </div>
                <div class="gallery-content">
                    <div class="gallery-grid" id="galleryGrid">
                        <!-- 갤러리 이미지들 -->
                    </div>
                    <div class="gallery-empty" id="galleryEmpty">
                        <div class="icon">🖼️</div>
                        <p>갤러리가 비어있습니다</p>
                        <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                    </div>
                </div>
            </div>

            <!-- 검열 모드 -->
            <div class="censor-container" id="censorContainer" style="display: none;">
                <!-- 툴바 (슬롯모드와 동일한 스타일) -->
                <div class="slots-toolbar" id="censorToolbar">
                    <div class="toolbar-left">
                        <button type="button" class="header-btn active" id="censorTabBefore">📥 검열 전</button>
                        <button type="button" class="header-btn" id="censorTabProcessing" style="display: none;">⚙️ 검열중</button>
                        <button type="button" class="header-btn" id="censorTabAfter">📤 검열 후</button>
                    </div>
                    <div class="toolbar-right">
                        <!-- 검열 전 폴더 드롭다운 -->
                        <div class="folder-dropdown" id="censorFolderBefore">
                            <button type="button" class="header-btn folder-btn" id="censorUncensoredFolderBtn">
                                <span class="folder-icon">📁</span>
                                <span class="folder-name" id="censorUncensoredFolderName">uncensored</span>
                                <span class="dropdown-arrow">▼</span>
                            </button>
                            <div class="folder-menu" id="censorUncensoredFolderMenu">
                                <div class="folder-list" id="censorUncensoredFolderList">
                                    <!-- 폴더 목록 -->
                                </div>
                                <div class="folder-actions">
                                    <button type="button" class="folder-action-btn" id="censorAddUncensoredBtn">+ 새 폴더</button>
                                </div>
                            </div>
                        </div>
                        <!-- 검열 후 폴더 드롭다운 -->
                        <div class="folder-dropdown" id="censorFolderAfter" style="display: none;">
                            <button type="button" class="header-btn folder-btn" id="censorCensoredFolderBtn">
                                <span class="folder-icon">📁</span>
                                <span class="folder-name" id="censorCensoredFolderName">censored</span>
                                <span class="dropdown-arrow">▼</span>
                            </button>
                            <div class="folder-menu" id="censorCensoredFolderMenu">
                                <div class="folder-list" id="censorCensoredFolderList">
                                    <!-- 폴더 목록 -->
                                </div>
                                <div class="folder-actions">
                                    <button type="button" class="folder-action-btn" id="censorAddCensoredBtn">+ 새 폴더</button>
                                </div>
                            </div>
                        </div>
                        <button type="button" class="header-btn icon-only" id="censorOpenFolderBtn" title="폴더 열기">📂</button>
                    </div>
                </div>
                
                <!-- 썸네일 가로 슬라이드 -->
                <div class="censor-thumbnails-wrapper">
                    <div class="censor-thumbnails" id="censorThumbnails">
                        <!-- 썸네일들이 여기에 렌더링됨 -->
                    </div>
                </div>
                
                <!-- 큰 프리뷰 + 편집 영역 -->
                <div class="censor-preview-area">
                    <!-- 좌측 네비게이션 화살표 -->
                    <button class="censor-nav-arrow censor-nav-left" id="censorNavLeft" title="이전 이미지 (휠 위)">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="15 18 9 12 15 6"></polyline>
                        </svg>
                    </button>

                    <div class="censor-preview-container" id="censorPreviewContainer">
                        <!-- 검열전 탭 안내 문구 -->
                        <div class="censor-preview-hint" id="censorPreviewHint" style="display: none;">
                            검열 부위 미리보기입니다. 실제 검열은 <strong>전체 검열</strong> 버튼을 눌러주세요.
                        </div>
                        <canvas id="censorPreviewCanvas"></canvas>
                        <canvas id="censorOverlayCanvas"></canvas>
                    </div>

                    <!-- 우측 네비게이션 화살표 -->
                    <button class="censor-nav-arrow censor-nav-right" id="censorNavRight" title="다음 이미지 (휠 아래)">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                    </button>

                    <!-- 이미지 번호 표시 -->
                    <div class="censor-image-counter" id="censorImageCounter">0 / 0</div>

                    <div class="censor-preview-empty" id="censorPreviewEmpty">
                        <div class="icon">🔍</div>
                        <p>이미지를 선택하세요</p>
                    </div>
                    <div class="censor-scan-loading" id="censorScanLoading">
                        <div class="scan-spinner"></div>
                        <span>검열 영역 스캔 중...</span>
                    </div>
                </div>
                
                <!-- 하단 옵션 패널 (고정 높이) -->
                <div class="censor-options-panel" id="censorOptionsPanel">
                    <!-- 검열 전 탭 옵션 -->
                    <div class="censor-options-before" id="censorOptionsBefore">
                        <div class="censor-panel-left">
                            <div class="censor-model-row">
                                <label>모델</label>
                                <select id="censorModel">
                                    <option value="">모델 선택...</option>
                                </select>
                            </div>
                            <div class="censor-targets-row">
                                <label>감지 대상</label>
                                <div class="censor-targets" id="censorTargets">
                                    <!-- 동적으로 클래스 체크박스 생성됨 -->
                                    <div class="censor-target-loading">모델을 선택하세요</div>
                                </div>
                            </div>
                        </div>
                        <div class="censor-panel-divider"></div>
                        <div class="censor-panel-right">
                            <div class="censor-method-select">
                                <label>검열 방식</label>
                                <select id="censorMethod">
                                    <option value="black">□ 검정</option>
                                    <option value="white">■ 흰색</option>
                                    <option value="mosaic">▦ 모자이크</option>
                                    <option value="blur">◐ 블러</option>
                                </select>
                            </div>
                            <button type="button" class="btn btn-primary btn-lg" id="censorRunAllBtn">🔍 전체 검열</button>
                        </div>
                    </div>
                    
                    <!-- 검열중 탭 옵션 -->
                    <div class="censor-options-processing" id="censorOptionsProcessing" style="display: none;">
                        <div class="censor-panel-left">
                            <div class="censor-proc-content">
                                <div class="censor-shortcuts-guide">
                                    <span class="shortcut-item">
                                        <kbd>1</kbd> <kbd>2</kbd> <kbd>3</kbd> 모드 전환
                                    </span>
                                    <span class="shortcut-item">
                                        <kbd>휠</kbd> 이미지 전환
                                    </span>
                                    <span class="shortcut-item">
                                        <kbd>우클릭</kbd> 박스 삭제
                                    </span>
                                </div>
                                <div class="censor-proc-tools">
                                    <button type="button" class="tool-btn active" id="procToolSelect">↔ 선택</button>
                                    <button type="button" class="tool-btn" id="procToolAdd">+ 추가</button>
                                    <button type="button" class="tool-btn" id="procToolDelete">🗑️ 삭제</button>
                                </div>
                                <div class="censor-proc-method">
                                    <span class="method-label">검열 방식</span>
                                    <select id="censorProcMethod">
                                        <option value="black">□ 검정</option>
                                        <option value="white">■ 흰색</option>
                                        <option value="mosaic">▦ 모자이크</option>
                                        <option value="blur">◐ 블러</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div class="censor-panel-divider"></div>
                        <div class="censor-panel-right">
                            <button type="button" class="btn btn-success btn-lg" id="censorCompleteBtn">✓ 검열 완료</button>
                            <button type="button" class="btn" id="censorCancelBtn">취소</button>
                        </div>
                    </div>
                    
                    <!-- 검열 후 탭 옵션 -->
                    <div class="censor-options-after" id="censorOptionsAfter" style="display: none;">
                        <div class="censor-panel-left">
                            <div class="censor-after-content">
                                <div class="censor-shortcuts-guide">
                                    <span class="shortcut-item">
                                        <kbd>1</kbd> <kbd>2</kbd> <kbd>3</kbd> 모드 전환
                                    </span>
                                    <span class="shortcut-item">
                                        <kbd>휠</kbd> 이미지 전환
                                    </span>
                                    <span class="shortcut-item">
                                        <kbd>우클릭</kbd> 박스 삭제
                                    </span>
                                </div>
                                <div class="censor-proc-tools">
                                    <button type="button" class="tool-btn active" id="afterToolSelect">↔ 선택</button>
                                    <button type="button" class="tool-btn" id="afterToolAdd">+ 추가</button>
                                    <button type="button" class="tool-btn" id="afterToolDelete">🗑️ 삭제</button>
                                </div>
                                <div class="censor-proc-method">
                                    <span class="method-label">검열 방식</span>
                                    <select id="censorAfterMethod">
                                        <option value="black">□ 검정</option>
                                        <option value="white">■ 흰색</option>
                                        <option value="mosaic">▦ 모자이크</option>
                                        <option value="blur">◐ 블러</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div class="censor-panel-divider"></div>
                        <div class="censor-panel-right">
                            <button type="button" class="btn btn-success btn-lg" id="censorAfterSaveBtn" disabled>💾 저장</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 검열 편집 모달 -->
            <div class="censor-edit-modal" id="censorEditModal">
                <div class="censor-edit-modal-header">
                    <h3>🔍 검열 편집</h3>
                    <button type="button" class="censor-edit-modal-close" id="censorEditModalClose">&times;</button>
                </div>
                <div class="censor-edit-modal-body">
                    <div class="censor-edit-modal-canvas-container">
                        <canvas id="censorEditCanvas"></canvas>
                        <canvas id="censorEditOverlay"></canvas>
                    </div>
                </div>
                <div class="censor-edit-modal-footer">
                    <div class="censor-edit-modal-tools">
                        <button type="button" class="tool-btn active" id="editToolSelect">↔ 선택</button>
                        <button type="button" class="tool-btn" id="editToolAdd">+ 추가</button>
                        <button type="button" class="tool-btn" id="editToolDelete">🗑️ 삭제</button>
                        <span style="color: var(--border); margin: 0 8px;">|</span>
                        <div class="censor-method-select">
                            <label>방식:</label>
                            <select id="editCensorMethod">
                                <option value="black">□ 검정</option>
                                <option value="white">■ 흰색</option>
                                <option value="mosaic">▦ 모자이크</option>
                                <option value="blur">◐ 블러</option>
                            </select>
                        </div>
                    </div>
                    <div class="censor-edit-modal-actions">
                        <button type="button" class="btn" id="censorEditCancelBtn">취소</button>
                        <button type="button" class="btn btn-primary" id="censorEditSaveBtn">💾 저장 (덮어쓰기)</button>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <span class="close">&times;</span>
        <img src="" alt="">
    </div>

    <!-- Drop Overlay -->
    <div class="drop-overlay" id="dropOverlay">
        <div class="drop-overlay-content">
            <div class="icon">📥</div>
            <h3>이미지 드롭</h3>
            <p>바이브 또는 생성 이미지를 드롭하세요</p>
        </div>
    </div>

    <!-- Drop Confirm Modal -->
    <div class="drop-modal" id="dropModal">
        <div class="drop-modal-content">
            <h3 id="dropModalTitle">이미지 가져오기</h3>
            <img id="dropModalPreview" class="preview" src="" alt="">
            <div id="dropModalMetadata" class="metadata"></div>
            <div class="buttons" id="dropModalButtons">
                <button type="button" class="btn btn-secondary" id="dropModalCancel">취소</button>
                <button type="button" class="btn" id="dropModalAsVibe" style="display: none;">바이브로 추가</button>
                <button type="button" class="btn" id="dropModalAsCharRef" style="display: none;">캐릭터 레퍼런스</button>
                <button type="button" class="btn" id="dropModalPromptOnly" style="display: none;">프롬프트만</button>
                <button type="button" class="btn" id="dropModalSeedOnly" style="display: none;">시드만</button>
                <button type="button" class="btn btn-primary" id="dropModalConfirm">적용</button>
            </div>
        </div>
    </div>

    <!-- Generic Confirm Modal -->
    <div class="drop-modal" id="confirmModal">
        <div class="drop-modal-content" style="max-width: 400px;">
            <h3 id="confirmModalTitle">확인</h3>
            <div id="confirmModalMessage" class="metadata" style="margin: 16px 0;"></div>
            <div class="buttons">
                <button type="button" class="btn btn-secondary" id="confirmModalCancel">취소</button>
                <button type="button" class="btn" id="confirmModalOk">확인</button>
            </div>
        </div>
    </div>

    <!-- Input Prompt Modal -->
    <div class="drop-modal" id="inputModal">
        <div class="drop-modal-content" style="max-width: 400px;">
            <h3 id="inputModalTitle">입력</h3>
            <div id="inputModalMessage" style="margin: 12px 0; color: var(--text-dim);"></div>
            <input type="text" id="inputModalInput" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-light); color: var(--text); margin-bottom: 16px;">
            <div class="buttons">
                <button type="button" class="btn btn-secondary" id="inputModalCancel">취소</button>
                <button type="button" class="btn" id="inputModalOk">확인</button>
            </div>
        </div>
    </div>

    <!-- Mask Editor Modal -->
    <div class="mask-editor-modal" id="maskEditorModal">
        <div class="mask-editor-container">
            <div class="mask-editor-header">
                <h3>🎨 Inpaint Mask Editor</h3>
                <button class="btn btn-secondary" id="maskEditorClose" style="padding: 6px 12px;">✕</button>
            </div>
            <div class="mask-editor-toolbar">
                <div class="tool-group">
                    <button class="tool-btn active" id="maskToolBrush" title="브러시 (마스크 그리기)">🖌️ Brush</button>
                    <button class="tool-btn" id="maskToolEraser" title="지우개">◼ Eraser</button>
                </div>
                <div class="slider-group">
                    <label>Size:</label>
                    <input type="range" id="maskBrushSize" min="5" max="100" value="30">
                    <span id="maskBrushSizeValue">30</span>
                </div>
                <div class="tool-group" style="margin-left: auto;">
                    <button class="tool-btn" id="maskToolClear" title="전체 지우기">🗑️ Clear</button>
                    <button class="tool-btn" id="maskToolInvert" title="마스크 반전">🔄 Invert</button>
                </div>
            </div>
            <div class="mask-editor-canvas-wrapper">
                <canvas id="maskEditorImageCanvas"></canvas>
                <canvas id="maskEditorMaskCanvas"></canvas>
                <canvas id="maskEditorDrawCanvas" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
            </div>
            <div class="mask-editor-toolbar">
                <div class="slider-group">
                    <label>Strength:</label>
                    <input type="range" id="maskEditorStrength" min="0" max="1" step="0.05" value="0.7">
                    <span id="maskEditorStrengthValue">0.7</span>
                </div>
            </div>
            <div class="mask-editor-footer">
                <button class="btn btn-secondary" id="maskEditorCancel">취소</button>
                <button class="btn btn-primary" id="maskEditorApply">✓ 베이스 이미지로 등록</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="modal-close" onclick="closeSettings()">&times;</button>
            </div>
            
            <div class="input-group">
                <label>NAI API Token</label>
                <input type="password" id="naiToken" placeholder="NAI 토큰 입력">
                <small>Get from novelai.net → Account → API</small>
            </div>
            
            <div class="input-group">
                <label>Status</label>
                <span class="status-badge" id="naiStatus">Checking...</span>
            </div>
            
            <div class="input-group">
                <label>Checkpoints Directory</label>
                <input type="text" id="checkpointsDir" placeholder="./models/checkpoints">
            </div>
            
            <div class="input-group">
                <label>LoRA Directory</label>
                <input type="text" id="loraDir" placeholder="./models/loras">
            </div>

            <div style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 16px;">
                <label class="toggle-switch" style="flex-shrink: 0; margin-top: 2px;">
                    <input type="checkbox" id="tagAutocompleteToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
                <div style="flex: 1; min-width: 0;">
                    <div style="font-weight: 600; margin-bottom: 4px;">태그 자동 완성</div>
                    <small style="color: var(--text-dim); display: block; line-height: 1.4;">
                        댄부루 태그 데이터베이스 기반 자동완성 제안 (Base/Negative/Character 프롬프트)
                    </small>
                </div>
            </div>

            <div style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 16px;">
                <label class="toggle-switch" style="flex-shrink: 0; margin-top: 2px;">
                    <input type="checkbox" id="promptHighlightToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
                <div style="flex: 1; min-width: 0;">
                    <div style="font-weight: 600; margin-bottom: 4px;">프롬프트 가중치 강조</div>
                    <small style="color: var(--text-dim); display: block; line-height: 1.4;">
                        가중치 문법 색상 표시 (NAI: {강화} [약화], Local: (강화) [약화])
                    </small>
                </div>
            </div>

            <hr style="border: none; border-top: 1px solid var(--border); margin: 16px 0;">
            
            <div class="input-group">
                <label>Local Generation Environment</label>
                <div id="localEnvStatus" class="local-env-status">
                    <span class="status-text">Checking...</span>
                </div>
                <div id="localEnvActions" style="margin-top: 8px;">
                    <!-- 동적으로 버튼 추가됨 -->
                </div>
                <div id="localEnvProgress" class="local-env-progress" style="display: none;">
                    <div class="local-env-progress-bar">
                        <div class="local-env-progress-fill" id="localEnvProgressFill"></div>
                    </div>
                    <span class="local-env-progress-text" id="localEnvProgressText">0%</span>
                </div>
                <small style="display: block; margin-top: 12px; color: var(--text-dim);">Python + PyTorch CUDA (~5GB, 3-5분)</small>
            </div>

            <button class="btn" onclick="saveSettings()" style="margin-top: 16px;">Save Settings</button>
        </div>
    </div>
    
    <!-- Local Install Modal -->
    <div class="modal" id="localInstallModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2>⚙️ 환경 설치</h2>
                <button class="modal-close" id="localInstallModalClose" onclick="closeLocalInstallModal()">&times;</button>
            </div>
            
            <p style="color: var(--text-dim); margin-bottom: 16px;">
                로컬 생성/검열 기능을 위해 Python 환경과 PyTorch를 설치해야 합니다. (최초 1회)
            </p>
            
            <div class="input-group">
                <div id="installModalStatus" class="local-env-status">
                    <span class="status-text">확인 중...</span>
                </div>
                <div id="installModalProgress" class="local-env-progress" style="display: none;">
                    <div class="local-env-progress-bar">
                        <div class="local-env-progress-fill" id="installModalProgressFill"></div>
                    </div>
                    <span class="local-env-progress-text" id="installModalProgressText">0%</span>
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn" id="installModalBtn" onclick="installFromModal()" style="flex: 1;">
                    ⬇️ 설치 (~5GB)
                </button>
                <button class="btn" id="installModalCancelBtn" onclick="closeLocalInstallModal()" style="flex: 1; background: var(--surface-light);">
                    취소
                </button>
            </div>
            
            <small style="display: block; margin-top: 12px; color: var(--text-dim);">
                인터넷 속도에 따라 3~5분 정도 소요됩니다.
            </small>
        </div>
    </div>
    
    <!-- Restart Confirmation Modal -->
    <div class="modal" id="restartModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2>🔄 재시작 필요</h2>
            </div>
            
            <p style="color: var(--text); margin-bottom: 8px;">
                설치가 완료되었습니다!
            </p>
            <p style="color: var(--text-dim); margin-bottom: 16px;">
                GPU(CUDA) 가속을 활성화하려면 앱을 재시작해야 합니다.
            </p>
            
            <div style="display: flex; gap: 8px;">
                <button class="btn" id="restartConfirmBtn" onclick="confirmRestart()" style="flex: 1;">
                    🔄 지금 재시작
                </button>
            </div>
            
            <small style="display: block; margin-top: 12px; color: var(--text-dim);">
                재시작 후 자동으로 연결됩니다.
            </small>
        </div>
    </div>
    
    <!-- NAI Token Modal -->
    <div class="modal" id="naiTokenModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2>🔑 NovelAI API 토큰</h2>
                <button class="modal-close" onclick="closeNaiTokenModal()">&times;</button>
            </div>
            
            <p style="color: var(--text-dim); margin-bottom: 16px;">
                NAI 생성을 사용하려면 API 토큰이 필요합니다.
            </p>
            
            <div class="input-group">
                <label>API 토큰</label>
                <input type="password" id="naiTokenModalInput" placeholder="토큰 붙여넣기">
                <small><a href="https://novelai.net/settings" target="_blank" style="color: var(--primary);">novelai.net</a> → Account Settings → Get Persistent API Token</small>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn" id="naiTokenModalBtn" onclick="saveNaiTokenFromModal()" style="flex: 2;">
                    💾 저장
                </button>
                <button class="btn" onclick="closeNaiTokenModal()" style="flex: 1; background: var(--surface-light);">
                    취소
                </button>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
    
    <script>
        console.log('[PeroPix] Script initialized');

        const API_BASE = 'http://127.0.0.1:8765';

        let currentProvider = 'nai';
        let currentIndex = 0;
        let totalImages = 0;
        let resetTimer = null;
        let naiTokenSet = false;  // NAI 토큰 설정 여부

        // WebSocket 연결 관리
        let ws = null;
        let wsClientId = localStorage.getItem('ws_client_id') || null;
        let wsReconnectTimer = null;
        let lastImageSeq = 0;  // 마지막으로 받은 이미지 순번 (재연결 시 동기화용)

        // Elements
        const tabs = document.querySelectorAll('.tab');
        const providerSections = document.querySelectorAll('.provider-section');
        const generateBtn = document.getElementById('generateBtn');
        const cancelCurrentBtn = document.getElementById('cancelCurrentBtn');
        const clearQueueBtn = document.getElementById('clearQueueBtn');
        const progressFill = document.getElementById('progressFill');
        const statusText = document.getElementById('statusText');
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = lightbox.querySelector('img');

        // Lightbox navigation state (for wheel navigation)
        let lightboxCurrentSlot = null;
        let lightboxCurrentCard = null;
        let lightboxCurrentGalleryItem = null;  // 갤러리 모드용
        
        // Slots
        const slotsContainer = document.getElementById('slotsContainer');
        const addSlotBtn = document.getElementById('addSlotBtn');
        let slotCounter = 0;
        
        function updateSlotNumbers() {
            const slots = slotsContainer.querySelectorAll('.slot');
            slots.forEach((slot, index) => {
                slot.querySelector('.slot-number').textContent = String(index + 1).padStart(3, '0');
            });
        }
        
        // 슬롯 너비 관리
        let currentSlotWidth = 280;
        const MIN_SLOT_WIDTH = 150;
        const MAX_SLOT_WIDTH = 1200;

        function setSlotWidth(width) {
            currentSlotWidth = Math.max(MIN_SLOT_WIDTH, Math.min(MAX_SLOT_WIDTH, width));
            document.documentElement.style.setProperty('--slot-width', currentSlotWidth + 'px');
            updateSlotSizePresetButtons();
            autoSaveSettings();
        }

        // 슬롯 사이즈 프리셋
        let slotSizePresets = [150, 675, 1200]; // 초기값: 최소, 중간, 최대

        function loadSlotSizePresets() {
            const saved = localStorage.getItem('slotSizePresets');
            if (saved) {
                try {
                    slotSizePresets = JSON.parse(saved);
                } catch (e) {
                    console.warn('Failed to load slot size presets:', e);
                }
            }
            updateSlotSizePresetButtons();
        }

        function saveSlotSizePresets() {
            localStorage.setItem('slotSizePresets', JSON.stringify(slotSizePresets));
        }

        function updateSlotSizePresetButtons() {
            for (let i = 0; i < 3; i++) {
                const btn = document.getElementById(`slotSizePreset${i + 1}`);
                if (btn) {
                    btn.textContent = slotSizePresets[i];
                    // 활성 프리셋 표시 (현재 슬롯 폭과 일치 시)
                    if (Math.abs(currentSlotWidth - slotSizePresets[i]) < 5) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            }
        }

        // 프리셋 버튼 이벤트 리스너
        (function setupSlotSizePresets() {
            for (let i = 0; i < 3; i++) {
                const btn = document.getElementById(`slotSizePreset${i + 1}`);
                if (!btn) continue;

                // 좌클릭: 프리셋 적용
                btn.addEventListener('click', () => {
                    setSlotWidth(slotSizePresets[i]);
                });

                // 우클릭: 현재 크기 저장
                btn.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    slotSizePresets[i] = currentSlotWidth;
                    saveSlotSizePresets();
                    updateSlotSizePresetButtons();
                });
            }
        })();

        function setupSlotResize(slot) {
            const handle = slot.querySelector('.slot-resize-handle');
            if (!handle) return;

            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = currentSlotWidth;

                document.body.classList.add('resizing-slot');
                handle.classList.add('active');

                function onMouseMove(e) {
                    const deltaX = e.clientX - startX;
                    setSlotWidth(startWidth + deltaX);
                }

                function onMouseUp() {
                    document.body.classList.remove('resizing-slot');
                    handle.classList.remove('active');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // 사이드바 너비 관리
        let currentSidebarWidth = 540;
        const MIN_SIDEBAR_WIDTH = 360;
        const MAX_SIDEBAR_WIDTH = 800;

        function setSidebarWidth(width) {
            currentSidebarWidth = Math.max(MIN_SIDEBAR_WIDTH, Math.min(MAX_SIDEBAR_WIDTH, width));
            document.documentElement.style.setProperty('--sidebar-width', currentSidebarWidth + 'px');
            autoSaveSettings();
        }

        // 사이드바 리사이즈 핸들 설정
        (function setupSidebarResize() {
            const handle = document.getElementById('sidebarResizeHandle');
            if (!handle) return;

            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = currentSidebarWidth;

                document.body.classList.add('resizing-slot');
                handle.classList.add('active');

                function onMouseMove(e) {
                    const deltaX = e.clientX - startX;
                    setSidebarWidth(startWidth + deltaX);
                }

                function onMouseUp() {
                    document.body.classList.remove('resizing-slot');
                    handle.classList.remove('active');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        })();

        function createSlot(name = '', content = '') {
            const slotId = slotCounter++;
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.dataset.slotIndex = slotId;
            slot.innerHTML = `
                <div class="slot-resize-handle"></div>
                <div class="slot-prompt">
                    <div class="slot-prompt-header">
                        <span class="slot-number">001</span>
                        <input type="text" placeholder="이름 (선택)" value="${name}" class="slot-name">
                        <button type="button" class="slot-drag" title="드래그하여 순서 변경" tabindex="-1">☰</button>
                        <button type="button" class="slot-delete" tabindex="-1">×</button>
                    </div>
                    <textarea placeholder="이 슬롯에만 적용할 태그" class="slot-tags">${content}</textarea>
                </div>
                <div class="slot-images">
                    <div class="slot-empty">이미지가 여기에 표시됩니다</div>
                </div>
            `;

            // 리사이즈 핸들 설정
            setupSlotResize(slot);
            
            slot.querySelector('.slot-delete').onclick = () => {
                if (slotsContainer.querySelectorAll('.slot').length > 1) {
                    slot.remove();
                    updateSlotNumbers();
                    updateQueueButton();
                    updateAnlasCost();
                    autoSaveSettings();
                }
            };

            const tagsTextarea = slot.querySelector('textarea');
            tagsTextarea.oninput = updateQueueButton;

            // 태그 자동완성 설정
            setupTagAutocomplete(tagsTextarea);

            // 탭 키로 같은 타입 필드 간 이동
            const nameInput = slot.querySelector('.slot-name');
            const tagsInput = slot.querySelector('.slot-tags');
            
            nameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const slots = [...slotsContainer.querySelectorAll('.slot')];
                    const currentIdx = slots.indexOf(slot);
                    const nextIdx = e.shiftKey 
                        ? (currentIdx - 1 + slots.length) % slots.length 
                        : (currentIdx + 1) % slots.length;
                    slots[nextIdx].querySelector('.slot-name').focus();
                }
            });
            
            tagsInput.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const slots = [...slotsContainer.querySelectorAll('.slot')];
                    const currentIdx = slots.indexOf(slot);
                    const nextIdx = e.shiftKey 
                        ? (currentIdx - 1 + slots.length) % slots.length 
                        : (currentIdx + 1) % slots.length;
                    slots[nextIdx].querySelector('.slot-tags').focus();
                }
            });
            
            // 드래그 핸들
            const dragHandle = slot.querySelector('.slot-drag');
            dragHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startSlotDrag(slot, e);
            });
            
            return slot;
        }
        
        // 슬롯 드래그 앤 드롭
        let draggedSlot = null;
        let dragStartX = 0;
        let slotStartX = 0;
        let placeholder = null;
        
        function startSlotDrag(slot, e) {
            draggedSlot = slot;
            dragStartX = e.clientX;
            
            const rect = slot.getBoundingClientRect();
            slotStartX = rect.left;
            
            // 플레이스홀더 생성
            placeholder = document.createElement('div');
            placeholder.className = 'slot-placeholder';
            placeholder.style.width = rect.width + 'px';
            placeholder.style.height = rect.height + 'px';
            
            // 드래그 중 스타일
            slot.classList.add('dragging');
            slot.style.position = 'fixed';
            slot.style.left = rect.left + 'px';
            slot.style.top = rect.top + 'px';
            slot.style.width = rect.width + 'px';
            slot.style.zIndex = '1000';
            
            slot.parentNode.insertBefore(placeholder, slot);
            document.body.appendChild(slot);
            
            document.addEventListener('mousemove', onSlotDrag);
            document.addEventListener('mouseup', endSlotDrag);
        }
        
        function onSlotDrag(e) {
            if (!draggedSlot) return;
            
            const dx = e.clientX - dragStartX;
            draggedSlot.style.left = (slotStartX + dx) + 'px';
            
            // 플레이스홀더 위치 업데이트
            const slots = [...slotsContainer.querySelectorAll('.slot:not(.dragging)')];
            const draggedRect = draggedSlot.getBoundingClientRect();
            const draggedCenter = draggedRect.left + draggedRect.width / 2;
            
            for (let i = 0; i < slots.length; i++) {
                const slotRect = slots[i].getBoundingClientRect();
                const slotCenter = slotRect.left + slotRect.width / 2;
                
                if (draggedCenter < slotCenter) {
                    slotsContainer.insertBefore(placeholder, slots[i]);
                    return;
                }
            }
            slotsContainer.appendChild(placeholder);
        }
        
        function endSlotDrag() {
            if (!draggedSlot) return;
            
            // 플레이스홀더 위치에 슬롯 삽입
            draggedSlot.classList.remove('dragging');
            draggedSlot.style.position = '';
            draggedSlot.style.left = '';
            draggedSlot.style.top = '';
            draggedSlot.style.width = '';
            draggedSlot.style.zIndex = '';
            
            slotsContainer.insertBefore(draggedSlot, placeholder);
            placeholder.remove();
            
            draggedSlot = null;
            placeholder = null;
            
            document.removeEventListener('mousemove', onSlotDrag);
            document.removeEventListener('mouseup', endSlotDrag);

            updateSlotNumbers();
            autoSaveSettings();
        }

        function addSlot(name = '', content = '') {
            const slot = createSlot(name, content);
            slotsContainer.appendChild(slot);
            setupSlotImageScroll(slot);
            updateSlotNumbers();
            updateQueueButton();
            updateAnlasCost();
        }
        
        function getSlotList() {
            const slots = slotsContainer.querySelectorAll('.slot');
            const list = [];
            
            slots.forEach((slot, index) => {
                const name = slot.querySelector('.slot-name').value.trim();
                const content = slot.querySelector('.slot-tags').value.trim();
                // 현재 위치 기반 인덱스 사용
                list.push({ name, content, slotIndex: index });
            });
            
            return list;
        }
        
        function updateQueueButton() {
            const list = getSlotList();
            const count = list.length || 1;
            generateBtn.textContent = `Queue (${count})`;
        }
        
        function addImageToSlot(slotIndex, data) {
            // slotIndex로 슬롯 찾기
            const slots = slotsContainer.querySelectorAll('.slot');
            const slotsWrapperDisplay = slotsWrapper.style.display;
            console.log(`[addImageToSlot] slotIndex=${slotIndex}, slots.length=${slots.length}, filename=${data.filename}, slotsWrapperDisplay=${slotsWrapperDisplay}`);

            // 슬롯이 없거나 인덱스가 범위를 벗어나면 첫 번째 슬롯에 추가
            let targetSlot;
            if (slotIndex >= slots.length || slotIndex < 0) {
                console.warn(`[addImageToSlot] Invalid slotIndex ${slotIndex}, falling back to slot 0`);
                if (slots.length === 0) {
                    console.error('[addImageToSlot] No slots available!');
                    return;
                }
                targetSlot = slots[0];
            } else {
                targetSlot = slots[slotIndex];
            }

            const imagesContainer = targetSlot.querySelector('.slot-images');

            // 빈 상태 제거
            const empty = imagesContainer.querySelector('.slot-empty');
            if (empty) empty.remove();

            const card = document.createElement('div');
            card.className = 'slot-image-card';

            // image_path가 있으면 URL로, 없으면 base64로 (하위 호환)
            const imgSrc = data.image_path
                ? `${API_BASE}/api/outputs/${data.image_path}`
                : `data:image/png;base64,${data.image}`;
            card.innerHTML = `
                <img src="${imgSrc}" alt="" draggable="false">
                <button type="button" class="save-gallery-btn" title="갤러리에 저장">☆</button>
                <div class="info">
                    <div class="info-row">
                        <button type="button" class="clear-card-btn" title="미리보기 지우기">🧹</button>
                        <div class="filename" title="${data.filename}">${data.filename}</div>
                        <button type="button" class="inpaint-btn" title="Inpaint">🎨</button>
                        <button type="button" class="apply-seed-btn" title="이 시드 적용">🎲</button>
                        <button type="button" class="load-settings-btn" title="전체 설정 불러오기">📋</button>
                    </div>
                    <div class="seed">${data.metadata ? 'Seed: ' + data.seed : '메타데이터 없음'}</div>
                </div>
            `;

            // 이미지 데이터 저장 (갤러리 저장용 + 설정 불러오기용)
            // metadata가 null이면 seed/prompt도 null로 처리 (strip_metadata 옵션)
            const hasMetadata = !!data.metadata;
            card._imageData = {
                image_path: data.image_path || null,
                image: data.image || null,  // 하위 호환
                filename: data.filename,
                seed: hasMetadata ? data.seed : null,
                prompt: hasMetadata ? (data.prompt || '') : null,
                metadata: data.metadata || null  // 전체 설정 메타데이터
            };

            // 갤러리 저장/제거 토글 버튼
            const saveBtn = card.querySelector('.save-gallery-btn');
            saveBtn.onclick = async (e) => {
                e.stopPropagation();

                // 이미 저장된 경우 갤러리에서 제거
                if (saveBtn.classList.contains('saved')) {
                    try {
                        const galleryFilename = card._imageData.galleryFilename || card._imageData.filename;
                        const response = await fetch(`${API_BASE}/api/gallery/${encodeURIComponent(galleryFilename)}`, {
                            method: 'DELETE'
                        });
                        const result = await response.json();
                        if (result.success) {
                            saveBtn.classList.remove('saved');
                            saveBtn.textContent = '☆';
                            card._imageData.galleryFilename = null;
                            showToast('갤러리에서 제거됨', 'success');
                            // 갤러리 캐시 무효화
                            window.galleryInitialized = false;
                            // 갤러리 뷰 새로고침
                            if (currentMode === 'gallery') {
                                loadGallery();
                            }
                        } else {
                            showToast('제거 실패: ' + result.error, 'error');
                        }
                    } catch (err) {
                        showToast('제거 오류: ' + err.message, 'error');
                    }
                    return;
                }

                // 저장되지 않은 경우 갤러리에 저장
                try {
                    // 현재 열린 갤러리 폴더에 저장
                    const response = await fetch(`${API_BASE}/api/gallery/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image: card._imageData.image,  // base64 (하위 호환)
                            image_path: card._imageData.image_path,  // 파일 경로
                            filename: card._imageData.filename,
                            folder: currentGalleryFolder || '',  // 현재 갤러리 폴더
                            metadata: card._imageData.metadata  // 메타데이터 (JPG/WebP 저장 시 필요)
                        })
                    });
                    const result = await response.json();
                    if (result.success) {
                        saveBtn.classList.add('saved');
                        saveBtn.textContent = '★';
                        card._imageData.galleryFilename = result.filename || card._imageData.filename;
                        showToast('갤러리에 저장됨', 'success');
                        // 갤러리 캐시 무효화
                        window.galleryInitialized = false;
                    } else {
                        showToast('저장 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('저장 오류: ' + err.message, 'error');
                }
            };

            // 시드 적용 버튼
            const applySeedBtn = card.querySelector('.apply-seed-btn');
            applySeedBtn.onclick = (e) => {
                e.stopPropagation();
                const seed = card._imageData.seed;
                if (seed !== undefined && seed !== null) {
                    document.getElementById('seed').value = seed;
                    showToast(`시드 ${seed} 적용됨`, 'success');
                } else {
                    showToast('시드 정보가 없습니다', 'error');
                }
            };

            // 설정 불러오기 버튼
            const loadSettingsBtn = card.querySelector('.load-settings-btn');
            loadSettingsBtn.onclick = (e) => {
                e.stopPropagation();
                const metadata = card._imageData.metadata;
                if (!metadata) {
                    showToast('메타데이터가 없습니다', 'error');
                    return;
                }
                showLoadSettingsConfirm(metadata);
            };

            // Inpaint 버튼
            const inpaintBtn = card.querySelector('.inpaint-btn');
            inpaintBtn.onclick = async (e) => {
                e.stopPropagation();
                // 이미지 base64 가져오기
                let imageBase64 = card._imageData.image;
                if (!imageBase64 && card._imageData.image_path) {
                    // 파일 경로에서 이미지 로드 (outputs API 사용)
                    try {
                        const response = await fetch(`${API_BASE}/api/outputs/${card._imageData.image_path}`);
                        const blob = await response.blob();
                        imageBase64 = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result.split(',')[1]);
                            reader.readAsDataURL(blob);
                        });
                    } catch (err) {
                        showToast('이미지 로드 실패', 'error');
                        return;
                    }
                }
                if (imageBase64) {
                    setBaseImageForInpaint('data:image/png;base64,' + imageBase64);
                } else {
                    showToast('이미지 데이터가 없습니다', 'error');
                }
            };

            // 미리보기 지우기 버튼
            const clearCardBtn = card.querySelector('.clear-card-btn');
            clearCardBtn.onclick = (e) => {
                e.stopPropagation();
                card.remove();
            };

            // 드래그와 클릭 구분
            const img = card.querySelector('img');
            let imgMouseDownX = 0;
            let imgMouseDownY = 0;

            img.addEventListener('mousedown', (e) => {
                imgMouseDownX = e.clientX;
                imgMouseDownY = e.clientY;
            });

            img.addEventListener('mouseup', (e) => {
                const dx = Math.abs(e.clientX - imgMouseDownX);
                const dy = Math.abs(e.clientY - imgMouseDownY);
                // 5px 이내면 클릭으로 간주
                if (dx < 5 && dy < 5) {
                    lightboxImg.src = imgSrc;  // URL 또는 base64 사용
                    lightboxCurrentSlot = targetSlot;
                    lightboxCurrentCard = card;
                    lightbox.classList.add('active');
                }
            });

            // 이미지 로드 완료 후 카드 추가 (이미지와 info가 동시에 표시되도록)
            const insertCard = () => {
                imagesContainer.insertBefore(card, imagesContainer.firstChild);
                console.log(`[addImageToSlot] Card inserted for ${data.filename}`);
            };
            img.onload = insertCard;
            img.onerror = insertCard;  // 로드 실패 시에도 카드 표시
        }

        function clearSlotImages() {
            const slots = slotsContainer.querySelectorAll('.slot');
            slots.forEach(slot => {
                const imagesContainer = slot.querySelector('.slot-images');
                imagesContainer.innerHTML = '<div class="slot-empty">이미지가 여기에 표시됩니다</div>';
            });
        }
        
        addSlotBtn.onclick = () => {
            addSlot();
            autoSaveSettings();
        };
        
        // === Preset System ===
        const presetDropdown = document.getElementById('presetDropdown');
        const presetBtn = document.getElementById('presetBtn');
        const presetMenu = document.getElementById('presetMenu');
        const presetList = document.getElementById('presetList');
        const presetNameSpan = document.getElementById('presetName');
        const newPresetBtn = document.getElementById('newPresetBtn');
        const savePresetBtn = document.getElementById('savePresetBtn');
        
        let currentPreset = null; // { filename, name }
        let presets = [];
        
        // 드롭다운 토글 (body에 붙여서 overflow 문제 해결)
        presetBtn.onclick = (e) => {
            e.stopPropagation();
            const isShowing = presetMenu.classList.contains('show');

            if (isShowing) {
                presetMenu.classList.remove('show');
                presetDropdown.appendChild(presetMenu); // 원래 위치로
            } else {
                // body에 붙이고 위치 계산
                document.body.appendChild(presetMenu);
                const btnRect = presetBtn.getBoundingClientRect();
                presetMenu.style.top = (btnRect.bottom + 4) + 'px';
                presetMenu.style.left = btnRect.left + 'px';
                presetMenu.classList.add('show');
                loadPresetList();
            }
        };

        // 외부 클릭 시 닫기
        document.addEventListener('click', (e) => {
            if (!presetDropdown.contains(e.target) && !presetMenu.contains(e.target)) {
                presetMenu.classList.remove('show');
                if (presetMenu.parentElement === document.body) {
                    presetDropdown.appendChild(presetMenu);
                }
            }
        });
        
        // 프리셋 목록 로드
        async function loadPresetList() {
            try {
                const res = await fetch(`${API_BASE}/api/presets`);
                const data = await res.json();
                presets = data.presets;
                renderPresetList();
            } catch (e) {
                console.error('Failed to load presets:', e);
            }
        }
        
        // 프리셋 목록 렌더링
        function renderPresetList() {
            if (presets.length === 0) {
                presetList.innerHTML = '<div class="preset-empty">No presets saved</div>';
                return;
            }
            
            presetList.innerHTML = presets.map(p => `
                <div class="preset-item ${currentPreset?.filename === p.filename ? 'selected' : ''}" data-filename="${p.filename}">
                    <span class="check">${currentPreset?.filename === p.filename ? '✓' : ''}</span>
                    <span class="label">${p.name}</span>
                    <button class="edit-btn" title="이름 변경">✏️</button>
                    <button class="delete-btn" title="삭제">🗑️</button>
                </div>
            `).join('');
            
            // 이벤트 바인딩
            presetList.querySelectorAll('.preset-item').forEach(item => {
                const filename = item.dataset.filename;
                
                item.querySelector('.label').onclick = () => loadPreset(filename);
                
                item.querySelector('.edit-btn').onclick = (e) => {
                    e.stopPropagation();
                    renamePreset(filename);
                };
                
                item.querySelector('.delete-btn').onclick = (e) => {
                    e.stopPropagation();
                    deletePreset(filename);
                };
            });
        }
        
        // 프리셋 로드
        async function loadPreset(filename) {
            try {
                const res = await fetch(`${API_BASE}/api/presets/${filename}`);
                const data = await res.json();
                
                // 현재 슬롯 모두 제거
                slotsContainer.innerHTML = '';
                
                // 프리셋 슬롯들로 교체
                data.slots.forEach(s => {
                    addSlot(s.name, s.content);
                });
                
                // 최소 1개 슬롯
                if (data.slots.length === 0) {
                    addSlot();
                }
                
                // 폴더 적용
                setOutputFolder(data.folder || '');
                
                currentPreset = { filename, name: data.name };
                presetNameSpan.textContent = data.name;
                presetMenu.classList.remove('show');
                
                showToast(`Loaded: ${data.name}`, 'success');
            } catch (e) {
                showToast('프리셋 로드 실패', 'error');
            }
        }
        
        // 새 프리셋 저장
        newPresetBtn.onclick = async () => {
            const name = prompt('프리셋 이름 입력:');
            if (!name) return;
            
            const slots = getSlotList().map(s => ({ name: s.name, content: s.content }));
            const folder = getOutputFolder();

            try {
                const res = await fetch(`${API_BASE}/api/presets`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, slots, folder })
                });
                const data = await res.json();
                
                currentPreset = { filename: data.filename, name: data.name };
                presetNameSpan.textContent = data.name;
                
                loadPresetList();
                showToast(`Saved: ${name}`, 'success');
            } catch (e) {
                showToast('프리셋 저장 실패', 'error');
            }
        };
        
        // 현재 프리셋에 덮어쓰기
        savePresetBtn.onclick = async () => {
            if (!currentPreset) {
                showToast('프리셋이 선택되지 않음', 'warning');
                return;
            }
            
            const slots = getSlotList().map(s => ({ name: s.name, content: s.content }));
            const folder = getOutputFolder();

            try {
                await fetch(`${API_BASE}/api/presets/${currentPreset.filename}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: currentPreset.name, slots, folder })
                });
                
                showToast(`Saved: ${currentPreset.name}`, 'success');
                presetMenu.classList.remove('show');
            } catch (e) {
                showToast('프리셋 저장 실패', 'error');
            }
        };
        
        // 프리셋 이름 변경
        async function renamePreset(filename) {
            const preset = presets.find(p => p.filename === filename);
            if (!preset) return;
            
            const newName = prompt('Enter new name:', preset.name);
            if (!newName || newName === preset.name) return;
            
            try {
                // 기존 데이터 로드
                const res = await fetch(`${API_BASE}/api/presets/${filename}`);
                const data = await res.json();
                
                // 이름만 변경해서 저장 (prefix 유지)
                await fetch(`${API_BASE}/api/presets/${filename}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName, slots: data.slots, prefix: data.prefix || 'Name_' })
                });
                
                if (currentPreset?.filename === filename) {
                    currentPreset.name = newName;
                    presetNameSpan.textContent = newName;
                }
                
                loadPresetList();
                showToast('이름 변경됨', 'success');
            } catch (e) {
                showToast('이름 변경 실패', 'error');
            }
        }
        
        // 프리셋 삭제
        async function deletePreset(filename) {
            const preset = presets.find(p => p.filename === filename);
            if (!preset) return;

            showConfirmModal(
                '🗑️ 프리셋 삭제',
                `<p>"${preset.name}" 프리셋을 삭제하시겠습니까?</p>`,
                async () => {
                    try {
                        await fetch(`${API_BASE}/api/presets/${filename}`, { method: 'DELETE' });

                        if (currentPreset?.filename === filename) {
                            currentPreset = null;
                            presetNameSpan.textContent = 'Slot Set';
                        }

                        loadPresetList();
                        showToast('삭제됨', 'success');
                    } catch (e) {
                        showToast('삭제 실패', 'error');
                    }
                },
                '삭제',
                true
            );
        }

        // ============================================================
        // Output Folder Dropdown
        // ============================================================
        const outputFolderDropdown = document.getElementById('outputFolderDropdown');
        const outputFolderBtn = document.getElementById('outputFolderBtn');
        const outputFolderMenu = document.getElementById('outputFolderMenu');
        const outputFolderList = document.getElementById('outputFolderList');
        const outputFolderName = document.getElementById('outputFolderName');
        const outputFolderIcon = outputFolderBtn.querySelector('.folder-icon');

        let currentOutputFolder = ''; // 빈 문자열 = output 루트

        // 현재 선택된 폴더 반환 (API 호출 시 사용)
        function getOutputFolder() {
            return currentOutputFolder;
        }

        // 폴더 선택 시 UI 업데이트
        function setOutputFolder(folderName) {
            currentOutputFolder = folderName;
            outputFolderName.textContent = folderName || 'output';
            outputFolderIcon.textContent = '📁';
            autoSaveSettings();
        }

        // 폴더 드롭다운 토글
        outputFolderBtn.onclick = (e) => {
            e.stopPropagation();
            const isShowing = outputFolderMenu.classList.contains('show');

            if (isShowing) {
                outputFolderMenu.classList.remove('show');
                outputFolderDropdown.appendChild(outputFolderMenu);
            } else {
                document.body.appendChild(outputFolderMenu);
                const btnRect = outputFolderBtn.getBoundingClientRect();
                outputFolderMenu.style.top = (btnRect.bottom + 4) + 'px';
                outputFolderMenu.style.right = (window.innerWidth - btnRect.right) + 'px';
                outputFolderMenu.style.left = 'auto';
                outputFolderMenu.classList.add('show');
                loadOutputFolderList();
            }
        };

        // 외부 클릭 시 닫기
        document.addEventListener('click', (e) => {
            if (!outputFolderDropdown.contains(e.target) && !outputFolderMenu.contains(e.target)) {
                outputFolderMenu.classList.remove('show');
                if (outputFolderMenu.parentElement === document.body) {
                    outputFolderDropdown.appendChild(outputFolderMenu);
                }
            }
        });

        // 폴더 목록 로드
        async function loadOutputFolderList() {
            try {
                const res = await fetch(`${API_BASE}/api/output-folders`);
                const data = await res.json();
                renderOutputFolderList(data.folders || []);
            } catch (e) {
                console.error('Failed to load output folders:', e);
                renderOutputFolderList([]);
            }
        }

        // 폴더 목록 렌더링
        function renderOutputFolderList(folders) {
            const isRootSelected = currentOutputFolder === '';

            let html = `
                <div class="folder-item root-folder ${isRootSelected ? 'active' : ''}" data-folder="">
                    <span>${isRootSelected ? '📂' : '📁'}</span>
                    <span>output</span>
                </div>
            `;

            folders.forEach(folder => {
                const isSelected = currentOutputFolder === folder.name;
                html += `
                    <div class="folder-item subfolder ${isSelected ? 'active' : ''}" data-folder="${folder.name}">
                        <span>${isSelected ? '📂' : '📁'}</span>
                        <span>${folder.name}</span>
                        <span style="margin-left: auto; opacity: 0.6; font-size: 0.75rem;">${folder.image_count}</span>
                    </div>
                `;
            });

            outputFolderList.innerHTML = html;

            // 폴더 클릭 이벤트
            outputFolderList.querySelectorAll('.folder-item').forEach(item => {
                item.onclick = () => {
                    setOutputFolder(item.dataset.folder);
                    outputFolderMenu.classList.remove('show');
                    outputFolderDropdown.appendChild(outputFolderMenu);
                };
            });
        }

        // 새 폴더 생성
        document.getElementById('newOutputFolderBtn').onclick = () => {
            outputFolderMenu.classList.remove('show');
            outputFolderDropdown.appendChild(outputFolderMenu);

            showInputModal('📁 새 폴더', '폴더 이름을 입력하세요', async (folderName) => {
                try {
                    const response = await fetch(`${API_BASE}/api/output-folders`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: folderName })
                    });
                    const result = await response.json();
                    if (result.success) {
                        setOutputFolder(result.name);
                        showToast(`폴더 생성: ${result.name}`, 'success');
                    } else {
                        showToast(result.error || '폴더 생성 실패', 'error');
                    }
                } catch (err) {
                    showToast('폴더 생성 오류', 'error');
                }
            }, '생성');
        };

        // 세트 저장 버튼 - 현재 슬롯에 표시된 이미지들을 폴더로 저장
        document.getElementById('saveImageSetBtn').onclick = async () => {
            // 모든 슬롯에서 표시된 이미지 경로 수집
            const imagePaths = [];
            slotsContainer.querySelectorAll('.slot').forEach(slot => {
                const imagesContainer = slot.querySelector('.slot-images');
                imagesContainer.querySelectorAll('.slot-image-card').forEach(card => {
                    if (card._imageData && card._imageData.image_path) {
                        imagePaths.push(card._imageData.image_path);
                    }
                });
            });

            if (imagePaths.length === 0) {
                showToast('저장할 이미지가 없습니다', 'warning');
                return;
            }

            try {
                showToast('폴더를 선택하세요...', 'info');
                const response = await fetch(`${API_BASE}/api/save-image-set`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image_paths: imagePaths })
                });
                const result = await response.json();

                if (result.cancelled) {
                    showToast('저장 취소됨', 'warning');
                } else if (result.success) {
                    showToast(`${result.saved_count}개 이미지 저장됨`, 'success');
                } else {
                    showToast(result.error || '저장 실패', 'error');
                }
            } catch (err) {
                showToast('저장 오류: ' + err.message, 'error');
            }
        };

        // Sync scroll 토글
        const syncScrollBtn = document.getElementById('syncScrollBtn');
        let syncScrollEnabled = false;
        let isSyncScrolling = false;
        
        syncScrollBtn.onclick = () => {
            syncScrollEnabled = !syncScrollEnabled;
            syncScrollBtn.classList.toggle('active', syncScrollEnabled);
        };
        
        function setupSlotImageScroll(slot) {
            const imagesContainer = slot.querySelector('.slot-images');
            
            imagesContainer.addEventListener('scroll', () => {
                if (!syncScrollEnabled || isSyncScrolling) return;
                
                isSyncScrolling = true;
                const scrollTop = imagesContainer.scrollTop;
                const scrollRatio = imagesContainer.scrollTop / (imagesContainer.scrollHeight - imagesContainer.clientHeight || 1);
                
                // 다른 모든 슬롯의 이미지 영역도 같이 스크롤
                slotsContainer.querySelectorAll('.slot').forEach(otherSlot => {
                    if (otherSlot === slot) return;
                    const otherImages = otherSlot.querySelector('.slot-images');
                    const maxScroll = otherImages.scrollHeight - otherImages.clientHeight;
                    otherImages.scrollTop = scrollRatio * maxScroll;
                });
                
                setTimeout(() => { isSyncScrolling = false; }, 10);
            });
        }
        
        // 스크롤 그라데이션 업데이트
        const slotsWrapper = document.getElementById('slotsWrapper');
        
        function updateScrollGradients() {
            const { scrollLeft, scrollWidth, clientWidth } = slotsContainer;
            const canScrollLeft = scrollLeft > 5;
            const canScrollRight = scrollLeft < scrollWidth - clientWidth - 5;
            
            slotsWrapper.classList.toggle('can-scroll-left', canScrollLeft);
            slotsWrapper.classList.toggle('can-scroll-right', canScrollRight);
        }
        
        slotsContainer.addEventListener('scroll', updateScrollGradients);
        // 초기화 및 슬롯 추가/삭제 시 업데이트를 위한 observer
        const resizeObserver = new ResizeObserver(updateScrollGradients);
        resizeObserver.observe(slotsContainer);
        
        // 가로 스크롤 드래그 (오버스크롤 바운스 포함)
        let isScrollDragging = false;
        let scrollStartX = 0;
        let scrollLeft = 0;
        let overscrollOffset = 0;
        
        slotsContainer.addEventListener('mousedown', (e) => {
            // 텍스트 입력란, 버튼, 드래그 핸들만 제외
            if (e.target.tagName === 'INPUT' || 
                e.target.tagName === 'TEXTAREA' || 
                e.target.tagName === 'BUTTON' ||
                e.target.classList.contains('slot-drag') ||
                e.target.classList.contains('slot-delete')) {
                return;
            }
            
            isScrollDragging = true;
            scrollStartX = e.pageX - slotsContainer.offsetLeft;
            scrollLeft = slotsContainer.scrollLeft;
            overscrollOffset = 0;
            slotsContainer.style.cursor = 'grabbing';
            slotsContainer.style.transition = 'none';
        });
        
        slotsContainer.addEventListener('mousemove', (e) => {
            if (!isScrollDragging) return;
            e.preventDefault();
            const x = e.pageX - slotsContainer.offsetLeft;
            const walk = (x - scrollStartX) * 1.5;
            
            const maxScroll = slotsContainer.scrollWidth - slotsContainer.clientWidth;
            const newScrollLeft = scrollLeft - walk;
            
            // 스크롤 가능 범위 체크
            if (maxScroll <= 0) {
                // 스크롤 불가 - 오버스크롤 효과만
                overscrollOffset = walk * 0.3; // 저항감 있게
                overscrollOffset = Math.max(-50, Math.min(50, overscrollOffset));
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else if (newScrollLeft < 0) {
                // 왼쪽 끝 넘어감
                slotsContainer.scrollLeft = 0;
                overscrollOffset = -newScrollLeft * 0.3;
                overscrollOffset = Math.min(50, overscrollOffset);
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else if (newScrollLeft > maxScroll) {
                // 오른쪽 끝 넘어감
                slotsContainer.scrollLeft = maxScroll;
                overscrollOffset = -(newScrollLeft - maxScroll) * 0.3;
                overscrollOffset = Math.max(-50, overscrollOffset);
                slotsContainer.style.transform = `translateX(${overscrollOffset}px)`;
            } else {
                // 정상 스크롤
                slotsContainer.scrollLeft = newScrollLeft;
                overscrollOffset = 0;
                slotsContainer.style.transform = '';
            }
        });
        
        function endScrollDrag() {
            if (!isScrollDragging) return;
            isScrollDragging = false;
            slotsContainer.style.cursor = '';
            
            // 오버스크롤 바운스백
            if (overscrollOffset !== 0) {
                slotsContainer.style.transition = 'transform 0.3s ease-out';
                slotsContainer.style.transform = '';
                overscrollOffset = 0;
            }
        }
        
        slotsContainer.addEventListener('mouseup', endScrollDrag);
        slotsContainer.addEventListener('mouseleave', endScrollDrag);
        
        // Tab switching
        let localEnvInstalled = false;  // Local 환경 설치 여부
        
        // Provider별 Generation 설정 저장소
        let naiGenerationSettings = { steps: 28, cfg: 6, sampler: 'k_euler_ancestral', scheduler: 'karras' };
        let localGenerationSettings = { steps: 20, cfg: 7, sampler: 'euler_ancestral', scheduler: 'normal' };
        
        // 현재 provider의 Generation 설정 저장
        function saveCurrentProviderGenerationSettings() {
            const settings = {
                steps: document.getElementById('steps').value,
                cfg: document.getElementById('cfg').value,
                sampler: document.getElementById('sampler').value,
                scheduler: document.getElementById('scheduler').value
            };
            if (currentProvider === 'nai') {
                naiGenerationSettings = settings;
            } else {
                localGenerationSettings = settings;
            }
        }
        
        // 특정 provider의 Generation 설정 복원
        function restoreProviderGenerationSettings(provider) {
            const settings = provider === 'nai' ? naiGenerationSettings : localGenerationSettings;
            document.getElementById('steps').value = settings.steps;
            document.getElementById('cfg').value = settings.cfg;
            // 샘플러/스케줄러는 옵션이 바뀌므로 옵션 업데이트 후 설정
            updateSamplerSchedulerOptions(provider);
            document.getElementById('sampler').value = settings.sampler;
            document.getElementById('scheduler').value = settings.scheduler;
        }
        
        // NAI / Local 샘플러/스케줄러 옵션
        const NAI_SAMPLERS = [
            { value: 'k_euler_ancestral', label: 'Euler Ancestral' },
            { value: 'k_euler', label: 'Euler' },
            { value: 'k_dpmpp_2s_ancestral', label: 'DPM++ 2S Ancestral' },
            { value: 'k_dpmpp_2m_sde', label: 'DPM++ 2M SDE' },
            { value: 'k_dpmpp_2m', label: 'DPM++ 2M' },
            { value: 'k_dpmpp_sde', label: 'DPM++ SDE' },
        ];
        const NAI_SCHEDULERS = [
            { value: 'karras', label: 'Karras' },
            { value: 'exponential', label: 'Exponential' },
            { value: 'polyexponential', label: 'Polyexponential' },
        ];
        const LOCAL_SAMPLERS = [
            { value: 'euler_ancestral', label: 'Euler Ancestral' },
            { value: 'euler', label: 'Euler' },
            { value: 'dpmpp_2m', label: 'DPM++ 2M' },
            { value: 'dpmpp_2m_sde', label: 'DPM++ 2M SDE' },
            { value: 'dpmpp_sde', label: 'DPM++ SDE' },
            { value: 'dpmpp_3m_sde', label: 'DPM++ 3M SDE' },
            { value: 'dpmpp_2s_ancestral', label: 'DPM++ 2S Ancestral' },
            { value: 'ddim', label: 'DDIM' },
            { value: 'uni_pc', label: 'UniPC' },
            { value: 'lcm', label: 'LCM' },
        ];
        const LOCAL_SCHEDULERS = [
            { value: 'normal', label: 'Normal' },
            { value: 'karras', label: 'Karras' },
            { value: 'exponential', label: 'Exponential' },
            { value: 'sgm_uniform', label: 'SGM Uniform' },
            { value: 'simple', label: 'Simple' },
            { value: 'ddim_uniform', label: 'DDIM Uniform' },
            { value: 'beta', label: 'Beta' },
        ];
        
        function updateSamplerSchedulerOptions(provider) {
            const samplerSelect = document.getElementById('sampler');
            const schedulerSelect = document.getElementById('scheduler');
            
            const samplers = provider === 'nai' ? NAI_SAMPLERS : LOCAL_SAMPLERS;
            const schedulers = provider === 'nai' ? NAI_SCHEDULERS : LOCAL_SCHEDULERS;
            
            // 현재 선택 저장
            const currentSampler = samplerSelect.value;
            const currentScheduler = schedulerSelect.value;
            
            // 옵션 교체
            samplerSelect.innerHTML = samplers.map(s => 
                `<option value="${s.value}">${s.label}</option>`
            ).join('');
            schedulerSelect.innerHTML = schedulers.map(s => 
                `<option value="${s.value}">${s.label}</option>`
            ).join('');
            
            // 기존 선택 복원 시도, 없으면 첫 번째
            if (samplers.some(s => s.value === currentSampler)) {
                samplerSelect.value = currentSampler;
            }
            if (schedulers.some(s => s.value === currentScheduler)) {
                schedulerSelect.value = currentScheduler;
            }
        }
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Local 탭 클릭 시 설치 안 됐으면 팝업
                if (tab.dataset.provider === 'local' && !localEnvInstalled) {
                    showLocalInstallModal();
                    return;
                }
                
                // 같은 탭 클릭 시 무시
                if (tab.dataset.provider === currentProvider) return;

                // 현재 provider의 모든 설정 저장
                const currentSettings = collectCurrentProviderSettings();
                if (currentProvider === 'nai') {
                    naiSettings = currentSettings;
                } else {
                    localSettings = currentSettings;
                }
                // Generation 설정도 동기화
                saveCurrentProviderGenerationSettings();
                
                // Provider 전환
                const newProvider = tab.dataset.provider;
                currentProvider = newProvider;
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                providerSections.forEach(s => {
                    s.classList.toggle('active', s.dataset.provider === currentProvider);
                });
                
                // 새 provider의 전체 설정 복원
                const newSettings = currentProvider === 'nai' ? naiSettings : localSettings;
                applyProviderSettings(newSettings, true);
                
                // Generation 설정도 복원 (샘플러/스케줄러 옵션 포함)
                restoreProviderGenerationSettings(currentProvider);
                
                updateAnlasVisibility();
                updateProviderLabels();
                autoSaveSettings();
            });
        });

        // Provider별 라벨 업데이트
        function updateProviderLabels() {
            const cfgLabel = document.getElementById('cfgLabel');
            if (cfgLabel) {
                cfgLabel.textContent = currentProvider === 'nai' ? 'Prompt Guidance' : 'CFG';
            }
        }
        
        // === Prompt Presets ===
        async function loadPromptPresets(category) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}`);
                const data = await res.json();
                return data.presets;
            } catch (e) {
                console.error('Failed to load prompt presets:', e);
                return [];
            }
        }
        
        async function getPromptPreset(category, filename) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}/${filename}`);
                const data = await res.json();
                return data.content;
            } catch (e) {
                console.error('Failed to get prompt preset:', e);
                return null;
            }
        }
        
        async function savePromptPreset(category, name, content) {
            try {
                const res = await fetch(`${API_BASE}/api/prompts/${category}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, content })
                });
                const data = await res.json();
                showToast(`Saved: ${name}`, 'success');
                return data;
            } catch (e) {
                showToast('저장 실패', 'error');
                return null;
            }
        }
        
        async function deletePromptPreset(category, filename) {
            try {
                await fetch(`${API_BASE}/api/prompts/${category}/${filename}`, { method: 'DELETE' });
                showToast('삭제됨', 'success');
                return true;
            } catch (e) {
                showToast('삭제 실패', 'error');
                return false;
            }
        }
        
        function setupPromptPresetDropdown(dropdown, textarea) {
            const category = dropdown.dataset.category;
            const btn = dropdown.querySelector('.prompt-preset-btn');
            const menu = dropdown.querySelector('.prompt-preset-menu');
            const list = dropdown.querySelector('.prompt-preset-list');
            const saveBtn = dropdown.querySelector('.prompt-preset-save-btn');
            
            btn.onclick = async (e) => {
                e.stopPropagation();
                // 다른 메뉴 닫기
                document.querySelectorAll('.prompt-preset-menu.show').forEach(m => {
                    if (m !== menu) m.classList.remove('show');
                });
                menu.classList.toggle('show');
                
                if (menu.classList.contains('show')) {
                    // 목록 로드
                    const presets = await loadPromptPresets(category);
                    if (presets.length === 0) {
                        list.innerHTML = '<div class="prompt-preset-empty">저장된 프리셋 없음</div>';
                    } else {
                        list.innerHTML = presets.map(p => `
                            <div class="prompt-preset-item" data-filename="${p.filename}">
                                <div class="prompt-preset-item-name" title="${p.name}">${p.name}</div>
                                <div class="prompt-preset-item-actions">
                                    <button class="add-btn">Add</button>
                                    <button class="replace-btn">Replace</button>
                                    <button class="delete-btn">🗑️</button>
                                </div>
                            </div>
                        `).join('');
                        
                        // 이벤트 바인딩
                        list.querySelectorAll('.prompt-preset-item').forEach(item => {
                            const filename = item.dataset.filename;
                            
                            item.querySelector('.add-btn').onclick = async (e) => {
                                e.stopPropagation();
                                const content = await getPromptPreset(category, filename);
                                if (content !== null) {
                                    if (textarea.value.trim()) {
                                        textarea.value = textarea.value.trim() + '\n\n' + content;
                                    } else {
                                        textarea.value = content;
                                    }
                                    menu.classList.remove('show');
                                }
                            };
                            
                            item.querySelector('.replace-btn').onclick = async (e) => {
                                e.stopPropagation();
                                const content = await getPromptPreset(category, filename);
                                if (content !== null) {
                                    textarea.value = content;
                                    // 하이라이팅 업데이트를 위해 input 이벤트 트리거
                                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                                    menu.classList.remove('show');
                                }
                            };
                            
                            item.querySelector('.delete-btn').onclick = async (e) => {
                                e.stopPropagation();
                                showConfirmModal(
                                    '🗑️ 프리셋 삭제',
                                    '<p>이 프리셋을 삭제하시겠습니까?</p>',
                                    async () => {
                                        if (await deletePromptPreset(category, filename)) {
                                            item.remove();
                                            if (list.querySelectorAll('.prompt-preset-item').length === 0) {
                                                list.innerHTML = '<div class="prompt-preset-empty">저장된 프리셋 없음</div>';
                                            }
                                        }
                                    },
                                    '삭제',
                                    true
                                );
                            };
                        });
                    }
                }
            };
            
            saveBtn.onclick = async (e) => {
                e.stopPropagation();
                const content = textarea.value.trim();
                if (!content) {
                    showToast('저장할 내용 없음', 'warning');
                    return;
                }
                const name = prompt('프리셋 이름 입력:');
                if (!name) return;
                
                if (await savePromptPreset(category, name, content)) {
                    menu.classList.remove('show');
                }
            };
        }
        
        // Base/Negative 프롬프트 프리셋 초기화
        document.querySelectorAll('.section > .prompt-label-row .prompt-preset-dropdown').forEach(dropdown => {
            const category = dropdown.dataset.category;
            let textarea;
            if (category === 'base') {
                textarea = document.getElementById('basePrompt');
            } else if (category === 'negative') {
                textarea = document.getElementById('negativePrompt');
            }
            if (textarea) {
                setupPromptPresetDropdown(dropdown, textarea);
            }
        });
        
        // 외부 클릭 시 프롬프트 프리셋 메뉴 닫기
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.prompt-preset-dropdown')) {
                document.querySelectorAll('.prompt-preset-menu.show').forEach(m => m.classList.remove('show'));
            }
        });
        
        // === Characters ===
        const charactersList = document.getElementById('charactersList');
        const addCharBtn = document.getElementById('addCharBtn');
        
        function createCharacterItem(content = '', collapsed = false, enabled = true) {
            const item = document.createElement('div');
            item.className = 'character-item' + (enabled ? '' : ' disabled');

            // 헤더 (접기 + on/off + 번호 + 프리셋 + 삭제)
            const header = document.createElement('div');
            header.className = 'character-item-header';

            // 드래그 핸들
            const dragHandle = document.createElement('button');
            dragHandle.type = 'button';
            dragHandle.className = 'char-drag';
            dragHandle.innerHTML = '⋮⋮';
            dragHandle.title = '드래그하여 순서 변경';

            // 접기 버튼
            const collapseBtn = document.createElement('button');
            collapseBtn.type = 'button';
            collapseBtn.className = 'collapse-toggle' + (collapsed ? ' collapsed' : '');
            collapseBtn.textContent = '▼';
            collapseBtn.title = '접기/펼치기';

            // On/Off 토글
            const enableToggle = document.createElement('input');
            enableToggle.type = 'checkbox';
            enableToggle.className = 'char-enable-toggle';
            enableToggle.checked = enabled;
            enableToggle.title = enabled ? '활성화됨 (클릭하여 비활성화)' : '비활성화됨 (클릭하여 활성화)';
            enableToggle.onchange = () => {
                item.classList.toggle('disabled', !enableToggle.checked);
                enableToggle.title = enableToggle.checked ? '활성화됨 (클릭하여 비활성화)' : '비활성화됨 (클릭하여 활성화)';
                autoSaveSettings();
            };

            const charNum = document.createElement('span');
            charNum.className = 'char-num';

            // 프리셋 드롭다운
            const presetDropdown = document.createElement('div');
            presetDropdown.className = 'prompt-preset-dropdown';
            presetDropdown.dataset.category = 'character';
            presetDropdown.innerHTML = `
                <button type="button" class="prompt-preset-btn" title="프롬프트 프리셋">🔖 ▼</button>
                <div class="prompt-preset-menu">
                    <div class="prompt-preset-list"></div>
                    <div class="prompt-preset-actions">
                        <button type="button" class="prompt-preset-save-btn">+ Save Current</button>
                    </div>
                </div>
            `;

            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'delete-char-btn';
            deleteBtn.textContent = '×';
            deleteBtn.onclick = () => {
                item.remove();
                updateCharacterNumbers();
                autoSaveSettings();
            };

            header.appendChild(dragHandle);
            header.appendChild(collapseBtn);
            header.appendChild(enableToggle);
            header.appendChild(charNum);
            header.appendChild(presetDropdown);
            header.appendChild(deleteBtn);

            // 프롬프트 입력 (접을 수 있는 영역)
            const contentDiv = document.createElement('div');
            contentDiv.className = 'collapsible-content' + (collapsed ? ' collapsed' : '');

            const textarea = document.createElement('textarea');
            textarea.value = content;
            textarea.placeholder = 'Character prompt...';
            textarea.rows = 2;

            // content가 있으면 나중에 input 이벤트 트리거
            if (content) {
                setTimeout(() => {
                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                }, 50);
            }

            contentDiv.appendChild(textarea);

            // 드래그 핸들 이벤트
            dragHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startCharDrag(item, e);
            });

            // 헤더 바 전체 클릭으로 접기/펴기
            header.addEventListener('click', (e) => {
                // 체크박스, 프리셋, 삭제, 드래그 버튼 클릭은 무시
                if (e.target.closest('.char-enable-toggle, .prompt-preset-dropdown, .delete-char-btn, .char-drag')) return;
                collapseBtn.classList.toggle('collapsed');
                contentDiv.classList.toggle('collapsed');
                autoSaveSettings();
            });

            item.appendChild(header);
            item.appendChild(contentDiv);

            // 프리셋 드롭다운 이벤트 연결
            setupPromptPresetDropdown(presetDropdown, textarea);

            // 태그 자동완성 설정
            setupTagAutocomplete(textarea);

            // 프롬프트 가중치 하이라이팅 설정
            setupPromptHighlighting(textarea);

            return item;
        }
        
        function updateCharacterNumbers() {
            const items = charactersList.querySelectorAll('.character-item');
            items.forEach((item, index) => {
                item.querySelector('.char-num').textContent = index + 1;
            });
            // 최대 6개 제한
            updateAddCharBtn();
        }
        
        function updateAddCharBtn() {
            const count = charactersList.querySelectorAll('.character-item').length;
            addCharBtn.disabled = count >= 6;
            addCharBtn.title = count >= 6 ? 'Maximum 6 characters' : 'Add character';
        }
        
        function addCharacter(content = '') {
            const count = charactersList.querySelectorAll('.character-item').length;
            if (count >= 6) {
                showToast('최대 6개의 캐릭터까지 가능', 'warning');
                return;
            }
            // Characters 섹션이 접혀있으면 펼치기
            const charactersContent = document.getElementById('charactersContent');
            if (charactersContent.classList.contains('collapsed')) {
                charactersContent.classList.remove('collapsed');
                // 토글 버튼 상태도 동기화
                const toggleBtn = document.querySelector('[data-target="charactersContent"]');
                if (toggleBtn) {
                    toggleBtn.classList.remove('collapsed');
                    localStorage.setItem('collapse_charactersContent', 'expanded');
                }
            }
            const item = createCharacterItem(content);
            charactersList.appendChild(item);
            updateCharacterNumbers();
            item.querySelector('textarea').focus();
        }
        
        function getCharacterPrompts() {
            const items = charactersList.querySelectorAll('.character-item');
            return Array.from(items)
                .filter(item => item.querySelector('.char-enable-toggle').checked)  // enabled만
                .map(item => item.querySelector('textarea').value)
                .filter(v => v.trim());
        }

        function getCharacterPromptsWithLayout() {
            const items = charactersList.querySelectorAll('.character-item');
            return Array.from(items).map(item => ({
                content: item.querySelector('textarea').value,
                collapsed: item.querySelector('.collapsible-content').classList.contains('collapsed'),
                height: item.querySelector('textarea').style.height || null,
                enabled: item.querySelector('.char-enable-toggle').checked
            }));
        }

        // 캐릭터 드래그 앤 드롭
        let draggedChar = null;
        let dragStartY = 0;
        let charStartY = 0;
        let charPlaceholder = null;

        function startCharDrag(item, e) {
            draggedChar = item;
            dragStartY = e.clientY;

            const rect = item.getBoundingClientRect();
            charStartY = rect.top;

            // 플레이스홀더 생성
            charPlaceholder = document.createElement('div');
            charPlaceholder.className = 'char-placeholder';
            charPlaceholder.style.height = rect.height + 'px';

            // 드래그 중 스타일
            item.classList.add('dragging');
            item.style.position = 'fixed';
            item.style.left = rect.left + 'px';
            item.style.top = rect.top + 'px';
            item.style.width = rect.width + 'px';
            item.style.zIndex = '1000';

            item.parentNode.insertBefore(charPlaceholder, item);
            document.body.appendChild(item);

            // 마우스 이벤트 등록
            document.addEventListener('mousemove', onCharDrag);
            document.addEventListener('mouseup', endCharDrag);
        }

        function onCharDrag(e) {
            if (!draggedChar) return;

            const deltaY = e.clientY - dragStartY;
            draggedChar.style.top = (charStartY + deltaY) + 'px';

            // 다른 캐릭터 아이템들과 위치 비교
            const items = charactersList.querySelectorAll('.character-item:not(.dragging)');
            let targetItem = null;
            let insertBefore = true;

            for (const item of items) {
                const rect = item.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;

                if (e.clientY < midY) {
                    targetItem = item;
                    insertBefore = true;
                    break;
                }
                targetItem = item;
                insertBefore = false;
            }

            // 플레이스홀더 위치 업데이트
            if (targetItem) {
                if (insertBefore) {
                    charactersList.insertBefore(charPlaceholder, targetItem);
                } else {
                    if (targetItem.nextSibling) {
                        charactersList.insertBefore(charPlaceholder, targetItem.nextSibling);
                    } else {
                        charactersList.appendChild(charPlaceholder);
                    }
                }
            }
        }

        function endCharDrag() {
            if (!draggedChar) return;

            // 플레이스홀더 위치에 아이템 삽입
            charactersList.insertBefore(draggedChar, charPlaceholder);
            charPlaceholder.remove();

            // 드래그 스타일 제거
            draggedChar.classList.remove('dragging');
            draggedChar.style.position = '';
            draggedChar.style.left = '';
            draggedChar.style.top = '';
            draggedChar.style.width = '';
            draggedChar.style.zIndex = '';

            // 번호 업데이트 및 저장
            updateCharacterNumbers();
            autoSaveSettings();

            // 이벤트 제거
            document.removeEventListener('mousemove', onCharDrag);
            document.removeEventListener('mouseup', endCharDrag);

            draggedChar = null;
            charPlaceholder = null;
        }

        addCharBtn.onclick = () => {
            addCharacter();
            autoSaveSettings();
        };

        // LoRA 슬롯 시스템
        let availableLoras = [];  // 폴더에서 로드된 LoRA 목록
        let loraSlots = [];       // 현재 활성화된 LoRA 슬롯들 [{ name, scale }]
        
        function renderLoraSlots() {
            const loraList = document.getElementById('loraList');
            if (loraSlots.length === 0) {
                loraList.innerHTML = '<div class="lora-empty">+ 버튼으로 LoRA 추가</div>';
                return;
            }
            
            loraList.innerHTML = loraSlots.map((slot, index) => `
                <div class="lora-slot" data-index="${index}">
                    <select onchange="updateLoraSlot(${index}, 'name', this.value)">
                        <option value="">-- Select LoRA --</option>
                        ${availableLoras.map(l => `<option value="${l}" ${slot.name === l ? 'selected' : ''}>${l}</option>`).join('')}
                    </select>
                    <input type="number" value="${slot.scale}" step="0.1" min="0" max="2" 
                           onchange="updateLoraSlot(${index}, 'scale', this.value)">
                    <button type="button" class="lora-remove-btn" onclick="removeLoraSlot(${index})">✕</button>
                </div>
            `).join('');
        }
        
        function addLoraSlot() {
            loraSlots.push({ name: '', scale: 1.0 });
            renderLoraSlots();
            autoSaveSettings();
        }
        
        function removeLoraSlot(index) {
            loraSlots.splice(index, 1);
            renderLoraSlots();
            autoSaveSettings();
        }
        
        function updateLoraSlot(index, field, value) {
            if (field === 'scale') {
                loraSlots[index].scale = parseFloat(value);
            } else {
                loraSlots[index].name = value;
            }
            autoSaveSettings();
        }
        
        // Load resources
        async function loadResources() {
            try {
                const [modelsRes, lorasRes, upscaleRes, configRes] = await Promise.all([
                    fetch(`${API_BASE}/api/models`),
                    fetch(`${API_BASE}/api/loras`),
                    fetch(`${API_BASE}/api/upscale_models`),
                    fetch(`${API_BASE}/api/config`)
                ]);
                
                const { models } = await modelsRes.json();
                const { loras } = await lorasRes.json();
                const upscaleData = await upscaleRes.json();
                const config = await configRes.json();
                
                // Models
                const modelSelect = document.getElementById('localModel');
                modelSelect.innerHTML = '<option value="">-- Select Model --</option>';
                models.forEach(m => {
                    modelSelect.innerHTML += `<option value="${m}">${m}</option>`;
                });
                
                // LoRAs - 사용 가능한 목록 저장 후 슬롯 렌더링
                availableLoras = loras;
                renderLoraSlots();
                
                // Upscale Models
                const upscaleSelect = document.getElementById('upscaleModel');
                upscaleSelect.innerHTML = '<option value="">-- Select Model --</option>';
                (upscaleData.models || []).forEach(m => {
                    upscaleSelect.innerHTML += `<option value="${m}">${m}</option>`;
                });
                
                // Config
                document.getElementById('checkpointsDir').value = config.checkpoints_dir || '';
                document.getElementById('loraDir').value = config.lora_dir || '';
                updateNaiStatus(config.nai_token_set);
                
            } catch (e) {
                console.error('Failed to load:', e);
                statusText.textContent = '백엔드 실행 안됨!';
                showToast('백엔드 연결 안됨', 'error');
            }
        }
        
        function updateNaiStatus(hasToken) {
            naiTokenSet = hasToken;
            const badge = document.getElementById('naiStatus');
            if (hasToken) {
                badge.textContent = 'Connected';
                badge.className = 'status-badge success';
            } else {
                badge.textContent = 'Token not set';
                badge.className = 'status-badge warning';
            }
        }
        
        // NAI Token Modal
        function showNaiTokenModal() {
            document.getElementById('naiTokenModal').classList.add('active');
            document.getElementById('naiTokenModalInput').focus();
        }
        
        function closeNaiTokenModal() {
            document.getElementById('naiTokenModal').classList.remove('active');
        }
        
        async function saveNaiTokenFromModal() {
            const token = document.getElementById('naiTokenModalInput').value.trim();
            if (!token) {
                showToast('토큰을 입력하세요', 'error');
                return;
            }
            
            const btn = document.getElementById('naiTokenModalBtn');
            btn.textContent = '⏳ 저장 중...';
            btn.disabled = true;
            
            try {
                const res = await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nai_token: token })
                });
                
                console.log('[Token Save] Response status:', res.status);
                const text = await res.text();
                console.log('[Token Save] Response body:', text);
                
                let data;
                try {
                    data = JSON.parse(text);
                } catch (parseErr) {
                    console.error('[Token Save] JSON parse error:', parseErr);
                    showToast('서버 응답 파싱 실패', 'error');
                    return;
                }

                if (res.ok && data.success) {
                    showToast('토큰 저장됨. Anlas 정보를 불러오는 중...', 'success');
                    naiTokenSet = true;
                    closeNaiTokenModal();

                    // Settings 모달의 토큰 필드도 업데이트
                    document.getElementById('naiToken').value = token;

                    // Anlas 정보 갱신 후 UI 업데이트
                    await fetchAnlasBalance();
                    updateNaiStatus(true);
                    
                    showToast('준비 완료. 다시 Queue를 눌러주세요.', 'info');
                } else {
                    console.error('[Token Save] Failed:', data);
                    showToast(data.error || '토큰 저장 실패', 'error');
                }
            } catch (e) {
                console.error('[Token Save Error]', e);
                showToast(`토큰 저장 실패: ${e.message}`, 'error');
            }
            
            btn.textContent = '💾 저장';
            btn.disabled = false;
        }
        
        // 모달 외부 클릭 및 Enter 키
        document.getElementById('naiTokenModal').addEventListener('click', (e) => {
            if (e.target.id === 'naiTokenModal') closeNaiTokenModal();
        });
        document.getElementById('naiTokenModalInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveNaiTokenFromModal();
        });
        
        function getSelectedLoras() {
            // 슬롯에서 선택된 LoRA만 반환 (name이 비어있지 않은 것만)
            return loraSlots.filter(slot => slot.name).map(slot => ({
                name: slot.name,
                scale: slot.scale
            }));
        }
        
        // Generate
        async function addToQueue() {
            // NAI 모드인데 토큰 없으면 팝업
            if (currentProvider === 'nai' && !naiTokenSet) {
                showNaiTokenModal();
                return;
            }
            
            // Complete 후 리셋 타이머 취소
            if (resetTimer) {
                clearTimeout(resetTimer);
                resetTimer = null;
            }
            
            // Complete 상태였다면 새로 시작
            if (totalImages > 0 && totalImages === currentIndex) {
                currentIndex = 0;
                totalImages = 0;
            }
            
            const slotList = getSlotList();
            const repeatCount = parseInt(document.getElementById('repeatCount').value) || 1;

            // 모든 슬롯 등록 (빈 슬롯도 포함)
            const promptCount = slotList.length || 1;

            // 백엔드용 데이터 변환
            const promptData = slotList.length > 0
                ? slotList.map(s => ({ name: s.name, content: s.content, slotIndex: s.slotIndex }))
                : [{ name: '', content: '', slotIndex: 0 }];

            console.log(`[Queue] Adding job: slots=${slotList.length}, promptData=`, promptData);
            
            const request = {
                provider: currentProvider,
                base_prompt: document.getElementById('basePrompt').value,
                negative_prompt: document.getElementById('negativePrompt').value,
                character_prompts: getCharacterPrompts(),
                prompt_list: promptData,
                width: parseInt(document.getElementById('width').value),
                height: parseInt(document.getElementById('height').value),
                steps: parseInt(document.getElementById('steps').value),
                cfg: parseFloat(document.getElementById('cfg').value),
                seed: parseInt(document.getElementById('seed').value),
                random_seed_per_image: document.getElementById('randomSeed').checked,
                sampler: document.getElementById('sampler').value,
                scheduler: document.getElementById('scheduler').value,
                output_folder: getOutputFolder(),
            };
            
            if (currentProvider === 'nai') {
                request.nai_model = document.getElementById('naiModel').value;
                request.smea = document.getElementById('smea').value;
                request.uc_preset = document.getElementById('ucPreset').value;
                request.quality_tags = document.getElementById('qualityTags').checked;
                request.furry_mode = furryModeEnabled;
                request.cfg_rescale = parseFloat(document.getElementById('cfgRescale').value);
                request.variety_plus = document.getElementById('varietyPlus').checked;

                // Vibe Transfer
                if (document.getElementById('enableVibeTransfer').checked && vibeList.length > 0) {
                    request.vibe_transfer = vibeList.map(v => ({
                        image: v.image,
                        info_extracted: v.info_extracted,
                        strength: v.strength,
                        name: v.name || 'vibe',
                        encoded: v.encoded,
                        encoded_model: v.encoded_model
                    }));
                }

                // Character Reference (V4.5 only)
                if (document.getElementById('enableCharRef').checked && charRefData) {
                    request.character_reference = {
                        image: charRefData.processedImage || charRefData.image,  // Canvas 처리된 이미지 우선
                        fidelity: parseFloat(document.getElementById('charRefFidelity').value),
                        style_aware: document.getElementById('charRefStyleAware').checked
                    };
                }
            } else {
                request.model = document.getElementById('localModel').value;
                request.loras = getSelectedLoras();
                if (!request.model) {
                    showToast('모델을 선택하세요', 'error');
                    return;
                }
                
                // Upscale settings
                request.enable_upscale = document.getElementById('enableUpscale').checked;
                if (request.enable_upscale) {
                    request.upscale_model = document.getElementById('upscaleModel').value;
                    request.downscale_ratio = parseFloat(document.getElementById('downscaleRatio').value);
                    request.upscale_steps = parseInt(document.getElementById('upscaleSteps').value);
                    request.upscale_cfg = parseFloat(document.getElementById('upscaleCfg').value);
                    request.upscale_denoise = parseFloat(document.getElementById('upscaleDenoise').value);
                    request.size_alignment = document.getElementById('sizeAlignment').value;
                    
                    if (!request.upscale_model) {
                        showToast('업스케일 모델을 선택하세요', 'error');
                        return;
                    }
                }
            }

            // Save options
            request.save_format = document.getElementById('saveFormat').value;
            request.jpg_quality = parseInt(document.getElementById('jpgQuality').value);
            request.strip_metadata = document.getElementById('stripMetadata').checked;

            // Base Image (img2img / inpaint)
            if (baseImageData.enabled && baseImageData.image) {
                request.base_image = baseImageData.image;
                request.base_mode = baseImageData.mode;
                request.base_strength = baseImageData.strength;
                request.base_noise = baseImageData.noise;
                if (baseImageData.mode === 'inpaint' && baseImageData.mask) {
                    request.base_mask = baseImageData.mask;
                }
            }

            // 시드 고정이 아닐 경우, 다음 큐를 위해 즉시 새 시드로 UI 갱신
            // (빠르게 여러 번 클릭해도 중복 시드 방지)
            if (!document.getElementById('lockSeed').checked) {
                document.getElementById('seed').value = Math.floor(Math.random() * 2147483647);
            }

            // N번 큐에 등록
            for (let i = 0; i < repeatCount; i++) {
                try {
                    await fetch(`${API_BASE}/api/generate/multi`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(request)
                    });
                } catch (e) {
                    showToast(`Error: ${e.message}`, 'error');
                }

                // 매번 새로운 시드
                request.seed = Math.floor(Math.random() * 2147483647);
            }

            showToast(`${repeatCount * promptCount} images queued`, 'success');
        }
        
        function updateProgress() {
            if (totalImages === 0) {
                statusText.textContent = '준비';
                progressFill.style.width = '0%';
            } else {
                statusText.textContent = `${currentIndex}/${totalImages}`;
                progressFill.style.width = `${(currentIndex / totalImages) * 100}%`;
            }
        }
        
        async function cancelCurrent() {
            try {
                const response = await fetch(`${API_BASE}/api/cancel-current`, { method: 'POST' });
                const result = await response.json();
                showToast(result.message, result.success ? 'warning' : 'error');
            } catch (e) {
                showToast(`Error: ${e.message}`, 'error');
            }
        }
        
        async function clearQueue() {
            try {
                const response = await fetch(`${API_BASE}/api/clear-queue`, { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    // 대기 이미지 수 제거
                    totalImages -= result.cleared_images;
                    if (totalImages < currentIndex) totalImages = currentIndex;
                    updateProgress();
                    showToast(`Cleared ${result.cleared_images} images`, 'warning');
                }
            } catch (e) {
                showToast(`Error: ${e.message}`, 'error');
            }
        }
        
        // ============================================================
        // WebSocket 연결 및 메시지 처리
        // ============================================================

        function connectWebSocket() {
            if (wsReconnectTimer) {
                clearTimeout(wsReconnectTimer);
                wsReconnectTimer = null;
            }

            if (ws && ws.readyState === WebSocket.OPEN) {
                return;
            }

            const wsUrl = `ws://127.0.0.1:8765/ws${wsClientId ? `?clientId=${wsClientId}` : ''}`;
            console.log('[WS] Connecting...', wsUrl);
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('[WS] Connected');
                // 재연결 시 누락된 이미지 동기화 요청
                if (lastImageSeq > 0) {
                    ws.send(JSON.stringify({ type: 'sync', last_seq: lastImageSeq }));
                }
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                } catch (e) {
                    console.error('[WS] Parse error:', e);
                }
            };

            ws.onclose = (event) => {
                console.log('[WS] Disconnected, reconnecting in 1s...', event.code);
                wsReconnectTimer = setTimeout(connectWebSocket, 1000);
            };

            ws.onerror = (error) => {
                console.error('[WS] Error:', error);
            };
        }

        function updateProgressFromServer(progress) {
            if (progress) {
                currentIndex = progress.completed;
                totalImages = progress.total;
                updateProgress();
            }
        }

        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'connected':
                    // 연결 성공, 클라이언트 ID 저장
                    wsClientId = data.client_id;
                    localStorage.setItem('ws_client_id', wsClientId);
                    console.log('[WS] Client ID:', wsClientId);
                    // 초기 상태 동기화
                    if (data.status) {
                        currentIndex = data.status.completed_images;
                        totalImages = data.status.total_images;
                        updateProgress();
                    }
                    break;

                case 'sync':
                    // 재연결 시 누락된 이미지 수신
                    console.log(`[WS] Sync: received ${data.images?.length || 0} missed images`);
                    if (data.images) {
                        data.images.forEach(img => {
                            addImageToSlot(img.slot_idx, img);
                            if (img.seq) lastImageSeq = Math.max(lastImageSeq, img.seq);
                        });
                    }
                    if (data.status) {
                        currentIndex = data.status.completed_images;
                        totalImages = data.status.total_images;
                        updateProgress();
                    }
                    break;

                case 'job_queued':
                    // 작업이 큐에 추가될 때 즉시 진행률 반영
                    console.log(`[WS] Job queued: ${data.job_id}, images: ${data.job_images}`);
                    updateProgressFromServer(data.progress);
                    break;

                case 'job_start':
                    console.log(`[WS] Job started: ${data.job_id}, total: ${data.job_total}`);
                    updateProgressFromServer(data.progress);
                    break;

                case 'image':
                    console.log(`[WS] Image received: job_id=${data.job_id}, slot_idx=${data.slot_idx}, filename=${data.filename}, seq=${data.seq}`);
                    if (data.seq) lastImageSeq = Math.max(lastImageSeq, data.seq);
                    updateProgressFromServer(data.progress);
                    addImageToSlot(data.slot_idx, data);
                    break;

                case 'job_done':
                    console.log(`[WS] Job done: ${data.job_id}`);
                    updateProgressFromServer(data.progress);

                    // Anlas 잔액 및 비용 갱신 (생성 완료 시)
                    if (currentProvider === 'nai') {
                        fetchAnlasBalance();
                        updateAnlasCost();

                        // V4+ 모델에서 바이브가 사용된 경우, vibeList의 인코딩 상태 갱신
                        // (생성 완료 후 해당 설정으로 캐시됨)
                        const currentModel = document.getElementById('naiModel').value;
                        if (currentModel.includes('diffusion-4') && vibeList.length > 0) {
                            let updated = false;
                            vibeList.forEach(v => {
                                // 현재 모델과 info_extracted가 인코딩된 값과 다르면 갱신
                                const baseModel = currentModel.replace('-inpainting', '');
                                const encodedBaseModel = (v.encoded_model || '').replace('-inpainting', '');
                                const infoMatch = Math.abs((v.info_extracted || 1.0) - (v.encoded_info_extracted || v.info_extracted || 1.0)) <= 0.001;

                                if (encodedBaseModel !== baseModel || !infoMatch) {
                                    v.encoded_model = currentModel;
                                    v.encoded_info_extracted = v.info_extracted || 1.0;
                                    updated = true;
                                }
                            });
                            if (updated) {
                                renderVibeList();
                                saveAppSettings();
                            }
                        }
                    }

                    if (data.progress?.queue_length === 0) {
                        // 모든 작업 완료
                        statusText.textContent = '완료!';
                        progressFill.style.width = '100%';
                        showToast('완료', 'success');
                        lastImageSeq = 0;  // 시퀀스 리셋

                        if (resetTimer) clearTimeout(resetTimer);
                        resetTimer = setTimeout(() => {
                            if (totalImages === currentIndex || totalImages === 0) {
                                currentIndex = 0;
                                totalImages = 0;
                                updateProgress();
                            }
                        }, 2000);
                    }
                    break;

                case 'job_cancelled':
                    console.log(`[WS] Job cancelled: ${data.job_id}`);
                    updateProgressFromServer(data.progress);
                    showToast('작업 취소됨', 'warning');
                    break;

                case 'queue_cleared':
                    console.log(`[WS] Queue cleared: ${data.cleared_images} images`);
                    updateProgressFromServer(data.progress);
                    break;

                case 'error':
                    console.error('[WS] Generation error:', data.error);
                    updateProgressFromServer(data.progress);
                    showToast(`Error: ${data.error || 'Generation failed'}`, 'error');
                    break;

                case 'pong':
                    // Heartbeat 응답
                    break;
            }
        }
        
        function clearResults() {
            clearSlotImages();
            statusText.textContent = '준비';
            progressFill.style.width = '0%';
            currentIndex = 0;
            totalImages = 0;
        }
        
        // Lightbox
        lightbox.onclick = (e) => {
            if (e.target === lightbox || e.target.classList.contains('close')) {
                lightbox.classList.remove('active');
                lightboxCurrentSlot = null;
                lightboxCurrentCard = null;
                lightboxCurrentGalleryItem = null;
            }
        };

        // Lightbox wheel navigation (slot mode & gallery mode)
        lightbox.addEventListener('wheel', (e) => {
            if (!lightbox.classList.contains('active')) return;

            // 슬롯 모드
            if (lightboxCurrentSlot && lightboxCurrentCard) {
                e.preventDefault();

                const imagesContainer = lightboxCurrentSlot.querySelector('.slot-images');
                const cards = Array.from(imagesContainer.querySelectorAll('.slot-image-card'));
                if (cards.length <= 1) return;

                const currentIndex = cards.indexOf(lightboxCurrentCard);
                if (currentIndex === -1) return;

                let newIndex;
                if (e.deltaY > 0) {
                    newIndex = currentIndex + 1;
                    if (newIndex >= cards.length) newIndex = 0;
                } else {
                    newIndex = currentIndex - 1;
                    if (newIndex < 0) newIndex = cards.length - 1;
                }

                const newCard = cards[newIndex];
                const newImg = newCard.querySelector('img');
                if (newImg) {
                    lightboxImg.src = newImg.src;
                    lightboxCurrentCard = newCard;
                }
                return;
            }

            // 갤러리/바이브 모드
            if (lightboxCurrentGalleryItem) {
                e.preventDefault();

                const items = Array.from(galleryGrid.querySelectorAll('.gallery-item'));
                if (items.length <= 1) return;

                const currentIndex = items.indexOf(lightboxCurrentGalleryItem);
                if (currentIndex === -1) return;

                let newIndex;
                if (e.deltaY > 0) {
                    newIndex = currentIndex + 1;
                    if (newIndex >= items.length) newIndex = 0;
                } else {
                    newIndex = currentIndex - 1;
                    if (newIndex < 0) newIndex = items.length - 1;
                }

                const newItem = items[newIndex];
                lightboxCurrentGalleryItem = newItem;

                // 바이브 캐시면 썸네일 직접 사용
                if (newItem._isVibe && newItem._thumbnail) {
                    lightboxImg.src = 'data:image/png;base64,' + newItem._thumbnail;
                    return;
                }

                // 갤러리 이미지 로드 (비동기)
                const filename = newItem._filename;
                const folder = newItem._folder || '';
                const folderQuery = folder ? `?folder=${encodeURIComponent(folder)}` : '';
                fetch(`${API_BASE}/api/gallery/${filename}${folderQuery}`)
                    .then(res => res.json())
                    .then(result => {
                        if (result.success) {
                            lightboxImg.src = 'data:image/png;base64,' + result.image;
                        }
                    })
                    .catch(() => {});
            }
        }, { passive: false });

        // Settings
        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
            // Sync tag autocomplete checkbox with current state
            document.getElementById('tagAutocompleteToggle').checked = tagAutocompleteEnabled;
            checkLocalEnvStatus();
        }
        
        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }
        
        // 모달 외부 클릭 시 닫기
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') closeSettings();
        });
        document.getElementById('localInstallModal').addEventListener('click', (e) => {
            if (e.target.id === 'localInstallModal') closeLocalInstallModal();
        });
        
        async function saveSettings() {
            const config = {
                nai_token: document.getElementById('naiToken').value || null,
                checkpoints_dir: document.getElementById('checkpointsDir').value || null,
                lora_dir: document.getElementById('loraDir').value || null,
            };

            try {
                const res = await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                const data = await res.json();

                if (res.ok && data.success) {
                    showToast('설정 저장됨', 'success');
                    closeSettings();
                } else {
                    showToast(data.error || '저장 실패', 'error');
                }
            } catch (e) {
                showToast('저장 실패', 'error');
            }
        }
        
        // Local Environment
        let localEnvPollInterval = null;
        
        async function checkLocalEnvStatus() {
            try {
                const res = await fetch(`${API_BASE}/api/local/status`);
                const data = await res.json();
                updateLocalEnvUI(data);
                return data;
            } catch (e) {
                console.error('Failed to check local env status:', e);
                return null;
            }
        }
        
        function updateLocalEnvUI(data) {
            const statusEl = document.getElementById('localEnvStatus');
            const actionsEl = document.getElementById('localEnvActions');
            const progressEl = document.getElementById('localEnvProgress');
            const progressFillEl = document.getElementById('localEnvProgressFill');
            const progressTextEl = document.getElementById('localEnvProgressText');
            
            if (data.installing) {
                statusEl.className = 'local-env-status installing';
                statusEl.innerHTML = `<span class="status-icon">⏳</span><span class="status-text">${data.message || 'Installing...'}</span>`;
                actionsEl.innerHTML = '';
                progressEl.style.display = 'flex';
                progressFillEl.style.width = `${data.progress}%`;
                progressTextEl.textContent = `${data.progress}%`;
                
                // 폴링 시작
                if (!localEnvPollInterval) {
                    localEnvPollInterval = setInterval(checkLocalEnvStatus, 1000);
                }
            } else if (data.error) {
                statusEl.className = 'local-env-status error';
                statusEl.innerHTML = `<span class="status-icon">❌</span><span class="status-text">Error: ${data.error}</span>`;
                actionsEl.innerHTML = `<button class="btn" onclick="installLocalEnv()">Retry Install</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
            } else if (data.installed) {
                statusEl.className = 'local-env-status installed';
                statusEl.innerHTML = `<span class="status-icon">✅</span><span class="status-text">Installed</span>`;
                actionsEl.innerHTML = `<button class="btn btn-danger" onclick="uninstallLocalEnv()">제거</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
                
                // Local 탭 활성화
                enableLocalTab(true);
                
                // 저장된 provider가 local이었으면 자동 전환
                if (window._pendingProvider === 'local') {
                    window._pendingProvider = null;
                    currentProvider = 'local';
                    tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === 'local'));
                    providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === 'local'));
                    // Local의 전체 설정 복원
                    applyProviderSettings(localSettings, true);
                    restoreProviderGenerationSettings('local');
                    updateAnlasVisibility();
                    updateProviderLabels();
                }
            } else {
                statusEl.className = 'local-env-status not-installed';
                statusEl.innerHTML = `<span class="status-icon">⚠️</span><span class="status-text">Not installed</span>`;
                actionsEl.innerHTML = `<button class="btn" onclick="installLocalEnv()">Install Local Engine</button>`;
                progressEl.style.display = 'none';
                stopLocalEnvPolling();
                
                // Local 탭 비활성화
                enableLocalTab(false);
            }
        }
        
        function stopLocalEnvPolling() {
            if (localEnvPollInterval) {
                clearInterval(localEnvPollInterval);
                localEnvPollInterval = null;
            }
        }
        
        function enableLocalTab(enabled) {
            localEnvInstalled = enabled;
            const localTab = document.querySelector('.tab[data-provider="local"]');
            if (localTab) {
                if (enabled) {
                    localTab.classList.remove('disabled');
                    localTab.style.opacity = '1';
                } else {
                    localTab.classList.add('disabled');
                    localTab.style.opacity = '0.6';
                }
                // pointerEvents는 항상 auto로 - 클릭 감지 필요
                localTab.style.pointerEvents = 'auto';
            }
        }
        
        // Local Install Modal
        let installModalSource = 'local'; // 'local' | 'censor' - 어디서 팝업을 열었는지
        
        function showLocalInstallModal(source = 'local') {
            installModalSource = source;
            document.getElementById('localInstallModal').classList.add('active');
            updateInstallModalStatus();
        }
        
        function closeLocalInstallModal() {
            if (isInstalling) return;
            document.getElementById('localInstallModal').classList.remove('active');
        }
        
        function updateInstallModalStatus() {
            const statusEl = document.getElementById('installModalStatus');
            const progressEl = document.getElementById('installModalProgress');
            const btn = document.getElementById('installModalBtn');
            const closeBtn = document.getElementById('localInstallModalClose');
            const cancelBtn = document.getElementById('installModalCancelBtn');
            
            fetch(`${API_BASE}/api/local/status`)
                .then(res => res.json())
                .then(data => {
                    if (data.installed) {
                        const wasInstalling = isInstalling;  // 방금 설치 완료인지 확인
                        isInstalling = false;
                        if (installPollInterval) {
                            clearInterval(installPollInterval);
                            installPollInterval = null;
                        }
                        statusEl.className = 'local-env-status installed';
                        statusEl.innerHTML = '<span class="status-text">✅ 설치됨</span>';
                        progressEl.style.display = 'none';
                        btn.textContent = '✓ 이미 설치됨';
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        // 모달 닫기/취소 버튼 다시 활성화
                        if (closeBtn) closeBtn.style.display = '';
                        if (cancelBtn) cancelBtn.disabled = false;
                        
                        // 방금 설치가 완료된 경우 → 상태 업데이트 후 재시작 모달 표시
                        if (wasInstalling) {
                            // Local 탭 활성화 (재시작 안 해도 접근 가능하게)
                            localEnvInstalled = true;
                            enableLocalTab(true);

                            setTimeout(() => {
                                closeLocalInstallModal();
                                showRestartModal();
                            }, 500);
                        } else {
                        // 이미 설치된 상태로 모달 열린 경우
                            setTimeout(() => {
                                closeLocalInstallModal();
                                if (installModalSource === 'censor') {
                                    // 검열 모드에서 열었으면 검열 모드로 진입
                                    if (data.censor_ready) {
                                        // ultralytics 설치됨 - 검열 모드 진입
                                        currentMode = 'censor';
                                        censorModeBtn.classList.add('active');
                                        slotModeBtn.classList.remove('active');
                                        galleryModeBtn.classList.remove('active');
                                        document.getElementById('slotsToolbar').style.display = 'none';
                                        document.getElementById('slotsWrapper').style.display = 'none';
                                        document.getElementById('galleryContainer').style.display = 'none';
                                        document.getElementById('censorContainer').style.display = 'flex';
                                        if (typeof initCensorMode === 'function') {
                                            initCensorMode();
                                        }
                                    } else {
                                        // ultralytics 미설치 - 재설치 필요 안내
                                        showToast('검열 기능을 위해 환경 재설치가 필요합니다. Settings > Local에서 제거 후 다시 설치해주세요.', 'error', 5000);
                                    }
                                } else {
                                    // 로컬에서 열었으면 로컬 탭으로 전환
                                    localEnvInstalled = true;
                                    currentProvider = 'local';
                                    tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === 'local'));
                                    providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === 'local'));
                                }
                            }, 500);
                        }
                    } else if (data.installing) {
                        statusEl.className = 'local-env-status installing';
                        statusEl.innerHTML = `<span class="status-text">⏳ ${data.message || '설치 중...'}</span>`;
                        progressEl.style.display = 'flex';
                        document.getElementById('installModalProgressFill').style.width = `${data.progress || 0}%`;
                        document.getElementById('installModalProgressText').textContent = `${data.progress || 0}%`;
                        btn.textContent = '⏳ 설치 중...';
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        // 설치 중에는 닫기/취소 버튼 비활성화
                        if (closeBtn) closeBtn.style.display = 'none';
                        if (cancelBtn) cancelBtn.disabled = true;
                        // 폴링은 interval로 처리됨
                    } else if (data.error) {
                        isInstalling = false;  // 에러 발생
                        stopInstallPolling();  // 폴링 중지
                        statusEl.className = 'local-env-status error';
                        statusEl.innerHTML = `<span class="status-text">❌ ${data.error}</span>`;
                        progressEl.style.display = 'none';
                        btn.textContent = '🔄 다시 시도';
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        // 에러 시 닫기/취소 버튼 다시 활성화
                        if (closeBtn) closeBtn.style.display = '';
                        if (cancelBtn) cancelBtn.disabled = false;
                    } else {
                        // 설치 완료됐지만 installed가 false인 경우 (progress 100)
                        if (data.progress === 100) {
                            isInstalling = false;
                            stopInstallPolling();
                            statusEl.className = 'local-env-status installed';
                            statusEl.innerHTML = '<span class="status-text">✅ 설치 완료</span>';
                            btn.textContent = '✓ 설치 완료';
                            btn.disabled = true;
                            btn.style.opacity = '0.5';
                            progressEl.style.display = 'none';
                            if (closeBtn) closeBtn.style.display = '';
                            if (cancelBtn) cancelBtn.disabled = false;
                        } else if (!isInstalling) {
                            // 설치 중이 아닐 때만 "설치 필요" 표시
                            stopInstallPolling();
                            statusEl.className = 'local-env-status not-installed';
                            statusEl.innerHTML = '<span class="status-text">⚠️ 설치 필요</span>';
                            btn.textContent = '⬇️ 설치 (~5GB)';
                            btn.disabled = false;
                            btn.style.opacity = '1';
                            progressEl.style.display = 'none';
                            if (closeBtn) closeBtn.style.display = '';
                            if (cancelBtn) cancelBtn.disabled = false;
                        }
                        // isInstalling이 true이고 progress < 100이면 폴링 계속 (백엔드가 아직 시작 안함)
                    }
                })
                .catch(() => {
                    statusEl.className = 'local-env-status error';
                    statusEl.innerHTML = '<span class="status-text">❌ 백엔드 연결 안됨</span>';
                    // 에러 시 닫기/취소 버튼 다시 활성화
                    if (closeBtn) closeBtn.style.display = '';
                    if (cancelBtn) cancelBtn.disabled = false;
                });
        }
        
        let isInstalling = false;  // 설치 중 플래그
        let installPollInterval = null;  // 설치 상태 폴링 인터벌
        
        function startInstallPolling() {
            if (installPollInterval) return;
            installPollInterval = setInterval(updateInstallModalStatus, 500);  // 0.5초마다 폴링
        }
        
        function stopInstallPolling() {
            if (installPollInterval) {
                clearInterval(installPollInterval);
                installPollInterval = null;
            }
        }
        
        // === Restart Modal ===
        function showRestartModal() {
            document.getElementById('restartModal').classList.add('active');
        }

        async function autoRestart() {
            // 자동 재시작 (토스트 알림만 표시)
            showToast('⏳ 재시작 중... 잠시만 기다려주세요.', 'info', 0);

            try {
                // 서버에 재시작 요청
                await fetch(`${API_BASE}/api/restart`, { method: 'POST' });
            } catch (e) {
                // 서버가 종료되면서 연결이 끊어질 수 있음
            }

            // 서버가 다시 올라올 때까지 대기 후 페이지 새로고침
            await waitForServer();

            // 페이지 새로고침
            window.location.reload();
        }

        async function confirmRestart() {
            const btn = document.getElementById('restartConfirmBtn');
            btn.textContent = '⏳ 재시작 중...';
            btn.disabled = true;
            btn.style.opacity = '0.5';

            try {
                // 서버에 재시작 요청
                await fetch(`${API_BASE}/api/restart`, { method: 'POST' });
            } catch (e) {
                // 서버가 종료되면서 연결이 끊어질 수 있음
            }

            // 서버가 다시 올라올 때까지 대기 후 페이지 새로고침
            btn.textContent = '⏳ 서버 대기 중...';
            await waitForServer();

            // 페이지 새로고침
            window.location.reload();
        }
        
        async function waitForServer(maxAttempts = 30) {
            // 서버가 내려갔다가 다시 올라올 때까지 대기
            // 먼저 서버가 내려가길 기다림 (최대 3초)
            await new Promise(r => setTimeout(r, 1000));
            
            for (let i = 0; i < maxAttempts; i++) {
                try {
                    const res = await fetch(`${API_BASE}/api/health`, { 
                        method: 'GET',
                        signal: AbortSignal.timeout(2000)
                    });
                    if (res.ok) {
                        // 서버가 올라옴
                        return true;
                    }
                } catch (e) {
                    // 아직 서버 안 올라옴
                }
                await new Promise(r => setTimeout(r, 1000));
            }
            return false;
        }
        
        async function installFromModal() {
            const btn = document.getElementById('installModalBtn');
            const closeBtn = document.getElementById('localInstallModalClose');
            const cancelBtn = document.getElementById('installModalCancelBtn');
            const progressEl = document.getElementById('installModalProgress');
            const statusEl = document.getElementById('installModalStatus');
            
            // 즉시 UI 잠금
            isInstalling = true;
            btn.textContent = '⏳ 시작 중...';
            btn.disabled = true;
            btn.style.opacity = '0.5';
            if (closeBtn) closeBtn.style.display = 'none';
            if (cancelBtn) cancelBtn.disabled = true;
            statusEl.className = 'local-env-status installing';
            statusEl.innerHTML = '<span class="status-text">⏳ 설치 준비 중...</span>';
            progressEl.style.display = 'flex';
            document.getElementById('installModalProgressFill').style.width = '0%';
            document.getElementById('installModalProgressText').textContent = '0%';
            
            try {
                const res = await fetch(`${API_BASE}/api/local/install`, { method: 'POST' });
                if (res.ok) {
                    showToast('설치 시작됨', 'success');
                    startInstallPolling();  // 폴링 시작
                    checkLocalEnvStatus();  // Settings 모달도 업데이트
                } else {
                    const data = await res.json();
                    showToast(data.detail || '설치 시작 실패', 'error');
                    // 실패 시 UI 복원
                    isInstalling = false;
                    btn.textContent = '⬇️ 설치 (~5GB)';
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    if (closeBtn) closeBtn.style.display = '';
                    if (cancelBtn) cancelBtn.disabled = false;
                    progressEl.style.display = 'none';
                    statusEl.className = 'local-env-status not-installed';
                    statusEl.innerHTML = '<span class="status-text">⚠️ 설치 필요</span>';
                }
            } catch (e) {
                showToast('설치 시작 실패', 'error');
                // 실패 시 UI 복원
                isInstalling = false;
                btn.textContent = '⬇️ 설치 (~5GB)';
                btn.disabled = false;
                btn.style.opacity = '1';
                if (closeBtn) closeBtn.style.display = '';
                if (cancelBtn) cancelBtn.disabled = false;
                progressEl.style.display = 'none';
                statusEl.className = 'local-env-status not-installed';
                statusEl.innerHTML = '<span class="status-text">⚠️ 설치 필요</span>';
            }
        }
        
        async function installLocalEnv() {
            try {
                const res = await fetch(`${API_BASE}/api/local/install`, { method: 'POST' });
                if (res.ok) {
                    showToast('설치 시작됨', 'success');
                    checkLocalEnvStatus();
                } else {
                    const data = await res.json();
                    showToast(data.detail || 'Failed to start installation', 'error');
                }
            } catch (e) {
                showToast('설치 시작 실패', 'error');
            }
        }
        
        async function uninstallLocalEnv() {
            showConfirmModal(
                '🗑️ 환경 제거',
                '<p>로컬 생성/검열 환경을 제거하시겠습니까?</p><p style="color: var(--text-dim); font-size: 0.9rem;">약 5GB 디스크 공간이 확보됩니다.</p>',
                async () => {
                    try {
                        showToast('제거 중...', '', 30000);
                        const res = await fetch(`${API_BASE}/api/local/uninstall`, { method: 'DELETE' });
                        if (res.ok) {
                            showToast('제거 완료', 'success');
                            checkLocalEnvStatus();
                        } else {
                            showToast('제거 실패', 'error');
                        }
                    } catch (e) {
                        showToast('제거 실패: ' + e.message, 'error');
                    }
                },
                '제거',
                true
            );
        }
        
        // Toast
        let toastTimeout = null;
        function showToast(msg, type = '', duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.className = 'toast show ' + type;
            if (toastTimeout) {
                clearTimeout(toastTimeout);
                toastTimeout = null;
            }
            if (duration > 0) {
                toastTimeout = setTimeout(() => toast.classList.remove('show'), duration);
            }
        }
        function hideToast() {
            const toast = document.getElementById('toast');
            toast.classList.remove('show');
            if (toastTimeout) {
                clearTimeout(toastTimeout);
                toastTimeout = null;
            }
        }

        // Generic Confirm Modal
        function showConfirmModal(title, message, onConfirm, confirmText = '확인', isDanger = false) {
            const modal = document.getElementById('confirmModal');
            document.getElementById('confirmModalTitle').textContent = title;
            document.getElementById('confirmModalMessage').innerHTML = message;
            const okBtn = document.getElementById('confirmModalOk');
            okBtn.textContent = confirmText;
            okBtn.className = isDanger ? 'btn btn-danger' : 'btn';
            okBtn.style.background = isDanger ? 'var(--error)' : '';

            // 이벤트 리스너 정리 후 재설정
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            const newCancelBtn = document.getElementById('confirmModalCancel').cloneNode(true);
            document.getElementById('confirmModalCancel').parentNode.replaceChild(newCancelBtn, document.getElementById('confirmModalCancel'));

            newOkBtn.onclick = () => {
                modal.classList.remove('active');
                if (onConfirm) onConfirm();
            };
            newCancelBtn.onclick = () => {
                modal.classList.remove('active');
            };

            modal.classList.add('active');
        }

        function showInputModal(title, message, onConfirm, confirmText = '확인', defaultValue = '') {
            const modal = document.getElementById('inputModal');
            document.getElementById('inputModalTitle').textContent = title;
            document.getElementById('inputModalMessage').textContent = message;
            const input = document.getElementById('inputModalInput');
            input.value = defaultValue;

            const okBtn = document.getElementById('inputModalOk');
            okBtn.textContent = confirmText;

            // 이벤트 리스너 정리 후 재설정
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);
            const newCancelBtn = document.getElementById('inputModalCancel').cloneNode(true);
            document.getElementById('inputModalCancel').parentNode.replaceChild(newCancelBtn, document.getElementById('inputModalCancel'));

            newOkBtn.onclick = () => {
                const value = input.value.trim();
                if (value) {
                    modal.classList.remove('active');
                    if (onConfirm) onConfirm(value);
                }
            };
            newCancelBtn.onclick = () => {
                modal.classList.remove('active');
            };
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    newOkBtn.click();
                } else if (e.key === 'Escape') {
                    modal.classList.remove('active');
                }
            };

            modal.classList.add('active');
            setTimeout(() => input.focus(), 100);
        }

        // NAI 형식 메타데이터를 앱 내부 형식으로 변환
        function normalizeMetadata(meta) {
            if (!meta) return null;

            // 이미 앱 내부 형식이면 그대로 반환
            if (meta.negative_prompt !== undefined || meta.cfg !== undefined || meta.nai_model !== undefined) {
                return meta;
            }

            // 캐릭터 프롬프트 추출 (peropix 또는 NAI 형식)
            let charPrompts = [];
            const ppx = meta.peropix || {};
            if (ppx.character_prompts && ppx.character_prompts.length > 0) {
                charPrompts = ppx.character_prompts;
            } else if (meta.v4_prompt?.caption?.char_captions) {
                charPrompts = meta.v4_prompt.caption.char_captions.map(c => c.char_caption).filter(c => c);
            } else if (meta.characterPrompts) {
                charPrompts = meta.characterPrompts.map(c => c.prompt).filter(c => c);
            }

            // UC Preset: 숫자 → 문자열 변환
            const ucPresetMap = { 0: 'Heavy', 1: 'Light', 2: 'Human Focus', 3: 'None' };
            let ucPreset = ucPresetMap[meta.ucPreset] || meta.ucPreset || 'Heavy';
            let qualityTags = meta.qualityToggle;

            // 순수 NAI 이미지 여부 확인 (peropix 확장이 없으면 순수 NAI)
            const isPureNai = !meta.peropix;

            // 순수 NAI 이미지면 프롬프트에서 퀄리티 태그/UC 프리셋 태그 제거 (중복 방지)
            let prompt = meta.prompt || '';
            let negativePrompt = meta.uc || '';

            if (isPureNai) {
                // V4.5 Quality Tags 제거 (프롬프트 끝에 추가된 태그)
                const v45QualityTagsPatterns = [
                    ", very aesthetic, masterpiece, no text, -2::upscaled, blurry::,", // Enhance
                    ", very aesthetic, masterpiece, no text" // 일반
                ];

                let tagRemoved = false;
                for (const pattern of v45QualityTagsPatterns) {
                    if (prompt.endsWith(pattern)) {
                        prompt = prompt.slice(0, -pattern.length);
                        qualityTags = true; // 제거했으므로 옵션을 켜서 다시 추가되도록 함
                        tagRemoved = true;
                        break;
                    }
                }

                if (!tagRemoved) {
                    qualityTags = false; // 퀄리티 태그가 없으면 옵션 끄기
                }

                // V4.5 UC 프리셋 태그 제거 (네거티브 프롬프트 앞에 추가된 태그)
                const v45UcPresets = {
                    'Heavy': 'nsfw, lowres, artistic error, film grain, scan artifacts, worst quality, bad quality, jpeg artifacts, very displeasing, chromatic aberration, dithering, halftone, screentone, multiple views, logo, too many watermarks, negative space, blank page',
                    'Light': 'nsfw, lowres, artistic error, scan artifacts, worst quality, bad quality, jpeg artifacts, multiple views, very displeasing, too many watermarks, negative space, blank page',
                    'Furry Focus': 'nsfw, {worst quality}, distracting watermark, unfinished, bad quality, {widescreen}, upscale, {sequence}, {{grandfathered content}}, blurred foreground, chromatic aberration, sketch, everyone, [sketch background], simple, [flat colors], ych (character), outline, multiple scenes, [[horror (theme)]], comic',
                    'Human Focus': 'nsfw, lowres, artistic error, film grain, scan artifacts, worst quality, bad quality, jpeg artifacts, very displeasing, chromatic aberration, dithering, halftone, screentone, multiple views, logo, too many watermarks, negative space, blank page, @_@, mismatched pupils, glowing eyes, bad anatomy'
                };

                // 실제 네거티브 프롬프트에서 UC 프리셋 감지 및 제거
                let foundPreset = false;
                for (const [presetName, presetTags] of Object.entries(v45UcPresets)) {
                    if (negativePrompt.startsWith(presetTags)) {
                        ucPreset = presetName;
                        negativePrompt = negativePrompt.slice(presetTags.length);
                        // 앞에 ", " 가 남아있으면 제거
                        negativePrompt = negativePrompt.replace(/^,\s*/, '');
                        foundPreset = true;
                        break;
                    }
                }
                // UC 프리셋 태그가 없으면 None으로 설정
                if (!foundPreset) {
                    ucPreset = 'None';
                }
            }

            // Variety+ 감지 (peropix 확장 또는 NAI skip_cfg_above_sigma)
            let varietyPlus = ppx.variety_plus || false;
            if (!varietyPlus && meta.skip_cfg_above_sigma !== undefined && meta.skip_cfg_above_sigma !== null) {
                varietyPlus = true;
            }

            // Furry Mode 감지 (peropix 확장 또는 프롬프트 시작)
            let furryMode = ppx.furry_mode || false;
            if (!furryMode && meta.prompt && meta.prompt.startsWith('fur dataset,')) {
                furryMode = true;
            }

            // NAI 형식 → 앱 내부 형식 변환
            // 모델명: request_type이 실제 모델명인지 확인 (NAI 내부 타입명 필터)
            let naiModel = '';
            if (meta.request_type && meta.request_type.startsWith('nai-diffusion')) {
                naiModel = meta.request_type;
            } else if (meta.model && meta.model.startsWith('nai-diffusion')) {
                naiModel = meta.model;
            }
            // request_type이 "PromptGenerateRequest" 같은 내부 타입이면 무시

            return {
                prompt: prompt,
                negative_prompt: negativePrompt,
                character_prompts: charPrompts,
                seed: meta.seed,
                width: meta.width,
                height: meta.height,
                steps: meta.steps,
                cfg: meta.scale,
                sampler: meta.sampler,
                scheduler: meta.noise_schedule || 'karras',
                nai_model: naiModel,
                smea: meta.sm_dyn ? 'SMEA+DYN' : (meta.sm ? 'SMEA' : 'none'),
                uc_preset: ucPreset,
                quality_tags: qualityTags,
                cfg_rescale: meta.cfg_rescale,
                variety_plus: varietyPlus,
                furry_mode: furryMode,
                provider: ppx.provider || 'nai',
                model: ppx.local_model || '',
                vibe_transfer: ppx.vibe_transfer || null,
                // NAI 바이브 데이터 (순수 NAI 이미지용)
                nai_vibes: {
                    images: meta.reference_image_multiple || [],
                    strengths: meta.reference_strength_multiple || [],
                    info_extracted: meta.reference_information_extracted_multiple || []
                }
            };
        }

        // 설정 불러오기 확인 팝업 (드롭 모달 재사용)
        function showLoadSettingsConfirm(rawMetadata) {
            // NAI 형식을 앱 내부 형식으로 변환
            const metadata = normalizeMetadata(rawMetadata) || rawMetadata;

            const dropModal = document.getElementById('dropModal');
            document.getElementById('dropModalTitle').textContent = '📋 설정 불러오기';
            document.getElementById('dropModalPreview').src = '';
            document.getElementById('dropModalPreview').style.display = 'none';

            // 캐릭터 프롬프트 정보
            const charPrompts = metadata.character_prompts || [];
            const charPromptsHtml = charPrompts.length > 0
                ? `<div><strong>캐릭터 (${charPrompts.length}):</strong> ${charPrompts.map((c, i) => `[${i+1}] ${(c || '').substring(0, 30)}${(c || '').length > 30 ? '...' : ''}`).join(', ')}</div>`
                : '';

            // 바이브 정보
            const vibes = metadata.vibe_transfer || [];
            const vibeHtml = vibes.length > 0
                ? `<div><strong>Vibe (${vibes.length}):</strong> ${vibes.map(v => v.name || `S:${v.strength} I:${v.info_extracted}`).join(', ')}</div>`
                : '';

            // 순수 NAI 이미지 여부 확인 (peropix 확장이 없으면 순수 NAI)
            const isPureNaiImage = !rawMetadata.peropix;

            // 순수 NAI 이미지에 대한 경고 메시지
            const naiWarningHtml = isPureNaiImage ? `
                <div style="background: #3a3520; border: 1px solid #665c30; padding: 8px; margin-bottom: 8px; border-radius: 4px; font-size: 11px;">
                    ⚠️ <strong>순수 NAI 이미지</strong> - Character Reference, Base Image 설정은 적용되지 않습니다.
                </div>
            ` : '';

            const metadataDiv = document.getElementById('dropModalMetadata');
            metadataDiv.innerHTML = `
                ${naiWarningHtml}
                <div><strong>Prompt:</strong> ${(metadata.prompt || '').substring(0, 100)}${(metadata.prompt || '').length > 100 ? '...' : ''}</div>
                <div><strong>Negative:</strong> ${(metadata.negative_prompt || '').substring(0, 50)}${(metadata.negative_prompt || '').length > 50 ? '...' : ''}</div>
                ${charPromptsHtml}
                ${vibeHtml}
                <div><strong>Seed:</strong> ${metadata.seed || 'N/A'}</div>
                <div><strong>Size:</strong> ${metadata.width}x${metadata.height}</div>
                <div><strong>Steps:</strong> ${metadata.steps}, <strong>CFG:</strong> ${metadata.cfg}</div>
                <div><strong>Sampler:</strong> ${metadata.sampler}</div>
                <div><strong>Model:</strong> ${metadata.nai_model || metadata.model || 'N/A'}</div>
            `;

            document.getElementById('dropModalConfirm').textContent = '전체 적용';
            document.getElementById('dropModalPromptOnly').style.display = 'inline-block';

            // 정규화된 데이터 저장
            window._pendingLoadMetadata = metadata;
            window._isPureNaiImage = isPureNaiImage;

            dropModal.classList.add('active');
        }

        // 순수 NAI 이미지 적용 시 경고 팝업
        function showPureNaiWarning(callback) {
            const msg = `⚠️ 순수 NAI 이미지입니다.

[적용되지 않는 항목]
• Character Reference
• Base Image (img2img/inpaint)

계속하시겠습니까?`;
            if (confirm(msg)) {
                callback();
            }
        }

        // 프롬프트만 적용 (시드 포함)
        function applyPromptOnly(metadata) {
            // 프롬프트 (공란이어도 적용)
            if (metadata.prompt !== undefined) document.getElementById('basePrompt').value = metadata.prompt;
            if (metadata.negative_prompt !== undefined) document.getElementById('negativePrompt').value = metadata.negative_prompt;

            // 캐릭터 프롬프트 적용
            if (metadata.character_prompts && metadata.character_prompts.length > 0) {
                const charactersList = document.getElementById('charactersList');
                charactersList.innerHTML = '';
                metadata.character_prompts.forEach(cp => {
                    if (cp && cp.trim()) {
                        addCharacter(cp);
                    }
                });
                updateCharacterNumbers();
            }

            // 시드
            if (metadata.seed) document.getElementById('seed').value = metadata.seed;

            showToast('프롬프트와 시드가 적용되었습니다', 'success');
        }

        // 메타데이터 설정 적용
        function applyMetadataSettings(metadata) {
            // 프롬프트 (공란이어도 적용)
            if (metadata.prompt !== undefined) {
                const basePrompt = document.getElementById('basePrompt');
                basePrompt.value = metadata.prompt;
                // 하이라이팅 업데이트를 위해 input 이벤트 트리거
                basePrompt.dispatchEvent(new Event('input', { bubbles: true }));
            }
            if (metadata.negative_prompt !== undefined) {
                const negativePrompt = document.getElementById('negativePrompt');
                negativePrompt.value = metadata.negative_prompt;
                // 하이라이팅 업데이트를 위해 input 이벤트 트리거
                negativePrompt.dispatchEvent(new Event('input', { bubbles: true }));
            }

            // 캐릭터 프롬프트 적용
            if (metadata.character_prompts && metadata.character_prompts.length > 0) {
                // 기존 캐릭터 슬롯 모두 제거
                const charactersList = document.getElementById('charactersList');
                charactersList.innerHTML = '';
                // 새 캐릭터 프롬프트 추가
                metadata.character_prompts.forEach(cp => {
                    if (cp && cp.trim()) {
                        addCharacter(cp);
                    }
                });
                updateCharacterNumbers();
            }

            // 크기
            if (metadata.width) document.getElementById('width').value = metadata.width;
            if (metadata.height) document.getElementById('height').value = metadata.height;
            // 사이즈 프리셋 체크
            const sizeValue = `${metadata.width}x${metadata.height}`;
            const sizePreset = document.getElementById('sizePreset');
            const matchingOption = [...sizePreset.options].find(o => o.value === sizeValue);
            sizePreset.value = matchingOption ? sizeValue : 'custom';

            // 생성 설정
            if (metadata.steps) document.getElementById('steps').value = metadata.steps;
            if (metadata.cfg) document.getElementById('cfg').value = metadata.cfg;
            if (metadata.seed) document.getElementById('seed').value = metadata.seed;
            if (metadata.sampler) document.getElementById('sampler').value = metadata.sampler;
            if (metadata.scheduler) document.getElementById('scheduler').value = metadata.scheduler;

            // NAI 설정
            if (metadata.nai_model) document.getElementById('naiModel').value = metadata.nai_model;
            if (metadata.smea) document.getElementById('smea').value = metadata.smea;
            if (metadata.uc_preset) document.getElementById('ucPreset').value = metadata.uc_preset;
            if (metadata.quality_tags !== undefined) document.getElementById('qualityTags').checked = metadata.quality_tags;
            if (metadata.cfg_rescale !== undefined) {
                document.getElementById('cfgRescale').value = metadata.cfg_rescale;
                document.getElementById('cfgRescaleValue').textContent = metadata.cfg_rescale;
            }
            if (metadata.variety_plus !== undefined) document.getElementById('varietyPlus').checked = metadata.variety_plus;
            if (metadata.furry_mode !== undefined) setFurryMode(metadata.furry_mode);

            // Local 설정
            if (metadata.model) document.getElementById('localModel').value = metadata.model;

            // Provider 설정
            if (metadata.provider && metadata.provider !== currentProvider) {
                // Provider 변경은 복잡하므로 알림만
                showToast(`원본 Provider: ${metadata.provider}`, 'warning');
            }

            // Vibe Transfer 설정
            let vibesRestored = false;
            if (metadata.vibe_transfer && metadata.vibe_transfer.length > 0) {
                // PeroPix 형식 바이브 (캐시에서 이름 매칭)
                loadVibesFromMetadata(metadata.vibe_transfer);
                vibesRestored = true;
            } else if (metadata.nai_vibes && metadata.nai_vibes.images && metadata.nai_vibes.images.length > 0) {
                // NAI 원본 이미지의 바이브 복원 (인코딩 데이터만 있음)
                const naiVibes = metadata.nai_vibes;
                vibeList = [];  // 기존 바이브 클리어

                for (let i = 0; i < naiVibes.images.length; i++) {
                    const encodedData = naiVibes.images[i];
                    const strength = naiVibes.strengths[i] || 0.6;
                    // info_extracted는 배열이 비어있을 수 있음 - 기본값 1.0
                    const infoExtracted = (naiVibes.info_extracted && naiVibes.info_extracted[i] !== undefined)
                        ? naiVibes.info_extracted[i]
                        : 1.0;

                    // 플레이스홀더 이미지 생성 (1x1 투명 PNG)
                    const placeholderImage = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';

                    vibeList.push({
                        image: placeholderImage,
                        strength: strength,
                        info_extracted: infoExtracted,
                        name: `NAI Vibe ${i + 1}`,
                        encoded: encodedData,
                        encoded_model: metadata.nai_model || 'nai-diffusion-4-5-full',
                        encoded_info_extracted: infoExtracted,
                        _isNaiVibe: true  // NAI 바이브 표시용
                    });
                }

                renderVibeList();
                saveAppSettings();
                updateAnlasCost();
                document.getElementById('enableVibeTransfer').checked = true;
                document.getElementById('vibeTransferSettings').style.display = 'block';
                // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                document.getElementById('enableCharRef').checked = false;
                document.getElementById('charRefSettings').style.display = 'none';
                vibesRestored = true;
            }

            autoSaveSettings();

            // 결과 메시지
            if (vibesRestored && metadata.nai_vibes?.images?.length > 0) {
                showToast(`설정 적용됨 (바이브 ${metadata.nai_vibes.images.length}개 복원)`, 'success');
            } else {
                showToast('설정을 불러왔습니다', 'success');
            }
        }

        // 메타데이터에서 바이브 로드 (캐시에서 이름 매칭)
        async function loadVibesFromMetadata(vibeInfoList) {
            if (!vibeInfoList || vibeInfoList.length === 0) return;

            try {
                // 캐시된 바이브 목록 가져오기
                const response = await fetch(`${API_BASE}/api/vibe-cache`);
                const data = await response.json();
                const cachedVibes = data.vibes || [];

                let loadedCount = 0;
                let matchedCount = 0;

                for (const vibeInfo of vibeInfoList) {
                    if (!vibeInfo.name) continue;

                    // 캐시에서 이름 매칭
                    const cached = cachedVibes.find(v => v.name === vibeInfo.name || v.filename === vibeInfo.name);
                    if (cached) {
                        // 상세 데이터 로드
                        const detailRes = await fetch(`${API_BASE}/api/vibe-cache/${cached.filename}`);
                        const detail = await detailRes.json();
                        if (detail.success && detail.vibe_data) {
                            // 기존 바이브에 같은 이름이 있으면 건너뛰기
                            const exists = vibeList.some(v => v.name === vibeInfo.name);
                            if (!exists && vibeList.length < 16) {
                                const infoExtracted = vibeInfo.info_extracted || detail.info_extracted || 1.0;
                                vibeList.push({
                                    image: detail.image,
                                    strength: vibeInfo.strength || detail.strength || 0.6,
                                    info_extracted: infoExtracted,
                                    name: vibeInfo.name,
                                    encoded: detail.vibe_data,
                                    encoded_model: cached.model,
                                    encoded_info_extracted: detail.info_extracted || 1.0  // 캐시된 인코딩 시 사용된 값
                                });
                                loadedCount++;
                            }
                        }
                        matchedCount++;
                    }
                }

                if (loadedCount > 0) {
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                    document.getElementById('enableCharRef').checked = false;
                    document.getElementById('charRefSettings').style.display = 'none';
                    showToast(`바이브 ${loadedCount}개 로드됨`, 'success');
                }
            } catch (err) {
                console.error('[Vibe] 메타데이터에서 로드 실패:', err);
            }
        }

        // Event listeners
        generateBtn.onclick = addToQueue;
        cancelCurrentBtn.onclick = cancelCurrent;
        clearQueueBtn.onclick = clearQueue;
        document.getElementById('clearImagesBtn').onclick = clearResults;

        // Anime/Furry Mode Toggle
        let furryModeEnabled = false;
        const modeToggle = document.getElementById('modeToggle');

        function setFurryMode(enabled) {
            furryModeEnabled = enabled;
            if (enabled) {
                modeToggle.textContent = '🐾';
                modeToggle.title = '퍼리 모드';
                modeToggle.classList.add('furry');
            } else {
                modeToggle.textContent = '🌸';
                modeToggle.title = '아니메 모드';
                modeToggle.classList.remove('furry');
            }
            autoSaveSettings();
        }

        modeToggle.onclick = () => {
            setFurryMode(!furryModeEnabled);
        };

        // Collapse toggle for prompts and sections
        document.querySelectorAll('.collapse-toggle').forEach(btn => {
            const targetId = btn.dataset.target;
            const target = document.getElementById(targetId);
            if (!target) return;

            // 토글 함수
            const toggleCollapse = (e) => {
                // 프리셋 드롭다운 버튼, 기타 컨트롤 클릭은 무시
                if (e && e.target.closest('.prompt-preset-dropdown, .add-char-btn, .section-toggle, .mode-toggle')) return;
                // 이벤트 버블링 방지
                if (e) e.stopPropagation();

                btn.classList.toggle('collapsed');
                target.classList.toggle('collapsed');
                localStorage.setItem(`collapse_${targetId}`, btn.classList.contains('collapsed') ? 'collapsed' : 'expanded');
            };

            // 저장된 상태 복원 또는 기본값 설정
            const savedState = localStorage.getItem(`collapse_${targetId}`);
            if (savedState === 'collapsed') {
                btn.classList.add('collapsed');
                target.classList.add('collapsed');
            } else if (savedState === null) {
                // 첫 실행: basePromptContent만 펼치고 나머지 접기
                if (targetId !== 'basePromptContent') {
                    btn.classList.add('collapsed');
                    target.classList.add('collapsed');
                    localStorage.setItem(`collapse_${targetId}`, 'collapsed');
                }
            }

            // 클릭 가능한 바 찾기 (prompt-label-row가 prompt-label-left보다 우선)
            let clickableBar = btn.closest('.section-title, .characters-header');
            if (!clickableBar) {
                // prompt-label-left 안에 있으면 prompt-label-row를 찾음
                const promptLabelLeft = btn.closest('.prompt-label-left');
                if (promptLabelLeft) {
                    clickableBar = promptLabelLeft.closest('.prompt-label-row');
                }
            }

            // 바 전체에 클릭 이벤트 설정
            if (clickableBar) {
                clickableBar.addEventListener('click', toggleCollapse);
            } else {
                // 바가 없으면 버튼에만 설정
                btn.onclick = toggleCollapse;
            }
        });

        // 폴더 열기 버튼 핸들러
        async function openFolder(folderType, subfolder = '') {
            try {
                const response = await fetch(`${API_BASE}/api/open-folder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder: folderType, subfolder: subfolder })
                });
                const data = await response.json();
                if (data.error) {
                    showToast(`폴더 열기 실패: ${data.error}`, 'error');
                }
            } catch (e) {
                showToast('폴더 열기 실패', 'error');
            }
        }

        document.getElementById('openOutputFolderBtn').onclick = () => {
            openFolder('outputs', getOutputFolder());
        };
        document.getElementById('openVibeFolderBtn').onclick = () => openFolder('vibe_cache');
        document.getElementById('openCheckpointsFolderBtn').onclick = () => openFolder('checkpoints');
        document.getElementById('openLorasFolderBtn').onclick = () => openFolder('loras');
        document.getElementById('addLoraSlotBtn').onclick = addLoraSlot;

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                lightbox.classList.remove('active');
                closeSettings();
            }
            if (e.ctrlKey && e.key === 'Enter') {
                addToQueue();
            }
        });
        
        // 탭 활성화 시 WebSocket 재연결 확인
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                connectWebSocket();
            }
        });
        
        // Size Preset
        const sizePreset = document.getElementById('sizePreset');
        const widthInput = document.getElementById('width');
        const heightInput = document.getElementById('height');
        
        sizePreset.onchange = () => {
            const value = sizePreset.value;
            if (value !== 'custom') {
                const [w, h] = value.split('x').map(Number);
                widthInput.value = w;
                heightInput.value = h;
            }
            updateAnlasCost();
        };
        
        // Width/Height 직접 수정 시 Custom으로 변경
        function checkCustomSize() {
            const w = widthInput.value;
            const h = heightInput.value;
            const currentValue = `${w}x${h}`;
            
            // 프리셋에 있는 값인지 확인
            const options = [...sizePreset.options];
            const match = options.find(opt => opt.value === currentValue);
            
            if (match) {
                sizePreset.value = currentValue;
            } else {
                sizePreset.value = 'custom';
            }
        }
        
        widthInput.onchange = checkCustomSize;
        heightInput.onchange = checkCustomSize;
        
        // Upscale toggle
        document.getElementById('enableUpscale').onchange = function() {
            document.getElementById('upscaleSettings').style.display = this.checked ? 'block' : 'none';
        };

        // Upscale denoise slider value display
        document.getElementById('upscaleDenoise').oninput = function() {
            document.getElementById('upscaleDenoiseValue').textContent = this.value;
        };

        // CFG Rescale slider value display
        document.getElementById('cfgRescale').oninput = function() {
            document.getElementById('cfgRescaleValue').textContent = this.value;
        };

        // ============================================================
        // Vibe Transfer
        // ============================================================
        let vibeList = []; // {image: base64, info_extracted: 1.0, strength: 0.6}

        document.getElementById('enableVibeTransfer').onchange = function() {
            document.getElementById('vibeTransferSettings').style.display = this.checked ? 'block' : 'none';
            // Vibe Transfer와 Character Reference는 동시 사용 불가
            if (this.checked && document.getElementById('enableCharRef').checked) {
                document.getElementById('enableCharRef').checked = false;
                document.getElementById('charRefSettings').style.display = 'none';
            }
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('addVibeBtn').onclick = function() {
            if (vibeList.length >= 16) {
                alert('최대 16개까지만 추가할 수 있습니다.');
                return;
            }
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const base64 = await fileToBase64(file);
                vibeList.push({
                    image: base64,
                    info_extracted: 1.0,
                    strength: 0.6,
                    name: file.name
                });
                renderVibeList();
                saveAppSettings();
                updateAnlasCost();
            };
            input.click();
        };

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    // data:image/png;base64,XXXXX -> XXXXX 만 추출
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function renderVibeList() {
            const container = document.getElementById('vibeList');
            container.innerHTML = '';
            vibeList.forEach((vibe, idx) => {
                const item = document.createElement('div');
                item.className = 'vibe-item';
                // NAI 바이브 (원본 이미지 없음)는 특별 표시
                const isNaiVibe = vibe._isNaiVibe;
                const imgContent = isNaiVibe
                    ? `<div class="nai-vibe-placeholder" title="NAI에서 복원된 바이브 (원본 이미지 없음)">🎨</div>`
                    : `<img src="data:image/png;base64,${vibe.image}" alt="vibe">`;
                const cachedBadge = vibe.encoded ? '<span class="vibe-cached-badge" title="인코딩 캐시됨">✓</span>' : '';
                item.innerHTML = `
                    <div class="vibe-item-header">
                        ${imgContent}
                        <span class="vibe-info">${vibe.name || 'Vibe ' + (idx + 1)}${cachedBadge}</span>
                        <button type="button" class="remove-btn" data-idx="${idx}">×</button>
                    </div>
                    <div class="vibe-sliders">
                        <div class="vibe-slider-row">
                            <label>${isNaiVibe ? 'Reference Strength' : 'Strength'}</label>
                            <input type="range" class="vibe-strength" data-idx="${idx}" value="${vibe.strength}" min="0" max="1" step="0.05">
                            <span class="value">${vibe.strength}</span>
                        </div>
                        ${!isNaiVibe ? `<div class="vibe-slider-row">
                            <label>Info Extract</label>
                            <input type="range" class="vibe-info" data-idx="${idx}" value="${vibe.info_extracted}" min="0.01" max="1" step="0.01">
                            <span class="value">${vibe.info_extracted}</span>
                        </div>` : ''}
                    </div>
                `;
                container.appendChild(item);
            });

            // Event listeners
            container.querySelectorAll('.remove-btn').forEach(btn => {
                btn.onclick = function() {
                    vibeList.splice(parseInt(this.dataset.idx), 1);
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                };
            });
            container.querySelectorAll('.vibe-strength').forEach(slider => {
                slider.oninput = function() {
                    const idx = parseInt(this.dataset.idx);
                    vibeList[idx].strength = parseFloat(this.value);
                    this.nextElementSibling.textContent = this.value;
                    saveAppSettings();
                };
            });
            container.querySelectorAll('.vibe-info').forEach(slider => {
                slider.oninput = function() {
                    const idx = parseInt(this.dataset.idx);
                    vibeList[idx].info_extracted = parseFloat(this.value);
                    this.nextElementSibling.textContent = this.value;
                    saveAppSettings();
                    updateAnlasCost();  // info_extracted 변경시 캐시 상태 재확인
                };
            });
        }

        // ============================================================
        // Character Reference (V4.5 only)
        // ============================================================
        let charRefData = null; // {image: base64, processedImage: base64, fidelity: 0.5, style_aware: true}

        // Canvas 기반 이미지 처리 (NAIS2/NAI 웹과 동일한 방식)
        async function processCharacterReferenceImage(base64Image) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = function() {
                    const width = img.width;
                    const height = img.height;
                    
                    // 캔버스 크기 선택 (1472x1472, 1536x1024, 1024x1536)
                    let targetW = 1472, targetH = 1472;
                    if (width > height) {
                        targetW = 1536;
                        targetH = 1024;
                    } else if (width < height) {
                        targetW = 1024;
                        targetH = 1536;
                    }
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = targetW;
                    canvas.height = targetH;
                    const ctx = canvas.getContext('2d');
                    
                    // 검은 배경으로 채우기 (letterbox)
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, targetW, targetH);
                    
                    // 비율 유지하면서 리사이즈 계산
                    const scale = Math.min(targetW / width, targetH / height);
                    const w = width * scale;
                    const h = height * scale;
                    const x = (targetW - w) / 2;
                    const y = (targetH - h) / 2;
                    
                    // 이미지 그리기
                    ctx.drawImage(img, x, y, w, h);
                    
                    console.log(`[CharRef] Canvas processed: ${width}x${height} -> ${targetW}x${targetH}`);
                    
                    // JPEG 95% 품질로 출력 (NAIS2와 동일)
                    const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
                    const base64Only = dataUrl.split(',')[1];
                    resolve(base64Only);
                };
                img.onerror = () => reject(new Error('Image load failed'));
                img.src = base64Image.startsWith('data:') ? base64Image : 'data:image/png;base64,' + base64Image;
            });
        }

        document.getElementById('enableCharRef').onchange = function() {
            document.getElementById('charRefSettings').style.display = this.checked ? 'block' : 'none';
            // Vibe Transfer와 Character Reference는 동시 사용 불가
            if (this.checked && document.getElementById('enableVibeTransfer').checked) {
                document.getElementById('enableVibeTransfer').checked = false;
                document.getElementById('vibeTransferSettings').style.display = 'none';
            }
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('uploadCharRefBtn').onclick = function() {
            document.getElementById('charRefInput').click();
        };

        document.getElementById('charRefInput').onchange = async function() {
            const file = this.files[0];
            if (!file) return;
            const base64 = await fileToBase64(file);
            
            // Canvas로 이미지 처리 (NAI 웹/NAIS2와 동일한 방식)
            let processedImage;
            try {
                processedImage = await processCharacterReferenceImage(base64);
                console.log(`[CharRef] Image processed, length: ${processedImage.length}`);
            } catch (e) {
                console.error('[CharRef] Processing failed:', e);
                processedImage = base64; // 실패시 원본 사용
            }
            
            charRefData = {
                image: base64,  // 원본 (프리뷰용)
                processedImage: processedImage,  // 처리된 이미지 (API용)
                fidelity: parseFloat(document.getElementById('charRefFidelity').value),
                style_aware: document.getElementById('charRefStyleAware').checked
            };
            document.getElementById('charRefImage').src = 'data:image/png;base64,' + base64;
            document.getElementById('charRefPreview').style.display = 'block';
            document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('removeCharRefBtn').onclick = function() {
            charRefData = null;
            document.getElementById('charRefPreview').style.display = 'none';
            document.getElementById('uploadCharRefBtn').textContent = '이미지 선택';
            document.getElementById('charRefInput').value = '';
            saveAppSettings();
            updateAnlasCost();
        };

        document.getElementById('charRefFidelity').oninput = function() {
            document.getElementById('charRefFidelityValue').textContent = this.value;
            if (charRefData) {
                charRefData.fidelity = parseFloat(this.value);
                saveAppSettings();
            }
        };

        document.getElementById('charRefStyleAware').onchange = function() {
            if (charRefData) {
                charRefData.style_aware = this.checked;
                saveAppSettings();
            }
        };

        // ============================================================
        // Anlas System
        // ============================================================
        let currentAnlas = null;
        let isOpusTier = false;

        async function fetchAnlasBalance() {
            try {
                const response = await fetch(`${API_BASE}/api/nai/subscription`);
                const data = await response.json();

                if (data.error) {
                    document.getElementById('anlasBalance').textContent = 'Error';
                    return;
                }

                currentAnlas = data.anlas;
                isOpusTier = data.tier >= 3; // Tier 3 = Opus
                console.log('[Anlas] Subscription loaded:', { tier: data.tier, isOpusTier, anlas: currentAnlas });

                document.getElementById('anlasBalance').textContent =
                    currentAnlas !== null ? currentAnlas.toLocaleString() : '--';

                updateAnlasCost();
            } catch (e) {
                console.error('[Anlas] Failed to fetch subscription:', e);
                document.getElementById('anlasBalance').textContent = '--';
            }
        }

        async function updateAnlasCost() {
            if (currentProvider !== 'nai') return;

            const width = parseInt(document.getElementById('width').value) || 832;
            const height = parseInt(document.getElementById('height').value) || 1216;
            const steps = parseInt(document.getElementById('steps').value) || 28;
            const vibeEnabled = document.getElementById('enableVibeTransfer').checked;
            const vibeCount = vibeEnabled ? vibeList.length : 0;
            const hasCharRef = document.getElementById('enableCharRef').checked && charRefData !== null;
            const repeatCount = parseInt(document.getElementById('repeatCount').value) || 1;
            const slotCount = document.querySelectorAll('.slot').length || 1;
            const totalCount = repeatCount * slotCount;
            const naiModel = document.getElementById('naiModel').value;

            // Vibe 데이터 (캐시 체크용)
            const vibes = vibeEnabled ? vibeList.map(v => ({
                image: v.image,
                info_extracted: v.info_extracted,
                encoded: !!v.encoded,  // 이미 인코딩된 바이브인지 여부
                encoded_model: v.encoded_model,  // 인코딩된 모델
                encoded_info_extracted: v.encoded_info_extracted  // 인코딩 시 사용된 info_extracted
            })) : [];

            try {
                const response = await fetch(`${API_BASE}/api/nai/calculate-cost`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        width, height, steps,
                        is_opus: isOpusTier,
                        vibe_count: vibeCount,
                        has_char_ref: hasCharRef,
                        count: totalCount,
                        vibes: vibes,
                        model: naiModel
                    })
                });
                const data = await response.json();
                console.log('[Cost Response]', data);

                if (data.is_free && data.vibe_encoding_cost === 0) {
                    document.getElementById('anlasCost').style.display = 'none';
                    document.getElementById('anlasFreeTag').style.display = 'inline';
                } else {
                    document.getElementById('anlasCost').style.display = 'inline';
                    document.getElementById('anlasFreeTag').style.display = 'none';

                    // Vibe 인코딩 비용 (일회성, 바이브 갯수만큼)
                    if (data.vibe_encoding_cost > 0) {
                        document.getElementById('anlasCost').textContent =
                            `${data.vibe_encoding_cost} (바이브 ${data.uncached_vibes}개)`;
                    }
                    // 일반 생성 비용 (CharRef 등)
                    else {
                        let costText = data.total_cost.toLocaleString();
                        if (slotCount > 1 || repeatCount > 1) {
                            let breakdown = `${data.cost_per_image}`;
                            if (slotCount > 1) breakdown += ` × ${slotCount}슬롯`;
                            if (repeatCount > 1) breakdown += ` × ${repeatCount}회`;
                            costText += ` (${breakdown})`;
                        }
                        document.getElementById('anlasCost').textContent = costText;
                    }
                }

                // Vibe 캐시 상태 표시
                const vibeCacheInfo = document.getElementById('vibeCacheInfo');
                if (vibeCacheInfo && vibes.length > 0) {
                    if (data.cached_vibes > 0 && data.uncached_vibes === 0) {
                        vibeCacheInfo.textContent = `✓ ${data.cached_vibes}개 캐시됨 (무료)`;
                        vibeCacheInfo.style.color = '#4CAF82';
                    } else if (data.uncached_vibes > 0) {
                        vibeCacheInfo.textContent = `${data.uncached_vibes}개 인코딩 필요 (+${data.vibe_encoding_cost} Anlas)`;
                        vibeCacheInfo.style.color = '#F5B942';
                    }
                    vibeCacheInfo.style.display = 'block';
                } else if (vibeCacheInfo) {
                    vibeCacheInfo.style.display = 'none';
                }
            } catch (e) {
                document.getElementById('anlasCost').textContent = '?';
            }
        }

        // Anlas UI 표시/숨김 (provider에 따라)
        function updateAnlasVisibility() {
            const anlasInfo = document.getElementById('anlasInfo');
            if (currentProvider === 'nai') {
                anlasInfo.style.display = 'block';
                fetchAnlasBalance();
            } else {
                anlasInfo.style.display = 'none';
            }
        }

        // Anlas 새로고침 버튼
        document.getElementById('refreshAnlasBtn').onclick = function() {
            this.style.transform = 'rotate(360deg)';
            setTimeout(() => this.style.transform = '', 300);
            fetchAnlasBalance();
        };

        // 설정 변경시 비용 재계산
        ['width', 'height', 'steps', 'repeatCount'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', updateAnlasCost);
            }
        });

        // Vibe/CharRef/모델 변경시 비용 재계산
        document.getElementById('enableVibeTransfer').addEventListener('change', updateAnlasCost);
        document.getElementById('enableCharRef').addEventListener('change', updateAnlasCost);
        document.getElementById('naiModel').addEventListener('change', () => {
            updateAnlasCost();
            updateSmeaVisibility();
        });

        // V4+ 모델에서 SMEA 비활성화
        function updateSmeaVisibility() {
            const model = document.getElementById('naiModel').value;
            const isV4 = model.includes('diffusion-4');
            const smeaSelect = document.getElementById('smea');
            const smeaContainer = smeaSelect.parentElement;

            if (isV4) {
                smeaSelect.value = 'none';
                smeaContainer.style.opacity = '0.5';
                smeaSelect.disabled = true;
                smeaContainer.title = 'V4+ 모델에서는 SMEA를 지원하지 않습니다';
            } else {
                smeaContainer.style.opacity = '1';
                smeaSelect.disabled = false;
                smeaContainer.title = '';
            }
        }
        updateSmeaVisibility(); // 초기 실행

        // ============================================================
        // Prompt Weight Highlighting System
        // ============================================================

        let promptHighlightEnabled = true;

        /**
         * NAI 문법 파싱: {text}, [text], number::text ::
         * @param {string} text - 파싱할 프롬프트 텍스트
         * @returns {Array} - [{text: string, level: number}, ...]
         */
        function parseNAIWeights(text) {
            const result = [];
            let i = 0;
            let currentLevel = 0;
            let levelStack = [];

            while (i < text.length) {
                // 수치 가중치 파싱: number::
                if (text[i].match(/\d/) || text[i] === '-') {
                    const numMatch = text.substring(i).match(/^(-?\d+\.?\d*)::(.*?)::/);
                    if (numMatch) {
                        const weight = parseFloat(numMatch[1]);
                        const content = numMatch[2];

                        // 가중치를 레벨로 변환 (1.0 = 0, 1.5 = +5, 0.5 = -5)
                        let level = Math.round((weight - 1.0) * 10);

                        // 수치 문법은 괄호 포함
                        result.push({ text: `${numMatch[1]}::${content}::`, level });
                        i += numMatch[0].length;
                        continue;
                    }
                }

                // { 강화 괄호
                if (text[i] === '{') {
                    result.push({ text: '{', level: 0 }); // 괄호는 강조 없음
                    levelStack.push(currentLevel);
                    currentLevel++;
                    i++;
                    continue;
                }

                // [ 약화 괄호
                if (text[i] === '[') {
                    result.push({ text: '[', level: 0 }); // 괄호는 강조 없음
                    levelStack.push(currentLevel);
                    currentLevel--;
                    i++;
                    continue;
                }

                // 닫는 괄호 } ]
                if (text[i] === '}' || text[i] === ']') {
                    if (levelStack.length > 0) {
                        currentLevel = levelStack.pop();
                    }
                    result.push({ text: text[i], level: 0 }); // 괄호는 강조 없음
                    i++;
                    continue;
                }

                // 일반 텍스트 수집
                let textChunk = '';
                while (i < text.length && text[i] !== '{' && text[i] !== '[' && text[i] !== '}' && text[i] !== ']') {
                    // 수치 가중치 체크
                    if (text[i].match(/\d/) || text[i] === '-') {
                        const numMatch = text.substring(i).match(/^(-?\d+\.?\d*)::(.*?)::/);
                        if (numMatch) break;
                    }
                    textChunk += text[i];
                    i++;
                }

                if (textChunk) {
                    result.push({ text: textChunk, level: currentLevel });
                }
            }

            return result;
        }

        /**
         * Local (Stable Diffusion) 문법 파싱: (text), [text], (text:number)
         * @param {string} text - 파싱할 프롬프트 텍스트
         * @returns {Array} - [{text: string, level: number}, ...]
         */
        function parseLocalWeights(text) {
            const result = [];
            let i = 0;
            let currentLevel = 0;
            let levelStack = [];

            while (i < text.length) {
                // ( 강화 괄호
                if (text[i] === '(') {
                    // (text:number) 형식 체크
                    const weightMatch = text.substring(i).match(/^\(([^:)]+):(-?\d+\.?\d*)\)/);
                    if (weightMatch) {
                        const content = weightMatch[1];
                        const weight = parseFloat(weightMatch[2]);

                        // 가중치를 레벨로 변환 (1.0 = 0, 1.1 = +1, 0.9 = -1)
                        let level = Math.round((weight - 1.0) * 10);

                        // 수치 문법은 괄호 포함
                        result.push({ text: `(${content}:${weightMatch[2]})`, level });
                        i += weightMatch[0].length;
                        continue;
                    }

                    // 일반 (text) 형식
                    result.push({ text: '(', level: 0 }); // 괄호는 강조 없음
                    levelStack.push(currentLevel);
                    currentLevel++;
                    i++;
                    continue;
                }

                // [ 약화 괄호
                if (text[i] === '[') {
                    result.push({ text: '[', level: 0 }); // 괄호는 강조 없음
                    levelStack.push(currentLevel);
                    currentLevel--;
                    i++;
                    continue;
                }

                // 닫는 괄호 ) ]
                if (text[i] === ')' || text[i] === ']') {
                    if (levelStack.length > 0) {
                        currentLevel = levelStack.pop();
                    }
                    result.push({ text: text[i], level: 0 }); // 괄호는 강조 없음
                    i++;
                    continue;
                }

                // 일반 텍스트 수집
                let textChunk = '';
                while (i < text.length && text[i] !== '(' && text[i] !== '[' && text[i] !== ')' && text[i] !== ']') {
                    textChunk += text[i];
                    i++;
                }

                if (textChunk) {
                    result.push({ text: textChunk, level: currentLevel });
                }
            }

            return result;
        }

        /**
         * 가중치 레벨을 색상으로 변환 (-2 ~ +2 범위로 제한)
         * @param {number} level - 가중치 레벨
         * @returns {string} - CSS 색상 문자열
         */
        function levelToColor(level) {
            // 레벨을 -2 ~ +2 범위로 제한
            const clampedLevel = Math.max(-2, Math.min(2, level));

            if (clampedLevel === 0) {
                return 'transparent';
            }

            const goldColor = '#F5B942'; // --accent-gold
            const blueColor = '#4A7AB8'; // --accent

            if (clampedLevel > 0) {
                // 강화: 골드 (투명도로 강도 표현)
                const opacity = 0.2 + (clampedLevel / 2) * 0.3; // 0.2 ~ 0.5
                return `rgba(245, 185, 66, ${opacity})`;
            } else {
                // 약화: 블루 (투명도로 강도 표현)
                const opacity = 0.2 + (Math.abs(clampedLevel) / 2) * 0.3; // 0.2 ~ 0.5
                return `rgba(74, 122, 184, ${opacity})`;
            }
        }

        /**
         * 프롬프트 텍스트를 하이라이팅하여 overlay에 렌더링
         * @param {HTMLTextAreaElement} textarea - 프롬프트 textarea
         * @param {HTMLElement} overlay - overlay div
         */
        function highlightPrompt(textarea, overlay) {
            const text = textarea.value;
            if (!text) {
                overlay.innerHTML = '';
                return;
            }

            // 하이라이트가 꺼져있으면 일반 텍스트만 표시
            if (!promptHighlightEnabled) {
                const escapedText = text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
                overlay.innerHTML = escapedText;
                overlay.scrollTop = textarea.scrollTop;
                overlay.scrollLeft = textarea.scrollLeft;
                return;
            }

            // 현재 모드에 따라 파서 선택
            const naiTab = document.getElementById('naiTab');
            const localTab = document.getElementById('localTab');
            const isLocalMode = localTab && localTab.classList.contains('active');
            const parseFunction = isLocalMode ? parseLocalWeights : parseNAIWeights;

            // 텍스트 파싱
            const parsed = parseFunction(text);

            // HTML 생성
            let html = '';
            parsed.forEach(chunk => {
                const color = levelToColor(chunk.level);
                const escapedText = chunk.text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');

                if (color === 'transparent' || !color) {
                    html += escapedText;
                } else {
                    html += `<span style="background-color: ${color};">${escapedText}</span>`;
                }
            });

            overlay.innerHTML = html;

            // overlay 스크롤을 textarea와 동기화
            overlay.scrollTop = textarea.scrollTop;
            overlay.scrollLeft = textarea.scrollLeft;
        }

        /**
         * textarea에 프롬프트 하이라이팅 적용
         * @param {HTMLTextAreaElement} textarea - 대상 textarea
         */
        function setupPromptHighlighting(textarea) {
            if (!textarea) {
                console.warn('[PromptHighlight] setupPromptHighlighting called with null textarea');
                return;
            }

            // 이미 설정된 경우 스킵
            if (textarea.dataset.highlightSetup === 'true') {
                console.log('[PromptHighlight] Already setup for', textarea.id);
                return;
            }
            textarea.dataset.highlightSetup = 'true';

            console.log('[PromptHighlight] Setting up highlighting for', textarea.id);

            // Wrapper 생성
            const wrapper = document.createElement('div');
            wrapper.className = 'prompt-highlight-container';

            // Overlay 생성
            const overlay = document.createElement('div');
            overlay.className = 'prompt-highlight-overlay';

            // textarea를 wrapper로 감싸기
            textarea.parentNode.insertBefore(wrapper, textarea);
            wrapper.appendChild(overlay);
            wrapper.appendChild(textarea);

            console.log('[PromptHighlight] Created wrapper and overlay for', textarea.id);

            // 초기 하이라이팅
            highlightPrompt(textarea, overlay);

            // 이벤트 리스너
            textarea.addEventListener('input', () => {
                highlightPrompt(textarea, overlay);
            });

            textarea.addEventListener('scroll', () => {
                overlay.scrollTop = textarea.scrollTop;
                overlay.scrollLeft = textarea.scrollLeft;
            });

            // 창 크기 변경 시 재렌더링
            const resizeObserver = new ResizeObserver(() => {
                highlightPrompt(textarea, overlay);
            });
            resizeObserver.observe(textarea);
        }

        // ============================================================
        // Tag Autocomplete System
        // ============================================================

        let ALL_TAGS = [];
        let TAG_INDEX = {}; // 첫 글자 인덱싱 for O(1) access
        let tagAutocompleteEnabled = true;
        let tagsLoaded = false;

        // Load tag data from JSON
        async function loadTagData() {
            console.log('[TagAutocomplete] Loading tag data from data/tags.json...');
            try {
                const response = await fetch('data/tags.json');
                console.log('[TagAutocomplete] Fetch response:', response.status, response.statusText);

                if (!response.ok) {
                    console.warn('[TagAutocomplete] Tag data not found (HTTP ' + response.status + '). Autocomplete disabled.');
                    tagAutocompleteEnabled = false;
                    return;
                }

                const tags = await response.json();
                ALL_TAGS = tags;
                console.log('[TagAutocomplete] Parsed', ALL_TAGS.length, 'tags from JSON');

                // Build first-letter index for fast lookup
                TAG_INDEX = {};
                tags.forEach(tag => {
                    const firstChar = tag.label[0].toLowerCase();
                    if (!TAG_INDEX[firstChar]) {
                        TAG_INDEX[firstChar] = [];
                    }
                    TAG_INDEX[firstChar].push(tag);

                    // Add lowercase cache
                    tag._lower = tag.label.toLowerCase();
                });

                tagsLoaded = true;
                console.log('[TagAutocomplete] Ready! Loaded', ALL_TAGS.length, 'tags, indexed', Object.keys(TAG_INDEX).length, 'letters');
                console.log('[TagAutocomplete] Enabled:', tagAutocompleteEnabled);
            } catch (error) {
                console.error('[TagAutocomplete] Failed to load tag data:', error);
                tagAutocompleteEnabled = false;
            }
        }

        // Get current word at cursor position
        function getCurrentWord(textarea) {
            const value = textarea.value;
            const cursorPos = textarea.selectionStart;

            // 태그에 유효한 문자: 알파벳, 숫자, 언더스코어, 하이픈, 공백
            const isTagChar = (char) => /[a-zA-Z0-9_\-\s]/.test(char);

            // 커서 위치에서 뒤로 스캔하여 단어 시작점 찾기
            let start = cursorPos;
            while (start > 0) {
                const char = value[start - 1];
                // 콤마, 개행, 괄호, 콜론은 단어 경계
                if (char === ',' || char === '\n' || char === '\r' ||
                    char === '{' || char === '}' || char === '[' || char === ']' ||
                    char === '(' || char === ')' || char === ':') {
                    break;
                }
                if (!isTagChar(char)) {
                    break;
                }
                start--;
            }

            // 커서 위치에서 앞으로 스캔하여 단어 끝점 찾기
            let end = cursorPos;
            while (end < value.length) {
                const char = value[end];
                // 콤마, 개행, 괄호, 콜론은 단어 경계
                if (char === ',' || char === '\n' || char === '\r' ||
                    char === '{' || char === '}' || char === '[' || char === ']' ||
                    char === '(' || char === ')' || char === ':') {
                    break;
                }
                if (!isTagChar(char)) {
                    break;
                }
                end++;
            }

            // 추출한 단어
            const beforeTrim = value.substring(start, end);
            const word = beforeTrim.trim();

            // 공백 제거한 후 실제 단어의 위치 재계산
            const leadingSpaces = beforeTrim.length - beforeTrim.trimStart().length;
            const trailingSpaces = beforeTrim.length - beforeTrim.trimEnd().length;

            return {
                word,
                rawWord: beforeTrim,  // trim 전 원본 (공백 포함)
                start: start + leadingSpaces,  // 공백 제외한 단어 시작
                end: end - trailingSpaces,     // 공백 제외한 단어 끝
                fullStart: start,              // 공백 포함한 시작
                fullEnd: end,                  // 공백 포함한 끝
                cursorPos
            };
        }

        // Search tags with 2-stage algorithm
        function searchTags(query, maxResults = 15) {
            if (!query || query.length < 2) return [];

            const lowerQuery = query.toLowerCase();
            const firstChar = lowerQuery[0];
            const results = [];

            // Stage 1: Search indexed tags (startsWith)
            if (TAG_INDEX[firstChar]) {
                for (const tag of TAG_INDEX[firstChar]) {
                    if (tag._lower.startsWith(lowerQuery)) {
                        results.push(tag);
                        if (results.length >= maxResults) return results;
                    }
                }
            }

            // Stage 2: If not enough results, search all tags (includes)
            if (results.length < maxResults) {
                for (const tag of ALL_TAGS) {
                    if (results.includes(tag)) continue;
                    if (tag._lower.includes(lowerQuery)) {
                        results.push(tag);
                        if (results.length >= maxResults) break;
                    }
                }
            }

            return results;
        }

        // Format number with K/M suffix
        function formatCount(count) {
            if (count >= 1000000) return (count / 1000000).toFixed(1) + 'M';
            if (count >= 1000) return (count / 1000).toFixed(1) + 'K';
            return count.toString();
        }

        // Create autocomplete dropdown
        function createAutocompleteDropdown() {
            const dropdown = document.createElement('div');
            dropdown.className = 'tag-autocomplete-dropdown';
            dropdown.id = 'tagAutocompleteDropdown';
            document.body.appendChild(dropdown);
            return dropdown;
        }

        // Get or create dropdown
        function getAutocompleteDropdown() {
            let dropdown = document.getElementById('tagAutocompleteDropdown');
            if (!dropdown) {
                dropdown = createAutocompleteDropdown();
            }
            return dropdown;
        }

        // Show autocomplete dropdown
        function showAutocomplete(textarea, results) {
            const dropdown = getAutocompleteDropdown();
            dropdown.innerHTML = '';

            if (results.length === 0) {
                dropdown.innerHTML = '<div class="tag-autocomplete-empty">No matching tags</div>';
                dropdown.classList.add('show');
                return;
            }

            results.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-autocomplete-item';
                if (index === 0) item.classList.add('selected');
                item.dataset.index = index;
                item.dataset.tagValue = tag.value;

                const name = document.createElement('span');
                name.className = 'tag-autocomplete-item-name';
                name.textContent = tag.label;
                name.title = tag.label;  // 마우스 오버 시 전체 태그명 표시

                const badge = document.createElement('span');
                badge.className = `tag-autocomplete-item-badge ${tag.type}`;

                // 카테고리 한글 표시
                const categoryNames = {
                    'general': '일반',
                    'artist': '작가',
                    'character': '캐릭터',
                    'copyright': '작품',
                    'meta': '기타'
                };
                badge.textContent = categoryNames[tag.type] || tag.type;

                const count = document.createElement('span');
                count.className = 'tag-autocomplete-item-count';
                count.textContent = formatCount(tag.count);

                item.appendChild(name);
                item.appendChild(badge);
                item.appendChild(count);

                // Click to insert
                item.addEventListener('click', () => {
                    insertTag(textarea, tag.value);
                    hideAutocomplete();
                });

                dropdown.appendChild(item);
            });

            // Position dropdown near cursor
            positionDropdown(textarea, dropdown);
            dropdown.classList.add('show');

            // Store results for keyboard navigation
            dropdown._currentResults = results;
            dropdown._selectedIndex = 0;
            dropdown._textarea = textarea;
        }

        // Hide autocomplete dropdown
        function hideAutocomplete() {
            const dropdown = getAutocompleteDropdown();
            dropdown.classList.remove('show');
        }

        // Get accurate cursor pixel position (handles word wrap)
        function getCursorPixelPosition(textarea) {
            const cursorPos = textarea.selectionStart;

            // Create a mirror div with exact same styles and content
            const mirror = document.createElement('div');
            const computed = window.getComputedStyle(textarea);

            // Copy all text styles
            mirror.style.position = 'absolute';
            mirror.style.visibility = 'hidden';
            mirror.style.whiteSpace = computed.whiteSpace;
            mirror.style.wordWrap = computed.wordWrap;
            mirror.style.overflowWrap = computed.overflowWrap;
            mirror.style.width = textarea.clientWidth + 'px';
            mirror.style.font = computed.font;
            mirror.style.fontSize = computed.fontSize;
            mirror.style.fontFamily = computed.fontFamily;
            mirror.style.fontWeight = computed.fontWeight;
            mirror.style.lineHeight = computed.lineHeight;
            mirror.style.letterSpacing = computed.letterSpacing;
            mirror.style.padding = computed.padding;
            mirror.style.border = '0';
            mirror.style.boxSizing = computed.boxSizing;

            // Add text before cursor
            const textBefore = textarea.value.substring(0, cursorPos);
            mirror.textContent = textBefore;

            // Create a marker span at cursor position
            const marker = document.createElement('span');
            marker.textContent = '\u200B'; // Zero-width space
            marker.style.display = 'inline';
            mirror.appendChild(marker);

            document.body.appendChild(mirror);

            // Get marker position relative to mirror
            const markerRect = marker.getBoundingClientRect();
            const mirrorRect = mirror.getBoundingClientRect();

            const x = markerRect.left - mirrorRect.left;
            const y = markerRect.top - mirrorRect.top;

            document.body.removeChild(mirror);

            return { x, y };
        }

        // Position dropdown near cursor
        function positionDropdown(textarea, dropdown) {
            const textareaRect = textarea.getBoundingClientRect();
            const cursorPos = getCursorPixelPosition(textarea);

            // Get line height
            const computed = window.getComputedStyle(textarea);
            const lineHeight = parseInt(computed.lineHeight) || parseInt(computed.fontSize) * 1.2;

            // Calculate absolute position
            // Account for textarea scroll
            const scrollTop = textarea.scrollTop;
            const scrollLeft = textarea.scrollLeft;

            // Position dropdown below cursor line
            let left = textareaRect.left + cursorPos.x - scrollLeft;
            let top = textareaRect.top + cursorPos.y - scrollTop + lineHeight + 4;

            // Dropdown dimensions
            const dropdownWidth = Math.min(350, Math.max(250, textareaRect.width - 20));
            const dropdownHeight = 300; // max-height

            // Adjust if goes off-screen horizontally
            if (left + dropdownWidth > window.innerWidth - 10) {
                left = window.innerWidth - dropdownWidth - 10;
            }
            if (left < 10) {
                left = 10;
            }

            // Adjust if goes off-screen vertically
            if (top + dropdownHeight > window.innerHeight - 10) {
                // Position above cursor instead
                top = textareaRect.top + cursorPos.y - scrollTop - dropdownHeight - 4;
            }
            if (top < 10) {
                top = 10;
            }

            dropdown.style.left = left + 'px';
            dropdown.style.top = top + 'px';
            dropdown.style.maxWidth = dropdownWidth + 'px';
        }

        // Insert tag at cursor position
        function insertTag(textarea, tagValue) {
            const { start, end, fullStart, fullEnd, word } = getCurrentWord(textarea);
            const value = textarea.value;

            // Transform tag based on provider
            // NAI V4/V4.5: Replace underscores with spaces (except emoticons like ^_^)
            // Local: Keep underscores (Danbooru format)
            let finalTag = tagValue;
            if (currentProvider === 'nai') {
                // Replace underscores with spaces, but preserve emoticons
                finalTag = tagValue.replace(/_/g, (match, offset, string) => {
                    // Check if it's part of an emoticon (preceded/followed by ^ or other emoticon chars)
                    const before = string[offset - 1];
                    const after = string[offset + 1];
                    if ((before === '^' || after === '^') ||
                        (before && after && /[><;:=]/.test(before + after))) {
                        return '_'; // Keep underscore in emoticons
                    }
                    return ' '; // Replace with space
                });
            }

            // Preserve leading spaces between comma and word
            const leadingSpaces = value.substring(fullStart, start);

            // Determine what comes after the tag
            let suffix = ', ';

            // Check if there's already a comma after the current word
            if (fullEnd < value.length && value[fullEnd] === ',') {
                suffix = ''; // Don't add comma if one already exists
                // But ensure space after comma
                if (fullEnd + 1 < value.length && value[fullEnd + 1] !== ' ') {
                    suffix = ' ';
                }
            }

            // Replace: keep everything before fullStart, add leading spaces + tag + suffix, then everything after end
            const before = value.substring(0, fullStart);
            const after = value.substring(end);
            const newValue = before + leadingSpaces + finalTag + suffix + after;

            textarea.value = newValue;

            // Set cursor position after inserted tag and suffix
            const newCursorPos = fullStart + leadingSpaces.length + finalTag.length + suffix.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);

            // Trigger input event for autosave
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            textarea.focus();
        }

        // Handle keyboard navigation in dropdown
        function handleAutocompleteKeyboard(e, dropdown) {
            if (!dropdown.classList.contains('show')) return false;

            const items = dropdown.querySelectorAll('.tag-autocomplete-item');
            if (items.length === 0) return false;

            let selectedIndex = dropdown._selectedIndex || 0;

            switch(e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, 0);
                    break;
                case 'Enter':
                    e.preventDefault();
                    const selectedItem = items[selectedIndex];
                    if (selectedItem) {
                        const tagValue = selectedItem.dataset.tagValue;
                        insertTag(dropdown._textarea, tagValue);
                        hideAutocomplete();
                    }
                    return true;
                case 'Escape':
                    e.preventDefault();
                    hideAutocomplete();
                    return true;
                default:
                    return false;
            }

            // Update selection
            items.forEach((item, i) => {
                item.classList.toggle('selected', i === selectedIndex);
            });
            dropdown._selectedIndex = selectedIndex;

            // Scroll selected item into view
            items[selectedIndex].scrollIntoView({ block: 'nearest' });

            return true;
        }

        // Setup tag autocomplete for a textarea
        function setupTagAutocomplete(textarea) {
            if (!textarea) {
                console.warn('[TagAutocomplete] setupTagAutocomplete called with null textarea');
                return;
            }
            if (textarea.dataset.autocompleteSetup) {
                console.log('[TagAutocomplete] Textarea already has autocomplete setup:', textarea.id || textarea.className);
                return;
            }
            console.log('[TagAutocomplete] Setting up autocomplete for:', textarea.id || textarea.className);
            textarea.dataset.autocompleteSetup = 'true';

            let inputTimeout = null;
            let lastValue = textarea.value;
            let isDeleting = false;

            // Input event - trigger autocomplete
            textarea.addEventListener('input', (e) => {
                console.log('[TagAutocomplete] Input event - enabled:', tagAutocompleteEnabled, 'loaded:', tagsLoaded);
                if (!tagAutocompleteEnabled || !tagsLoaded) return;
                
                // 포커스가 없거나 프로그래밍적 이벤트면 무시
                if (document.activeElement !== textarea || !e.isTrusted) {
                    hideAutocomplete();
                    return;
                }

                // Detect if user is deleting (backspace/delete)
                const currentValue = textarea.value;
                isDeleting = currentValue.length < lastValue.length;
                lastValue = currentValue;

                // Don't show autocomplete while deleting
                if (isDeleting) {
                    hideAutocomplete();
                    return;
                }

                // Debounce input
                if (inputTimeout) clearTimeout(inputTimeout);
                inputTimeout = setTimeout(() => {
                    // 연속 스페이스 2개 입력 시 자동완성 종료 체크
                    // (커서 앞 2글자가 모두 스페이스인지 확인)
                    const cursorPos = textarea.selectionStart;
                    if (cursorPos >= 2) {
                        const beforeCursor = textarea.value.substring(cursorPos - 2, cursorPos);
                        if (beforeCursor === '  ') {
                            hideAutocomplete();
                            return;
                        }
                    }

                    const { word } = getCurrentWord(textarea);

                    // 스페이스를 언더바로 치환하여 검색
                    const searchWord = word.replace(/ /g, '_');

                    if (searchWord.length >= 2) {
                        const results = searchTags(searchWord);
                        if (results.length > 0) {
                            showAutocomplete(textarea, results);
                        } else {
                            hideAutocomplete();
                        }
                    } else {
                        hideAutocomplete();
                    }
                }, 50);
            });

            // Keydown event - handle navigation
            textarea.addEventListener('keydown', (e) => {
                if (!tagAutocompleteEnabled || !tagsLoaded) return;

                const dropdown = getAutocompleteDropdown();
                if (handleAutocompleteKeyboard(e, dropdown)) {
                    // Event was handled by autocomplete
                    return;
                }
            });

            // Focus event - update lastValue
            textarea.addEventListener('focus', () => {
                lastValue = textarea.value;
            });

            // Blur event - hide dropdown
            textarea.addEventListener('blur', () => {
                // Delay to allow click on dropdown item
                setTimeout(() => {
                    const dropdown = getAutocompleteDropdown();
                    if (!dropdown.matches(':hover')) {
                        hideAutocomplete();
                    }
                }, 200);
            });
        }

        // Initialize tag autocomplete system
        console.log('[PeroPix] Initializing tag autocomplete system...');
        console.log('[PeroPix] tagAutocompleteEnabled initial value:', tagAutocompleteEnabled);
        loadTagData();

        // ============================================================
        // Settings Persistence (localStorage) - NAI/Local 완전 분리
        // ============================================================
        const SETTINGS_KEY = 'peropix_settings_v2';
        
        // Provider별 설정 저장소
        let naiSettings = {};
        let localSettings = {};
        
        // 현재 provider의 모든 설정을 객체로 수집
        function collectCurrentProviderSettings() {
            return {
                // Prompts
                basePrompt: document.getElementById('basePrompt').value,
                negativePrompt: document.getElementById('negativePrompt').value,
                characterPromptsLayout: getCharacterPromptsWithLayout(),
                
                // Size
                sizePreset: document.getElementById('sizePreset').value,
                width: document.getElementById('width').value,
                height: document.getElementById('height').value,
                
                // Generation
                steps: document.getElementById('steps').value,
                cfg: document.getElementById('cfg').value,
                sampler: document.getElementById('sampler').value,
                scheduler: document.getElementById('scheduler').value,
                seed: document.getElementById('seed').value,
                randomSeed: document.getElementById('randomSeed').checked,
                lockSeed: document.getElementById('lockSeed').checked,
                
                // Save Options
                saveFormat: document.getElementById('saveFormat').value,
                jpgQuality: document.getElementById('jpgQuality').value,
                stripMetadata: document.getElementById('stripMetadata').checked,
                
                // Output
                outputFolder: getOutputFolder(),
                repeatCount: document.getElementById('repeatCount').value,
                
                // Slots & Preset
                slots: getSlotList(),
                currentPreset: currentPreset,
                
                // NAI-specific (NAI일 때만 의미있음)
                naiModel: document.getElementById('naiModel').value,
                smea: document.getElementById('smea').value,
                ucPreset: document.getElementById('ucPreset').value,
                qualityTags: document.getElementById('qualityTags').checked,
                furryModeEnabled: furryModeEnabled,
                cfgRescale: document.getElementById('cfgRescale').value,
                varietyPlus: document.getElementById('varietyPlus').checked,
                enableVibeTransfer: document.getElementById('enableVibeTransfer').checked,
                vibeList: vibeList,
                enableCharRef: document.getElementById('enableCharRef').checked,
                charRefData: charRefData,
                charRefFidelity: document.getElementById('charRefFidelity').value,
                charRefStyleAware: document.getElementById('charRefStyleAware').checked,
                
                // Local-specific (Local일 때만 의미있음)
                localModel: document.getElementById('localModel').value,
                loraSlots: loraSlots,
                enableUpscale: document.getElementById('enableUpscale').checked,
                upscaleModel: document.getElementById('upscaleModel').value,
                downscaleRatio: document.getElementById('downscaleRatio').value,
                sizeAlignment: document.getElementById('sizeAlignment').value,
                upscaleSteps: document.getElementById('upscaleSteps').value,
                upscaleCfg: document.getElementById('upscaleCfg').value,
                upscaleDenoise: document.getElementById('upscaleDenoise').value,

                // Tag Autocomplete
                tagAutocompleteEnabled: tagAutocompleteEnabled,

                // Prompt Weight Highlighting
                promptHighlightEnabled: promptHighlightEnabled,
            };
        }
        
        // 설정을 UI에 적용
        function applyProviderSettings(settings, isFullRestore = false) {
            if (!settings || Object.keys(settings).length === 0) return;
            
            // Prompts
            if (settings.basePrompt !== undefined) document.getElementById('basePrompt').value = settings.basePrompt;
            if (settings.negativePrompt !== undefined) document.getElementById('negativePrompt').value = settings.negativePrompt;
            
            // Character prompts
            if (settings.characterPromptsLayout && settings.characterPromptsLayout.length > 0) {
                const charactersList = document.getElementById('charactersList');
                charactersList.innerHTML = '';
                settings.characterPromptsLayout.forEach(charData => {
                    const content = charData.content || '';
                    const collapsed = charData.collapsed || false;
                    const height = charData.height || null;
                    const enabled = charData.enabled !== false;
                    if (content.trim() || collapsed) {
                        const item = createCharacterItem(content, collapsed, enabled);
                        if (height) {
                            item.querySelector('textarea').style.height = height;
                        }
                        charactersList.appendChild(item);
                    }
                });
                updateCharacterNumbers();
            } else if (isFullRestore) {
                document.getElementById('charactersList').innerHTML = '';
            }
            
            // Size
            if (settings.sizePreset) document.getElementById('sizePreset').value = settings.sizePreset;
            if (settings.width) document.getElementById('width').value = settings.width;
            if (settings.height) document.getElementById('height').value = settings.height;
            
            // Generation - 샘플러/스케줄러는 provider에 따라 옵션이 다름
            if (settings.steps) document.getElementById('steps').value = settings.steps;
            if (settings.cfg) document.getElementById('cfg').value = settings.cfg;
            updateSamplerSchedulerOptions(currentProvider);
            if (settings.sampler) {
                const samplerSelect = document.getElementById('sampler');
                if ([...samplerSelect.options].some(o => o.value === settings.sampler)) {
                    samplerSelect.value = settings.sampler;
                }
            }
            if (settings.scheduler) {
                const schedulerSelect = document.getElementById('scheduler');
                if ([...schedulerSelect.options].some(o => o.value === settings.scheduler)) {
                    schedulerSelect.value = settings.scheduler;
                }
            }
            if (settings.seed !== undefined) document.getElementById('seed').value = settings.seed;
            if (settings.randomSeed !== undefined) document.getElementById('randomSeed').checked = settings.randomSeed;
            if (settings.lockSeed !== undefined) document.getElementById('lockSeed').checked = settings.lockSeed;
            
            // Save Options
            if (settings.saveFormat) document.getElementById('saveFormat').value = settings.saveFormat;
            if (settings.jpgQuality) document.getElementById('jpgQuality').value = settings.jpgQuality;
            if (settings.stripMetadata !== undefined) document.getElementById('stripMetadata').checked = settings.stripMetadata;
            
            // Output
            if (settings.outputFolder) setOutputFolder(settings.outputFolder);
            if (settings.repeatCount) document.getElementById('repeatCount').value = settings.repeatCount;
            
            // Slots - provider별로 분리됨
            if (settings.slots && settings.slots.length > 0) {
                slotsContainer.innerHTML = '';
                settings.slots.forEach(slot => {
                    addSlot(slot.name || '', slot.content || '');
                });
            } else if (isFullRestore) {
                // 슬롯이 없으면 빈 상태로 (기본 슬롯 1개)
                slotsContainer.innerHTML = '';
                addSlot('', '');
            }
            
            // Preset
            if (settings.currentPreset !== undefined) {
                currentPreset = settings.currentPreset;
                presetNameSpan.textContent = currentPreset?.name || 'Slot Set';
            }
            
            // NAI-specific
            if (currentProvider === 'nai') {
                if (settings.naiModel) document.getElementById('naiModel').value = settings.naiModel;
                if (settings.smea) document.getElementById('smea').value = settings.smea;
                if (settings.ucPreset) document.getElementById('ucPreset').value = settings.ucPreset;
                if (settings.qualityTags !== undefined) document.getElementById('qualityTags').checked = settings.qualityTags;
                if (settings.furryModeEnabled !== undefined) {
                    furryModeEnabled = settings.furryModeEnabled;
                    if (furryModeEnabled) {
                        modeToggle.textContent = '🐾';
                        modeToggle.title = '퍼리 모드';
                        modeToggle.classList.add('furry');
                    } else {
                        modeToggle.textContent = '🌸';
                        modeToggle.title = '일반 모드';
                        modeToggle.classList.remove('furry');
                    }
                }
                if (settings.cfgRescale !== undefined) {
                    document.getElementById('cfgRescale').value = settings.cfgRescale;
                    document.getElementById('cfgRescaleValue').textContent = settings.cfgRescale;
                }
                if (settings.varietyPlus !== undefined) document.getElementById('varietyPlus').checked = settings.varietyPlus;
                if (settings.enableVibeTransfer !== undefined) {
                    document.getElementById('enableVibeTransfer').checked = settings.enableVibeTransfer;
                    document.getElementById('vibeTransferSettings').style.display = settings.enableVibeTransfer ? 'block' : 'none';
                }
                if (settings.vibeList) {
                    vibeList = settings.vibeList;
                    renderVibeList();
                }
                if (settings.enableCharRef !== undefined) {
                    document.getElementById('enableCharRef').checked = settings.enableCharRef;
                    document.getElementById('charRefSettings').style.display = settings.enableCharRef ? 'block' : 'none';
                }
                if (settings.charRefData) {
                    charRefData = settings.charRefData;
                    document.getElementById('charRefImage').src = 'data:image/png;base64,' + charRefData.image;
                    document.getElementById('charRefPreview').style.display = 'block';
                    document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
                }
                if (settings.charRefFidelity !== undefined) {
                    document.getElementById('charRefFidelity').value = settings.charRefFidelity;
                    document.getElementById('charRefFidelityValue').textContent = settings.charRefFidelity;
                }
                if (settings.charRefStyleAware !== undefined) {
                    document.getElementById('charRefStyleAware').checked = settings.charRefStyleAware;
                }
            }
            
            // Local-specific
            if (currentProvider === 'local') {
                if (settings.localModel) {
                    window._pendingLocalModel = settings.localModel;
                }
                if (settings.loraSlots) {
                    loraSlots = settings.loraSlots;
                    renderLoraSlots();
                }
                if (settings.enableUpscale !== undefined) {
                    document.getElementById('enableUpscale').checked = settings.enableUpscale;
                    document.getElementById('upscaleSettings').style.display = settings.enableUpscale ? 'block' : 'none';
                }
                if (settings.upscaleModel) window._pendingUpscaleModel = settings.upscaleModel;
                if (settings.downscaleRatio) document.getElementById('downscaleRatio').value = settings.downscaleRatio;
                if (settings.sizeAlignment) document.getElementById('sizeAlignment').value = settings.sizeAlignment;
                if (settings.upscaleSteps) document.getElementById('upscaleSteps').value = settings.upscaleSteps;
                if (settings.upscaleCfg) document.getElementById('upscaleCfg').value = settings.upscaleCfg;
                if (settings.upscaleDenoise !== undefined) {
                    document.getElementById('upscaleDenoise').value = settings.upscaleDenoise;
                    document.getElementById('upscaleDenoiseValue').textContent = settings.upscaleDenoise;
                }
            }

            // Tag Autocomplete (기본값 true 유지)
            console.log('[PeroPix] applyProviderSettings - tagAutocompleteEnabled in settings:', settings.tagAutocompleteEnabled);
            if (settings.tagAutocompleteEnabled !== undefined) {
                tagAutocompleteEnabled = settings.tagAutocompleteEnabled;
                console.log('[PeroPix] applyProviderSettings - set to saved value:', tagAutocompleteEnabled);
            } else {
                // 설정이 없으면 기본값 true
                tagAutocompleteEnabled = true;
                console.log('[PeroPix] applyProviderSettings - using default value: true');
            }

            // Prompt Highlight (기본값 true 유지)
            if (settings.promptHighlightEnabled !== undefined) {
                promptHighlightEnabled = settings.promptHighlightEnabled;
            } else {
                promptHighlightEnabled = true;
            }

            // UI 토글 상태 업데이트
            const tagToggle = document.getElementById('tagAutocompleteToggle');
            if (tagToggle) tagToggle.checked = tagAutocompleteEnabled;

            const highlightToggle = document.getElementById('promptHighlightToggle');
            if (highlightToggle) highlightToggle.checked = promptHighlightEnabled;
        }
        
        function saveAppSettings() {
            // 현재 provider 설정 수집
            const currentSettings = collectCurrentProviderSettings();
            if (currentProvider === 'nai') {
                naiSettings = currentSettings;
            } else {
                localSettings = currentSettings;
            }
            
            const settings = {
                // 현재 provider
                provider: currentProvider,
                
                // Provider별 설정 (완전 분리)
                nai: naiSettings,
                local: localSettings,
                
                // UI 레이아웃 (공유)
                slotWidth: currentSlotWidth,
                sidebarWidth: currentSidebarWidth,
                basePromptHeight: document.getElementById('basePrompt').style.height || null,
                negativePromptHeight: document.getElementById('negativePrompt').style.height || null,
                basePromptCollapsed: document.getElementById('basePromptContent').classList.contains('collapsed'),
                charactersCollapsed: document.getElementById('charactersContent').classList.contains('collapsed'),
                negativePromptCollapsed: document.getElementById('negativePromptContent').classList.contains('collapsed'),
            };
            
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        }
        
        function loadAppSettings() {
            console.log('[PeroPix] loadAppSettings() called');
            console.log('[PeroPix] tagAutocompleteEnabled before loading:', tagAutocompleteEnabled);

            // 새 설정 키로 로드 시도
            let saved = localStorage.getItem(SETTINGS_KEY);
            let isLegacy = false;
            
            // 새 설정이 없으면 레거시 키 확인
            if (!saved) {
                saved = localStorage.getItem('nai_generator_settings');
                if (saved) {
                    isLegacy = true;
                    console.log('Legacy settings found, will migrate to new format');
                } else {
                    return; // 설정 없음
                }
            }
            
            try {
                const settings = JSON.parse(saved);
                
                // ============================================
                // 새 구조 (peropix_settings_v2) 로드
                // ============================================
                if (!isLegacy && settings.nai !== undefined) {
                    // Provider별 설정을 전역 변수에 저장
                    naiSettings = settings.nai || {};
                    localSettings = settings.local || {};
                    
                    // Provider 결정 (local은 설치 확인 후 적용)
                    if (settings.provider === 'local') {
                        window._pendingProvider = 'local';
                        currentProvider = 'nai'; // 일단 NAI로
                    } else {
                        currentProvider = settings.provider || 'nai';
                    }
                    
                    // UI 탭 활성화
                    tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === currentProvider));
                    providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === currentProvider));
                    
                    // UI 레이아웃 복원 (공유)
                    if (settings.slotWidth) setSlotWidth(settings.slotWidth);
                    if (settings.sidebarWidth) setSidebarWidth(settings.sidebarWidth);
                    if (settings.basePromptHeight) document.getElementById('basePrompt').style.height = settings.basePromptHeight;
                    if (settings.negativePromptHeight) document.getElementById('negativePrompt').style.height = settings.negativePromptHeight;
                    if (settings.basePromptCollapsed) {
                        document.getElementById('basePromptContent').classList.add('collapsed');
                        document.querySelector('[data-target="basePromptContent"]').classList.add('collapsed');
                    }
                    if (settings.charactersCollapsed) {
                        document.getElementById('charactersContent').classList.add('collapsed');
                        document.querySelector('[data-target="charactersContent"]').classList.add('collapsed');
                    }
                    if (settings.negativePromptCollapsed) {
                        document.getElementById('negativePromptContent').classList.add('collapsed');
                        document.querySelector('[data-target="negativePromptContent"]').classList.add('collapsed');
                    }
                    
                    // 현재 provider 설정 적용 (NAI로 시작)
                    const currentSettings = currentProvider === 'nai' ? naiSettings : localSettings;
                    
                    // Prompts
                    if (currentSettings.basePrompt !== undefined) document.getElementById('basePrompt').value = currentSettings.basePrompt;
                    if (currentSettings.negativePrompt !== undefined) document.getElementById('negativePrompt').value = currentSettings.negativePrompt;
                    
                    // Size
                    if (currentSettings.sizePreset) document.getElementById('sizePreset').value = currentSettings.sizePreset;
                    if (currentSettings.width) document.getElementById('width').value = currentSettings.width;
                    if (currentSettings.height) document.getElementById('height').value = currentSettings.height;
                    
                    // Generation - 샘플러/스케줄러는 옵션 로드 후 적용
                    if (currentSettings.steps) document.getElementById('steps').value = currentSettings.steps;
                    if (currentSettings.cfg) document.getElementById('cfg').value = currentSettings.cfg;
                    window._pendingSampler = currentSettings.sampler;
                    window._pendingScheduler = currentSettings.scheduler;
                    if (currentSettings.seed !== undefined) document.getElementById('seed').value = currentSettings.seed;
                    if (currentSettings.randomSeed !== undefined) document.getElementById('randomSeed').checked = currentSettings.randomSeed;
                    if (currentSettings.lockSeed !== undefined) document.getElementById('lockSeed').checked = currentSettings.lockSeed;
                    
                    // naiGenerationSettings / localGenerationSettings도 동기화
                    if (naiSettings.steps) {
                        naiGenerationSettings = {
                            steps: naiSettings.steps,
                            cfg: naiSettings.cfg,
                            sampler: naiSettings.sampler || 'k_euler_ancestral',
                            scheduler: naiSettings.scheduler || 'karras'
                        };
                    }
                    if (localSettings.steps) {
                        localGenerationSettings = {
                            steps: localSettings.steps,
                            cfg: localSettings.cfg,
                            sampler: localSettings.sampler || 'euler_ancestral',
                            scheduler: localSettings.scheduler || 'normal'
                        };
                    }
                    
                    // Save Options
                    if (currentSettings.saveFormat) document.getElementById('saveFormat').value = currentSettings.saveFormat;
                    if (currentSettings.jpgQuality) document.getElementById('jpgQuality').value = currentSettings.jpgQuality;
                    if (currentSettings.stripMetadata !== undefined) document.getElementById('stripMetadata').checked = currentSettings.stripMetadata;
                    
                    // Output
                    if (currentSettings.outputFolder !== undefined) setOutputFolder(currentSettings.outputFolder);
                    if (currentSettings.repeatCount) document.getElementById('repeatCount').value = currentSettings.repeatCount;
                    
                    // Slots - provider별로 분리됨
                    if (currentSettings.slots && currentSettings.slots.length > 0) {
                        slotsContainer.innerHTML = '';
                        currentSettings.slots.forEach(slot => {
                            addSlot(slot.name || '', slot.content || '');
                        });
                    }
                    
                    // Preset
                    if (currentSettings.currentPreset) {
                        currentPreset = currentSettings.currentPreset;
                        presetNameSpan.textContent = currentPreset.name || 'Slot Set';
                    }
                    
                    // Character prompts
                    if (currentSettings.characterPromptsLayout && currentSettings.characterPromptsLayout.length > 0) {
                        window._pendingCharacterPromptsLayout = currentSettings.characterPromptsLayout;
                    }
                    
                    // NAI-specific (시작 provider가 NAI일 때)
                    if (currentProvider === 'nai' && naiSettings) {
                        if (naiSettings.naiModel) document.getElementById('naiModel').value = naiSettings.naiModel;
                        if (naiSettings.smea) document.getElementById('smea').value = naiSettings.smea;
                        if (naiSettings.ucPreset) document.getElementById('ucPreset').value = naiSettings.ucPreset;
                        if (naiSettings.qualityTags !== undefined) document.getElementById('qualityTags').checked = naiSettings.qualityTags;
                        if (naiSettings.furryModeEnabled) {
                            furryModeEnabled = true;
                            modeToggle.textContent = '🐾';
                            modeToggle.title = '퍼리 모드';
                            modeToggle.classList.add('furry');
                        }
                        if (naiSettings.cfgRescale !== undefined) {
                            document.getElementById('cfgRescale').value = naiSettings.cfgRescale;
                            document.getElementById('cfgRescaleValue').textContent = naiSettings.cfgRescale;
                        }
                        if (naiSettings.varietyPlus !== undefined) document.getElementById('varietyPlus').checked = naiSettings.varietyPlus;
                        if (naiSettings.enableVibeTransfer !== undefined) {
                            document.getElementById('enableVibeTransfer').checked = naiSettings.enableVibeTransfer;
                            document.getElementById('vibeTransferSettings').style.display = naiSettings.enableVibeTransfer ? 'block' : 'none';
                        }
                        if (naiSettings.vibeList && naiSettings.vibeList.length > 0) {
                            vibeList = naiSettings.vibeList;
                            renderVibeList();
                        }
                        if (naiSettings.enableCharRef !== undefined) {
                            document.getElementById('enableCharRef').checked = naiSettings.enableCharRef;
                            document.getElementById('charRefSettings').style.display = naiSettings.enableCharRef ? 'block' : 'none';
                        }
                        if (naiSettings.charRefData) {
                            charRefData = naiSettings.charRefData;
                            document.getElementById('charRefImage').src = 'data:image/png;base64,' + charRefData.image;
                            document.getElementById('charRefPreview').style.display = 'block';
                            document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
                        }
                        if (naiSettings.charRefFidelity !== undefined) {
                            document.getElementById('charRefFidelity').value = naiSettings.charRefFidelity;
                            document.getElementById('charRefFidelityValue').textContent = naiSettings.charRefFidelity;
                        }
                        if (naiSettings.charRefStyleAware !== undefined) {
                            document.getElementById('charRefStyleAware').checked = naiSettings.charRefStyleAware;
                        }
                    }
                    
                    // Local-specific - 모델은 loadResources 후 적용
                    if (localSettings) {
                        window._pendingLocalModel = localSettings.localModel;
                        window._pendingUpscaleModel = localSettings.upscaleModel;
                        if (localSettings.loraSlots && localSettings.loraSlots.length > 0) {
                            loraSlots = localSettings.loraSlots;
                        }
                        if (localSettings.enableUpscale !== undefined) {
                            document.getElementById('enableUpscale').checked = localSettings.enableUpscale;
                            document.getElementById('upscaleSettings').style.display = localSettings.enableUpscale ? 'block' : 'none';
                        }
                        if (localSettings.downscaleRatio) document.getElementById('downscaleRatio').value = localSettings.downscaleRatio;
                        if (localSettings.sizeAlignment) document.getElementById('sizeAlignment').value = localSettings.sizeAlignment;
                        if (localSettings.upscaleSteps) document.getElementById('upscaleSteps').value = localSettings.upscaleSteps;
                        if (localSettings.upscaleCfg) document.getElementById('upscaleCfg').value = localSettings.upscaleCfg;
                        if (localSettings.upscaleDenoise !== undefined) {
                            document.getElementById('upscaleDenoise').value = localSettings.upscaleDenoise;
                            document.getElementById('upscaleDenoiseValue').textContent = localSettings.upscaleDenoise;
                        }
                    }
                    
                    return; // 새 구조 로드 완료
                }
                
                // ============================================
                // 레거시 구조 마이그레이션 (flat structure)
                // ============================================
                console.log('Migrating legacy settings...');
                
                // 레거시 설정을 NAI 설정으로 변환
                naiSettings = {
                    basePrompt: settings.basePrompt || '',
                    negativePrompt: settings.negativePrompt || '',
                    characterPromptsLayout: settings.characterPromptsLayout || 
                        (settings.characterPrompts ? settings.characterPrompts.map(c => ({ content: c, collapsed: false, height: null, enabled: true })) : []),
                    sizePreset: settings.sizePreset || 'custom',
                    width: settings.width || 832,
                    height: settings.height || 1216,
                    steps: settings.naiGeneration?.steps || settings.steps || 28,
                    cfg: settings.naiGeneration?.cfg || settings.cfg || 6,
                    sampler: settings.naiGeneration?.sampler || settings.sampler || 'k_euler_ancestral',
                    scheduler: settings.naiGeneration?.scheduler || settings.scheduler || 'karras',
                    seed: settings.seed || '',
                    randomSeed: settings.randomSeed !== false,
                    lockSeed: settings.lockSeed || false,
                    saveFormat: settings.saveFormat || 'png',
                    jpgQuality: settings.jpgQuality || 95,
                    stripMetadata: settings.stripMetadata || false,
                    outputFolder: settings.outputFolder || '',
                    repeatCount: settings.repeatCount || 1,
                    slots: settings.slots || [],
                    currentPreset: settings.currentPreset || null,
                    naiModel: settings.naiModel || 'nai-diffusion-4-5-curated',
                    smea: settings.smea || 'none',
                    ucPreset: settings.ucPreset || 'none',
                    qualityTags: settings.qualityTags !== false,
                    furryModeEnabled: settings.furryModeEnabled || false,
                    cfgRescale: settings.cfgRescale || 0,
                    varietyPlus: settings.varietyPlus || false,
                    enableVibeTransfer: settings.enableVibeTransfer || false,
                    vibeList: settings.vibeList || [],
                    enableCharRef: settings.enableCharRef || false,
                    charRefData: settings.charRefData || null,
                    charRefFidelity: settings.charRefFidelity || 1,
                    charRefStyleAware: settings.charRefStyleAware !== false,
                };
                
                // Local 설정 (레거시에서 가능한 것만)
                localSettings = {
                    basePrompt: '',
                    negativePrompt: '',
                    characterPromptsLayout: [],
                    sizePreset: 'custom',
                    width: 1024,
                    height: 1024,
                    steps: settings.localGeneration?.steps || 20,
                    cfg: settings.localGeneration?.cfg || 7,
                    sampler: settings.localGeneration?.sampler || 'euler_ancestral',
                    scheduler: settings.localGeneration?.scheduler || 'normal',
                    seed: '',
                    randomSeed: true,
                    lockSeed: false,
                    saveFormat: 'png',
                    jpgQuality: 95,
                    stripMetadata: false,
                    outputFolder: '',
                    repeatCount: 1,
                    slots: [],
                    currentPreset: null,
                    localModel: settings.localModel || '',
                    loraSlots: settings.loraSlots || [],
                    enableUpscale: settings.enableUpscale || false,
                    upscaleModel: settings.upscaleModel || '',
                    downscaleRatio: settings.downscaleRatio || 2,
                    sizeAlignment: settings.sizeAlignment || 64,
                    upscaleSteps: settings.upscaleSteps || 15,
                    upscaleCfg: settings.upscaleCfg || 6,
                    upscaleDenoise: settings.upscaleDenoise || 0.35,
                };
                
                // naiGenerationSettings / localGenerationSettings 동기화
                naiGenerationSettings = {
                    steps: naiSettings.steps,
                    cfg: naiSettings.cfg,
                    sampler: naiSettings.sampler,
                    scheduler: naiSettings.scheduler
                };
                localGenerationSettings = {
                    steps: localSettings.steps,
                    cfg: localSettings.cfg,
                    sampler: localSettings.sampler,
                    scheduler: localSettings.scheduler
                };
                
                // Provider (레거시는 항상 NAI)
                currentProvider = 'nai';
                if (settings.provider === 'local') {
                    window._pendingProvider = 'local';
                }
                tabs.forEach(t => t.classList.toggle('active', t.dataset.provider === currentProvider));
                providerSections.forEach(s => s.classList.toggle('active', s.dataset.provider === currentProvider));
                
                // NAI 설정을 UI에 적용
                document.getElementById('basePrompt').value = naiSettings.basePrompt;
                document.getElementById('negativePrompt').value = naiSettings.negativePrompt;
                document.getElementById('sizePreset').value = naiSettings.sizePreset;
                document.getElementById('width').value = naiSettings.width;
                document.getElementById('height').value = naiSettings.height;
                document.getElementById('steps').value = naiSettings.steps;
                document.getElementById('cfg').value = naiSettings.cfg;
                window._pendingSampler = naiSettings.sampler;
                window._pendingScheduler = naiSettings.scheduler;
                if (naiSettings.seed) document.getElementById('seed').value = naiSettings.seed;
                document.getElementById('randomSeed').checked = naiSettings.randomSeed;
                document.getElementById('lockSeed').checked = naiSettings.lockSeed;
                document.getElementById('saveFormat').value = naiSettings.saveFormat;
                document.getElementById('jpgQuality').value = naiSettings.jpgQuality;
                document.getElementById('stripMetadata').checked = naiSettings.stripMetadata;
                if (naiSettings.outputFolder) setOutputFolder(naiSettings.outputFolder);
                document.getElementById('repeatCount').value = naiSettings.repeatCount;
                
                // Slots
                if (naiSettings.slots && naiSettings.slots.length > 0) {
                    slotsContainer.innerHTML = '';
                    naiSettings.slots.forEach(slot => {
                        addSlot(slot.name || '', slot.content || '');
                    });
                }
                
                // Preset
                if (naiSettings.currentPreset) {
                    currentPreset = naiSettings.currentPreset;
                    presetNameSpan.textContent = currentPreset.name || 'Slot Set';
                }
                
                // Character prompts
                if (naiSettings.characterPromptsLayout && naiSettings.characterPromptsLayout.length > 0) {
                    window._pendingCharacterPromptsLayout = naiSettings.characterPromptsLayout;
                }
                
                // NAI-specific
                document.getElementById('naiModel').value = naiSettings.naiModel;
                document.getElementById('smea').value = naiSettings.smea;
                document.getElementById('ucPreset').value = naiSettings.ucPreset;
                document.getElementById('qualityTags').checked = naiSettings.qualityTags;
                if (naiSettings.furryModeEnabled) {
                    furryModeEnabled = true;
                    modeToggle.textContent = '🐾';
                    modeToggle.title = '퍼리 모드';
                    modeToggle.classList.add('furry');
                }
                document.getElementById('cfgRescale').value = naiSettings.cfgRescale;
                document.getElementById('cfgRescaleValue').textContent = naiSettings.cfgRescale;
                document.getElementById('varietyPlus').checked = naiSettings.varietyPlus;
                document.getElementById('enableVibeTransfer').checked = naiSettings.enableVibeTransfer;
                document.getElementById('vibeTransferSettings').style.display = naiSettings.enableVibeTransfer ? 'block' : 'none';
                if (naiSettings.vibeList && naiSettings.vibeList.length > 0) {
                    vibeList = naiSettings.vibeList;
                    renderVibeList();
                }
                document.getElementById('enableCharRef').checked = naiSettings.enableCharRef;
                document.getElementById('charRefSettings').style.display = naiSettings.enableCharRef ? 'block' : 'none';
                if (naiSettings.charRefData) {
                    charRefData = naiSettings.charRefData;
                    document.getElementById('charRefImage').src = 'data:image/png;base64,' + charRefData.image;
                    document.getElementById('charRefPreview').style.display = 'block';
                    document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
                }
                document.getElementById('charRefFidelity').value = naiSettings.charRefFidelity;
                document.getElementById('charRefFidelityValue').textContent = naiSettings.charRefFidelity;
                document.getElementById('charRefStyleAware').checked = naiSettings.charRefStyleAware;
                
                // Local-specific
                window._pendingLocalModel = localSettings.localModel;
                window._pendingUpscaleModel = localSettings.upscaleModel;
                if (localSettings.loraSlots && localSettings.loraSlots.length > 0) {
                    loraSlots = localSettings.loraSlots;
                }
                document.getElementById('enableUpscale').checked = localSettings.enableUpscale;
                document.getElementById('upscaleSettings').style.display = localSettings.enableUpscale ? 'block' : 'none';
                document.getElementById('downscaleRatio').value = localSettings.downscaleRatio;
                document.getElementById('sizeAlignment').value = localSettings.sizeAlignment;
                document.getElementById('upscaleSteps').value = localSettings.upscaleSteps;
                document.getElementById('upscaleCfg').value = localSettings.upscaleCfg;
                document.getElementById('upscaleDenoise').value = localSettings.upscaleDenoise;
                document.getElementById('upscaleDenoiseValue').textContent = localSettings.upscaleDenoise;
                
                // UI 레이아웃 (공유)
                if (settings.slotWidth) setSlotWidth(settings.slotWidth);
                if (settings.sidebarWidth) setSidebarWidth(settings.sidebarWidth);
                if (settings.basePromptHeight) document.getElementById('basePrompt').style.height = settings.basePromptHeight;
                if (settings.negativePromptHeight) document.getElementById('negativePrompt').style.height = settings.negativePromptHeight;
                if (settings.basePromptCollapsed) {
                    document.getElementById('basePromptContent').classList.add('collapsed');
                    document.querySelector('[data-target="basePromptContent"]').classList.add('collapsed');
                }
                if (settings.charactersCollapsed) {
                    document.getElementById('charactersContent').classList.add('collapsed');
                    document.querySelector('[data-target="charactersContent"]').classList.add('collapsed');
                }
                if (settings.negativePromptCollapsed) {
                    document.getElementById('negativePromptContent').classList.add('collapsed');
                    document.querySelector('[data-target="negativePromptContent"]').classList.add('collapsed');
                }
                
                // 레거시 키 삭제하고 새 형식으로 저장
                localStorage.removeItem('nai_generator_settings');
                saveAppSettings();
                console.log('Legacy settings migrated successfully');
                
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
        }
        
        // 설정 변경 시 자동 저장 (debounce)
        let saveTimeout = null;
        function autoSaveSettings() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveAppSettings, 500);
        }
        
        // 주요 입력 요소에 자동 저장 연결
        function setupAutoSave() {
            const inputs = [
                'basePrompt', 'negativePrompt', 'width', 'height', 'steps', 'cfg',
                'sampler', 'scheduler', 'seed', 'randomSeed', 'naiModel', 'smea',
                'ucPreset', 'qualityTags', 'localModel', 'enableUpscale', 'upscaleModel',
                'downscaleRatio', 'sizeAlignment', 'upscaleSteps', 'upscaleCfg',
                'upscaleDenoise', 'repeatCount', 'sizePreset',
                'cfgRescale', 'varietyPlus', 'lockSeed',
                'saveFormat', 'jpgQuality', 'stripMetadata'
            ];
            
            inputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', autoSaveSettings);
                    if (el.tagName === 'TEXTAREA' || el.type === 'text' || el.type === 'number') {
                        el.addEventListener('input', autoSaveSettings);
                    }
                }
            });
            
            // 슬롯 변경 감지
            slotsContainer.addEventListener('input', autoSaveSettings);
            slotsContainer.addEventListener('change', autoSaveSettings);

            // 캐릭터 프롬프트 변경 감지
            charactersList.addEventListener('input', autoSaveSettings);
            charactersList.addEventListener('change', autoSaveSettings);

            // 프롬프트 창 리사이즈 감지
            const resizeObserver = new ResizeObserver(() => autoSaveSettings());
            resizeObserver.observe(document.getElementById('basePrompt'));
            resizeObserver.observe(document.getElementById('negativePrompt'));

            // Tag autocomplete toggle
            const tagAutocompleteToggle = document.getElementById('tagAutocompleteToggle');
            if (tagAutocompleteToggle) {
                tagAutocompleteToggle.addEventListener('change', () => {
                    tagAutocompleteEnabled = tagAutocompleteToggle.checked;
                    autoSaveSettings();
                });
            }

            // Prompt highlight toggle
            const promptHighlightToggle = document.getElementById('promptHighlightToggle');
            if (promptHighlightToggle) {
                promptHighlightToggle.addEventListener('change', () => {
                    promptHighlightEnabled = promptHighlightToggle.checked;
                    autoSaveSettings();

                    // 모든 프롬프트 필드 다시 렌더링
                    document.querySelectorAll('.prompt-highlight-overlay').forEach(overlay => {
                        const container = overlay.parentElement;
                        const textarea = container.querySelector('textarea');
                        if (textarea) {
                            highlightPrompt(textarea, overlay);
                        }
                    });
                });
            }
        }
        
        // Init
        loadAppSettings();  // 저장된 설정 먼저 로드
        console.log('[PeroPix] After loadAppSettings, tagAutocompleteEnabled:', tagAutocompleteEnabled);
        loadSlotSizePresets();  // 슬롯 사이즈 프리셋 로드

        // Setup tag autocomplete for base prompts
        console.log('[PeroPix] Setting up tag autocomplete for base prompts...');
        setupTagAutocomplete(document.getElementById('basePrompt'));
        setupTagAutocomplete(document.getElementById('negativePrompt'));

        // Setup prompt weight highlighting for base prompts
        console.log('[PeroPix] Setting up prompt weight highlighting...');
        setupPromptHighlighting(document.getElementById('basePrompt'));
        setupPromptHighlighting(document.getElementById('negativePrompt'));

        // 현재 provider에 맞게 샘플러/스케줄러 옵션 설정 및 복원
        updateSamplerSchedulerOptions(currentProvider);

        // Anlas 정보 초기화 (NAI인 경우)
        updateAnlasVisibility();
        if (window._pendingSampler) {
            const samplerSelect = document.getElementById('sampler');
            // 현재 옵션에 있는 값만 복원
            if ([...samplerSelect.options].some(o => o.value === window._pendingSampler)) {
                samplerSelect.value = window._pendingSampler;
                window._pendingSampler = null;
            }
            // 없으면 pending 유지 (local 전환 시 복원)
        }
        if (window._pendingScheduler) {
            const schedulerSelect = document.getElementById('scheduler');
            if ([...schedulerSelect.options].some(o => o.value === window._pendingScheduler)) {
                schedulerSelect.value = window._pendingScheduler;
                window._pendingScheduler = null;
            }
        }
        
        loadResources().then(() => {
            // 모델 선택 복원 (loadResources 완료 후)
            if (window._pendingLocalModel) {
                document.getElementById('localModel').value = window._pendingLocalModel;
            }
            if (window._pendingUpscaleModel) {
                document.getElementById('upscaleModel').value = window._pendingUpscaleModel;
            }
            // 캐릭터 프롬프트 복원 (레이아웃 포함)
            if (window._pendingCharacterPromptsLayout) {
                window._pendingCharacterPromptsLayout.forEach(charData => {
                    const content = charData.content || '';
                    const collapsed = charData.collapsed || false;
                    const height = charData.height || null;
                    const enabled = charData.enabled !== false;  // 기본값 true (하위 호환)
                    if (content.trim() || collapsed) {
                        const item = createCharacterItem(content, collapsed, enabled);
                        if (height) {
                            item.querySelector('textarea').style.height = height;
                        }
                        charactersList.appendChild(item);
                    }
                });
                updateCharacterNumbers();
                window._pendingCharacterPromptsLayout = null;
            }

            // 모든 복원 완료 후 자동 저장 설정
            setupAutoSave();
        });
        connectWebSocket();
        checkLocalEnvStatus();
        
        // 슬롯이 없으면 하나 추가
        if (slotsContainer.children.length === 0) {
            addSlot();
        }
        
        // 시드가 비어있으면 랜덤 생성
        if (!document.getElementById('seed').value) {
            document.getElementById('seed').value = Math.floor(Math.random() * 2147483647);
        }
        
        // 초기 그라데이션 업데이트
        setTimeout(updateScrollGradients, 100);
        
        // 페이지 떠날 때 저장 및 경고
        window.addEventListener('beforeunload', (e) => {
            saveAppSettings();
            // 브라우저 기본 확인 팝업 표시
            e.preventDefault();
            e.returnValue = '';
        });

        // ============================================================
        // Gallery Mode
        // ============================================================
        const slotModeBtn = document.getElementById('slotModeBtn');
        const galleryModeBtn = document.getElementById('galleryModeBtn');
        const censorModeBtn = document.getElementById('censorModeBtn');
        const slotsToolbar = document.getElementById('slotsToolbar');
        const galleryContainer = document.getElementById('galleryContainer');
        const censorContainer = document.getElementById('censorContainer');
        const galleryGrid = document.getElementById('galleryGrid');
        const galleryEmpty = document.getElementById('galleryEmpty');
        const gallerySubfolders = document.getElementById('gallerySubfolders');
        const galleryRootBtn = document.getElementById('galleryRootBtn');

        let currentMode = 'slot'; // 'slot' | 'gallery' | 'censor'
        let currentGalleryFolder = ''; // 현재 선택된 폴더 (빈 문자열 = gallery 루트)
        let isVibeMode = false; // vibe cache mode

        slotModeBtn.onclick = () => {
            if (currentMode === 'slot') return;
            currentMode = 'slot';
            slotModeBtn.classList.add('active');
            galleryModeBtn.classList.remove('active');
            censorModeBtn.classList.remove('active');
            slotsToolbar.style.display = 'flex';
            slotsWrapper.style.display = 'flex';
            galleryContainer.style.display = 'none';
            censorContainer.style.display = 'none';
        };

        galleryModeBtn.onclick = () => {
            if (currentMode === 'gallery') return;
            currentMode = 'gallery';
            galleryModeBtn.classList.add('active');
            slotModeBtn.classList.remove('active');
            censorModeBtn.classList.remove('active');
            slotsToolbar.style.display = 'none';
            slotsWrapper.style.display = 'none';
            galleryContainer.style.display = 'flex';
            censorContainer.style.display = 'none';

            // 갤러리가 이미 로드되어 있으면 스킵 (폴더는 첫 진입 시 로드됨)
            if (!window.galleryInitialized) {
                loadGalleryFolders();
                loadGallery(currentGalleryFolder);
                window.galleryInitialized = true;
            }
        };

        censorModeBtn.onclick = async () => {
            if (currentMode === 'censor') return;

            currentMode = 'censor';
            censorModeBtn.classList.add('active');
            slotModeBtn.classList.remove('active');
            galleryModeBtn.classList.remove('active');
            slotsToolbar.style.display = 'none';
            slotsWrapper.style.display = 'none';
            galleryContainer.style.display = 'none';
            censorContainer.style.display = 'flex';

            // 검열 모드 초기화 (내부에서 캐싱 처리)
            if (typeof initCensorMode === 'function') {
                await initCensorMode();
            }
        };

        // 갤러리 폴더 열기 (현재 선택된 폴더)
        document.getElementById('openGalleryFolderBtn').onclick = async () => {
            try {
                const response = await fetch(`${API_BASE}/api/gallery/open-folder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder: currentGalleryFolder })
                });
                const result = await response.json();
                if (!result.success) {
                    showToast('폴더 열기 실패', 'error');
                }
            } catch (err) {
                showToast('폴더 열기 오류', 'error');
            }
        };

        // 새 폴더 생성
        document.getElementById('addFolderBtn').onclick = () => {
            showInputModal('📁 새 폴더', '폴더 이름을 입력하세요', async (folderName) => {
                try {
                    const response = await fetch(`${API_BASE}/api/gallery/folders`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: folderName })
                    });
                    const result = await response.json();
                    if (result.success) {
                        showToast('폴더 생성됨', 'success');
                        loadGalleryFolders();
                    } else {
                        showToast('폴더 생성 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('폴더 생성 오류: ' + err.message, 'error');
                }
            }, '생성');
        };

        // 폴더 아이콘 업데이트 (📂 선택됨 / 📁 미선택)
        function updateFolderIcons() {
            const vibeCacheBtn = document.getElementById('vibeCacheBtn');

            // vibe 폴더
            vibeCacheBtn.classList.toggle('active', isVibeMode);

            // 루트 폴더
            const isRootActive = !isVibeMode && currentGalleryFolder === '';
            galleryRootBtn.textContent = `${isRootActive ? '📂' : '📁'} gallery`;
            galleryRootBtn.classList.toggle('active', isRootActive);

            // 하위 폴더들
            gallerySubfolders.querySelectorAll('.folder-tab').forEach(tab => {
                const isActive = !isVibeMode && tab.dataset.folder === currentGalleryFolder;
                const folderName = tab.dataset.folder;
                const count = tab.dataset.count || '';
                tab.textContent = `${isActive ? '📂' : '📁'} ${folderName}${count ? ` (${count})` : ''}`;
                tab.classList.toggle('active', isActive);
            });
        }

        // 폴더 목록 로드
        async function loadGalleryFolders() {
            try {
                const response = await fetch(`${API_BASE}/api/gallery/folders`);
                const result = await response.json();

                // 기존 하위 폴더 탭 제거
                gallerySubfolders.innerHTML = '';

                if (result.success && result.folders) {
                    result.folders.forEach(folder => {
                        const tab = document.createElement('button');
                        tab.type = 'button';
                        tab.className = 'folder-tab';
                        tab.dataset.folder = folder.name;
                        tab.dataset.count = folder.image_count;
                        tab.title = `${folder.image_count}개 이미지`;
                        setupFolderTab(tab);
                        gallerySubfolders.appendChild(tab);
                    });
                }

                // 루트 폴더 탭 이벤트 설정
                setupFolderTab(galleryRootBtn);

                // 아이콘 상태 업데이트
                updateFolderIcons();
            } catch (err) {
                console.error('폴더 목록 로드 실패:', err);
            }
        }

        // Vibe 캐시 버튼 클릭
        document.getElementById('vibeCacheBtn').onclick = () => {
            if (isVibeMode) return;
            isVibeMode = true;
            updateFolderIcons();
            loadVibeCache();
        };

        // 폴더 탭 이벤트 설정
        function setupFolderTab(tab) {
            tab.onclick = () => {
                if (!isVibeMode && tab.dataset.folder === currentGalleryFolder) return;
                isVibeMode = false;  // Exit vibe mode when clicking gallery folders
                currentGalleryFolder = tab.dataset.folder;
                updateFolderIcons();
                loadGallery(currentGalleryFolder);
            };

            // 드래그 오버 이벤트 (이미지를 폴더로 이동할 때)
            tab.ondragover = (e) => {
                e.preventDefault();
                tab.classList.add('drag-over');
            };
            tab.ondragleave = () => {
                tab.classList.remove('drag-over');
            };
            tab.ondrop = async (e) => {
                e.preventDefault();
                tab.classList.remove('drag-over');
                const filename = e.dataTransfer.getData('text/plain');
                const fromFolder = e.dataTransfer.getData('application/x-gallery-folder');
                const toFolder = tab.dataset.folder;

                if (!filename || fromFolder === toFolder) return;

                try {
                    const response = await fetch(`${API_BASE}/api/gallery/${encodeURIComponent(filename)}/move`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ from_folder: fromFolder, to_folder: toFolder })
                    });
                    const result = await response.json();
                    if (result.success) {
                        showToast('이미지 이동됨', 'success');
                        loadGallery(currentGalleryFolder);
                        loadGalleryFolders();
                    } else {
                        showToast('이동 실패: ' + result.error, 'error');
                    }
                } catch (err) {
                    showToast('이동 오류: ' + err.message, 'error');
                }
            };
        }

        let galleryLoaded = false;

        async function loadGallery(folder = '') {
            // 바이브 모드면 갤러리 로드 안함
            if (isVibeMode) return;

            // 로딩 중 표시
            galleryGrid.style.display = 'none';
            galleryEmpty.innerHTML = `
                <div class="icon">⏳</div>
                <p>갤러리 로딩 중...</p>
            `;
            galleryEmpty.style.display = 'flex';

            try {
                const response = await fetch(`${API_BASE}/api/gallery?folder=${encodeURIComponent(folder)}`);
                const result = await response.json();

                // 로딩 중에 바이브 모드로 전환되었으면 렌더링 안함
                if (isVibeMode) return;

                if (result.images && result.images.length > 0) {
                    galleryEmpty.style.display = 'none';
                    galleryGrid.style.display = 'grid';
                    renderGallery(result.images, folder);
                } else {
                    galleryEmpty.innerHTML = `
                        <div class="icon">🖼️</div>
                        <p>${folder ? `'${folder}' 폴더가` : '갤러리가'} 비어있습니다</p>
                        <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                    `;
                    galleryEmpty.style.display = 'flex';
                    galleryGrid.style.display = 'none';
                    galleryGrid.innerHTML = '';
                }
                galleryLoaded = true;
            } catch (err) {
                galleryEmpty.innerHTML = `
                    <div class="icon">❌</div>
                    <p>갤러리 로드 실패</p>
                    <small>${err.message}</small>
                `;
                showToast('갤러리 로드 실패: ' + err.message, 'error');
            }
        }

        function renderGallery(images, folder = '') {
            galleryGrid.innerHTML = '';

            images.forEach(img => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                item._filename = img.filename;
                item._folder = folder;
                item.draggable = true;
                item.innerHTML = `
                    <img src="data:image/png;base64,${img.thumbnail}" alt="">
                    <div class="gallery-item-info">
                        <div class="filename-row">
                            <span class="filename" title="${img.filename}">${img.filename.replace('.png', '')}</span>
                            <button class="rename-btn" title="이름 변경">✏️</button>
                        </div>
                        <div class="seed">${img.seed ? 'Seed: ' + img.seed : '메타데이터 없음'}</div>
                    </div>
                    <div class="gallery-item-actions">
                        <button class="inpaint-btn" title="인페인트">🎨 Inpaint</button>
                        <button class="copy-seed-btn" title="시드 복사">🎲 Seed</button>
                        <button class="apply-all-btn" title="전체 설정 적용">📋 Apply</button>
                        <button class="delete-btn" title="삭제">🗑️</button>
                    </div>
                `;

                // 드래그 시작 (폴더 이동용)
                item.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', item._filename);
                    e.dataTransfer.setData('application/x-gallery-folder', item._folder);
                    e.dataTransfer.effectAllowed = 'move';

                    // 커스텀 드래그 고스트 생성
                    const ghost = document.createElement('div');
                    ghost.id = 'dragGhost';
                    ghost.style.cssText = 'position: fixed; top: -100px; left: -100px; width: 60px; height: 60px; background: var(--accent); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: none; z-index: 10000;';
                    ghost.textContent = '📁';
                    document.body.appendChild(ghost);
                    e.dataTransfer.setDragImage(ghost, 30, 30);

                    item.classList.add('dragging');
                };
                item.ondragend = () => {
                    item.classList.remove('dragging');
                    // 드래그 고스트 제거
                    const ghost = document.getElementById('dragGhost');
                    if (ghost) ghost.remove();
                };

                // 이미지 자체의 기본 드래그 동작 방지 (부모 item의 드래그로 대체)
                const imgEl = item.querySelector('img');
                if (imgEl) {
                    imgEl.draggable = false;
                }

                // 라이트박스 표시 함수
                const folderQuery = folder ? `?folder=${encodeURIComponent(folder)}` : '';
                const showLightbox = async () => {
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success) {
                            lightboxImg.src = 'data:image/png;base64,' + result.image;
                            lightboxCurrentGalleryItem = item;  // 휠 네비게이션용
                            lightbox.classList.add('active');
                        }
                    } catch (err) {
                        showToast('이미지 로드 실패', 'error');
                    }
                };

                // 카드 클릭 - 라이트박스 (버튼 제외)
                item.onclick = (e) => {
                    // 버튼이나 입력 필드 클릭시 무시
                    if (e.target.closest('.gallery-item-actions') || e.target.closest('.rename-btn') || e.target.tagName === 'INPUT') {
                        return;
                    }
                    showLightbox();
                };

                // 이름 변경
                item.querySelector('.rename-btn').onclick = (e) => {
                    e.stopPropagation();
                    const filenameRow = item.querySelector('.filename-row');
                    const filenameSpan = item.querySelector('.filename');
                    const currentName = item._filename.replace('.png', '');

                    // 입력 필드로 교체
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'filename-input';
                    input.value = currentName;

                    filenameSpan.style.display = 'none';
                    filenameRow.insertBefore(input, filenameRow.querySelector('.rename-btn'));
                    input.focus();
                    input.select();

                    const saveRename = async () => {
                        const newName = input.value.trim();
                        if (!newName || newName === currentName) {
                            // 취소
                            input.remove();
                            filenameSpan.style.display = '';
                            return;
                        }

                        try {
                            const response = await fetch(`${API_BASE}/api/gallery/${item._filename}`, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ new_name: newName, folder: item._folder })
                            });
                            const result = await response.json();
                            if (result.success) {
                                item._filename = result.new_filename;
                                filenameSpan.textContent = newName;
                                filenameSpan.title = result.new_filename;
                                showToast('이름 변경됨', 'success');
                            } else {
                                showToast(result.error || '이름 변경 실패', 'error');
                            }
                        } catch (err) {
                            showToast('이름 변경 오류', 'error');
                        }

                        input.remove();
                        filenameSpan.style.display = '';
                    };

                    input.onblur = saveRename;
                    input.onkeydown = (ke) => {
                        if (ke.key === 'Enter') {
                            ke.preventDefault();
                            input.blur();
                        } else if (ke.key === 'Escape') {
                            input.value = currentName;
                            input.blur();
                        }
                    };
                };

                // 시드 적용 (확인 팝업)
                item.querySelector('.copy-seed-btn').onclick = async (e) => {
                    e.stopPropagation();
                    if (img.seed) {
                        showConfirmModal(
                            '🎲 시드 적용',
                            `<p>이 시드를 적용하시겠습니까?</p><div class="metadata" style="font-size: 0.9rem; margin-top: 8px;"><strong>Seed:</strong> ${img.seed}</div>`,
                            async () => {
                                document.getElementById('seed').value = img.seed;
                                await navigator.clipboard.writeText(String(img.seed));
                                showToast('시드 적용 및 복사됨', 'success');
                            },
                            '적용'
                        );
                    } else {
                        showToast('시드 정보 없음', 'warning');
                    }
                };

                // 전체 설정 적용 (확인 팝업)
                item.querySelector('.apply-all-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success && result.metadata) {
                            // showLoadSettingsConfirm 내부에서 normalizeMetadata 호출
                            showLoadSettingsConfirm(result.metadata);
                        } else {
                            showToast('메타데이터 없음', 'warning');
                        }
                    } catch (err) {
                        showToast('적용 실패: ' + err.message, 'error');
                    }
                };

                // 인페인트
                item.querySelector('.inpaint-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`);
                        const result = await response.json();
                        if (result.success && result.image) {
                            setBaseImageForInpaint(result.image);
                            showToast('인페인트 모드로 전환', 'success');
                        } else {
                            showToast('이미지 로드 실패', 'error');
                        }
                    } catch (err) {
                        showToast('인페인트 오류: ' + err.message, 'error');
                    }
                };

                // 삭제
                item.querySelector('.delete-btn').onclick = async (e) => {
                    e.stopPropagation();
                    showConfirmModal(
                        '🗑️ 이미지 삭제',
                        '<p>이 이미지를 갤러리에서 삭제하시겠습니까?</p>',
                        async () => {
                            try {
                                const response = await fetch(`${API_BASE}/api/gallery/${item._filename}${folderQuery}`, {
                                    method: 'DELETE'
                                });
                                const result = await response.json();
                                if (result.success) {
                                    item.remove();
                                    showToast('삭제됨', 'success');
                                    // 갤러리가 비었는지 확인
                                    if (galleryGrid.children.length === 0) {
                                        galleryEmpty.innerHTML = `
                                            <div class="icon">🖼️</div>
                                            <p>갤러리가 비어있습니다</p>
                                            <small>이미지에서 ⭐ 버튼을 눌러 갤러리에 저장하세요</small>
                                        `;
                                        galleryEmpty.style.display = 'flex';
                                        galleryGrid.style.display = 'none';
                                    }
                                } else {
                                    showToast('삭제 실패', 'error');
                                }
                            } catch (err) {
                                showToast('삭제 오류: ' + err.message, 'error');
                            }
                        },
                        '삭제',
                        true
                    );
                };

                galleryGrid.appendChild(item);
            });
        }

        // ============================================================
        // Vibe Cache Loading
        // ============================================================
        async function loadVibeCache() {
            // 로딩 중 표시
            galleryGrid.style.display = 'none';
            galleryEmpty.innerHTML = `
                <div class="icon">⏳</div>
                <p>바이브 캐시 로딩 중...</p>
            `;
            galleryEmpty.style.display = 'flex';

            try {
                const response = await fetch(`${API_BASE}/api/vibe-cache`);
                const result = await response.json();

                if (result.vibes && result.vibes.length > 0) {
                    galleryEmpty.style.display = 'none';
                    galleryGrid.style.display = 'grid';
                    renderVibeCache(result.vibes);
                } else {
                    galleryEmpty.innerHTML = `
                        <div class="icon">🎨</div>
                        <p>바이브 캐시가 비어있습니다</p>
                        <small>이미지 생성 시 바이브가 자동으로 캐시됩니다</small>
                    `;
                    galleryEmpty.style.display = 'flex';
                    galleryGrid.style.display = 'none';
                    galleryGrid.innerHTML = '';
                }
            } catch (err) {
                galleryEmpty.innerHTML = `
                    <div class="icon">❌</div>
                    <p>바이브 캐시 로드 실패</p>
                    <small>${err.message}</small>
                `;
                showToast('바이브 캐시 로드 실패: ' + err.message, 'error');
            }
        }

        function renderVibeCache(vibes) {
            galleryGrid.innerHTML = '';

            vibes.forEach(vibe => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                item._filename = vibe.filename;
                item._isVibe = true;  // 바이브 캐시 아이템 마커
                item._thumbnail = vibe.thumbnail;  // 휠 네비게이션용
                item.draggable = false;  // Vibe items are not draggable

                // 파일명에서 이름 추출 (예: name_0.6_1.0_0000001.png → name)
                const displayName = vibe.filename.replace(/\.png$/i, '').replace(/_[\d.]+_[\d.]+_\d+$/, '');

                item.innerHTML = `
                    <img src="data:image/png;base64,${vibe.thumbnail}" alt="">
                    <div class="gallery-item-info">
                        <div class="filename-row">
                            <span class="filename" title="${vibe.filename}">${displayName}</span>
                        </div>
                        <div class="seed">S:${vibe.strength} IE:${vibe.info_extracted}</div>
                    </div>
                    <div class="gallery-item-actions">
                        <button class="apply-vibe-btn" title="바이브 적용">🎨 Vibe</button>
                        <button class="delete-btn" title="삭제">🗑️</button>
                    </div>
                `;

                // 이미지 클릭 시 라이트박스
                const imgEl = item.querySelector('img');
                imgEl.onclick = () => {
                    lightboxImg.src = `data:image/png;base64,${vibe.thumbnail}`;
                    lightboxCurrentGalleryItem = item;  // 휠 네비게이션용
                    lightbox.classList.add('active');
                };

                // 바이브 적용 버튼
                item.querySelector('.apply-vibe-btn').onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch(`${API_BASE}/api/vibe-cache/${vibe.filename}`);
                        const result = await response.json();
                        if (result.success && result.vibe_data) {
                            // vibeList에 추가
                            if (vibeList.length >= 16) {
                                showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                                return;
                            }

                            vibeList.push({
                                image: result.image,
                                strength: result.strength,
                                info_extracted: result.info_extracted,
                                name: displayName,
                                encoded: result.vibe_data,  // Pre-encoded vibe data
                                encoded_model: result.model,  // Model used for encoding
                                encoded_info_extracted: result.info_extracted  // Info extracted used for encoding
                            });
                            renderVibeList();
                            saveAppSettings();
                            updateAnlasCost();

                            // Vibe Transfer 활성화
                            document.getElementById('enableVibeTransfer').checked = true;
                            document.getElementById('vibeTransferSettings').style.display = 'block';
                            // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                            document.getElementById('enableCharRef').checked = false;
                            document.getElementById('charRefSettings').style.display = 'none';

                            showToast('바이브가 추가되었습니다', 'success');
                        } else {
                            showToast('바이브 데이터 없음', 'warning');
                        }
                    } catch (err) {
                        showToast('바이브 적용 실패: ' + err.message, 'error');
                    }
                };

                // 삭제 버튼
                item.querySelector('.delete-btn').onclick = async (e) => {
                    e.stopPropagation();
                    showConfirmModal(
                        '🗑️ 바이브 삭제',
                        '<p>이 바이브 캐시를 삭제하시겠습니까?</p>',
                        async () => {
                            try {
                                const response = await fetch(`${API_BASE}/api/vibe-cache/${vibe.filename}`, {
                                    method: 'DELETE'
                                });
                                const result = await response.json();
                                if (result.success) {
                                    item.remove();
                                    showToast('삭제됨', 'success');
                                    // 캐시가 비었는지 확인
                                    if (galleryGrid.children.length === 0) {
                                        galleryEmpty.innerHTML = `
                                            <div class="icon">🎨</div>
                                            <p>바이브 캐시가 비어있습니다</p>
                                            <small>이미지 생성 시 바이브가 자동으로 캐시됩니다</small>
                                        `;
                                        galleryEmpty.style.display = 'flex';
                                        galleryGrid.style.display = 'none';
                                    }
                                } else {
                                    showToast('삭제 실패', 'error');
                                }
                            } catch (err) {
                                showToast('삭제 오류: ' + err.message, 'error');
                            }
                        },
                        '삭제',
                        true
                    );
                };

                galleryGrid.appendChild(item);
            });
        }

        // ============================================================
        // 외부 이미지 드롭 처리
        // ============================================================
        const dropOverlay = document.getElementById('dropOverlay');
        const dropModal = document.getElementById('dropModal');
        let pendingDropData = null;

        // 드래그 이벤트 처리
        let dragCounter = 0;
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            if (e.dataTransfer.types.includes('Files')) {
                dropOverlay.classList.add('active');
            }
        });

        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dropOverlay.classList.remove('active');
            }
        });

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropOverlay.classList.remove('active');

            const files = e.dataTransfer.files;
            if (files.length === 0) return;

            const file = files[0];

            // NAI 바이브 파일 (.naiv4vibe) 처리
            if (file.name.endsWith('.naiv4vibe')) {
                try {
                    const text = await file.text();
                    const vibeData = JSON.parse(text);

                    // NAI 바이브 파일 검증
                    if (vibeData.identifier !== 'novelai-vibe-transfer') {
                        showToast('유효하지 않은 NAI 바이브 파일입니다', 'error');
                        return;
                    }

                    // 바이브 정보 추출
                    const importInfo = vibeData.importInfo || {};
                    const model = importInfo.model || 'nai-diffusion-4-5-full';
                    const strength = importInfo.strength || 0.6;
                    const infoExtracted = importInfo.information_extracted || 1.0;

                    // 모델에 맞는 인코딩 찾기
                    const modelKeyMap = {
                        'nai-diffusion-4-5-full': 'v4-5full',
                        'nai-diffusion-4-curated-preview': 'v4-curated',
                        'nai-diffusion-4-full': 'v4-full'
                    };
                    const encodingKey = modelKeyMap[model] || 'v4-5full';
                    const modelEncodings = vibeData.encodings?.[encodingKey] || {};

                    // info_extracted에 맞는 인코딩 찾기 (없으면 첫 번째 사용)
                    let encodedData = null;
                    let encodedInfoExtracted = infoExtracted;
                    for (const [hash, data] of Object.entries(modelEncodings)) {
                        if (data.params?.information_extracted === infoExtracted) {
                            encodedData = data.encoding;
                            break;
                        }
                        if (!encodedData) {
                            encodedData = data.encoding;
                            encodedInfoExtracted = data.params?.information_extracted || infoExtracted;
                        }
                    }

                    // 모달 표시
                    const thumbnail = vibeData.thumbnail || '';
                    const imageBase64 = vibeData.image || '';

                    document.getElementById('dropModalPreview').src = thumbnail || 'data:image/png;base64,' + imageBase64;
                    document.getElementById('dropModalTitle').textContent = '🎨 NAI 바이브 파일';
                    document.getElementById('dropModalMetadata').innerHTML = `
                        <div><strong>Name:</strong> ${vibeData.name || file.name}</div>
                        <div><strong>Model:</strong> ${model}</div>
                        <div><strong>Strength:</strong> ${strength}</div>
                        <div><strong>Info Extracted:</strong> ${infoExtracted}</div>
                        ${encodedData ? '<div style="color:#4ade80">✓ 인코딩 캐시 있음 (Anlas 무료)</div>' : '<div style="color:#fbbf24">⚠ 인코딩 없음 - 생성 시 인코딩됨</div>'}
                    `;
                    document.getElementById('dropModalConfirm').textContent = '바이브에 추가';

                    pendingDropData = {
                        type: 'nai-vibe',
                        image: imageBase64,
                        strength: strength,
                        info_extracted: infoExtracted,
                        name: vibeData.name || file.name.replace('.naiv4vibe', ''),
                        encoded: encodedData,
                        encoded_model: encodedData ? model : null,
                        encoded_info_extracted: encodedData ? encodedInfoExtracted : null
                    };

                    dropModal.classList.add('active');
                    return;
                } catch (err) {
                    showToast('NAI 바이브 파일 파싱 오류: ' + err.message, 'error');
                    return;
                }
            }

            if (!file.type.startsWith('image/')) {
                showToast('이미지 파일만 드롭할 수 있습니다', 'error');
                return;
            }

            // 이미지를 base64로 변환
            const base64 = await fileToBase64(file);

            // 서버에서 메타데이터 추출
            try {
                const response = await fetch(`${API_BASE}/api/extract-metadata`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: base64 })
                });
                const result = await response.json();

                if (!result.success) {
                    showToast('메타데이터 추출 실패: ' + result.error, 'error');
                    return;
                }

                // 모달 표시 준비
                document.getElementById('dropModalPreview').src = 'data:image/png;base64,' + base64;
                const metadataDiv = document.getElementById('dropModalMetadata');

                if (result.is_vibe) {
                    // 바이브 캐시 파일
                    const hasCache = result.vibe_data && result.vibe_model;
                    document.getElementById('dropModalTitle').textContent = hasCache ? '🎨 바이브 캐시 파일' : '🎨 바이브 파일';
                    metadataDiv.innerHTML = `
                        <div><strong>Strength:</strong> ${result.vibe_strength}</div>
                        <div><strong>Info Extracted:</strong> ${result.vibe_info_extracted}</div>
                        ${hasCache ? `<div><strong>Model:</strong> ${result.vibe_model}</div><div style="color:#4ade80">✓ 인코딩 캐시 있음 (Anlas 무료)</div>` : ''}
                    `;
                    document.getElementById('dropModalConfirm').textContent = '바이브에 추가';
                    pendingDropData = {
                        type: 'vibe',
                        image: base64,
                        strength: result.vibe_strength,
                        info_extracted: result.vibe_info_extracted,
                        name: file.name,
                        encoded: result.vibe_data || null,
                        encoded_model: result.vibe_model || null,
                        encoded_info_extracted: result.vibe_data ? result.vibe_info_extracted : null  // 캐시된 경우 인코딩 시 사용된 info_extracted
                    };
                } else if (result.is_nai && result.nai_metadata) {
                    // NAI 생성 이미지 - 정규화된 메타데이터로 표시
                    const meta = normalizeMetadata(result.nai_metadata);
                    const isPureNai = !result.nai_metadata.peropix;
                    document.getElementById('dropModalTitle').textContent = isPureNai ? '🖼️ NAI 원본 이미지' : '🖼️ PeroPix 이미지';

                    metadataDiv.innerHTML = `
                        <div><strong>Prompt:</strong> ${(meta.prompt || '').substring(0, 100)}${(meta.prompt || '').length > 100 ? '...' : ''}</div>
                        <div><strong>Negative:</strong> ${(meta.negative_prompt || '').substring(0, 50)}${(meta.negative_prompt || '').length > 50 ? '...' : ''}</div>
                        <div><strong>Seed:</strong> ${meta.seed || 'N/A'}</div>
                        <div><strong>Size:</strong> ${meta.width}x${meta.height}</div>
                        <div><strong>Steps:</strong> ${meta.steps}, <strong>CFG:</strong> ${meta.cfg}, <strong>Rescale:</strong> ${meta.cfg_rescale || 0}</div>
                        <div><strong>Sampler:</strong> ${meta.sampler}, <strong>Scheduler:</strong> ${meta.scheduler}</div>
                        <div><strong>SMEA:</strong> ${meta.smea}, <strong>Variety+:</strong> ${meta.variety_plus ? 'On' : 'Off'}</div>
                        <div><strong>Model:</strong> ${meta.nai_model || 'N/A'}</div>
                        ${isPureNai ? '<div style="color:#4ade80; margin-top:8px;">✓ NAI 원본: 퀄리티 태그/UC 프리셋 자동 분리됨</div>' : ''}
                    `;
                    document.getElementById('dropModalConfirm').textContent = '전체 적용';
                    document.getElementById('dropModalPromptOnly').style.display = 'inline-block';
                    document.getElementById('dropModalSeedOnly').style.display = 'inline-block';
                    document.getElementById('dropModalAsVibe').style.display = 'inline-block';
                    document.getElementById('dropModalAsCharRef').style.display = 'inline-block';
                    pendingDropData = {
                        type: 'nai',
                        metadata: result.nai_metadata,  // 원본 저장 (적용 시 다시 정규화)
                        image: base64,
                        name: file.name
                    };
                    window._isPureNaiImage = isPureNai;
                } else {
                    // 일반 이미지 - 바이브 또는 캐릭터 레퍼런스로 추가 제안
                    document.getElementById('dropModalTitle').textContent = '📷 일반 이미지';
                    metadataDiv.innerHTML = '<div>메타데이터가 없습니다. 바이브 또는 캐릭터 레퍼런스로 추가할 수 있습니다.</div>';
                    document.getElementById('dropModalConfirm').textContent = '바이브에 추가';
                    document.getElementById('dropModalAsCharRef').style.display = 'inline-block';
                    pendingDropData = {
                        type: 'plain',
                        image: base64,
                        name: file.name
                    };
                }

                dropModal.classList.add('active');

            } catch (err) {
                showToast('메타데이터 추출 오류: ' + err.message, 'error');
            }
        });

        // 모달 닫기 헬퍼
        function closeDropModal() {
            dropModal.classList.remove('active');
            pendingDropData = null;
            window._pendingLoadMetadata = null;
            window._isPureNaiImage = false;
            document.getElementById('dropModalPreview').style.display = '';
            document.getElementById('dropModalPromptOnly').style.display = 'none';
            document.getElementById('dropModalSeedOnly').style.display = 'none';
            document.getElementById('dropModalAsVibe').style.display = 'none';
            document.getElementById('dropModalAsCharRef').style.display = 'none';
            document.getElementById('dropModalConfirm').textContent = '확인';
        }

        // 모달 버튼 이벤트
        document.getElementById('dropModalCancel').onclick = () => {
            closeDropModal();
        };

        // 프롬프트만 적용 버튼
        document.getElementById('dropModalPromptOnly').onclick = () => {
            const doApply = () => {
                if (window._pendingLoadMetadata) {
                    applyPromptOnly(window._pendingLoadMetadata);
                    closeDropModal();
                } else if (pendingDropData && pendingDropData.type === 'nai') {
                    // 정규화된 메타데이터로 applyPromptOnly 호출 (캐릭터 프롬프트 포함)
                    const normalized = normalizeMetadata(pendingDropData.metadata);
                    applyPromptOnly(normalized);
                    closeDropModal();
                }
            };

            // 순수 NAI 이미지면 경고 팝업 표시
            if (window._isPureNaiImage) {
                showPureNaiWarning(doApply);
            } else {
                doApply();
            }
        };

        // 시드만 적용 버튼
        document.getElementById('dropModalSeedOnly').onclick = () => {
            if (pendingDropData && pendingDropData.type === 'nai') {
                const meta = pendingDropData.metadata;
                if (meta.seed) {
                    document.getElementById('seed').value = meta.seed;
                    saveAppSettings();
                    showToast(`시드 ${meta.seed} 적용됨`, 'success');
                }
                closeDropModal();
            }
        };

        // 바이브로 추가 버튼
        document.getElementById('dropModalAsVibe').onclick = () => {
            if (pendingDropData && pendingDropData.image) {
                if (vibeList.length >= 16) {
                    showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                } else {
                    vibeList.push({
                        image: pendingDropData.image,
                        strength: 0.6,
                        info_extracted: 1.0,
                        name: pendingDropData.name
                    });
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                    document.getElementById('enableCharRef').checked = false;
                    document.getElementById('charRefSettings').style.display = 'none';
                    showToast('바이브에 추가됨', 'success');
                }
                closeDropModal();
            }
        };

        // 캐릭터 레퍼런스로 추가 버튼
        document.getElementById('dropModalAsCharRef').onclick = async () => {
            if (pendingDropData && pendingDropData.image) {
                try {
                    // Canvas로 이미지 처리 (NAI 웹/NAIS2와 동일한 방식)
                    let processedImage;
                    try {
                        processedImage = await processCharacterReferenceImage(pendingDropData.image);
                    } catch (e) {
                        console.error('[CharRef] Processing failed:', e);
                        processedImage = pendingDropData.image; // 실패시 원본 사용
                    }
                    
                    charRefData = { image: processedImage };
                    document.getElementById('charRefImage').src = 'data:image/png;base64,' + processedImage;
                    document.getElementById('charRefPreview').style.display = 'block';
                    document.getElementById('uploadCharRefBtn').textContent = '이미지 변경';
                    
                    // 캐릭터 레퍼런스 활성화
                    document.getElementById('enableCharRef').checked = true;
                    document.getElementById('charRefSettings').style.display = 'block';
                    // Vibe Transfer와 Character Reference는 동시 사용 불가 - Vibe 비활성화
                    document.getElementById('enableVibeTransfer').checked = false;
                    document.getElementById('vibeTransferSettings').style.display = 'none';
                    
                    saveAppSettings();
                    updateAnlasCost();
                    showToast('캐릭터 레퍼런스에 추가됨', 'success');
                } catch (e) {
                    showToast('캐릭터 레퍼런스 추가 실패: ' + e.message, 'error');
                }
                closeDropModal();
            }
        };

        document.getElementById('dropModalConfirm').onclick = () => {
            // 설정 불러오기 처리
            if (window._pendingLoadMetadata) {
                const doApply = () => {
                    applyMetadataSettings(window._pendingLoadMetadata);
                    closeDropModal();
                };

                // 순수 NAI 이미지면 경고 팝업 표시
                if (window._isPureNaiImage) {
                    showPureNaiWarning(doApply);
                } else {
                    doApply();
                }
                return;
            }

            if (!pendingDropData) return;

            if (pendingDropData.type === 'vibe') {
                // 바이브 리스트에 추가 (캐시 데이터 포함)
                if (vibeList.length >= 16) {
                    showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                } else {
                    const vibeEntry = {
                        image: pendingDropData.image,
                        strength: pendingDropData.strength || 0.6,
                        info_extracted: pendingDropData.info_extracted || 1.0,
                        name: pendingDropData.name
                    };
                    // 캐시된 인코딩 데이터가 있으면 포함
                    if (pendingDropData.encoded) {
                        vibeEntry.encoded = pendingDropData.encoded;
                        vibeEntry.encoded_model = pendingDropData.encoded_model;
                        vibeEntry.encoded_info_extracted = pendingDropData.encoded_info_extracted || vibeEntry.info_extracted;  // 인코딩 시 사용된 값
                    }
                    vibeList.push(vibeEntry);
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    // Vibe Transfer 활성화
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                    document.getElementById('enableCharRef').checked = false;
                    document.getElementById('charRefSettings').style.display = 'none';
                    const msg = pendingDropData.encoded ? '바이브 추가됨 (캐시 사용)' : '바이브에 추가됨';
                    showToast(msg, 'success');
                }
            } else if (pendingDropData.type === 'nai') {
                // NAI 메타데이터 적용 - 정규화 후 applyMetadataSettings 사용
                const doApply = () => {
                    const normalized = normalizeMetadata(pendingDropData.metadata);
                    applyMetadataSettings(normalized);
                    closeDropModal();
                };

                // 순수 NAI 이미지면 경고 팝업 표시
                if (window._isPureNaiImage) {
                    showPureNaiWarning(doApply);
                    return;  // closeDropModal은 doApply 안에서 호출
                } else {
                    doApply();
                    return;
                }
            } else if (pendingDropData.type === 'nai-vibe') {
                // NAI 바이브 파일 (.naiv4vibe) 처리
                if (vibeList.length >= 16) {
                    showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                } else {
                    const vibeEntry = {
                        image: pendingDropData.image,
                        strength: pendingDropData.strength || 0.6,
                        info_extracted: pendingDropData.info_extracted || 1.0,
                        name: pendingDropData.name
                    };
                    // NAI 인코딩 데이터가 있으면 포함
                    if (pendingDropData.encoded) {
                        vibeEntry.encoded = pendingDropData.encoded;
                        vibeEntry.encoded_model = pendingDropData.encoded_model;
                        vibeEntry.encoded_info_extracted = pendingDropData.encoded_info_extracted || vibeEntry.info_extracted;
                    }
                    vibeList.push(vibeEntry);
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                    document.getElementById('enableCharRef').checked = false;
                    document.getElementById('charRefSettings').style.display = 'none';
                    const msg = pendingDropData.encoded ? 'NAI 바이브 추가됨 (캐시 사용)' : 'NAI 바이브 추가됨';
                    showToast(msg, 'success');
                }
                closeDropModal();
                return;
            } else if (pendingDropData.type === 'plain') {
                // 일반 이미지를 바이브로 추가
                if (vibeList.length >= 16) {
                    showToast('바이브는 최대 16개까지만 추가할 수 있습니다', 'error');
                } else {
                    vibeList.push({
                        image: pendingDropData.image,
                        strength: 0.6,
                        info_extracted: 1.0,
                        name: pendingDropData.name
                    });
                    renderVibeList();
                    saveAppSettings();
                    updateAnlasCost();
                    document.getElementById('enableVibeTransfer').checked = true;
                    document.getElementById('vibeTransferSettings').style.display = 'block';
                    // Vibe Transfer와 Character Reference는 동시 사용 불가 - CharRef 비활성화
                    document.getElementById('enableCharRef').checked = false;
                    document.getElementById('charRefSettings').style.display = 'none';
                    showToast('바이브에 추가됨', 'success');
                }
            }

            closeDropModal();
        };

        // ============================================================
        // Mask Editor & Base Image (Inpaint/Img2Img)
        // ============================================================

        // Base Image 데이터
        let baseImageData = {
            enabled: false,
            image: null,        // base64
            mask: null,         // base64 (white = inpaint area)
            mode: 'inpaint',    // 'inpaint' | 'img2img'
            strength: 0.7,
            noise: 0,
            width: 0,
            height: 0
        };

        // Mask Editor 상태
        const maskEditor = {
            isDrawing: false,
            tool: 'brush',  // 'brush' | 'eraser'
            brushSize: 30,
            imageCanvas: null,
            maskCanvas: null,
            drawCanvas: null,
            imageCtx: null,
            maskCtx: null,
            drawCtx: null,
            originalImage: null,
            scale: 1,
            paintedCells: new Set()  // 그리드 셀 추적 (8x8 그리드 브러시용)
        };

        // Mask Editor 열기
        function openMaskEditor(imageBase64, existingMask = null) {
            const modal = document.getElementById('maskEditorModal');
            const img = new Image();

            img.onload = () => {
                maskEditor.originalImage = img;

                // 원본 크기로 캔버스 설정 (축소/업스케일 없음)
                // 디스플레이는 CSS로 조정
                const maxWidth = window.innerWidth * 0.9;
                const maxHeight = window.innerHeight * 0.65;
                let displayScale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
                maskEditor.scale = displayScale;

                // 캔버스 실제 크기 = 원본 이미지 크기
                const canvasWidth = img.width;
                const canvasHeight = img.height;

                // 디스플레이 크기 (CSS)
                const displayWidth = Math.round(img.width * displayScale);
                const displayHeight = Math.round(img.height * displayScale);

                // 캔버스 초기화
                maskEditor.imageCanvas = document.getElementById('maskEditorImageCanvas');
                maskEditor.maskCanvas = document.getElementById('maskEditorMaskCanvas');
                maskEditor.drawCanvas = document.getElementById('maskEditorDrawCanvas');

                [maskEditor.imageCanvas, maskEditor.maskCanvas, maskEditor.drawCanvas].forEach(c => {
                    c.width = canvasWidth;      // 실제 해상도 = 원본
                    c.height = canvasHeight;
                    c.style.width = displayWidth + 'px';   // 디스플레이만 축소
                    c.style.height = displayHeight + 'px';
                });

                maskEditor.imageCtx = maskEditor.imageCanvas.getContext('2d');
                maskEditor.maskCtx = maskEditor.maskCanvas.getContext('2d');
                maskEditor.drawCtx = maskEditor.drawCanvas.getContext('2d');

                // 이미지 그리기 (원본 크기)
                maskEditor.imageCtx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

                // 기존 마스크 로드 또는 클리어 (검정 배경)
                maskEditor.maskCtx.fillStyle = 'black';
                maskEditor.maskCtx.fillRect(0, 0, canvasWidth, canvasHeight);
                if (existingMask) {
                    const maskImg = new Image();
                    maskImg.onload = () => {
                        maskEditor.maskCtx.drawImage(maskImg, 0, 0, canvasWidth, canvasHeight);
                    };
                    maskImg.src = existingMask;
                }

                // 설정 복원 (인페인트 모드 고정)
                document.getElementById('maskEditorStrength').value = baseImageData.strength;
                document.getElementById('maskEditorStrengthValue').textContent = baseImageData.strength;

                modal.classList.add('active');
            };

            img.src = imageBase64.startsWith('data:') ? imageBase64 : 'data:image/png;base64,' + imageBase64;
        }

        // Mask Editor 닫기
        function closeMaskEditor() {
            document.getElementById('maskEditorModal').classList.remove('active');
        }

        // 마스크 그리기 이벤트
        function setupMaskEditorEvents() {
            const drawCanvas = document.getElementById('maskEditorDrawCanvas');

            // NAIS2/NAI 웹 방식: 8x8 그리드 기반 브러시
            const GRID_SIZE = 8;
            let lastGridPos = null;  // 마지막 그리드 위치 (선 그리기용)
            maskEditor.paintedCells.clear();  // 에디터 열 때 초기화

            function getPos(e) {
                const rect = drawCanvas.getBoundingClientRect();
                const displayX = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
                const displayY = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
                // CSS 스케일링 보정: 디스플레이 좌표 → 캔버스 좌표
                const x = displayX * (drawCanvas.width / rect.width);
                const y = displayY * (drawCanvas.height / rect.height);
                return { x, y };
            }

            // 픽셀 좌표를 그리드 좌표로 변환
            function pixelToGrid(pixelX, pixelY) {
                const gx = Math.floor(pixelX / GRID_SIZE);
                const gy = Math.floor(pixelY / GRID_SIZE);
                const maxGx = Math.floor(maskEditor.maskCanvas.width / GRID_SIZE) - 1;
                const maxGy = Math.floor(maskEditor.maskCanvas.height / GRID_SIZE) - 1;
                return {
                    gx: Math.max(0, Math.min(gx, maxGx)),
                    gy: Math.max(0, Math.min(gy, maxGy))
                };
            }

            // 그리드 셀 채우기
            function fillGridCell(ctx, gx, gy, erase) {
                const cellKey = `${gx},${gy}`;

                if (erase) {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(gx * GRID_SIZE, gy * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    maskEditor.paintedCells.delete(cellKey);
                } else {
                    if (maskEditor.paintedCells.has(cellKey)) return;  // 이미 칠한 셀은 스킵
                    ctx.fillStyle = 'white';
                    ctx.fillRect(gx * GRID_SIZE, gy * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    maskEditor.paintedCells.add(cellKey);
                }
            }

            // 브러시 영역 채우기 (브러시 크기에 따라 여러 셀)
            function fillBrushArea(ctx, gx, gy, erase) {
                const brushGridSize = Math.max(1, Math.floor(maskEditor.brushSize / GRID_SIZE));
                const halfBrush = Math.floor(brushGridSize / 2);

                for (let offsetY = -halfBrush; offsetY <= halfBrush; offsetY++) {
                    for (let offsetX = -halfBrush; offsetX <= halfBrush; offsetX++) {
                        const targetGx = gx + offsetX;
                        const targetGy = gy + offsetY;
                        const maxGx = Math.floor(maskEditor.maskCanvas.width / GRID_SIZE) - 1;
                        const maxGy = Math.floor(maskEditor.maskCanvas.height / GRID_SIZE) - 1;

                        if (targetGx >= 0 && targetGx <= maxGx && targetGy >= 0 && targetGy <= maxGy) {
                            fillGridCell(ctx, targetGx, targetGy, erase);
                        }
                    }
                }
            }

            // Bresenham 선 알고리즘 (그리드 셀 간 부드러운 연결)
            function drawGridLine(ctx, startGx, startGy, endGx, endGy, erase) {
                const dx = Math.abs(endGx - startGx);
                const dy = Math.abs(endGy - startGy);
                const sx = startGx < endGx ? 1 : -1;
                const sy = startGy < endGy ? 1 : -1;
                let err = dx - dy;

                let gx = startGx;
                let gy = startGy;

                while (true) {
                    fillBrushArea(ctx, gx, gy, erase);

                    if (gx === endGx && gy === endGy) break;

                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        gx += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        gy += sy;
                    }
                }
            }

            function draw(e) {
                if (!maskEditor.isDrawing) return;
                const pos = getPos(e);
                const ctx = maskEditor.maskCtx;
                const erase = maskEditor.tool !== 'brush';

                const gridPos = pixelToGrid(pos.x, pos.y);

                if (lastGridPos) {
                    // 이전 위치에서 현재 위치까지 선 그리기
                    drawGridLine(ctx, lastGridPos.gx, lastGridPos.gy, gridPos.gx, gridPos.gy, erase);
                } else {
                    // 첫 클릭
                    fillBrushArea(ctx, gridPos.gx, gridPos.gy, erase);
                }

                lastGridPos = gridPos;
            }

            // 브러시 커서 미리보기 (그리드 정렬, 실제 칠해지는 영역과 동일)
            function drawCursor(e) {
                const pos = getPos(e);
                const ctx = maskEditor.drawCtx;
                const gridPos = pixelToGrid(pos.x, pos.y);
                const brushGridSize = Math.max(1, Math.floor(maskEditor.brushSize / GRID_SIZE));
                const halfBrush = Math.floor(brushGridSize / 2);

                // 이전 커서 지우기
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

                // 실제 칠해지는 영역: -halfBrush ~ +halfBrush (총 halfBrush*2+1 셀)
                const cellCount = halfBrush * 2 + 1;
                const startX = (gridPos.gx - halfBrush) * GRID_SIZE;
                const startY = (gridPos.gy - halfBrush) * GRID_SIZE;
                const size = cellCount * GRID_SIZE;

                ctx.strokeStyle = maskEditor.tool === 'brush' ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(startX, startY, size, size);

                // 내부 점선 테두리 (대비용)
                ctx.strokeStyle = maskEditor.tool === 'brush' ? 'rgba(0, 0, 0, 0.5)' : 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.strokeRect(startX + 1, startY + 1, size - 2, size - 2);
                ctx.setLineDash([]);
            }

            function clearCursor() {
                maskEditor.drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            }

            drawCanvas.addEventListener('mousedown', (e) => {
                maskEditor.isDrawing = true;
                lastGridPos = null;  // 새 스트로크 시작
                draw(e);
            });
            drawCanvas.addEventListener('mousemove', (e) => {
                draw(e);
                drawCursor(e);
            });
            drawCanvas.addEventListener('mouseup', () => {
                maskEditor.isDrawing = false;
                lastGridPos = null;
            });
            drawCanvas.addEventListener('mouseleave', () => {
                maskEditor.isDrawing = false;
                lastGridPos = null;
                clearCursor();
            });

            // Touch support
            drawCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                maskEditor.isDrawing = true;
                lastGridPos = null;
                draw(e);
            });
            drawCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                draw(e);
            });
            drawCanvas.addEventListener('touchend', () => {
                maskEditor.isDrawing = false;
                lastGridPos = null;
            });

            // 도구 버튼
            document.getElementById('maskToolBrush').onclick = () => {
                maskEditor.tool = 'brush';
                document.getElementById('maskToolBrush').classList.add('active');
                document.getElementById('maskToolEraser').classList.remove('active');
            };
            document.getElementById('maskToolEraser').onclick = () => {
                maskEditor.tool = 'eraser';
                document.getElementById('maskToolEraser').classList.add('active');
                document.getElementById('maskToolBrush').classList.remove('active');
            };

            // 브러시 크기
            document.getElementById('maskBrushSize').oninput = function() {
                maskEditor.brushSize = parseInt(this.value);
                document.getElementById('maskBrushSizeValue').textContent = this.value;
            };

            // Clear (검정으로 채우기 = 마스크 없음)
            document.getElementById('maskToolClear').onclick = () => {
                maskEditor.maskCtx.fillStyle = 'black';
                maskEditor.maskCtx.fillRect(0, 0, maskEditor.maskCanvas.width, maskEditor.maskCanvas.height);
                maskEditor.paintedCells.clear();  // 그리드 셀 추적도 초기화
            };

            // Invert (검정 ↔ 흰색 반전)
            document.getElementById('maskToolInvert').onclick = () => {
                const ctx = maskEditor.maskCtx;
                const imageData = ctx.getImageData(0, 0, maskEditor.maskCanvas.width, maskEditor.maskCanvas.height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];       // R
                    data[i + 1] = 255 - data[i + 1]; // G
                    data[i + 2] = 255 - data[i + 2]; // B
                    data[i + 3] = 255;             // A (항상 불투명)
                }
                ctx.putImageData(imageData, 0, 0);
            };

            // Strength slider
            document.getElementById('maskEditorStrength').oninput = function() {
                document.getElementById('maskEditorStrengthValue').textContent = this.value;
            };

            // Cancel
            document.getElementById('maskEditorCancel').onclick = closeMaskEditor;
            document.getElementById('maskEditorClose').onclick = closeMaskEditor;

            // Apply
            document.getElementById('maskEditorApply').onclick = () => {
                // 캔버스가 이미 원본 해상도이므로 직접 사용 (업스케일 불필요)
                // NAI는 순수 흑백 마스크만 지원 - 회색 픽셀이 생기면 경계선 아티팩트 발생

                // 원본 크기 이미지
                const fullImageCanvas = document.createElement('canvas');
                fullImageCanvas.width = maskEditor.originalImage.width;
                fullImageCanvas.height = maskEditor.originalImage.height;
                fullImageCanvas.getContext('2d').drawImage(maskEditor.originalImage, 0, 0);

                // Base Image 데이터 설정
                baseImageData.enabled = true;
                baseImageData.image = fullImageCanvas.toDataURL('image/png').split(',')[1];
                baseImageData.mask = maskEditor.maskCanvas.toDataURL('image/png').split(',')[1];  // 이미 원본 크기
                baseImageData.mode = 'inpaint';  // 마스크 에디터는 항상 인페인트
                baseImageData.strength = parseFloat(document.getElementById('maskEditorStrength').value);
                baseImageData.noise = 0;  // 인페인트는 noise 미사용
                baseImageData.width = maskEditor.originalImage.width;
                baseImageData.height = maskEditor.originalImage.height;

                // UI 업데이트
                updateBaseImageUI();
                closeMaskEditor();
                showToast('베이스 이미지로 등록됨', 'success');
            };
        }

        // Base Image UI 업데이트
        function updateBaseImageUI() {
            const section = document.getElementById('baseImageSection');
            const preview = document.getElementById('baseImageImg');
            const maskOverlay = document.getElementById('baseImageMaskOverlay');

            if (baseImageData.enabled && baseImageData.image) {
                section.style.display = 'block';
                preview.src = 'data:image/png;base64,' + baseImageData.image;

                if (baseImageData.mask) {
                    maskOverlay.style.backgroundImage = `url(data:image/png;base64,${baseImageData.mask})`;
                    maskOverlay.style.backgroundSize = 'contain';
                    maskOverlay.style.backgroundPosition = 'center';
                    maskOverlay.style.backgroundRepeat = 'no-repeat';
                } else {
                    maskOverlay.style.backgroundImage = 'none';
                }

                document.getElementById('baseImageMode').value = baseImageData.mode;
                document.getElementById('baseImageStrength').value = baseImageData.strength;
                document.getElementById('baseImageStrengthValue').textContent = baseImageData.strength;
                document.getElementById('baseImageNoise').value = baseImageData.noise;
                document.getElementById('baseImageNoiseValue').textContent = baseImageData.noise;
                updateBaseImageNoiseVisibility();

                // 사이즈 동기화
                document.getElementById('width').value = baseImageData.width;
                document.getElementById('height').value = baseImageData.height;
            } else {
                section.style.display = 'none';
            }
        }

        // Base Image 섹션 이벤트
        function setupBaseImageEvents() {
            // Clear 버튼
            document.getElementById('clearBaseImage').onclick = () => {
                baseImageData = {
                    enabled: false,
                    image: null,
                    mask: null,
                    mode: 'inpaint',
                    strength: 0.7,
                    noise: 0,
                    width: 0,
                    height: 0
                };
                updateBaseImageUI();
                showToast('Base Image 제거됨', 'success');
            };

            // Edit Mask 버튼
            document.getElementById('editMaskBtn').onclick = () => {
                if (baseImageData.image) {
                    openMaskEditor('data:image/png;base64,' + baseImageData.image,
                        baseImageData.mask ? 'data:image/png;base64,' + baseImageData.mask : null);
                }
            };

            // Sliders
            document.getElementById('baseImageStrength').oninput = function() {
                baseImageData.strength = parseFloat(this.value);
                document.getElementById('baseImageStrengthValue').textContent = this.value;
            };
            document.getElementById('baseImageNoise').oninput = function() {
                baseImageData.noise = parseFloat(this.value);
                document.getElementById('baseImageNoiseValue').textContent = this.value;
            };
            document.getElementById('baseImageMode').onchange = function() {
                baseImageData.mode = this.value;
                updateBaseImageNoiseVisibility();
            };
        }

        // Noise 슬라이더 가시성 업데이트 (인페인트는 noise 없음)
        function updateBaseImageNoiseVisibility() {
            const noiseContainer = document.getElementById('baseImageNoiseContainer');
            const mode = document.getElementById('baseImageMode').value;
            noiseContainer.style.display = mode === 'inpaint' ? 'none' : 'block';
        }

        // Inpaint용 이미지 설정 함수 (외부에서 호출)
        function setBaseImageForInpaint(imageBase64) {
            // 슬롯 모드로 전환 (생성은 슬롯 모드에서만 가능)
            if (currentMode !== 'slot') {
                document.getElementById('slotModeBtn').click();
            }
            openMaskEditor(imageBase64);
        }

        // 초기화
        setupMaskEditorEvents();
        setupBaseImageEvents();
        updateBaseImageNoiseVisibility();
        updateProviderLabels();

        // ============================================================
        // Censor Mode - New Implementation
        // ============================================================
        
        // 검열 모드 상태
        const censorState = {
            currentTab: 'before',  // 'before' | 'processing' | 'after'
            images: [],            // 검열 전 이미지 목록
            censoredImages: [],    // 검열 후 이미지 목록
            currentIndex: 0,
            beforeIndex: 0,        // 검열전 탭 인덱스
            afterIndex: 0,         // 검열후 탭 인덱스 (항상 0으로 리셋)
            beforeTabVisited: true,  // 검열전 탭 방문 여부 (기본값 true - 시작 탭이므로)
            currentImage: null,    // {path, filename, width, height, imgObj(Image객체)}
            originalImageObj: null, // Image 객체 (재렌더링용)
            imageCache: {},        // 하위호환용 (deprecated)
            // LRU 이미지 캐시 (Image 객체 직접 저장)
            imgCache: new Map(),   // Map<cacheKey, {img: Image, width, height, filename}>
            imgCacheMaxSize: 30,   // 최대 캐시 크기
            detections: [],        // [{label, confidence, box: [x1,y1,x2,y2]}]
            editBoxes: [],         // 편집용 박스들 [{box: [x1,y1,x2,y2], method: string}]
            modelClasses: [],      // 현재 모델의 클래스 목록
            labelConf: {},         // 클래스별 confidence
            selectedBoxIndex: -1,
            hoverBoxIndex: -1,     // 마우스 호버 중인 박스 인덱스
            isScanning: false,
            displayScale: 1,
            overlayOffsetY: 0,     // 오버레이 캔버스 상단 여백 (회전 핸들용)
            // 폴더 상태
            currentUncensoredFolder: '',  // uncensored 하위 폴더
            currentCensoredFolder: '',    // censored 하위 폴더
            // 편집 상태
            currentTool: 'select', // 'select' | 'add' | 'delete'
            isDragging: false,
            isResizing: false,
            isRotating: false,
            isDrawing: false,
            dragStartX: 0,
            dragStartY: 0,
            dragBoxOriginal: null,
            resizeHandle: null,    // 'nw' | 'ne' | 'sw' | 'se' | 'n' | 's' | 'e' | 'w' | null
            resizeAnchor: null,    // {localX, localY, worldX, worldY} 리사이즈 앵커
            rotateCenter: null,    // {x, y} 회전 중심점
            rotateStartAngle: 0,   // 회전 시작 각도
            newBoxStart: null,     // {x, y} 새 박스 시작점
            // 검열중(processing) 모드 상태
            processingMode: false,
            processingResults: {}, // 이미지별 스캔 결과 {path: {detections, editBoxes, originalImage}}
            processingMethod: 'black',
            processingImages: [],  // 검열중인 이미지 경로 목록
            // 편집 모달 상태
            editModalOpen: false,
            editModalImage: null,  // 편집 중인 이미지 정보
            editModalBoxes: [],
            editModalOriginal: null,
            // 검열후 탭 편집 상태
            afterEditDirty: false,  // 편집 변경 여부
            // 휠 네비게이션 상태
            wheelDebounceTimer: null,  // 휠 디바운스 타이머
            wheelRequestId: 0,         // 휠 요청 ID (취소용)
            // 초기화 플래그
            eventsInitialized: false  // 이벤트 리스너 초기화 여부
        };
        
        // LRU 캐시 헬퍼 함수
        function censorCacheGet(key) {
            if (censorState.imgCache.has(key)) {
                // LRU: 접근 시 맨 뒤로 이동 (가장 최근 사용)
                const value = censorState.imgCache.get(key);
                censorState.imgCache.delete(key);
                censorState.imgCache.set(key, value);
                return value;
            }
            return null;
        }
        
        function censorCacheSet(key, value) {
            // 이미 있으면 삭제 후 다시 추가 (LRU 순서 갱신)
            if (censorState.imgCache.has(key)) {
                censorState.imgCache.delete(key);
            }
            censorState.imgCache.set(key, value);
            // 최대 크기 초과 시 가장 오래된 항목 제거
            while (censorState.imgCache.size > censorState.imgCacheMaxSize) {
                const oldestKey = censorState.imgCache.keys().next().value;
                censorState.imgCache.delete(oldestKey);
            }
        }
        
        // 이미지 로드 함수 (FileResponse URL + crossOrigin)
        function loadCensorImageFile(source, path) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Image load failed'));
                // 경로의 각 부분을 개별 인코딩 (슬래시는 유지)
                const encodedPath = path.split('/').map(p => encodeURIComponent(p)).join('/');
                img.src = `${API_BASE}/api/censor/file/${source}/${encodedPath}?t=${Date.now()}`;
            });
        }
        
        // 스캔 로딩 표시
        function showCensorScanLoading(show) {
            const el = document.getElementById('censorScanLoading');
            if (el) el.classList.toggle('active', show);
        }
        
        // 프리페치: 좌우 이미지 백그라운드 로드
        function prefetchCensorImages(currentIndex, count = 3) {
            const images = censorState.currentTab === 'before' 
                ? censorState.images 
                : censorState.censoredImages;
            const source = censorState.currentTab === 'before' ? 'uncensored' : 'censored';
            
            for (let offset = 1; offset <= count; offset++) {
                // 다음 이미지
                const nextIdx = currentIndex + offset;
                if (nextIdx < images.length) {
                    const nextPath = images[nextIdx].path;
                    const nextKey = `${source}:${nextPath}`;
                    if (!censorState.imgCache.has(nextKey)) {
                        loadCensorImageFile(source, nextPath).then(img => {
                            censorCacheSet(nextKey, {
                                img,
                                width: img.naturalWidth,
                                height: img.naturalHeight,
                                filename: images[nextIdx].filename
                            });
                        }).catch(() => {});
                    }
                }
                // 이전 이미지
                const prevIdx = currentIndex - offset;
                if (prevIdx >= 0) {
                    const prevPath = images[prevIdx].path;
                    const prevKey = `${source}:${prevPath}`;
                    if (!censorState.imgCache.has(prevKey)) {
                        loadCensorImageFile(source, prevPath).then(img => {
                            censorCacheSet(prevKey, {
                                img,
                                width: img.naturalWidth,
                                height: img.naturalHeight,
                                filename: images[prevIdx].filename
                            });
                        }).catch(() => {});
                    }
                }
            }
        }
        
        // 캔버스 참조
        const censorPreviewCanvas = document.getElementById('censorPreviewCanvas');
        const censorOverlayCanvas = document.getElementById('censorOverlayCanvas');
        const censorPreviewCtx = censorPreviewCanvas?.getContext('2d');
        const censorOverlayCtx = censorOverlayCanvas?.getContext('2d');
        
        // 현재 탭에 맞는 재렌더링 함수
        function redrawCurrentTab() {
            if (censorState.currentTab === 'processing') {
                redrawProcessingPreview();
            } else if (censorState.currentTab === 'after') {
                redrawAfterPreview();
            } else {
                drawEditBoxes();
            }
        }
        
        // 현재 탭의 검열 방식 선택자 ID 반환
        function getCurrentMethodSelector() {
            if (censorState.currentTab === 'processing') return 'censorProcMethod';
            if (censorState.currentTab === 'after') return 'censorAfterMethod';
            return 'censorMethod';
        }
        
        // 편집 가능 탭인지 확인 (processing 또는 after)
        function isEditableTab() {
            return censorState.currentTab === 'processing' || censorState.currentTab === 'after';
        }
        
        // 검열 설정 저장 (localStorage)
        function saveCensorSettings() {
            const settings = {
                currentUncensoredFolder: censorState.currentUncensoredFolder,
                currentCensoredFolder: censorState.currentCensoredFolder,
                censorModel: document.getElementById('censorModel')?.value || '',
                censorMethod: document.getElementById('censorMethod')?.value || 'black',
                labelConf: censorState.labelConf,
                selectedTargets: Array.from(document.querySelectorAll('#censorTargets input[type="checkbox"]:checked'))
                    .map(cb => cb.dataset.class)
            };
            localStorage.setItem('censorSettings', JSON.stringify(settings));
        }
        
        // 검열 설정 복원 (localStorage)
        function restoreCensorSettings() {
            try {
                const saved = localStorage.getItem('censorSettings');
                if (!saved) return null;
                return JSON.parse(saved);
            } catch (e) {
                console.error('Failed to restore censor settings:', e);
                return null;
            }
        }
        
        // 검열 모드 초기화
        async function initCensorMode() {
            // 스캔 로딩 숨기기 (다른 모드에서 돌아왔을 때)
            showCensorScanLoading(false);
            
            // 검열전 탭 안내 문구 표시 (초기 진입 시 기본 탭이 before이므로)
            const previewHint = document.getElementById('censorPreviewHint');
            if (previewHint && censorState.currentTab === 'before') {
                previewHint.style.display = 'block';
            }
            
            // 네비게이션 UI 표시 (초기 진입 시)
            document.getElementById('censorNavLeft').style.display = 'flex';
            document.getElementById('censorNavRight').style.display = 'flex';
            document.getElementById('censorImageCounter').style.display = 'block';
            
            // 이미 초기화되어 있으면 현재 이미지만 다시 표시하고 스킵
            if (censorState.eventsInitialized &&
                (censorState.images.length > 0 || censorState.censoredImages.length > 0)) {
                // 현재 이미지가 있으면 다시 그리기
                if (censorState.currentImage) {
                    drawCensorPreview();
                }
                return;
            }

            const savedSettings = restoreCensorSettings();

            // 폴더 상태 복원
            if (savedSettings) {
                censorState.currentUncensoredFolder = savedSettings.currentUncensoredFolder || '';
                censorState.currentCensoredFolder = savedSettings.currentCensoredFolder || '';
                censorState.labelConf = savedSettings.labelConf || {};
            }

            // 폴더와 모델 병렬 로드 (둘 다 완료 대기)
            await Promise.all([
                loadCensorFolders(),
                loadCensorModels(savedSettings)
            ]);

            // 폴더 이름 표시 업데이트
            if (censorState.currentUncensoredFolder) {
                document.getElementById('censorUncensoredFolderName').textContent = censorState.currentUncensoredFolder;
            }
            if (censorState.currentCensoredFolder) {
                document.getElementById('censorCensoredFolderName').textContent = censorState.currentCensoredFolder;
            }

            // 이미지 로드 (저장된 폴더 또는 루트 폴더)
            await loadCensorImages();

            // 이벤트는 최초 1회만 등록
            if (!censorState.eventsInitialized) {
                setupCensorEvents();
                censorState.eventsInitialized = true;
            }
        }
        
        // 모델 목록 로드
        async function loadCensorModels(savedSettings = null) {
            const modelSelect = document.getElementById('censorModel');
            const methodSelect = document.getElementById('censorMethod');
            
            try {
                const response = await fetch(`${API_BASE}/api/censor/models`);
                const result = await response.json();
                
                if (result.models && result.models.length > 0) {
                    // 저장된 모델 또는 기본 모델 선택
                    const defaultModel = 'ntd11_anime_nsfw_segm_v5-variant1.pt';
                    let selectedModel;
                    if (savedSettings?.censorModel && result.models.includes(savedSettings.censorModel)) {
                        selectedModel = savedSettings.censorModel;
                    } else if (result.models.includes(defaultModel)) {
                        selectedModel = defaultModel;
                    } else {
                        selectedModel = result.models[0];
                    }
                    
                    modelSelect.innerHTML = result.models.map(m => 
                        `<option value="${m}" ${m === selectedModel ? 'selected' : ''}>${m}</option>`
                    ).join('');
                    
                    // 저장된 검열 방식 복원
                    if (savedSettings?.censorMethod && methodSelect) {
                        methodSelect.value = savedSettings.censorMethod;
                    }
                    
                    // 선택된 모델의 클래스 로드
                    await loadModelClasses(selectedModel, savedSettings);
                } else {
                    modelSelect.innerHTML = '<option value="">모델 없음</option>';
                }
            } catch (err) {
                console.error('Failed to load censor models:', err);
                modelSelect.innerHTML = '<option value="">로드 실패</option>';
            }
        }
        
        // 모델 클래스 로드 및 UI 생성
        async function loadModelClasses(modelName, savedSettings = null) {
            const targetsContainer = document.getElementById('censorTargets');
            try {
                const response = await fetch(`${API_BASE}/api/censor/model-info?model=${encodeURIComponent(modelName)}`);
                const result = await response.json();
                
                if (result.success && result.classes) {
                    censorState.modelClasses = result.classes;
                    // 기본 confidence 설정
                    result.classes.forEach(cls => {
                        if (!(cls in censorState.labelConf)) {
                            censorState.labelConf[cls] = 0.3;  // 기본값
                        }
                    });
                    renderCensorTargets(savedSettings?.selectedTargets);
                } else {
                    console.error('Model info failed:', result.error);
                    targetsContainer.innerHTML = `<div class="censor-target-loading">클래스 로드 실패: ${result.error || '알 수 없는 오류'}</div>`;
                }
            } catch (err) {
                console.error('Failed to load model classes:', err);
                targetsContainer.innerHTML = `<div class="censor-target-loading">클래스 로드 실패: ${err.message}</div>`;
            }
        }
        
        // 슬라이더 채움 배경 업데이트 (Chrome/Safari용 - CSS 변수 활용)
        function updateSliderFill(slider) {
            const min = parseFloat(slider.min) || 0;
            const max = parseFloat(slider.max) || 1;
            const val = parseFloat(slider.value) || 0;
            const percent = ((val - min) / (max - min)) * 100;
            slider.style.setProperty('--slider-percent', `${percent}%`);
        }
        
        // 검열 대상 UI 렌더링
        function renderCensorTargets(selectedTargets = null) {
            const container = document.getElementById('censorTargets');
            if (censorState.modelClasses.length === 0) {
                container.innerHTML = '<div class="censor-target-loading">모델을 선택하면 감지 대상이 표시됩니다</div>';
                return;
            }
            
            container.innerHTML = censorState.modelClasses.map(cls => {
                const conf = censorState.labelConf[cls] || 0.3;
                // 저장된 선택 상태 복원 (없거나 빈 배열이면 기본 체크)
                const isChecked = (selectedTargets && selectedTargets.length > 0) ? selectedTargets.includes(cls) : true;
                return `
                    <div class="censor-target-item">
                        <input type="checkbox" id="censor-target-${cls}" ${isChecked ? 'checked' : ''} data-class="${cls}">
                        <label for="censor-target-${cls}">${cls}</label>
                        <input type="range" min="0" max="1" step="0.01" value="${conf}" 
                               data-class="${cls}" class="censor-conf-slider">
                        <span class="conf-value">${conf.toFixed(2)}</span>
                    </div>
                `;
            }).join('');
            
            // 슬라이더 이벤트 및 초기 채움 설정
            container.querySelectorAll('.censor-conf-slider').forEach(slider => {
                // 초기 채움 설정
                updateSliderFill(slider);
                
                slider.oninput = function() {
                    const cls = this.dataset.class;
                    censorState.labelConf[cls] = parseFloat(this.value);
                    this.nextElementSibling.textContent = parseFloat(this.value).toFixed(2);
                    // 채움 업데이트
                    updateSliderFill(this);
                    // 실시간 재스캔
                    if (censorState.currentImage) {
                        debouncedScan();
                    }
                    saveCensorSettings();
                };
            });
            
            // 체크박스 이벤트
            container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.onchange = () => {
                    if (censorState.currentImage) {
                        debouncedScan();
                    }
                    saveCensorSettings();
                };
            });
        }
        
        // 디바운스된 스캔
        let scanDebounceTimer = null;
        function debouncedScan() {
            clearTimeout(scanDebounceTimer);
            scanDebounceTimer = setTimeout(() => {
                scanCurrentImage();
            }, 300);
        }
        
        // 폴더 목록 로드
        async function loadCensorFolders() {
            // uncensored 폴더 목록
            await loadCensorSubfolders('uncensored');
            // censored 폴더 목록
            await loadCensorSubfolders('censored');
        }
        
        // 폴더 목록을 드롭다운에 렌더링
        async function loadCensorSubfolders(type) {
            const listId = type === 'uncensored' ? 'censorUncensoredFolderList' : 'censorCensoredFolderList';
            const listEl = document.getElementById(listId);
            if (!listEl) return;
            
            try {
                const response = await fetch(`${API_BASE}/api/censor/folders?type=${type}`);
                const result = await response.json();
                
                renderCensorFolderList(type, result.folders || []);
            } catch (err) {
                console.error(`Failed to load ${type} folders:`, err);
                listEl.innerHTML = '<div class="folder-item">로드 실패</div>';
            }
        }
        
        // 폴더 목록 렌더링 (슬롯모드와 동일한 패턴)
        function renderCensorFolderList(type, folders) {
            const listId = type === 'uncensored' ? 'censorUncensoredFolderList' : 'censorCensoredFolderList';
            const listEl = document.getElementById(listId);
            const currentFolder = type === 'uncensored' ? censorState.currentUncensoredFolder : censorState.currentCensoredFolder;
            
            const rootName = type === 'uncensored' ? 'uncensored' : 'censored';
            const isRootSelected = currentFolder === '';
            
            let html = `
                <div class="folder-item root-folder ${isRootSelected ? 'active' : ''}" data-folder="" data-type="${type}">
                    <span>${isRootSelected ? '📂' : '📁'}</span>
                    <span>${rootName}</span>
                </div>
            `;
            
            folders.forEach(folder => {
                const isSelected = currentFolder === folder.name;
                html += `
                    <div class="folder-item subfolder ${isSelected ? 'active' : ''}" data-folder="${folder.name}" data-type="${type}">
                        <span>${isSelected ? '📂' : '📁'}</span>
                        <span>${folder.name}</span>
                        <span style="margin-left: auto; opacity: 0.6; font-size: 0.75rem;">${folder.image_count}</span>
                    </div>
                `;
            });
            
            listEl.innerHTML = html;
            
            // 폴더 클릭 이벤트
            listEl.querySelectorAll('.folder-item').forEach(item => {
                item.onclick = () => {
                    const folderName = item.dataset.folder;
                    const folderType = item.dataset.type;
                    selectCensorFolder(folderType, folderName);
                };
            });
        }
        
        // 폴더 선택 시 UI 업데이트 및 이미지 로드
        function selectCensorFolder(type, folderName) {
            const nameId = type === 'uncensored' ? 'censorUncensoredFolderName' : 'censorCensoredFolderName';
            const menuId = type === 'uncensored' ? 'censorUncensoredFolderMenu' : 'censorCensoredFolderMenu';
            const dropdownId = type === 'uncensored' ? 'censorFolderBefore' : 'censorFolderAfter';
            
            // 배치 모드 중 폴더 변경 시 초기화
            if (censorState.batchMode) {
                censorState.batchMode = false;
                censorState.batchResults = {};
                document.getElementById('censorRunAllBtn').style.display = 'block';
                document.getElementById('censorSaveBatchBtn').style.display = 'none';
            }
            
            // 상태 업데이트
            if (type === 'uncensored') {
                censorState.currentUncensoredFolder = folderName;
            } else {
                censorState.currentCensoredFolder = folderName;
            }
            
            // 이름 표시 업데이트
            const nameEl = document.getElementById(nameId);
            if (nameEl) {
                nameEl.textContent = folderName || (type === 'uncensored' ? 'uncensored' : 'censored');
            }
            
            // 메뉴 닫기
            const menuEl = document.getElementById(menuId);
            const dropdownEl = document.getElementById(dropdownId);
            if (menuEl) {
                menuEl.classList.remove('show');
                if (menuEl.parentElement === document.body && dropdownEl) {
                    dropdownEl.appendChild(menuEl);
                }
            }
            
            // 현재 탭에 해당하는 폴더면 이미지 새로고침
            if ((type === 'uncensored' && censorState.currentTab === 'before') ||
                (type === 'censored' && censorState.currentTab === 'after')) {
                loadCensorImages();
            }
            
            // 설정 저장
            saveCensorSettings();
        }
        
        // 폴더 드롭다운 토글
        function toggleCensorFolderMenu(type, e) {
            e.stopPropagation();
            
            const menuId = type === 'uncensored' ? 'censorUncensoredFolderMenu' : 'censorCensoredFolderMenu';
            const btnId = type === 'uncensored' ? 'censorUncensoredFolderBtn' : 'censorCensoredFolderBtn';
            const dropdownId = type === 'uncensored' ? 'censorFolderBefore' : 'censorFolderAfter';
            
            const menuEl = document.getElementById(menuId);
            const btnEl = document.getElementById(btnId);
            const dropdownEl = document.getElementById(dropdownId);
            
            if (!menuEl || !btnEl) return;
            
            const isShowing = menuEl.classList.contains('show');
            
            // 다른 메뉴 닫기
            closeCensorFolderMenus();
            
            if (isShowing) {
                menuEl.classList.remove('show');
                if (dropdownEl) dropdownEl.appendChild(menuEl);
            } else {
                document.body.appendChild(menuEl);
                const btnRect = btnEl.getBoundingClientRect();
                menuEl.style.top = (btnRect.bottom + 4) + 'px';
                menuEl.style.right = (window.innerWidth - btnRect.right) + 'px';
                menuEl.style.left = 'auto';
                menuEl.classList.add('show');
                loadCensorSubfolders(type);
            }
        }
        
        // 모든 검열 폴더 메뉴 닫기
        function closeCensorFolderMenus() {
            ['censorUncensoredFolderMenu', 'censorCensoredFolderMenu'].forEach(menuId => {
                const menuEl = document.getElementById(menuId);
                if (menuEl && menuEl.classList.contains('show')) {
                    menuEl.classList.remove('show');
                    const dropdownId = menuId === 'censorUncensoredFolderMenu' ? 'censorFolderBefore' : 'censorFolderAfter';
                    const dropdownEl = document.getElementById(dropdownId);
                    if (menuEl.parentElement === document.body && dropdownEl) {
                        dropdownEl.appendChild(menuEl);
                    }
                }
            });
        }
        
        // 이미지 목록 로드
        async function loadCensorImages() {
            // 현재 탭에 맞는 폴더 선택 (상태값 사용)
            const folder = censorState.currentTab === 'before'
                ? censorState.currentUncensoredFolder
                : censorState.currentCensoredFolder;
            const thumbnailsContainer = document.getElementById('censorThumbnails');

            // 로딩 표시
            thumbnailsContainer.innerHTML = '<div class="censor-loading">⏳ 이미지 로딩중...</div>';

            try {
                const endpoint = censorState.currentTab === 'before'
                    ? `/api/censor/images?folder=${encodeURIComponent(folder)}`
                    : `/api/censor/censored?folder=${encodeURIComponent(folder)}`;

                const response = await fetch(`${API_BASE}${endpoint}`);
                const result = await response.json();

                if (result.success) {
                    // 파일명 순 정렬
                    const images = (result.images || []).sort((a, b) =>
                        a.filename.localeCompare(b.filename, undefined, { numeric: true, sensitivity: 'base' })
                    );

                    // 현재 인덱스 저장 (재로드 시 유지용)
                    const previousIndex = censorState.currentIndex;
                    const previousImagePath = censorState.currentImage?.path;

                    if (censorState.currentTab === 'before') {
                        censorState.images = images;
                    } else {
                        censorState.censoredImages = images;
                    }
                    renderCensorThumbnails(images);

                    // 이전에 보던 이미지가 있으면 그걸 유지, 없으면 첫 번째 선택
                    if (images.length > 0) {
                        let targetIndex = 0;

                        // 이전에 보던 이미지를 찾아서 유지
                        if (previousImagePath) {
                            const foundIndex = images.findIndex(img => img.path === previousImagePath);
                            if (foundIndex >= 0) {
                                targetIndex = foundIndex;
                            } else if (previousIndex < images.length) {
                                targetIndex = previousIndex;
                            }
                        }

                        // 인덱스만 설정하고 UI만 업데이트 (스캔은 하지 않음)
                        censorState.currentIndex = targetIndex;
                        document.querySelectorAll('.censor-thumbnail').forEach((t, i) => {
                            t.classList.toggle('active', i === targetIndex);
                        });
                        document.getElementById('censorImageCounter').textContent = `${targetIndex + 1} / ${images.length}`;

                        // 이전 이미지가 없었던 경우에만 실제로 선택 (스캔 포함)
                        if (!previousImagePath) {
                            selectCensorImage(targetIndex);
                        }
                    } else {
                        clearCensorPreview();
                    }
                }
            } catch (err) {
                console.error('Failed to load censor images:', err);
                thumbnailsContainer.innerHTML = '<div class="censor-loading">로드 실패</div>';
                clearCensorPreview();
            }
        }
        
        // 썸네일 렌더링
        function renderCensorThumbnails(images) {
            const container = document.getElementById('censorThumbnails');
            if (images.length === 0) {
                container.innerHTML = '<div class="censor-loading">이미지가 없습니다</div>';
                return;
            }
            container.innerHTML = images.map((img, index) => `
                <div class="censor-thumbnail ${index === censorState.currentIndex ? 'active' : ''}" 
                     data-index="${index}" data-path="${img.path}">
                    <img src="data:image/jpeg;base64,${img.thumbnail}" alt="${img.filename}">
                </div>
            `).join('');
            
            // 클릭 이벤트
            container.querySelectorAll('.censor-thumbnail').forEach(thumb => {
                thumb.onclick = async () => {
                    const index = parseInt(thumb.dataset.index);
                    
                    // 배치 모드에서는 현재 이미지의 editBoxes를 저장하고 배치 모드용 선택 함수 사용
                    if (censorState.batchMode && censorState.currentTab === 'before') {
                        // 현재 이미지의 editBoxes를 batchResults에 저장
                        if (censorState.currentImage && censorState.batchResults[censorState.currentImage.path]) {
                            censorState.batchResults[censorState.currentImage.path].editBoxes = censorState.editBoxes.map(b => ({...b, box: [...b.box]}));
                        }
                        await selectCensorImageForBatch(index);
                    } else {
                        selectCensorImage(index);
                    }
                };
            });
        }
        
        // 이미지 선택 (skipScan: 휠 네비게이션에서 스캔 스킵용)
        async function selectCensorImage(index, { skipScan = false } = {}) {
            const requestId = ++censorState.wheelRequestId;  // 요청 ID 증가
            
            const images = censorState.currentTab === 'before'
                ? censorState.images
                : censorState.censoredImages;

            if (index < 0 || index >= images.length) return;

            censorState.currentIndex = index;

            // 현재 탭의 인덱스도 저장
            if (censorState.currentTab === 'before') {
                censorState.beforeIndex = index;
            } else if (censorState.currentTab === 'after') {
                censorState.afterIndex = index;
            }
            const imgInfo = images[index];
            
            // 편집 상태 초기화
            censorState.editBoxes = [];
            censorState.selectedBoxIndex = -1;
            censorState.hoverBoxIndex = -1;
            censorState.detections = [];
            
            // 오버레이 클리어 (깜빡임 방지)
            if (censorOverlayCtx) {
                censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);
            }
            
            // 검열후 탭일 경우 편집 상태 초기화
            if (censorState.currentTab === 'after') {
                censorState.afterEditDirty = false;
                const saveBtn = document.getElementById('censorAfterSaveBtn');
                if (saveBtn) saveBtn.disabled = true;
            }
            
            // 썸네일 활성화 표시 및 자동 스크롤
            const thumbnails = document.querySelectorAll('.censor-thumbnail');
            thumbnails.forEach((t, i) => {
                t.classList.toggle('active', i === index);
            });
            // 선택된 썸네일이 보이도록 자동 스크롤
            if (thumbnails[index]) {
                thumbnails[index].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            }

            // 이미지 번호 표시
            document.getElementById('censorImageCounter').textContent = `${index + 1} / ${images.length}`;

            // 화살표 버튼 활성화/비활성화
            const leftBtn = document.getElementById('censorNavLeft');
            const rightBtn = document.getElementById('censorNavRight');
            leftBtn.disabled = index === 0;
            rightBtn.disabled = index === images.length - 1;
            
            // 검열전 탭 + 스캔 예정이면 로딩 표시
            if (censorState.currentTab === 'before' && !skipScan) {
                showCensorScanLoading(true);
            }
            
            // 이미지 로드 (LRU 캐시 우선, FileResponse 사용)
            try {
                const source = censorState.currentTab === 'before' ? 'uncensored' : 'censored';
                const cacheKey = `${source}:${imgInfo.path}`;
                let cached = censorCacheGet(cacheKey);

                // 캐시에 없으면 FileResponse로 로드
                if (!cached) {
                    const img = await loadCensorImageFile(source, imgInfo.path);
                    // 로드 중 다른 이미지로 넘어갔으면 무시
                    if (requestId !== censorState.wheelRequestId) return;
                    
                    cached = {
                        img,
                        width: img.naturalWidth,
                        height: img.naturalHeight,
                        filename: imgInfo.filename
                    };
                    censorCacheSet(cacheKey, cached);
                }

                // 다른 이미지로 넘어갔으면 무시
                if (requestId !== censorState.wheelRequestId) return;

                // currentImage 설정 (Image 객체 직접 저장)
                censorState.currentImage = {
                    path: imgInfo.path,
                    filename: cached.filename,
                    width: cached.width,
                    height: cached.height,
                    imgObj: cached.img  // Image 객체 직접 참조
                };
                
                // 프리페치: 좌우 이미지 백그라운드 로드
                prefetchCensorImages(index);
                
                // 이미지 먼저 표시
                drawCensorPreview();

                // 검열 전 탭이면 스캔 실행 (skipScan이 아닐 때만)
                if (censorState.currentTab === 'before' && !skipScan) {
                    await scanCurrentImage();
                    // 스캔 완료 후 다른 이미지로 넘어갔으면 무시
                    if (requestId !== censorState.wheelRequestId) {
                        return;
                    }
                    showCensorScanLoading(false);
                    // 스캔 완료 후 박스와 함께 다시 그리기
                    drawCensorPreview();
                }
            } catch (err) {
                console.error('Failed to load image:', err);
                if (requestId === censorState.wheelRequestId) {
                    showCensorScanLoading(false);
                }
            }
        }
        
        // 프리뷰 그리기
        function drawCensorPreview() {
            if (!censorState.currentImage || !censorPreviewCtx) return;
            
            // 이미 로드된 Image 객체 사용 (캐시에서 가져옴)
            const img = censorState.currentImage.imgObj;
            if (!img) {
                console.error('No image object in currentImage');
                return;
            }
            
            // 원본 이미지 객체 저장 (재렌더링용)
            censorState.originalImageObj = img;
            
            // 회전 핸들을 위한 상단 여백
            const handleMargin = 40;
            
            // 캔버스 크기 설정 - 부모 영역(censor-preview-area)에서 크기 가져오기
            const previewArea = document.querySelector('.censor-preview-area');
            const maxW = previewArea.clientWidth - 48;
            const maxH = previewArea.clientHeight - 48 - handleMargin;  // 여백 고려
            
            let scale = Math.min(maxW / img.width, maxH / img.height, 1);
            const displayW = Math.round(img.width * scale);
            const displayH = Math.round(img.height * scale);
            
            censorPreviewCanvas.width = displayW;
            censorPreviewCanvas.height = displayH;
            // 오버레이 캔버스는 상단으로 확장 (회전 핸들용)
            censorOverlayCanvas.width = displayW;
            censorOverlayCanvas.height = displayH + handleMargin;
            
            censorPreviewCanvas.style.width = displayW + 'px';
            censorPreviewCanvas.style.height = displayH + 'px';
            censorOverlayCanvas.style.width = displayW + 'px';
            censorOverlayCanvas.style.height = (displayH + handleMargin) + 'px';
            // 오버레이를 위로 이동하여 회전 핸들 공간 확보
            censorOverlayCanvas.style.top = (-handleMargin) + 'px';
            
            // 오프셋 저장 (박스 그릴 때 사용)
            censorState.overlayOffsetY = handleMargin;
            
            // 스케일 저장
            censorState.displayScale = scale;
            
            // 이미지 그리기
            if (censorState.currentTab === 'processing') {
                // 검열중: 원본 + 검열 효과 적용
                drawCensoredImage(img, displayW, displayH);
            } else if (censorState.currentTab === 'after') {
                // 검열후: 이미 검열된 이미지 + 추가 편집 오버레이
                censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);
                drawAfterTabOverlay(img, displayW, displayH);
            } else {
                // 검열전: 원본 + 감지 박스 표시
                censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);
                drawDetectionBoxes();
            }
            
            // 빈 상태 숨기기
            document.getElementById('censorPreviewEmpty').style.display = 'none';
        }
        
        // 검열 적용된 이미지 그리기 (검열중 탭용)
        function drawCensoredImage(img, displayW, displayH) {
            if (!img || !censorPreviewCtx) return;
            
            const scale = censorState.displayScale;
            const method = document.getElementById('censorProcMethod')?.value || censorState.processingMethod;
            
            // 원본 이미지 먼저 그리기
            censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);

            // 박스들에 검열 효과 적용 (검열중 탭에서는 editBoxes만 사용)
            const boxes = censorState.editBoxes;
            
            boxes.forEach((det, index) => {
                const [x1, y1, x2, y2] = det.box;
                const sx = x1 * scale;
                const sy = y1 * scale;
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                const boxMethod = det.method || method;
                const rotation = det.rotation || 0;
                
                if (rotation !== 0) {
                    const cx = sx + sw / 2;
                    const cy = sy + sh / 2;
                    censorPreviewCtx.save();
                    censorPreviewCtx.translate(cx, cy);
                    censorPreviewCtx.rotate(rotation);
                    censorPreviewCtx.translate(-cx, -cy);
                    applyCensorEffect(censorPreviewCtx, sx, sy, sw, sh, boxMethod, img, x1, y1, x2 - x1, y2 - y1);
                    censorPreviewCtx.restore();
                } else {
                    applyCensorEffect(censorPreviewCtx, sx, sy, sw, sh, boxMethod, img, x1, y1, x2 - x1, y2 - y1);
                }
            });
            
            // 오버레이에 선택된 박스 표시
            drawProcessingOverlay();
        }
        
        // 검열 효과 적용
        function applyCensorEffect(ctx, x, y, w, h, method, originalImg, origX, origY, origW, origH) {
            switch (method) {
                case 'black':
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x, y, w, h);
                    break;
                case 'white':
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(x, y, w, h);
                    break;
                case 'mosaic':
                    applyMosaicEffect(ctx, x, y, w, h, originalImg, origX, origY, origW, origH);
                    break;
                case 'blur':
                    applyBlurEffect(ctx, x, y, w, h);
                    break;
                default:
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x, y, w, h);
            }
        }
        
        // 모자이크 효과
        function applyMosaicEffect(ctx, x, y, w, h, originalImg, origX, origY, origW, origH) {
            const blockSize = Math.max(8, Math.min(w, h) / 8);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = origW;
            tempCanvas.height = origH;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 원본에서 해당 영역 추출
            tempCtx.drawImage(originalImg, origX, origY, origW, origH, 0, 0, origW, origH);
            
            // 축소 후 확대로 모자이크
            const smallW = Math.ceil(w / blockSize);
            const smallH = Math.ceil(h / blockSize);
            
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tempCanvas, 0, 0, origW, origH, x, y, smallW, smallH);
            ctx.drawImage(ctx.canvas, x, y, smallW, smallH, x, y, w, h);
            ctx.imageSmoothingEnabled = true;
        }
        
        // 블러 효과 (간단한 버전)
        function applyBlurEffect(ctx, x, y, w, h) {
            // CSS blur 대신 다중 그리기로 블러 효과
            ctx.save();
            ctx.globalAlpha = 0.1;
            for (let i = -5; i <= 5; i++) {
                for (let j = -5; j <= 5; j++) {
                    ctx.drawImage(ctx.canvas, x, y, w, h, x + i, y + j, w, h);
                }
            }
            ctx.restore();
            
            // 반투명 오버레이
            ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
            ctx.fillRect(x, y, w, h);
        }
        
        // 검열중 탭 오버레이 그리기 (호버 시에만 핸들 표시)
        function drawProcessingOverlay() {
            if (!censorOverlayCtx) return;
            
            const scale = censorState.displayScale || 1;
            const offsetY = censorState.overlayOffsetY || 0;  // 상단 여백 오프셋
            censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);

            // 검열중 탭에서는 editBoxes만 사용 (모두 삭제한 경우 빈 배열)
            const boxes = censorState.editBoxes;
            const isDeleteMode = censorState.currentTool === 'delete';
            const canEdit = censorState.currentTool === 'select' || censorState.currentTool === 'add';
            
            boxes.forEach((det, index) => {
                const [x1, y1, x2, y2] = det.box;
                const sx = x1 * scale;
                const sy = y1 * scale + offsetY;  // 오프셋 적용
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                const rotation = det.rotation || 0;
                const cx = sx + sw / 2;
                const cy = sy + sh / 2;
                
                const isSelected = index === censorState.selectedBoxIndex;
                const isHovered = index === censorState.hoverBoxIndex;
                const showHandles = canEdit && (isHovered || isSelected);
                
                censorOverlayCtx.save();
                censorOverlayCtx.translate(cx, cy);
                censorOverlayCtx.rotate(rotation);
                censorOverlayCtx.translate(-cx, -cy);
                
                // 삭제 모드에서 호버 시 빨간 강조
                if (isDeleteMode && isHovered) {
                    censorOverlayCtx.strokeStyle = 'rgba(255, 80, 80, 1)';
                    censorOverlayCtx.lineWidth = 3;
                    censorOverlayCtx.setLineDash([]);
                    censorOverlayCtx.strokeRect(sx, sy, sw, sh);
                    censorOverlayCtx.fillStyle = 'rgba(255, 80, 80, 0.3)';
                    censorOverlayCtx.fillRect(sx, sy, sw, sh);
                } else if (showHandles) {
                    // 호버/선택 시 테두리 + 핸들 표시
                    censorOverlayCtx.strokeStyle = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.9)';
                    censorOverlayCtx.lineWidth = 2;
                    censorOverlayCtx.setLineDash([]);
                    censorOverlayCtx.strokeRect(sx, sy, sw, sh);
                    
                    // 리사이즈 핸들
                    const hs = 7;
                    const handleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.95)';
                    censorOverlayCtx.fillStyle = handleColor;
                    
                    // 모서리 핸들
                    censorOverlayCtx.fillRect(sx - hs/2, sy - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx + sw - hs/2, sy - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx - hs/2, sy + sh - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx + sw - hs/2, sy + sh - hs/2, hs, hs);
                    
                    // 변 핸들
                    const ehs = 5;
                    censorOverlayCtx.fillRect(cx - ehs/2, sy - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(cx - ehs/2, sy + sh - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(sx - ehs/2, cy - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(sx + sw - ehs/2, cy - ehs/2, ehs, ehs);
                    
                    // 회전 핸들 (선택 또는 호버 시 모두)
                    const rotateY = sy - 25;
                    const rotHandleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.95)';
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.strokeStyle = rotHandleColor;
                    censorOverlayCtx.lineWidth = 1;
                    censorOverlayCtx.moveTo(cx, sy);
                    censorOverlayCtx.lineTo(cx, rotateY + 6);
                    censorOverlayCtx.stroke();
                    
                    censorOverlayCtx.fillStyle = rotHandleColor;
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.arc(cx, rotateY, 6, 0, Math.PI * 2);
                    censorOverlayCtx.fill();
                    
                    censorOverlayCtx.fillStyle = isSelected ? 'white' : 'rgba(0, 0, 0, 0.7)';
                    censorOverlayCtx.font = '8px sans-serif';
                    censorOverlayCtx.textAlign = 'center';
                    censorOverlayCtx.textBaseline = 'middle';
                    censorOverlayCtx.fillText('↻', cx, rotateY);
                }
                // 호버/선택 아닐 때는 테두리 없음 (검열 효과만 보임)
                
                censorOverlayCtx.restore();
            });
        }
        
        // 검열중 모드에서 이미지 재렌더링 (박스 편집 후)
        function redrawProcessingPreview() {
            if (censorState.currentTab !== 'processing' || !censorState.originalImageObj) return;
            
            const img = censorState.originalImageObj;
            const displayW = censorPreviewCanvas.width;
            const displayH = censorPreviewCanvas.height;
            
            drawCensoredImage(img, displayW, displayH);
        }
        
        // 검열후 탭 오버레이 그리기 (추가된 편집 박스 + 검열 효과)
        function drawAfterTabOverlay(img, displayW, displayH) {
            if (!censorOverlayCtx) return;
            
            const scale = censorState.displayScale || 1;
            const method = document.getElementById('censorAfterMethod')?.value || 'black';
            
            // 추가된 editBoxes에 검열 효과 적용
            if (censorState.editBoxes.length > 0) {
                censorState.editBoxes.forEach(det => {
                    const [x1, y1, x2, y2] = det.box;
                    const sx = x1 * scale;
                    const sy = y1 * scale;
                    const sw = (x2 - x1) * scale;
                    const sh = (y2 - y1) * scale;
                    const rotation = det.rotation || 0;
                    
                    if (rotation !== 0) {
                        const cx = sx + sw / 2;
                        const cy = sy + sh / 2;
                        censorPreviewCtx.save();
                        censorPreviewCtx.translate(cx, cy);
                        censorPreviewCtx.rotate(rotation);
                        censorPreviewCtx.translate(-cx, -cy);
                        applyCensorEffect(censorPreviewCtx, sx, sy, sw, sh, det.method || method, img, x1, y1, x2 - x1, y2 - y1);
                        censorPreviewCtx.restore();
                    } else {
                        applyCensorEffect(censorPreviewCtx, sx, sy, sw, sh, det.method || method, img, x1, y1, x2 - x1, y2 - y1);
                    }
                });
            }
            
            // 오버레이에 편집 박스 표시 (호버/선택 시 핸들 표시)
            drawAfterTabBoxOverlay();
        }
        
        // 검열후 탭 박스 오버레이 (drawProcessingOverlay와 동일한 로직)
        function drawAfterTabBoxOverlay() {
            if (!censorOverlayCtx) return;
            
            const scale = censorState.displayScale || 1;
            const offsetY = censorState.overlayOffsetY || 0;  // 상단 여백 오프셋
            censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);
            
            const boxes = censorState.editBoxes;
            const isDeleteMode = censorState.currentTool === 'delete';
            const canEdit = censorState.currentTool === 'select' || censorState.currentTool === 'add';
            
            boxes.forEach((det, index) => {
                const [x1, y1, x2, y2] = det.box;
                const sx = x1 * scale;
                const sy = y1 * scale + offsetY;  // 오프셋 적용
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                const rotation = det.rotation || 0;
                const cx = sx + sw / 2;
                const cy = sy + sh / 2;
                
                const isSelected = index === censorState.selectedBoxIndex;
                const isHovered = index === censorState.hoverBoxIndex;
                const showHandles = canEdit && (isHovered || isSelected);
                
                censorOverlayCtx.save();
                censorOverlayCtx.translate(cx, cy);
                censorOverlayCtx.rotate(rotation);
                censorOverlayCtx.translate(-cx, -cy);
                
                if (isDeleteMode && isHovered) {
                    censorOverlayCtx.strokeStyle = 'rgba(255, 80, 80, 1)';
                    censorOverlayCtx.lineWidth = 3;
                    censorOverlayCtx.setLineDash([]);
                    censorOverlayCtx.strokeRect(sx, sy, sw, sh);
                    censorOverlayCtx.fillStyle = 'rgba(255, 80, 80, 0.3)';
                    censorOverlayCtx.fillRect(sx, sy, sw, sh);
                } else if (showHandles) {
                    censorOverlayCtx.strokeStyle = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.9)';
                    censorOverlayCtx.lineWidth = 2;
                    censorOverlayCtx.setLineDash([]);
                    censorOverlayCtx.strokeRect(sx, sy, sw, sh);
                    
                    const hs = 7;
                    const handleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.95)';
                    censorOverlayCtx.fillStyle = handleColor;
                    
                    censorOverlayCtx.fillRect(sx - hs/2, sy - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx + sw - hs/2, sy - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx - hs/2, sy + sh - hs/2, hs, hs);
                    censorOverlayCtx.fillRect(sx + sw - hs/2, sy + sh - hs/2, hs, hs);
                    
                    const ehs = 5;
                    censorOverlayCtx.fillRect(cx - ehs/2, sy - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(cx - ehs/2, sy + sh - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(sx - ehs/2, cy - ehs/2, ehs, ehs);
                    censorOverlayCtx.fillRect(sx + sw - ehs/2, cy - ehs/2, ehs, ehs);
                    
                    // 회전 핸들 (선택 또는 호버 시 모두)
                    const rotateY = sy - 25;
                    const rotHandleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.95)';
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.strokeStyle = rotHandleColor;
                    censorOverlayCtx.lineWidth = 1;
                    censorOverlayCtx.moveTo(cx, sy);
                    censorOverlayCtx.lineTo(cx, rotateY + 6);
                    censorOverlayCtx.stroke();
                    
                    censorOverlayCtx.fillStyle = rotHandleColor;
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.arc(cx, rotateY, 6, 0, Math.PI * 2);
                    censorOverlayCtx.fill();
                    
                    censorOverlayCtx.fillStyle = isSelected ? 'white' : 'rgba(0, 0, 0, 0.7)';
                    censorOverlayCtx.font = '8px sans-serif';
                    censorOverlayCtx.textAlign = 'center';
                    censorOverlayCtx.textBaseline = 'middle';
                    censorOverlayCtx.fillText('↻', cx, rotateY);
                }
                
                censorOverlayCtx.restore();
            });
        }
        
        // 검열후 탭 재렌더링
        function redrawAfterPreview() {
            if (censorState.currentTab !== 'after' || !censorState.originalImageObj) return;
            
            const img = censorState.originalImageObj;
            const displayW = censorPreviewCanvas.width;
            const displayH = censorPreviewCanvas.height;
            
            // 원본(검열된) 이미지 다시 그리기
            censorPreviewCtx.drawImage(img, 0, 0, displayW, displayH);
            // 추가 편집 오버레이
            drawAfterTabOverlay(img, displayW, displayH);
        }
        
        // 검열후 탭 편집 변경 표시
        function markAfterEditDirty() {
            if (censorState.currentTab !== 'after') return;
            censorState.afterEditDirty = true;
            const saveBtn = document.getElementById('censorAfterSaveBtn');
            if (saveBtn) saveBtn.disabled = false;
        }
        
        // 검열후 탭 저장
        async function saveAfterEdit() {
            if (!censorState.currentImage || censorState.editBoxes.length === 0) {
                showToast('저장할 편집 내용이 없습니다', 'warning');
                return;
            }
            
            const method = document.getElementById('censorAfterMethod').value;
            const boxes = censorState.editBoxes.map(d => ({
                box: d.box,
                method: d.method || method,
                rotation: d.rotation || 0
            }));
            
            const imagePath = censorState.currentImage.path;
            const pathParts = imagePath.split(/[\/\\]/);
            const outputFolder = pathParts.length > 1 ? pathParts.slice(0, -1).join('/') : '';
            
            try {
                const response = await fetch(`${API_BASE}/api/censor/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_path: imagePath,
                        boxes: boxes,
                        method: method,
                        output_folder: outputFolder,
                        filename: censorState.currentImage.filename,
                        source: 'censored'
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showToast('저장 완료', 'success');
                    censorState.afterEditDirty = false;
                    censorState.editBoxes = [];
                    document.getElementById('censorAfterSaveBtn').disabled = true;
                    // 현재 이미지 새로고침
                    selectCensorImage(censorState.currentIndex);
                } else {
                    showToast('저장 실패: ' + result.error, 'error');
                }
            } catch (err) {
                showToast('저장 오류: ' + err.message, 'error');
            }
        }
        
        // 감지 박스 그리기 (검열 전 탭용 - 점선)
        function drawDetectionBoxes() {
            drawEditBoxes();
        }
        
        // 현재 이미지 스캔
        async function scanCurrentImage() {
            if (!censorState.currentImage) return;
            
            const scanRequestId = censorState.wheelRequestId;  // 스캔 시작 시점의 requestId 저장
            const scanImagePath = censorState.currentImage.path;  // 스캔 대상 이미지 경로 저장
            
            // 활성화된 타겟 클래스
            const targetLabels = [];
            const labelConf = {};
            document.querySelectorAll('#censorTargets input[type="checkbox"]:checked').forEach(cb => {
                const cls = cb.dataset.class;
                targetLabels.push(cls);
                labelConf[cls] = censorState.labelConf[cls] || 0.3;
            });
            
            if (targetLabels.length === 0) {
                censorState.detections = [];
                drawDetectionBoxes();
                return;
            }
            
            try {
                const model = document.getElementById('censorModel').value;
                const response = await fetch(`${API_BASE}/api/censor/scan`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_path: scanImagePath,
                        model: model,
                        target_labels: targetLabels,
                        label_conf: labelConf,
                        return_all: true  // 모든 감지 반환 (threshold 이하 포함)
                    })
                });
                
                const result = await response.json();
                
                // 스캔 완료 후 다른 이미지로 넘어갔으면 결과 무시
                if (scanRequestId !== censorState.wheelRequestId || 
                    censorState.currentImage?.path !== scanImagePath) {
                    return;
                }
                
                if (result.success) {
                    censorState.detections = result.detections || [];
                    drawDetectionBoxes();
                }
            } catch (err) {
                console.error('Scan failed:', err);
            }
        }
        
        // 프리뷰 초기화
        function clearCensorPreview() {
            if (censorPreviewCtx) {
                censorPreviewCtx.clearRect(0, 0, censorPreviewCanvas.width, censorPreviewCanvas.height);
            }
            if (censorOverlayCtx) {
                censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);
            }
            censorState.currentImage = null;
            censorState.detections = [];
            document.getElementById('censorPreviewEmpty').style.display = 'flex';
        }
        
        // 전체 검열 실행 → 검열중 탭으로 전환
        async function runBatchCensor() {
            const model = document.getElementById('censorModel').value;
            const method = document.getElementById('censorMethod').value;
            
            // 활성화된 타겟 클래스
            const targetLabels = [];
            const labelConf = {};
            document.querySelectorAll('#censorTargets input[type="checkbox"]:checked').forEach(cb => {
                const cls = cb.dataset.class;
                targetLabels.push(cls);
                labelConf[cls] = censorState.labelConf[cls] || 0.3;
            });
            
            if (targetLabels.length === 0) {
                showToast('검열 대상을 선택하세요', 'warning');
                return;
            }
            
            if (censorState.images.length === 0) {
                showToast('검열할 이미지가 없습니다', 'warning');
                return;
            }
            
            // 버튼 비활성화
            const runBtn = document.getElementById('censorRunAllBtn');
            runBtn.disabled = true;
            runBtn.textContent = '⏳ 스캔 중...';
            
            const totalCount = censorState.images.length;
            
            // 토스트로 진행 상황 표시 (사라지지 않는 토스트)
            showToast(`스캔 중... 0/${totalCount} (0%)`, 'info', 0);
            
            // 검열중 모드 활성화
            censorState.processingMode = true;
            censorState.processingResults = {};
            censorState.processingMethod = method;
            censorState.processingImages = [];
            
            // 모든 이미지에 대해 스캔 수행
            let scannedCount = 0;
            let detectedCount = 0;
            
            for (const imgInfo of censorState.images) {
                try {
                    const response = await fetch(`${API_BASE}/api/censor/scan`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image_path: imgInfo.path,
                            model: model,
                            target_labels: targetLabels,
                            label_conf: labelConf
                        })
                    });
                    
                    const result = await response.json();
                    // 감지 여부와 관계없이 모든 이미지를 processingImages에 추가
                    const detections = (result.success && result.detections) ? result.detections : [];
                    censorState.processingResults[imgInfo.path] = {
                        detections: detections,
                        editBoxes: detections.map(d => ({
                            box: Array.isArray(d.box) ? [d.box[0], d.box[1], d.box[2], d.box[3]] : d.box,
                            label: d.label,
                            confidence: d.confidence,
                            method: method
                        }))
                    };
                    censorState.processingImages.push(imgInfo.path);
                    if (detections.length > 0) {
                        detectedCount++;
                    }
                    scannedCount++;
                    
                    // 토스트 업데이트
                    const percent = Math.round((scannedCount / totalCount) * 100);
                    showToast(`스캔 중... ${scannedCount}/${totalCount} (${percent}%)`, 'info', 0);
                } catch (err) {
                    console.error('Scan failed for:', imgInfo.path, err);
                    scannedCount++;
                    // 실패해도 토스트 업데이트
                    const percent = Math.round((scannedCount / totalCount) * 100);
                    showToast(`스캔 중... ${scannedCount}/${totalCount} (${percent}%)`, 'info', 0);
                }
            }
            
            // 버튼 복원
            runBtn.disabled = false;
            runBtn.textContent = '🔍 전체 검열';
            
            if (scannedCount === 0) {
                showToast('스캔할 이미지가 없습니다', 'warning');
                censorState.processingMode = false;
                censorState.processingResults = {};
                return;
            }
            
            showToast(`스캔 완료: ${detectedCount}/${scannedCount} 이미지에서 감지`, 'success');

            // 이벤트가 초기화되지 않았으면 초기화
            if (!censorState.eventsInitialized) {
                setupCensorEvents();
                censorState.eventsInitialized = true;
            }

            // 검열중 탭 표시 및 전환
            document.getElementById('censorTabProcessing').style.display = 'inline-block';
            document.getElementById('censorProcMethod').value = method;

            // 이전 탭의 상태 초기화 (editBoxes 덮어쓰기 방지)
            censorState.currentImage = null;
            censorState.editBoxes = [];

            switchCensorTab('processing');
        }
        
        // 검열중 모드에서 이미지 선택
        async function selectProcessingImage(index) {
            const images = censorState.processingImages;
            if (index < 0 || index >= images.length) return;
            
            // 현재 이미지의 editBoxes를 저장 (이미 검열중 탭에 있을 때만)
            if (censorState.currentTab === 'processing' && 
                censorState.currentImage && 
                images.includes(censorState.currentImage.path) &&
                censorState.processingResults[censorState.currentImage.path]) {
                censorState.processingResults[censorState.currentImage.path].editBoxes = censorState.editBoxes.map(b => ({...b, box: [...b.box]}));
            }
            
            censorState.currentIndex = index;
            const imagePath = images[index];
            
            // 썸네일 활성화 표시 및 자동 스크롤
            const thumbnails = document.querySelectorAll('.censor-thumbnail');
            thumbnails.forEach((t, i) => {
                t.classList.toggle('active', i === index);
            });
            // 선택된 썸네일이 보이도록 자동 스크롤
            if (thumbnails[index]) {
                thumbnails[index].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            }

            // 진행 상황 표시 (기존 하단 - 제거됨)
            // document.getElementById('censorProcProgress').textContent = `${index + 1} / ${images.length}`;

            // 이미지 번호 표시 (새로운 위치)
            document.getElementById('censorImageCounter').textContent = `${index + 1} / ${images.length}`;

            // 화살표 버튼 활성화/비활성화
            const leftBtn = document.getElementById('censorNavLeft');
            const rightBtn = document.getElementById('censorNavRight');
            leftBtn.disabled = index === 0;
            rightBtn.disabled = index === images.length - 1;
            
            // 이미지 로드 (LRU 캐시 우선, FileResponse 사용)
            try {
                const cacheKey = `uncensored:${imagePath}`;
                let cached = censorCacheGet(cacheKey);

                // 캐시에 없으면 FileResponse로 로드
                if (!cached) {
                    const img = await loadCensorImageFile('uncensored', imagePath);
                    cached = {
                        img,
                        width: img.naturalWidth,
                        height: img.naturalHeight,
                        filename: imagePath.split('/').pop()
                    };
                    censorCacheSet(cacheKey, cached);
                }

                // currentImage 설정 (Image 객체 직접 저장)
                censorState.currentImage = {
                    path: imagePath,
                    filename: cached.filename,
                    width: cached.width,
                    height: cached.height,
                    imgObj: cached.img
                };

                // 저장된 결과에서 editBoxes 로드
                const procResult = censorState.processingResults[imagePath];
                if (procResult) {
                    censorState.detections = procResult.detections || [];
                    censorState.editBoxes = (procResult.editBoxes || []).map(b => ({
                        ...b,
                        box: Array.isArray(b.box) ? [...b.box] : b.box
                    }));
                    console.log('Loaded editBoxes:', JSON.stringify(censorState.editBoxes));
                } else {
                    censorState.detections = [];
                    censorState.editBoxes = [];
                }
                censorState.selectedBoxIndex = -1;

                drawCensorPreview();
            } catch (err) {
                console.error('Failed to load image:', err);
            }
        }
        
        // 검열 완료 (저장 후 검열중 탭 숨김)
        async function completeCensoring() {
            if (!censorState.processingMode || Object.keys(censorState.processingResults).length === 0) {
                showToast('저장할 검열 결과가 없습니다', 'warning');
                return;
            }
            
            // 현재 이미지의 editBoxes를 저장 (검증 포함)
            if (censorState.currentImage && censorState.processingResults[censorState.currentImage.path]) {
                const validBoxes = censorState.editBoxes.filter(b => {
                    if (!b.box || !Array.isArray(b.box) || b.box.length !== 4) {
                        console.error('Invalid box in current editBoxes:', b);
                        return false;
                    }
                    return true;
                });
                censorState.processingResults[censorState.currentImage.path].editBoxes = validBoxes.map(b => ({
                    ...b,
                    box: [b.box[0], b.box[1], b.box[2], b.box[3]]
                }));
            }
            
            const method = document.getElementById('censorProcMethod')?.value || censorState.processingMethod;
            const outputFolder = censorState.currentUncensoredFolder || '';
            let savedCount = 0;
            let failedCount = 0;
            const totalCount = censorState.processingImages.length;
            
            showToast(`저장 중... 0/${totalCount} (0%)`, 'info', 0);
            
            for (let i = 0; i < censorState.processingImages.length; i++) {
                const imagePath = censorState.processingImages[i];
                const result = censorState.processingResults[imagePath];
                
                try {
                    // 원본 데이터 로깅 (상세)
                    console.log('=== Saving image:', imagePath, '===');
                    console.log('Raw editBoxes count:', result?.editBoxes?.length || 0);
                    result?.editBoxes?.forEach((d, idx) => {
                        console.log(`  Box ${idx}: box=${JSON.stringify(d.box)}, method=${d.method}, label=${d.label}`);
                    });
                    
                    // 박스 데이터 검증 및 변환 (박스 없으면 빈 배열 - 원본 복사됨)
                    const boxes = (result?.editBoxes || [])
                        .filter(d => {
                            if (!d.box) {
                                console.error(`Invalid box (no box property):`, d);
                                return false;
                            }
                            if (!Array.isArray(d.box)) {
                                console.error(`Invalid box (not array): type=${typeof d.box}, value=`, d.box);
                                return false;
                            }
                            if (d.box.length !== 4) {
                                console.error(`Invalid box (wrong length): len=${d.box.length}, box=`, d.box);
                                return false;
                            }
                            // 각 좌표가 숫자인지 확인
                            for (let i = 0; i < 4; i++) {
                                if (typeof d.box[i] !== 'number' || isNaN(d.box[i])) {
                                    console.error(`Invalid box (bad coordinate at index ${i}): box=`, d.box);
                                    return false;
                                }
                            }
                            return true;
                        })
                        .map(d => ({
                            box: [Math.round(d.box[0]), Math.round(d.box[1]), Math.round(d.box[2]), Math.round(d.box[3])],
                            method: d.method || method,
                            rotation: d.rotation || 0  // 회전 값 포함
                        }));
                    
                    // 박스 없어도 저장 (원본 이미지가 그대로 복사됨)
                    console.log('Saving:', imagePath, 'boxes:', boxes.length, '(empty = copy original)');
                    
                    console.log('Saving details:', imagePath, 'boxes:', JSON.stringify(boxes), 'outputFolder:', outputFolder);
                    
                    const response = await fetch(`${API_BASE}/api/censor/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image_path: imagePath,
                            boxes: boxes,
                            method: method,
                            output_folder: outputFolder
                        })
                    });
                    
                    const saveResult = await response.json();
                    console.log('Save result:', saveResult);
                    
                    if (saveResult.success) {
                        savedCount++;
                    } else {
                        failedCount++;
                        console.error('Save returned failure:', saveResult);
                    }
                } catch (err) {
                    failedCount++;
                    console.error('Save failed:', imagePath, err);
                }
                
                // 진행률 업데이트
                const percent = Math.round(((i + 1) / totalCount) * 100);
                showToast(`저장 중... ${i + 1}/${totalCount} (${percent}%)`, 'info', 0);
            }
            
            if (savedCount > 0) {
                showToast(`저장 완료: ${savedCount}/${totalCount} 이미지`, 'success');
                
                // 검열 후 폴더를 저장된 폴더로 변경
                censorState.currentCensoredFolder = outputFolder;
                document.getElementById('censorCensoredFolderName').textContent = outputFolder || 'censored';
                
                // 저장된 이미지들의 censored 캐시 무효화 (덮어쓴 파일의 이전 캐시 제거)
                censorState.processingImages.forEach(imagePath => {
                    // Windows/Unix 경로 모두 처리
                    const filename = imagePath.split(/[\/\\]/).pop();
                    const censoredPath = outputFolder ? `${outputFolder}/${filename}` : filename;
                    const cacheKey = `censored:${censoredPath}`;
                    console.log('[Cache] Deleting:', cacheKey, 'exists:', censorState.imgCache.has(cacheKey));
                    censorState.imgCache.delete(cacheKey);
                });
                // 전체 censored 캐시도 삭제 (확실하게)
                for (const key of censorState.imgCache.keys()) {
                    if (key.startsWith('censored:')) {
                        console.log('[Cache] Also deleting:', key);
                        censorState.imgCache.delete(key);
                    }
                }
            } else if (failedCount > 0) {
                showToast(`저장 실패: ${failedCount}개 이미지`, 'error');
            } else {
                showToast('저장할 검열 영역이 없습니다', 'warning');
            }
            
            // 검열중 모드 종료
            exitProcessingMode();

            // 검열후 탭 인덱스 리셋 (첫 이미지부터 보여주기 위해)
            censorState.afterIndex = 0;
            censorState.currentIndex = 0;

            // 검열된 이미지 목록 클리어 (새로 로드하도록)
            censorState.censoredImages = [];
            
            // 강제 새로고침 플래그 설정
            censorState.forceReloadAfterTab = true;

            // 검열 후 탭으로 전환
            switchCensorTab('after');
        }
        
        // 검열중 모드 취소/종료
        function exitProcessingMode() {
            censorState.processingMode = false;
            censorState.processingResults = {};
            censorState.processingImages = [];
            censorState.editBoxes = [];
            censorState.detections = [];
            censorState.currentImage = null;
            censorState.originalImageObj = null;
            
            // 캔버스 클리어
            if (censorPreviewCtx) {
                censorPreviewCtx.clearRect(0, 0, censorPreviewCanvas.width, censorPreviewCanvas.height);
            }
            if (censorOverlayCtx) {
                censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);
            }
            
            // 검열중 탭 숨김
            document.getElementById('censorTabProcessing').style.display = 'none';
        }
        
        // 검열 취소
        function cancelCensoring() {
            exitProcessingMode();
            switchCensorTab('before');
        }
        
        // 탭 전환
        function switchCensorTab(tab) {
            // 현재 탭의 인덱스 저장
            if (censorState.currentTab === 'before') {
                censorState.beforeIndex = censorState.currentIndex;
            } else if (censorState.currentTab === 'after') {
                censorState.afterIndex = censorState.currentIndex;
            }

            censorState.currentTab = tab;

            // 새 탭의 인덱스 복원
            if (tab === 'before') {
                // 검열전 탭: 첫 방문이면 0, 아니면 저장된 인덱스
                if (!censorState.beforeTabVisited) {
                    censorState.currentIndex = 0;
                    censorState.beforeTabVisited = true;
                } else {
                    censorState.currentIndex = censorState.beforeIndex;
                }
            } else if (tab === 'after') {
                // 검열후 탭: 항상 저장된 인덱스 사용 (기본값 0)
                censorState.currentIndex = censorState.afterIndex;
            } else {
                censorState.currentIndex = 0;
            }

            // 휠 디바운스 타이머 클리어
            if (censorState.wheelDebounceTimer) {
                clearTimeout(censorState.wheelDebounceTimer);
                censorState.wheelDebounceTimer = null;
            }
            
            // 스캔 로딩 숨기기 + 진행 중인 스캔 무효화
            showCensorScanLoading(false);
            censorState.wheelRequestId++;  // 진행 중인 스캔 결과 무시하도록

            // 탭 버튼 활성화 상태
            document.getElementById('censorTabBefore').classList.toggle('active', tab === 'before');
            document.getElementById('censorTabProcessing').classList.toggle('active', tab === 'processing');
            document.getElementById('censorTabAfter').classList.toggle('active', tab === 'after');

            // 하단 옵션 패널 표시
            document.getElementById('censorOptionsBefore').style.display = tab === 'before' ? 'flex' : 'none';
            document.getElementById('censorOptionsProcessing').style.display = tab === 'processing' ? 'flex' : 'none';
            document.getElementById('censorOptionsAfter').style.display = tab === 'after' ? 'flex' : 'none';

            // 프리뷰 영역 배경 구분 (검열중 탭만 다른 배경)
            document.querySelector('.censor-preview-area')?.classList.toggle('processing', tab === 'processing');

            // 네비게이션 화살표 및 카운터 항상 표시
            const navLeft = document.getElementById('censorNavLeft');
            const navRight = document.getElementById('censorNavRight');
            const imageCounter = document.getElementById('censorImageCounter');

            // 모든 탭에서 표시
            navLeft.style.display = 'flex';
            navRight.style.display = 'flex';
            imageCounter.style.display = 'block';

            // 초기 상태 설정
            navLeft.disabled = true;
            navRight.disabled = true;
            imageCounter.textContent = '0 / 0';
            
            // 탭 전환 시 캔버스 및 상태 초기화
            if (censorPreviewCtx) {
                censorPreviewCtx.clearRect(0, 0, censorPreviewCanvas.width, censorPreviewCanvas.height);
            }
            if (censorOverlayCtx) {
                censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);
            }
            // 빈 상태 표시
            document.getElementById('censorPreviewEmpty').style.display = 'flex';

            // 이전 탭의 detections/editBoxes 상태 초기화
            censorState.detections = [];
            censorState.editBoxes = [];
            censorState.selectedBoxIndex = -1;
            censorState.hoverBoxIndex = -1;
            censorState.currentImage = null;
            censorState.originalImageObj = null;
            
            // 폴더 드롭다운 표시/숨김
            document.getElementById('censorFolderBefore').style.display = tab === 'before' ? 'flex' : 'none';
            document.getElementById('censorFolderAfter').style.display = tab === 'after' ? 'flex' : 'none';
            
            // 검열중 탭이면 processingImages 기반 썸네일 렌더링
            if (tab === 'processing') {
                // 도구 상태 초기화
                censorState.currentTool = 'select';
                censorState.selectedBoxIndex = -1;
                censorState.hoverBoxIndex = -1;
                // 도구 버튼 활성화 상태 초기화
                ['procToolSelect', 'procToolAdd', 'procToolDelete'].forEach((id, i) => {
                    document.getElementById(id)?.classList.toggle('active', i === 0);
                });
                
                renderProcessingThumbnails();
                if (censorState.processingImages.length > 0) {
                    selectProcessingImage(0);
                }
            } else if (tab === 'after') {
                // 검열후 탭 도구 상태 초기화
                censorState.currentTool = 'select';
                censorState.selectedBoxIndex = -1;
                censorState.hoverBoxIndex = -1;
                censorState.afterEditDirty = false;
                // 도구 버튼 활성화 상태 초기화
                ['afterToolSelect', 'afterToolAdd', 'afterToolDelete'].forEach((id, i) => {
                    document.getElementById(id)?.classList.toggle('active', i === 0);
                });
                // 저장 버튼 비활성화
                const saveBtn = document.getElementById('censorAfterSaveBtn');
                if (saveBtn) {
                    saveBtn.disabled = true;
                }

                // 이미지 목록이 비어있거나 강제 새로고침이면 새로 로드
                const currentImages = censorState.censoredImages;
                if (currentImages.length === 0 || censorState.forceReloadAfterTab) {
                    censorState.forceReloadAfterTab = false;
                    // 새로 로드 후 첫 이미지 선택
                    loadCensorImages().then(() => {
                        if (censorState.censoredImages.length > 0) {
                            selectCensorImage(0);
                        }
                    });
                } else {
                    // 기존 이미지로 썸네일만 렌더링
                    renderCensorThumbnails(currentImages);
                    // 저장된 인덱스의 이미지 선택
                    const validIndex = Math.min(censorState.currentIndex, currentImages.length - 1);
                    selectCensorImage(validIndex);
                }
            } else {
                // 이미 로드된 이미지가 있으면 다시 로드하지 않음
                const currentImages = censorState.images;
                if (currentImages.length === 0) {
                    loadCensorImages();
                } else {
                    // 기존 이미지로 썸네일만 렌더링
                    renderCensorThumbnails(currentImages);
                    // 저장된 인덱스의 이미지 선택
                    const validIndex = Math.min(censorState.currentIndex, currentImages.length - 1);
                    selectCensorImage(validIndex);
                }
            }
        }
        
        // 검열중 탭 썸네일 렌더링
        function renderProcessingThumbnails() {
            const container = document.getElementById('censorThumbnails');
            const images = censorState.processingImages;
            
            if (images.length === 0) {
                container.innerHTML = '<div class="censor-loading">검열 대상이 없습니다</div>';
                return;
            }
            
            // 원본 images에서 해당 경로의 썸네일 찾기
            container.innerHTML = images.map((path, index) => {
                const imgInfo = censorState.images.find(img => img.path === path);
                const thumb = imgInfo?.thumbnail || '';
                return `
                    <div class="censor-thumbnail ${index === 0 ? 'active' : ''}" 
                         data-index="${index}" data-path="${path}">
                        <img src="data:image/jpeg;base64,${thumb}" alt="">
                    </div>
                `;
            }).join('');
            
            // 클릭 이벤트
            container.querySelectorAll('.censor-thumbnail').forEach(thumb => {
                thumb.onclick = async () => {
                    const index = parseInt(thumb.dataset.index);
                    await selectProcessingImage(index);
                };
            });
        }
        
        // 이벤트 설정
        function setupCensorEvents() {
            // 탭 전환
            document.getElementById('censorTabBefore').onclick = () => {
                if (censorState.processingMode) {
                    if (!confirm('검열 작업이 진행중입니다. 취소하시겠습니까?')) return;
                    exitProcessingMode();
                }
                switchCensorTab('before');
            };
            document.getElementById('censorTabProcessing').onclick = () => {
                if (censorState.processingMode) {
                    switchCensorTab('processing');
                }
            };
            document.getElementById('censorTabAfter').onclick = () => {
                if (censorState.processingMode) {
                    if (!confirm('검열 작업이 진행중입니다. 취소하시겠습니까?')) return;
                    exitProcessingMode();
                }
                // 검열후 탭으로 전환 시 항상 afterIndex 값 사용 (탭 간 이동 시 인덱스 독립)
                switchCensorTab('after');
            };
            
            // 모델 변경
            document.getElementById('censorModel').onchange = async function() {
                await loadModelClasses(this.value);
                if (censorState.currentImage && censorState.currentTab === 'before') {
                    await scanCurrentImage();
                }
                saveCensorSettings();
            };
            
            // 검열 방식 변경
            document.getElementById('censorMethod').onchange = function() {
                saveCensorSettings();
            };
            
            // 폴더 드롭다운 버튼 클릭 이벤트
            document.getElementById('censorUncensoredFolderBtn').onclick = (e) => toggleCensorFolderMenu('uncensored', e);
            document.getElementById('censorCensoredFolderBtn').onclick = (e) => toggleCensorFolderMenu('censored', e);
            
            // 외부 클릭 시 폴더 메뉴 닫기
            document.addEventListener('click', (e) => {
                const folderBefore = document.getElementById('censorFolderBefore');
                const folderAfter = document.getElementById('censorFolderAfter');
                const menuBefore = document.getElementById('censorUncensoredFolderMenu');
                const menuAfter = document.getElementById('censorCensoredFolderMenu');
                
                if (folderBefore && !folderBefore.contains(e.target) && menuBefore && !menuBefore.contains(e.target)) {
                    if (menuBefore.classList.contains('show')) {
                        menuBefore.classList.remove('show');
                        if (menuBefore.parentElement === document.body) {
                            folderBefore.appendChild(menuBefore);
                        }
                    }
                }
                if (folderAfter && !folderAfter.contains(e.target) && menuAfter && !menuAfter.contains(e.target)) {
                    if (menuAfter.classList.contains('show')) {
                        menuAfter.classList.remove('show');
                        if (menuAfter.parentElement === document.body) {
                            folderAfter.appendChild(menuAfter);
                        }
                    }
                }
            });
            
            // 폴더 추가 버튼
            document.getElementById('censorAddUncensoredBtn').onclick = () => {
                closeCensorFolderMenus();
                showInputModal('📁 새 폴더', '폴더 이름을 입력하세요', async (folderName) => {
                    if (!folderName) return;
                    try {
                        const response = await fetch(`${API_BASE}/api/censor/folders`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ type: 'uncensored', name: folderName })
                        });
                        const result = await response.json();
                        if (result.success) {
                            showToast(`폴더 생성: ${folderName}`, 'success');
                            selectCensorFolder('uncensored', folderName);
                        } else {
                            showToast(result.error || '폴더 생성 실패', 'error');
                        }
                    } catch (err) {
                        showToast('폴더 생성 오류', 'error');
                    }
                });
            };
            
            document.getElementById('censorAddCensoredBtn').onclick = () => {
                closeCensorFolderMenus();
                showInputModal('📁 새 폴더', '폴더 이름을 입력하세요', async (folderName) => {
                    if (!folderName) return;
                    try {
                        const response = await fetch(`${API_BASE}/api/censor/folders`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ type: 'censored', name: folderName })
                        });
                        const result = await response.json();
                        if (result.success) {
                            showToast(`폴더 생성: ${folderName}`, 'success');
                            selectCensorFolder('censored', folderName);
                        } else {
                            showToast(result.error || '폴더 생성 실패', 'error');
                        }
                    } catch (err) {
                        showToast('폴더 생성 오류', 'error');
                    }
                });
            };
            
            // 폴더 열기 버튼 (현재 탭에 따라 다른 폴더 열기)
            document.getElementById('censorOpenFolderBtn').onclick = async () => {
                const folder = censorState.currentTab === 'before' ? 'uncensored' : 'censored';
                const subfolder = censorState.currentTab === 'before' 
                    ? censorState.currentUncensoredFolder 
                    : censorState.currentCensoredFolder;
                try {
                    const response = await fetch(`${API_BASE}/api/open-folder`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ folder: folder, subfolder: subfolder })
                    });
                    const result = await response.json();
                    if (result.error) {
                        showToast('폴더 열기 실패', 'error');
                    }
                } catch (err) {
                    showToast('폴더 열기 실패', 'error');
                }
            };
            
            // 전체 검열 실행
            document.getElementById('censorRunAllBtn').onclick = runBatchCensor;

            // === 네비게이션 화살표 버튼 ===
            document.getElementById('censorNavLeft').onclick = () => {
                if (censorState.currentIndex > 0) {
                    if (censorState.currentTab === 'processing') {
                        selectProcessingImage(censorState.currentIndex - 1);
                    } else {
                        // before, after 탭 모두 selectCensorImage 사용
                        selectCensorImage(censorState.currentIndex - 1);
                    }
                }
            };
            document.getElementById('censorNavRight').onclick = () => {
                const maxIndex = censorState.currentTab === 'processing'
                    ? censorState.processingImages.length - 1
                    : censorState.currentTab === 'before'
                    ? censorState.images.length - 1
                    : censorState.censoredImages.length - 1;

                if (censorState.currentIndex < maxIndex) {
                    if (censorState.currentTab === 'processing') {
                        selectProcessingImage(censorState.currentIndex + 1);
                    } else {
                        // before, after 탭 모두 selectCensorImage 사용
                        selectCensorImage(censorState.currentIndex + 1);
                    }
                }
            };

            // === UI 즉시 업데이트 헬퍼 함수 ===
            function updateCensorNavigationUI(index, maxIndex) {
                // 썸네일 활성화 표시
                document.querySelectorAll('.censor-thumbnail').forEach((t, i) => {
                    t.classList.toggle('active', i === index);
                });

                // 이미지 번호 표시
                document.getElementById('censorImageCounter').textContent = `${index + 1} / ${maxIndex + 1}`;

                // 화살표 버튼 활성화/비활성화
                const leftBtn = document.getElementById('censorNavLeft');
                const rightBtn = document.getElementById('censorNavRight');
                leftBtn.disabled = index === 0;
                rightBtn.disabled = index === maxIndex;
            }

            // === 마우스 휠로 이미지 전환 ===
            const censorPreviewArea = document.querySelector('.censor-preview-area');

            // 휠 핸들러 함수 (중복 등록 방지를 위해 명명)
            if (!window.censorWheelHandler) {
                window.censorWheelHandler = (e) => {
                    e.preventDefault();

                    const delta = e.deltaY;

                    // 현재 탭의 최대 인덱스 계산
                    const maxIndex = censorState.currentTab === 'processing'
                        ? censorState.processingImages.length - 1
                        : censorState.currentTab === 'before'
                        ? censorState.images.length - 1
                        : censorState.censoredImages.length - 1;

                    // 새 인덱스 계산
                    let newIndex = censorState.currentIndex;
                    if (delta > 0 && newIndex < maxIndex) {
                        newIndex++;
                    } else if (delta < 0 && newIndex > 0) {
                        newIndex--;
                    }

                    // 인덱스가 변경된 경우에만 처리
                    if (newIndex !== censorState.currentIndex) {
                        // 검열전 탭: 스캔 디바운스 처리
                        if (censorState.currentTab === 'before') {
                            // 즉시 이미지만 로드 (스캔은 스킵)
                            selectCensorImage(newIndex, { skipScan: true });
                            
                            // 로딩 표시
                            showCensorScanLoading(true);
                            
                            // 스캔은 휠 멈춘 후에만 실행
                            if (censorState.wheelDebounceTimer) {
                                clearTimeout(censorState.wheelDebounceTimer);
                            }
                            censorState.wheelDebounceTimer = setTimeout(async () => {
                                const scanRequestId = censorState.wheelRequestId;
                                if (censorState.currentImage) {
                                    await scanCurrentImage();
                                    // 스캔 완료 후 다른 이미지로 넘어갔으면 무시
                                    if (scanRequestId === censorState.wheelRequestId) {
                                        showCensorScanLoading(false);
                                        drawCensorPreview();
                                    }
                                }
                            }, 200);
                        } else if (censorState.currentTab === 'processing') {
                            // 검열중 탭: selectProcessingImage 사용
                            selectProcessingImage(newIndex);
                        } else {
                            // 검열후 탭: 일반 selectCensorImage 사용
                            selectCensorImage(newIndex);
                        }
                    }
                };
            }

            // 프리뷰 영역 전체에 휠 이벤트 등록 (이미지 배경에서도 작동)
            if (censorPreviewArea) {
                censorPreviewArea.removeEventListener('wheel', window.censorWheelHandler);
                censorPreviewArea.addEventListener('wheel', window.censorWheelHandler, { passive: false });
            }

            // 썸네일 리스트에는 좌우 스크롤 허용 (기본 동작)
            const censorThumbnails = document.getElementById('censorThumbnails');
            if (censorThumbnails) {
                censorThumbnails.addEventListener('wheel', (e) => {
                    // 썸네일 영역에서는 좌우 스크롤만 허용 (이미지 전환 방지)
                    e.stopPropagation();
                    // 세로 휠을 가로 스크롤로 변환
                    if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
                        censorThumbnails.scrollLeft += e.deltaY;
                        e.preventDefault();
                    }
                }, { passive: false });
            }

            // === 우클릭으로 박스 삭제 ===
            const censorOverlayCanvas = document.getElementById('censorOverlayCanvas');
            censorOverlayCanvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();

                if (!censorState.currentImage) return;

                // 편집 불가능한 탭(검열전)에서는 삭제 비활성화
                if (!isEditableTab()) return;

                // 클릭 위치 계산
                const rect = censorOverlayCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // 캔버스 좌표를 이미지 좌표로 변환
                const canvas = document.getElementById('censorPreviewCanvas');
                const scaleX = censorState.currentImage.width / canvas.width;
                const scaleY = censorState.currentImage.height / canvas.height;
                const imgX = x * scaleX;
                const imgY = y * scaleY;

                // 클릭 위치의 박스 찾기
                for (let i = censorState.editBoxes.length - 1; i >= 0; i--) {
                    const box = censorState.editBoxes[i].box;
                    const [x1, y1, x2, y2] = box;
                    if (imgX >= x1 && imgX <= x2 && imgY >= y1 && imgY <= y2) {
                        // 박스 삭제
                        censorState.editBoxes.splice(i, 1);
                        censorState.selectedBoxIndex = -1;
                        censorState.hoverBoxIndex = -1;

                        // 검열중 탭: processingResults에도 반영
                        if (censorState.currentTab === 'processing' && censorState.currentImage) {
                            const path = censorState.currentImage.path;
                            if (censorState.processingResults[path]) {
                                censorState.processingResults[path].editBoxes = [...censorState.editBoxes];
                            }
                        }

                        // 검열후 탭: dirty 표시
                        if (censorState.currentTab === 'after') {
                            markAfterEditDirty();
                        }

                        redrawCurrentTab();
                        break;
                    }
                }
            });

            // === 검열중 탭 이벤트 ===
            // 검열중/검열후 탭에서도 공통 네비게이션 화살표 사용 (censorNavLeft/Right)
            // 화살표 버튼 이벤트는 아래 "=== 네비게이션 화살표 버튼 ===" 섹션에서 처리됨

            document.getElementById('censorCompleteBtn').onclick = completeCensoring;
            document.getElementById('censorCancelBtn').onclick = cancelCensoring;
            
            // 검열중 탭 방식 변경 시 재렌더링
            document.getElementById('censorProcMethod').onchange = function() {
                censorState.processingMethod = this.value;
                // 현재 이미지의 모든 박스 방식 변경
                censorState.editBoxes.forEach(box => {
                    box.method = this.value;
                });
                if (censorState.currentImage && censorState.processingResults[censorState.currentImage.path]) {
                    censorState.processingResults[censorState.currentImage.path].editBoxes = censorState.editBoxes.map(b => ({...b, box: [...b.box]}));
                }
                redrawProcessingPreview();
            };
            
            // 검열중 탭 도구 버튼
            const procToolBtns = ['procToolSelect', 'procToolAdd', 'procToolDelete'];
            procToolBtns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.onclick = function() {
                        procToolBtns.forEach(bid => {
                            document.getElementById(bid)?.classList.remove('active');
                        });
                        this.classList.add('active');
                        if (id === 'procToolSelect') censorState.currentTool = 'select';
                        else if (id === 'procToolAdd') censorState.currentTool = 'add';
                        else if (id === 'procToolDelete') censorState.currentTool = 'delete';
                        // 도구 변경 시 호버 상태 초기화 및 재렌더링
                        censorState.hoverBoxIndex = -1;
                        if (censorState.currentTab === 'processing') {
                            redrawProcessingPreview();
                        }
                    };
                }
            });
            
            // === 검열 후 탭 이벤트 ===
            // 검열후 탭에서도 공통 네비게이션 화살표 사용 (censorNavLeft/Right)
            // 화살표 버튼 이벤트는 위 "=== 네비게이션 화살표 버튼 ===" 섹션에서 처리됨

            // 검열후 탭 도구 버튼
            const afterToolBtns = ['afterToolSelect', 'afterToolAdd', 'afterToolDelete'];
            afterToolBtns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.onclick = function() {
                        afterToolBtns.forEach(bid => {
                            document.getElementById(bid)?.classList.remove('active');
                        });
                        this.classList.add('active');
                        if (id === 'afterToolSelect') censorState.currentTool = 'select';
                        else if (id === 'afterToolAdd') censorState.currentTool = 'add';
                        else if (id === 'afterToolDelete') censorState.currentTool = 'delete';
                        // 도구 변경 시 호버 상태 초기화 및 재렌더링
                        censorState.hoverBoxIndex = -1;
                        if (censorState.currentTab === 'after') {
                            redrawAfterPreview();
                        }
                    };
                }
            });
            
            // 검열후 탭 저장 버튼
            document.getElementById('censorAfterSaveBtn').onclick = saveAfterEdit;
            
            // 검열후 탭 검열 방식 변경 시 재렌더링
            document.getElementById('censorAfterMethod').onchange = function() {
                if (censorState.currentTab === 'after' && censorState.editBoxes.length > 0) {
                    redrawAfterPreview();
                }
            };
            
            // 캔버스 마우스 이벤트
            setupCensorCanvasEvents();
            
            // 윈도우 리사이즈 대응
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                if (currentMode !== 'censor') return;
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (censorState.currentImage) {
                        drawCensorPreview();
                    }
                }, 100);
            });
            
            // 키보드 이벤트 (Delete 키, 숫자키)
            document.addEventListener('keydown', (e) => {
                // 검열 모드가 활성화되어 있는지 확인
                if (currentMode !== 'censor') return;

                // 입력 필드에서는 무시
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

                // 숫자키로 모드 전환 (1: 선택, 2: 추가, 3: 삭제) - 편집 가능 탭에서만
                if ((e.key === '1' || e.key === '2' || e.key === '3') && isEditableTab()) {
                    e.preventDefault();
                    const newTool = e.key === '1' ? 'select' : e.key === '2' ? 'add' : 'delete';
                    censorState.currentTool = newTool;

                    // 버튼 UI 업데이트
                    if (censorState.currentTab === 'processing') {
                        const procToolBtns = ['procToolSelect', 'procToolAdd', 'procToolDelete'];
                        procToolBtns.forEach(id => document.getElementById(id)?.classList.remove('active'));
                        const activeBtn = e.key === '1' ? 'procToolSelect' : e.key === '2' ? 'procToolAdd' : 'procToolDelete';
                        document.getElementById(activeBtn)?.classList.add('active');
                    } else if (censorState.currentTab === 'after') {
                        const afterToolBtns = ['afterToolSelect', 'afterToolAdd', 'afterToolDelete'];
                        afterToolBtns.forEach(id => document.getElementById(id)?.classList.remove('active'));
                        const activeBtn = e.key === '1' ? 'afterToolSelect' : e.key === '2' ? 'afterToolAdd' : 'afterToolDelete';
                        document.getElementById(activeBtn)?.classList.add('active');
                    }

                    redrawCurrentTab();
                    return;
                }

                // Delete 키로 선택된 박스 삭제 (편집 가능 탭에서만)
                if (e.key === 'Delete' && censorState.selectedBoxIndex >= 0 && isEditableTab()) {
                    e.preventDefault();

                    // 선택된 박스 삭제
                    censorState.editBoxes.splice(censorState.selectedBoxIndex, 1);
                    censorState.selectedBoxIndex = -1;
                    censorState.hoverBoxIndex = -1;

                    // 검열중 탭: processingResults에도 반영
                    if (censorState.currentTab === 'processing' && censorState.currentImage) {
                        const path = censorState.currentImage.path;
                        if (censorState.processingResults[path]) {
                            censorState.processingResults[path].editBoxes = [...censorState.editBoxes];
                        }
                    }

                    // 검열후 탭: dirty 표시
                    if (censorState.currentTab === 'after') {
                        markAfterEditDirty();
                    }

                    redrawCurrentTab();
                }
            });
        }
        
        // === 편집 모달 함수들 ===
        async function openEditModal() {
            if (!censorState.currentImage) {
                showToast('편집할 이미지가 없습니다', 'warning');
                return;
            }
            
            const imagePath = censorState.currentImage.path;  // test/102.png (하위폴더 포함)
            const filename = censorState.currentImage.filename;  // 102.png
            
            // censored 폴더에서 이미 검열된 이미지 로드 (새 박스 추가만 가능)
            try {
                const response = await fetch(`${API_BASE}/api/censor/image?path=${encodeURIComponent(imagePath)}&source=censored`);
                const result = await response.json();
                
                if (!result.success || !result.image) {
                    showToast('검열된 이미지를 찾을 수 없습니다', 'warning');
                    return;
                }
                
                censorState.editModalOpen = true;
                censorState.editModalImage = {
                    path: imagePath,
                    filename: filename,
                    width: result.width,
                    height: result.height,
                    image: result.image
                };
                censorState.editModalOriginal = null;
                censorState.currentTool = 'box';  // 기본 도구를 박스 추가로 설정
                censorState.selectedBoxIndex = -1;
                
                document.getElementById('censorEditModal').classList.add('show');
                
                // 검열된 이미지로 모달 캔버스 설정 (이미지 로드 완료까지 대기)
                await setupEditModalCanvas();
                
                // 빈 박스 목록으로 시작 (새 박스 추가만 가능, 기존 검열은 이미지에 적용됨)
                censorState.editModalBoxes = [];
                drawEditModalPreview();
                
            } catch (err) {
                console.error('Failed to open edit modal:', err);
                showToast('편집 모달 열기 실패', 'error');
            }
        }
        
        function closeEditModal() {
            censorState.editModalOpen = false;
            censorState.editModalImage = null;
            censorState.editModalBoxes = [];
            document.getElementById('censorEditModal').classList.remove('show');
        }
        
        function setupEditModalCanvas() {
            return new Promise((resolve) => {
                const canvas = document.getElementById('censorEditCanvas');
                const overlay = document.getElementById('censorEditOverlay');
                const ctx = canvas.getContext('2d');
                
                const img = new Image();
                img.onload = () => {
                    censorState.editModalOriginal = img;
                    
                    const container = document.querySelector('.censor-edit-modal-body');
                    const maxW = container.clientWidth - 40;
                    const maxH = container.clientHeight - 40;
                    
                    const scale = Math.min(maxW / img.width, maxH / img.height, 1);
                    const displayW = Math.round(img.width * scale);
                    const displayH = Math.round(img.height * scale);
                    
                    canvas.width = displayW;
                    canvas.height = displayH;
                    overlay.width = displayW;
                    overlay.height = displayH;
                    
                    canvas.style.width = displayW + 'px';
                    canvas.style.height = displayH + 'px';
                    overlay.style.width = displayW + 'px';
                    overlay.style.height = displayH + 'px';
                    overlay.style.position = 'absolute';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    
                    censorState.displayScale = scale;
                    
                    ctx.drawImage(img, 0, 0, displayW, displayH);
                    
                    // 마우스 이벤트 설정
                    setupEditModalCanvasEvents(overlay);
                    
                    resolve();
                };
                img.src = 'data:image/png;base64,' + censorState.editModalImage.image;
            });
        }
        
        async function scanForEditModal() {
            if (!censorState.editModalImage) return;
            
            const model = document.getElementById('censorModel').value;
            const targetLabels = [];
            const labelConf = {};
            
            document.querySelectorAll('#censorTargets input[type="checkbox"]:checked').forEach(cb => {
                const cls = cb.dataset.class;
                targetLabels.push(cls);
                labelConf[cls] = censorState.labelConf[cls] || 0.3;
            });
            
            if (targetLabels.length === 0) {
                // 타겟이 없으면 기본값 사용
                censorState.modelClasses.forEach(cls => {
                    targetLabels.push(cls);
                    labelConf[cls] = 0.3;
                });
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/censor/scan`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_path: censorState.editModalImage.path,
                        model: model,
                        target_labels: targetLabels,
                        label_conf: labelConf
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    const method = document.getElementById('editCensorMethod').value;
                    censorState.editModalBoxes = (result.detections || []).map(d => ({
                        box: [...d.box],
                        label: d.label,
                        method: method
                    }));
                    drawEditModalPreview();
                }
            } catch (err) {
                console.error('Scan failed:', err);
            }
        }
        
        function drawEditModalPreview() {
            const canvas = document.getElementById('censorEditCanvas');
            const overlay = document.getElementById('censorEditOverlay');
            const ctx = canvas.getContext('2d');
            const overlayCtx = overlay.getContext('2d');
            
            if (!censorState.editModalOriginal) return;
            
            const img = censorState.editModalOriginal;
            const scale = censorState.displayScale;
            const method = document.getElementById('editCensorMethod').value;
            
            // 원본 그리기
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // 검열 효과 적용
            censorState.editModalBoxes.forEach(det => {
                const [x1, y1, x2, y2] = det.box;
                const sx = x1 * scale;
                const sy = y1 * scale;
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                const rotation = det.rotation || 0;
                
                if (rotation !== 0) {
                    const cx = sx + sw / 2;
                    const cy = sy + sh / 2;
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(rotation);
                    ctx.translate(-cx, -cy);
                    applyCensorEffect(ctx, sx, sy, sw, sh, det.method || method, img, x1, y1, x2 - x1, y2 - y1);
                    ctx.restore();
                } else {
                    applyCensorEffect(ctx, sx, sy, sw, sh, det.method || method, img, x1, y1, x2 - x1, y2 - y1);
                }
            });
            
            // 오버레이 (호버/선택된 박스에만 핸들 표시)
            overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
            const isDeleteMode = censorState.currentTool === 'delete';
            const canEdit = censorState.currentTool === 'select' || censorState.currentTool === 'add';
            
            censorState.editModalBoxes.forEach((det, index) => {
                const [x1, y1, x2, y2] = det.box;
                const sx = x1 * scale;
                const sy = y1 * scale;
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                const rotation = det.rotation || 0;
                const cx = sx + sw / 2;
                const cy = sy + sh / 2;
                
                const isSelected = index === censorState.selectedBoxIndex;
                const isHovered = index === censorState.hoverBoxIndex;
                const showHandles = canEdit && (isHovered || isSelected);
                
                overlayCtx.save();
                overlayCtx.translate(cx, cy);
                overlayCtx.rotate(rotation);
                overlayCtx.translate(-cx, -cy);
                
                // 삭제 모드에서 호버 시 빨간 강조
                if (isDeleteMode && isHovered) {
                    overlayCtx.strokeStyle = 'rgba(255, 80, 80, 1)';
                    overlayCtx.lineWidth = 3;
                    overlayCtx.setLineDash([]);
                    overlayCtx.strokeRect(sx, sy, sw, sh);
                    overlayCtx.fillStyle = 'rgba(255, 80, 80, 0.3)';
                    overlayCtx.fillRect(sx, sy, sw, sh);
                } else if (showHandles) {
                    // 호버/선택 시 테두리 + 핸들 표시
                    overlayCtx.strokeStyle = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.9)';
                    overlayCtx.lineWidth = 2;
                    overlayCtx.setLineDash([]);
                    overlayCtx.strokeRect(sx, sy, sw, sh);
                    
                    // 리사이즈 핸들
                    const hs = 7;
                    const handleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 255, 255, 0.95)';
                    overlayCtx.fillStyle = handleColor;
                    
                    // 모서리 핸들
                    overlayCtx.fillRect(sx - hs/2, sy - hs/2, hs, hs);
                    overlayCtx.fillRect(sx + sw - hs/2, sy - hs/2, hs, hs);
                    overlayCtx.fillRect(sx - hs/2, sy + sh - hs/2, hs, hs);
                    overlayCtx.fillRect(sx + sw - hs/2, sy + sh - hs/2, hs, hs);
                    
                    // 변 핸들
                    const ehs = 5;
                    overlayCtx.fillRect(cx - ehs/2, sy - ehs/2, ehs, ehs);
                    overlayCtx.fillRect(cx - ehs/2, sy + sh - ehs/2, ehs, ehs);
                    overlayCtx.fillRect(sx - ehs/2, cy - ehs/2, ehs, ehs);
                    overlayCtx.fillRect(sx + sw - ehs/2, cy - ehs/2, ehs, ehs);
                    
                    // 회전 핸들 (선택된 박스만)
                    if (isSelected) {
                        const rotateY = sy - 25;
                        overlayCtx.beginPath();
                        overlayCtx.strokeStyle = 'rgba(0, 200, 255, 0.8)';
                        overlayCtx.lineWidth = 1;
                        overlayCtx.moveTo(cx, sy);
                        overlayCtx.lineTo(cx, rotateY + 6);
                        overlayCtx.stroke();
                        
                        overlayCtx.fillStyle = 'rgba(0, 200, 255, 1)';
                        overlayCtx.beginPath();
                        overlayCtx.arc(cx, rotateY, 6, 0, Math.PI * 2);
                        overlayCtx.fill();
                        
                        overlayCtx.fillStyle = 'white';
                        overlayCtx.font = '8px sans-serif';
                        overlayCtx.textAlign = 'center';
                        overlayCtx.textBaseline = 'middle';
                        overlayCtx.fillText('↻', cx, rotateY);
                    }
                }
                // 호버/선택 아닐 때는 테두리 없음 (검열 효과만 보임)
                
                overlayCtx.restore();
            });
        }
        
        function setupEditModalCanvasEvents(overlay) {
            overlay.onmousedown = (e) => handleEditModalMouseDown(e, overlay);
            overlay.onmousemove = (e) => handleEditModalMouseMove(e, overlay);
            overlay.onmouseup = handleEditModalMouseUp;
            overlay.onmouseleave = handleEditModalMouseUp;
        }
        
        // 편집 모달용 박스 히트 테스트 (회전 고려)
        function hitTestEditModalBox(imageX, imageY) {
            for (let i = censorState.editModalBoxes.length - 1; i >= 0; i--) {
                const det = censorState.editModalBoxes[i];
                const [x1, y1, x2, y2] = det.box;
                const rotation = det.rotation || 0;
                const cx = (x1 + x2) / 2;
                const cy = (y1 + y2) / 2;
                const cos = Math.cos(-rotation);
                const sin = Math.sin(-rotation);
                const dx = imageX - cx;
                const dy = imageY - cy;
                const localX = cx + dx * cos - dy * sin;
                const localY = cy + dx * sin + dy * cos;
                if (localX >= x1 && localX <= x2 && localY >= y1 && localY <= y2) {
                    return i;
                }
            }
            return -1;
        }
        
        // 편집 모달용 리사이즈/회전 핸들 히트 테스트 (호버/선택된 박스만 체크)
        // 반환: { handle: 'nw'|'ne'|...|'rotate'|null, boxIndex: number }
        function hitTestEditModalResizeHandle(imageX, imageY) {
            const boxes = censorState.editModalBoxes;
            const handleSize = 12 / (censorState.displayScale || 1);
            
            // 호버 또는 선택된 박스만 핸들 체크 (핸들이 보이는 박스만)
            const visibleBoxes = [];
            for (let i = boxes.length - 1; i >= 0; i--) {
                if (i === censorState.selectedBoxIndex || i === censorState.hoverBoxIndex) {
                    visibleBoxes.push(i);
                }
            }
            
            for (const i of visibleBoxes) {
                const det = boxes[i];
                if (!det?.box) continue;
                
                const [x1, y1, x2, y2] = det.box;
                const rotation = det.rotation || 0;
                const cx = (x1 + x2) / 2;
                const cy = (y1 + y2) / 2;
                
                // 마우스 좌표를 박스 중심 기준으로 역회전
                const rotated = rotatePointAroundCenter(imageX, imageY, cx, cy, rotation);
                const rx = rotated.x;
                const ry = rotated.y;
                
                // 회전 핸들 (선택된 박스만)
                if (i === censorState.selectedBoxIndex) {
                    const rotateHandleY = y1 - 25 / (censorState.displayScale || 1);
                    if (Math.abs(rx - cx) < handleSize && Math.abs(ry - rotateHandleY) < handleSize) {
                        return { handle: 'rotate', boxIndex: i };
                    }
                }
                
                // 모서리 핸들 (코너)
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'nw', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'ne', boxIndex: i };
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 'sw', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 'se', boxIndex: i };
                
                // 변 핸들 (엣지)
                if (Math.abs(rx - cx) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'n', boxIndex: i };
                if (Math.abs(rx - cx) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 's', boxIndex: i };
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - cy) < handleSize) return { handle: 'w', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - cy) < handleSize) return { handle: 'e', boxIndex: i };
            }
            
            return { handle: null, boxIndex: -1 };
        }
        
        function handleEditModalMouseDown(e, overlay) {
            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const scale = censorState.displayScale;
            const imageX = x / scale;
            const imageY = y / scale;
            
            censorState.dragStartX = imageX;
            censorState.dragStartY = imageY;
            
            if (censorState.currentTool === 'select') {
                // 리사이즈/회전 핸들 체크 (모든 박스)
                const handleResult = hitTestEditModalResizeHandle(imageX, imageY);
                if (handleResult.handle === 'rotate') {
                    censorState.selectedBoxIndex = handleResult.boxIndex;
                    censorState.isRotating = true;
                    const box = censorState.editModalBoxes[handleResult.boxIndex].box;
                    censorState.rotateCenter = {
                        x: (box[0] + box[2]) / 2,
                        y: (box[1] + box[3]) / 2
                    };
                    overlay.style.cursor = 'grabbing';
                    return;
                } else if (handleResult.handle) {
                    censorState.selectedBoxIndex = handleResult.boxIndex;
                    censorState.isResizing = true;
                    censorState.resizeHandle = handleResult.handle;
                    const box = censorState.editModalBoxes[handleResult.boxIndex].box;
                    const rotation = censorState.editModalBoxes[handleResult.boxIndex].rotation || 0;
                    censorState.dragBoxOriginal = [...box];
                    
                    // 앵커 포인트 계산 (핸들 반대편 코너)
                    const [x1, y1, x2, y2] = box;
                    const cx = (x1 + x2) / 2;
                    const cy = (y1 + y2) / 2;
                    let anchorLocalX, anchorLocalY;
                    switch (handleResult.handle) {
                        // 코너 핸들: 대각선 반대편 코너
                        case 'nw': anchorLocalX = x2; anchorLocalY = y2; break;
                        case 'ne': anchorLocalX = x1; anchorLocalY = y2; break;
                        case 'sw': anchorLocalX = x2; anchorLocalY = y1; break;
                        case 'se': anchorLocalX = x1; anchorLocalY = y1; break;
                        // 엣지 핸들: 대각선 반대편 코너 (코너처럼 처리하되 한 축 고정)
                        case 'n': anchorLocalX = x1; anchorLocalY = y2; break;  // SW
                        case 's': anchorLocalX = x2; anchorLocalY = y1; break;  // NE
                        case 'w': anchorLocalX = x2; anchorLocalY = y1; break;  // NE
                        case 'e': anchorLocalX = x1; anchorLocalY = y2; break;  // SW
                    }
                    // 앵커를 월드 좌표로 변환 (회전 적용) - 월드 좌표만 저장
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    const dx = anchorLocalX - cx;
                    const dy = anchorLocalY - cy;
                    censorState.resizeAnchor = {
                        worldX: cx + dx * cos - dy * sin,
                        worldY: cy + dx * sin + dy * cos
                    };
                    return;
                }
                
                // 박스 선택 (드래그 시작)
                let found = -1;
                for (let i = censorState.editModalBoxes.length - 1; i >= 0; i--) {
                    const det = censorState.editModalBoxes[i];
                    const [x1, y1, x2, y2] = det.box;
                    const rotation = det.rotation || 0;
                    const cx = (x1 + x2) / 2;
                    const cy = (y1 + y2) / 2;
                    const cos = Math.cos(-rotation);
                    const sin = Math.sin(-rotation);
                    const dx = imageX - cx;
                    const dy = imageY - cy;
                    const localX = cx + dx * cos - dy * sin;
                    const localY = cy + dx * sin + dy * cos;
                    if (localX >= x1 && localX <= x2 && localY >= y1 && localY <= y2) {
                        found = i;
                        break;
                    }
                }
                censorState.selectedBoxIndex = found;
                if (found >= 0) {
                    censorState.isDragging = true;
                    censorState.dragBoxOriginal = [...censorState.editModalBoxes[found].box];
                }
                drawEditModalPreview();
            } else if (censorState.currentTool === 'add') {
                // 핸들 위에서 클릭하면 리사이즈 (호버된 박스의 핸들)
                const addHandleResult = hitTestEditModalResizeHandle(imageX, imageY);
                if (addHandleResult.handle && addHandleResult.handle !== 'rotate') {
                    censorState.selectedBoxIndex = addHandleResult.boxIndex;
                    censorState.isResizing = true;
                    censorState.resizeHandle = addHandleResult.handle;
                    const box = censorState.editModalBoxes[addHandleResult.boxIndex].box;
                    const rotation = censorState.editModalBoxes[addHandleResult.boxIndex].rotation || 0;
                    censorState.dragBoxOriginal = [...box];
                    
                    const [x1, y1, x2, y2] = box;
                    const cx = (x1 + x2) / 2;
                    const cy = (y1 + y2) / 2;
                    let anchorLocalX, anchorLocalY;
                    switch (addHandleResult.handle) {
                        case 'nw': anchorLocalX = x2; anchorLocalY = y2; break;
                        case 'ne': anchorLocalX = x1; anchorLocalY = y2; break;
                        case 'sw': anchorLocalX = x2; anchorLocalY = y1; break;
                        case 'se': anchorLocalX = x1; anchorLocalY = y1; break;
                        case 'n': anchorLocalX = x1; anchorLocalY = y2; break;
                        case 's': anchorLocalX = x2; anchorLocalY = y1; break;
                        case 'w': anchorLocalX = x2; anchorLocalY = y1; break;
                        case 'e': anchorLocalX = x1; anchorLocalY = y2; break;
                    }
                    const cos = Math.cos(rotation);
                    const sin = Math.sin(rotation);
                    const dx = anchorLocalX - cx;
                    const dy = anchorLocalY - cy;
                    censorState.resizeAnchor = {
                        worldX: cx + dx * cos - dy * sin,
                        worldY: cy + dx * sin + dy * cos
                    };
                } else {
                    // 새 박스 그리기 시작 (선택 해제)
                    censorState.selectedBoxIndex = -1;
                    censorState.isDrawing = true;
                    censorState.newBoxStart = { x: imageX, y: imageY };
                    drawEditModalPreview();
                }
            } else if (censorState.currentTool === 'delete') {
                const deleteIndex = hitTestEditModalBox(imageX, imageY);
                if (deleteIndex >= 0) {
                    censorState.editModalBoxes.splice(deleteIndex, 1);
                    censorState.selectedBoxIndex = -1;
                    censorState.hoverBoxIndex = -1;
                    drawEditModalPreview();
                }
            }
        }
        
        function handleEditModalMouseMove(e, overlay) {
            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const scale = censorState.displayScale;
            const imageX = x / scale;
            const imageY = y / scale;
            
            // 삭제 모드에서 호버 박스 추적
            if (censorState.currentTool === 'delete') {
                const hoverIndex = hitTestEditModalBox(imageX, imageY);
                if (hoverIndex !== censorState.hoverBoxIndex) {
                    censorState.hoverBoxIndex = hoverIndex;
                    drawEditModalPreview();
                }
                overlay.style.cursor = hoverIndex >= 0 ? 'pointer' : 'default';
            }
            // 커서 업데이트 및 호버 추적 (선택/추가 도구)
            else if ((censorState.currentTool === 'select' || censorState.currentTool === 'add') && 
                     !censorState.isDragging && !censorState.isResizing && !censorState.isRotating) {
                // 호버 박스 추적
                const newHoverIndex = hitTestEditModalBox(imageX, imageY);
                if (newHoverIndex !== censorState.hoverBoxIndex) {
                    censorState.hoverBoxIndex = newHoverIndex;
                    drawEditModalPreview();
                }
                
                const handleResult = hitTestEditModalResizeHandle(imageX, imageY);
                if (handleResult.handle) {
                    const cursors = {
                        'n': 'ns-resize', 's': 'ns-resize',
                        'e': 'ew-resize', 'w': 'ew-resize',
                        'nw': 'nwse-resize', 'se': 'nwse-resize',
                        'ne': 'nesw-resize', 'sw': 'nesw-resize',
                        'rotate': 'grab'
                    };
                    overlay.style.cursor = cursors[handleResult.handle];
                } else {
                    const boxIndex = hitTestEditModalBox(imageX, imageY);
                    overlay.style.cursor = boxIndex >= 0 ? 'move' : (censorState.currentTool === 'add' ? 'crosshair' : 'default');
                }
            }
            
            // 드래그 중 (박스 이동)
            if (censorState.isDragging && censorState.selectedBoxIndex >= 0) {
                const dx = imageX - censorState.dragStartX;
                const dy = imageY - censorState.dragStartY;
                const orig = censorState.dragBoxOriginal;
                censorState.editModalBoxes[censorState.selectedBoxIndex].box = [
                    orig[0] + dx, orig[1] + dy, orig[2] + dx, orig[3] + dy
                ];
                drawEditModalPreview();
            }
            
            // 리사이즈 중 (회전 고려, Ctrl: 중심 기준 확장)
            if (censorState.isResizing && censorState.selectedBoxIndex >= 0 && censorState.resizeAnchor) {
                const det = censorState.editModalBoxes[censorState.selectedBoxIndex];
                const rotation = det.rotation || 0;
                const anchor = censorState.resizeAnchor;
                const handle = censorState.resizeHandle;
                const orig = censorState.dragBoxOriginal;
                const isCtrl = e.ctrlKey;
                
                // 마우스 월드 좌표
                const mwx = imageX;
                const mwy = imageY;
                
                let x1, y1, x2, y2;
                const cos = Math.cos(-rotation);
                const sin = Math.sin(-rotation);
                
                if (isCtrl) {
                    // Ctrl 누름: 중심 기준 대칭 확장
                    const [ox1, oy1, ox2, oy2] = orig;
                    const ocx = (ox1 + ox2) / 2;
                    const ocy = (oy1 + oy2) / 2;
                    
                    // 마우스를 원래 중심 기준으로 역회전 → 로컬 좌표
                    const mox = mwx - ocx;
                    const moy = mwy - ocy;
                    const mlx = ocx + mox * cos - moy * sin;
                    const mly = ocy + mox * sin + moy * cos;
                    
                    if (handle === 'nw' || handle === 'ne' || handle === 'sw' || handle === 'se') {
                        // 코너: 중심에서 마우스까지의 거리를 양쪽으로
                        const dx = Math.abs(mlx - ocx);
                        const dy = Math.abs(mly - ocy);
                        x1 = ocx - dx;
                        y1 = ocy - dy;
                        x2 = ocx + dx;
                        y2 = ocy + dy;
                    } else {
                        // 엣지: 해당 축만 대칭 확장
                        x1 = ox1; y1 = oy1; x2 = ox2; y2 = oy2;
                        if (handle === 'n' || handle === 's') {
                            const dy = Math.abs(mly - ocy);
                            y1 = ocy - dy;
                            y2 = ocy + dy;
                        } else {
                            const dx = Math.abs(mlx - ocx);
                            x1 = ocx - dx;
                            x2 = ocx + dx;
                        }
                    }
                } else if (handle === 'nw' || handle === 'ne' || handle === 'sw' || handle === 'se') {
                    // 코너 핸들: 앵커 월드 좌표 고정
                    const wcx = (anchor.worldX + mwx) / 2;
                    const wcy = (anchor.worldY + mwy) / 2;
                    
                    const aox = anchor.worldX - wcx;
                    const aoy = anchor.worldY - wcy;
                    const alx = wcx + aox * cos - aoy * sin;
                    const aly = wcy + aox * sin + aoy * cos;
                    
                    const mox = mwx - wcx;
                    const moy = mwy - wcy;
                    const mlx = wcx + mox * cos - moy * sin;
                    const mly = wcy + mox * sin + moy * cos;
                    
                    x1 = Math.min(alx, mlx);
                    y1 = Math.min(aly, mly);
                    x2 = Math.max(alx, mlx);
                    y2 = Math.max(aly, mly);
                } else {
                    // 엣지 핸들: 마우스의 해당 축만 사용
                    const origWidth = orig[2] - orig[0];
                    const origHeight = orig[3] - orig[1];
                    
                    const dwx = mwx - anchor.worldX;
                    const dwy = mwy - anchor.worldY;
                    const dlx = dwx * cos - dwy * sin;
                    const dly = dwx * sin + dwy * cos;
                    
                    let effectiveDLX, effectiveDLY;
                    switch (handle) {
                        case 'n': effectiveDLX = origWidth; effectiveDLY = dly; break;
                        case 's': effectiveDLX = -origWidth; effectiveDLY = dly; break;
                        case 'w': effectiveDLX = dlx; effectiveDLY = origHeight; break;
                        case 'e': effectiveDLX = dlx; effectiveDLY = -origHeight; break;
                    }
                    
                    const cosR = Math.cos(rotation);
                    const sinR = Math.sin(rotation);
                    const effectiveDWX = effectiveDLX * cosR - effectiveDLY * sinR;
                    const effectiveDWY = effectiveDLX * sinR + effectiveDLY * cosR;
                    
                    const emwx = anchor.worldX + effectiveDWX;
                    const emwy = anchor.worldY + effectiveDWY;
                    
                    const wcx = (anchor.worldX + emwx) / 2;
                    const wcy = (anchor.worldY + emwy) / 2;
                    
                    const aox = anchor.worldX - wcx;
                    const aoy = anchor.worldY - wcy;
                    const alx = wcx + aox * cos - aoy * sin;
                    const aly = wcy + aox * sin + aoy * cos;
                    
                    const emox = emwx - wcx;
                    const emoy = emwy - wcy;
                    const emlx = wcx + emox * cos - emoy * sin;
                    const emly = wcy + emox * sin + emoy * cos;
                    
                    x1 = Math.min(alx, emlx);
                    y1 = Math.min(aly, emly);
                    x2 = Math.max(alx, emlx);
                    y2 = Math.max(aly, emly);
                }
                
                censorState.editModalBoxes[censorState.selectedBoxIndex].box = [x1, y1, x2, y2];
                drawEditModalPreview();
            }
            
            // 회전 중
            if (censorState.isRotating && censorState.selectedBoxIndex >= 0 && censorState.rotateCenter) {
                const cx = censorState.rotateCenter.x;
                const cy = censorState.rotateCenter.y;
                const angle = Math.atan2(imageY - cy, imageX - cx) + Math.PI / 2;
                censorState.editModalBoxes[censorState.selectedBoxIndex].rotation = angle;
                drawEditModalPreview();
            }
            
            // 새 박스 그리는 중 - 프리뷰 표시
            if (censorState.isDrawing && censorState.newBoxStart) {
                drawEditModalPreview();
                // 임시 박스 프리뷰
                const overlayCanvas = document.getElementById('censorEditOverlay');
                const ctx = overlayCanvas.getContext('2d');
                const sx = censorState.newBoxStart.x * scale;
                const sy = censorState.newBoxStart.y * scale;
                const sw = (imageX - censorState.newBoxStart.x) * scale;
                const sh = (imageY - censorState.newBoxStart.y) * scale;
                
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(sx, sy, sw, sh);
                ctx.setLineDash([]);
                
                // 크기 표시
                const w = Math.abs(Math.round(imageX - censorState.newBoxStart.x));
                const h = Math.abs(Math.round(imageY - censorState.newBoxStart.y));
                ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
                ctx.font = '12px monospace';
                ctx.fillText(`${w} x ${h}`, sx + 4, sy - 4);
            }
        }
        
        function handleEditModalMouseUp(e) {
            if (censorState.isDrawing && censorState.newBoxStart) {
                const overlay = document.getElementById('censorEditOverlay');
                const rect = overlay.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const scale = censorState.displayScale;
                const imageX = x / scale;
                const imageY = y / scale;
                
                const x1 = Math.min(censorState.newBoxStart.x, imageX);
                const y1 = Math.min(censorState.newBoxStart.y, imageY);
                const x2 = Math.max(censorState.newBoxStart.x, imageX);
                const y2 = Math.max(censorState.newBoxStart.y, imageY);
                
                if (x2 - x1 > 10 && y2 - y1 > 10) {
                    const method = document.getElementById('editCensorMethod').value;
                    censorState.editModalBoxes.push({
                        box: [x1, y1, x2, y2],
                        label: 'manual',
                        method: method
                    });
                    censorState.selectedBoxIndex = censorState.editModalBoxes.length - 1;
                    drawEditModalPreview();
                }
            }
            
            censorState.isDragging = false;
            censorState.isResizing = false;
            censorState.isRotating = false;
            censorState.isDrawing = false;
            censorState.newBoxStart = null;
            censorState.rotateCenter = null;
            censorState.resizeAnchor = null;
        }
        
        async function saveEditModal() {
            if (!censorState.editModalImage || censorState.editModalBoxes.length === 0) {
                showToast('저장할 박스가 없습니다', 'warning');
                return;
            }
            
            const method = document.getElementById('editCensorMethod').value;
            const boxes = censorState.editModalBoxes.map(d => ({
                box: d.box,
                method: d.method || method,
                rotation: d.rotation || 0  // 회전 값 포함
            }));
            
            const imagePath = censorState.editModalImage.path;
            const pathParts = imagePath.split(/[\/\\]/);  // Windows 백슬래시 지원
            const outputFolder = pathParts.length > 1 ? pathParts.slice(0, -1).join('/') : '';
            
            try {
                const response = await fetch(`${API_BASE}/api/censor/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_path: imagePath,
                        boxes: boxes,
                        method: method,
                        output_folder: outputFolder,
                        filename: censorState.editModalImage.filename,
                        source: 'censored'  // 편집 모달에서는 검열된 이미지 기준
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showToast('저장 완료', 'success');
                    closeEditModal();
                    // 이미지 새로고침
                    loadCensorImages();
                } else {
                    showToast('저장 실패: ' + result.error, 'error');
                }
            } catch (err) {
                showToast('저장 오류: ' + err.message, 'error');
            }
        }
        
        // 커서 업데이트
        function updateCensorCursor() {
            if (!censorOverlayCanvas) return;
            switch (censorState.currentTool) {
                case 'select':
                    censorOverlayCanvas.style.cursor = 'default';
                    break;
                case 'add':
                    censorOverlayCanvas.style.cursor = 'crosshair';
                    break;
                case 'delete':
                    censorOverlayCanvas.style.cursor = 'not-allowed';
                    break;
            }
        }
        
        // 캔버스 마우스 이벤트 설정
        function setupCensorCanvasEvents() {
            if (!censorOverlayCanvas) return;
            
            censorOverlayCanvas.onmousedown = handleCensorMouseDown;
            censorOverlayCanvas.onmousemove = handleCensorMouseMove;
            censorOverlayCanvas.onmouseup = handleCensorMouseUp;
            censorOverlayCanvas.onmouseleave = handleCensorMouseUp;
        }
        
        // 마우스 좌표 → 이미지 좌표 변환
        function canvasToImageCoords(e) {
            const rect = censorOverlayCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const scale = censorState.displayScale || 1;
            const offsetY = censorState.overlayOffsetY || 0;
            return {
                canvasX: x,
                canvasY: y,
                imageX: x / scale,
                imageY: (y - offsetY) / scale  // 오프셋 보정
            };
        }
        
        // 박스 히트 테스트 (어떤 박스 위에 있는지, 회전 고려)
        function hitTestBox(imageX, imageY) {
            const boxes = censorState.editBoxes.length > 0 ? censorState.editBoxes : censorState.detections;
            for (let i = boxes.length - 1; i >= 0; i--) {
                const det = boxes[i];
                const [x1, y1, x2, y2] = det.box;
                const rotation = det.rotation || 0;
                const cx = (x1 + x2) / 2;
                const cy = (y1 + y2) / 2;
                
                // 마우스 좌표를 박스 중심 기준으로 역회전하여 로컬 좌표로 변환
                const cos = Math.cos(-rotation);
                const sin = Math.sin(-rotation);
                const dx = imageX - cx;
                const dy = imageY - cy;
                const localX = cx + dx * cos - dy * sin;
                const localY = cy + dx * sin + dy * cos;
                
                // 로컬 좌표에서 AABB 체크
                if (localX >= x1 && localX <= x2 && localY >= y1 && localY <= y2) {
                    return i;
                }
            }
            return -1;
        }
        
        // 점을 중심 기준으로 역회전
        function rotatePointAroundCenter(px, py, cx, cy, angle) {
            const cos = Math.cos(-angle);
            const sin = Math.sin(-angle);
            const dx = px - cx;
            const dy = py - cy;
            return {
                x: cx + dx * cos - dy * sin,
                y: cy + dx * sin + dy * cos
            };
        }
        
        // 리사이즈/회전 핸들 히트 테스트 (호버/선택된 박스만)
        // 반환: { handle: 'nw'|'ne'|...|'rotate'|null, boxIndex: number }
        function hitTestResizeHandle(imageX, imageY) {
            const boxes = censorState.editBoxes.length > 0 ? censorState.editBoxes : censorState.detections;
            const handleSize = 12 / (censorState.displayScale || 1);
            
            // 호버 또는 선택된 박스만 핸들 체크 (핸들이 보이는 박스만)
            const visibleBoxes = [];
            for (let i = boxes.length - 1; i >= 0; i--) {
                if (i === censorState.selectedBoxIndex || i === censorState.hoverBoxIndex) {
                    visibleBoxes.push(i);
                }
            }
            
            for (const i of visibleBoxes) {
                const det = boxes[i];
                if (!det?.box) continue;
                
                const [x1, y1, x2, y2] = det.box;
                const rotation = det.rotation || 0;
                const cx = (x1 + x2) / 2;
                const cy = (y1 + y2) / 2;
                
                // 마우스 좌표를 박스 중심 기준으로 역회전
                const rotated = rotatePointAroundCenter(imageX, imageY, cx, cy, rotation);
                const rx = rotated.x;
                const ry = rotated.y;
                
                // 회전 핸들 (선택 또는 호버된 박스 - 둘 다 허용)
                const rotateHandleY = y1 - 25 / (censorState.displayScale || 1);
                if (Math.abs(rx - cx) < handleSize && Math.abs(ry - rotateHandleY) < handleSize) {
                    return { handle: 'rotate', boxIndex: i };
                }
                
                // 모서리 핸들 (코너)
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'nw', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'ne', boxIndex: i };
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 'sw', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 'se', boxIndex: i };
                
                // 변 핸들 (엣지)
                if (Math.abs(rx - cx) < handleSize && Math.abs(ry - y1) < handleSize) return { handle: 'n', boxIndex: i };
                if (Math.abs(rx - cx) < handleSize && Math.abs(ry - y2) < handleSize) return { handle: 's', boxIndex: i };
                if (Math.abs(rx - x1) < handleSize && Math.abs(ry - cy) < handleSize) return { handle: 'w', boxIndex: i };
                if (Math.abs(rx - x2) < handleSize && Math.abs(ry - cy) < handleSize) return { handle: 'e', boxIndex: i };
            }
            
            return { handle: null, boxIndex: -1 };
        }
        
        // 마우스 다운
        function handleCensorMouseDown(e) {
            if (!censorState.currentImage) return;

            // 편집 불가능한 탭(검열전)에서는 편집 기능 비활성화
            if (!isEditableTab()) return;

            const coords = canvasToImageCoords(e);
            censorState.dragStartX = coords.imageX;
            censorState.dragStartY = coords.imageY;

            // editBoxes가 비어있으면 detections로 초기화 (검열전 탭만)
            // 검열중/검열후 탭은 selectProcessingImage/selectCensorImage에서 이미 로드되므로 제외
            if (censorState.editBoxes.length === 0 && censorState.detections.length > 0 && censorState.currentTab === 'before') {
                censorState.editBoxes = censorState.detections.map(d => ({
                    box: [...d.box],
                    label: d.label,
                    method: document.getElementById('censorMethod')?.value || 'black'
                }));
            }

            switch (censorState.currentTool) {
                case 'select':
                    // 리사이즈/회전 핸들 체크 (모든 박스)
                    const handleResult = hitTestResizeHandle(coords.imageX, coords.imageY);
                    if (handleResult.handle === 'rotate') {
                        censorState.selectedBoxIndex = handleResult.boxIndex;
                        censorState.isRotating = true;
                        const box = censorState.editBoxes[handleResult.boxIndex].box;
                        censorState.rotateCenter = {
                            x: (box[0] + box[2]) / 2,
                            y: (box[1] + box[3]) / 2
                        };
                        censorOverlayCanvas.style.cursor = 'grabbing';
                    } else if (handleResult.handle) {
                        censorState.selectedBoxIndex = handleResult.boxIndex;
                        censorState.isResizing = true;
                        censorState.resizeHandle = handleResult.handle;
                        const box = censorState.editBoxes[handleResult.boxIndex].box;
                        const rotation = censorState.editBoxes[handleResult.boxIndex].rotation || 0;
                        censorState.dragBoxOriginal = [...box];
                        
                        // 앵커 포인트 계산 (핸들 반대편 코너)
                        const [x1, y1, x2, y2] = box;
                        const cx = (x1 + x2) / 2;
                        const cy = (y1 + y2) / 2;
                        let anchorLocalX, anchorLocalY;
                        switch (handleResult.handle) {
                            // 코너 핸들: 대각선 반대편 코너
                            case 'nw': anchorLocalX = x2; anchorLocalY = y2; break;
                            case 'ne': anchorLocalX = x1; anchorLocalY = y2; break;
                            case 'sw': anchorLocalX = x2; anchorLocalY = y1; break;
                            case 'se': anchorLocalX = x1; anchorLocalY = y1; break;
                            // 엣지 핸들: 대각선 반대편 코너 (코너처럼 처리하되 한 축 고정)
                            case 'n': anchorLocalX = x1; anchorLocalY = y2; break;  // SW
                            case 's': anchorLocalX = x2; anchorLocalY = y1; break;  // NE
                            case 'w': anchorLocalX = x2; anchorLocalY = y1; break;  // NE
                            case 'e': anchorLocalX = x1; anchorLocalY = y2; break;  // SW
                        }
                        // 앵커를 월드 좌표로 변환 (회전 적용) - 월드 좌표만 저장
                        const cos = Math.cos(rotation);
                        const sin = Math.sin(rotation);
                        const dx = anchorLocalX - cx;
                        const dy = anchorLocalY - cy;
                        censorState.resizeAnchor = {
                            worldX: cx + dx * cos - dy * sin,
                            worldY: cy + dx * sin + dy * cos
                        };
                    } else {
                        // 박스 선택 (드래그 시작)
                        const hitIndex = hitTestBox(coords.imageX, coords.imageY);
                        if (hitIndex >= 0) {
                            censorState.selectedBoxIndex = hitIndex;
                            censorState.isDragging = true;
                            censorState.dragBoxOriginal = [...censorState.editBoxes[hitIndex].box];
                        } else {
                            censorState.selectedBoxIndex = -1;
                        }
                    }
                    redrawCurrentTab();
                    break;
                    
                case 'add':
                    // 핸들 위에서 클릭하면 리사이즈/회전 (호버된 박스의 핸들)
                    const addHandleResult = hitTestResizeHandle(coords.imageX, coords.imageY);
                    if (addHandleResult.handle === 'rotate') {
                        // 회전 핸들
                        censorState.selectedBoxIndex = addHandleResult.boxIndex;
                        censorState.isRotating = true;
                        const rotBox = censorState.editBoxes[addHandleResult.boxIndex].box;
                        censorState.rotateCenter = {
                            x: (rotBox[0] + rotBox[2]) / 2,
                            y: (rotBox[1] + rotBox[3]) / 2
                        };
                        censorOverlayCanvas.style.cursor = 'grabbing';
                    } else if (addHandleResult.handle) {
                        // 리사이즈 핸들
                        censorState.selectedBoxIndex = addHandleResult.boxIndex;
                        censorState.isResizing = true;
                        censorState.resizeHandle = addHandleResult.handle;
                        const box = censorState.editBoxes[addHandleResult.boxIndex].box;
                        const rotation = censorState.editBoxes[addHandleResult.boxIndex].rotation || 0;
                        censorState.dragBoxOriginal = [...box];
                        
                        const [x1, y1, x2, y2] = box;
                        const cx = (x1 + x2) / 2;
                        const cy = (y1 + y2) / 2;
                        let anchorLocalX, anchorLocalY;
                        switch (addHandleResult.handle) {
                            case 'nw': anchorLocalX = x2; anchorLocalY = y2; break;
                            case 'ne': anchorLocalX = x1; anchorLocalY = y2; break;
                            case 'sw': anchorLocalX = x2; anchorLocalY = y1; break;
                            case 'se': anchorLocalX = x1; anchorLocalY = y1; break;
                            case 'n': anchorLocalX = x1; anchorLocalY = y2; break;
                            case 's': anchorLocalX = x2; anchorLocalY = y1; break;
                            case 'w': anchorLocalX = x2; anchorLocalY = y1; break;
                            case 'e': anchorLocalX = x1; anchorLocalY = y2; break;
                        }
                        const cos = Math.cos(rotation);
                        const sin = Math.sin(rotation);
                        const dx = anchorLocalX - cx;
                        const dy = anchorLocalY - cy;
                        censorState.resizeAnchor = {
                            worldX: cx + dx * cos - dy * sin,
                            worldY: cy + dx * sin + dy * cos
                        };
                    } else {
                        // 새 박스 그리기 시작 (선택 해제)
                        censorState.selectedBoxIndex = -1;
                        censorState.isDrawing = true;
                        censorState.newBoxStart = { x: coords.imageX, y: coords.imageY };
                        if (censorState.currentTab === 'processing') {
                            drawProcessingOverlay();
                        } else if (censorState.currentTab === 'after') {
                            drawAfterTabBoxOverlay();
                        }
                    }
                    break;
                    
                case 'delete':
                    // 박스 삭제
                    const deleteIndex = hitTestBox(coords.imageX, coords.imageY);
                    if (deleteIndex >= 0) {
                        censorState.editBoxes.splice(deleteIndex, 1);
                        censorState.selectedBoxIndex = -1;
                        if (censorState.currentTab === 'after') {
                            markAfterEditDirty();
                        }
                        redrawCurrentTab();
                    }
                    break;
            }
        }
        
        // 마우스 이동
        function handleCensorMouseMove(e) {
            if (!censorState.currentImage) return;

            const coords = canvasToImageCoords(e);

            // 편집 불가능한 탭(검열전)에서는 호버/편집 기능 비활성화
            if (!isEditableTab()) {
                // 드래그/리사이즈/회전 중이어도 중단
                if (censorState.isDragging || censorState.isResizing || censorState.isRotating || censorState.isDrawing) {
                    censorState.isDragging = false;
                    censorState.isResizing = false;
                    censorState.isRotating = false;
                    censorState.isDrawing = false;
                }
                censorOverlayCanvas.style.cursor = 'default';
                return;
            }

            // 삭제 모드에서 호버 박스 추적
            if (censorState.currentTool === 'delete') {
                const hoverIndex = hitTestBox(coords.imageX, coords.imageY);
                if (hoverIndex !== censorState.hoverBoxIndex) {
                    censorState.hoverBoxIndex = hoverIndex;
                    redrawCurrentTab();
                }
                censorOverlayCanvas.style.cursor = hoverIndex >= 0 ? 'pointer' : 'default';
            }
            // 선택/추가 모드에서 호버 시 핸들 표시
            else if ((censorState.currentTool === 'select' || censorState.currentTool === 'add') && 
                     !censorState.isDragging && !censorState.isResizing && !censorState.isRotating && !censorState.isDrawing) {
                // 호버 중인 박스 또는 핸들 체크
                const handleResult = hitTestResizeHandle(coords.imageX, coords.imageY);
                const hoverIndex = handleResult.boxIndex >= 0 ? handleResult.boxIndex : hitTestBox(coords.imageX, coords.imageY);
                
                if (hoverIndex !== censorState.hoverBoxIndex) {
                    censorState.hoverBoxIndex = hoverIndex;
                    redrawCurrentTab();
                }
                
                // 커서 업데이트
                if (handleResult.handle) {
                    const cursors = {
                        'n': 'ns-resize', 's': 'ns-resize',
                        'e': 'ew-resize', 'w': 'ew-resize',
                        'nw': 'nwse-resize', 'se': 'nwse-resize',
                        'ne': 'nesw-resize', 'sw': 'nesw-resize',
                        'rotate': 'grab'
                    };
                    censorOverlayCanvas.style.cursor = cursors[handleResult.handle];
                } else if (hoverIndex >= 0) {
                    censorOverlayCanvas.style.cursor = censorState.currentTool === 'select' ? 'move' : 'crosshair';
                } else {
                    censorOverlayCanvas.style.cursor = censorState.currentTool === 'add' ? 'crosshair' : 'default';
                }
            }
            
            // 드래그 중
            if (censorState.isDragging && censorState.selectedBoxIndex >= 0) {
                const dx = coords.imageX - censorState.dragStartX;
                const dy = coords.imageY - censorState.dragStartY;
                const orig = censorState.dragBoxOriginal;
                censorState.editBoxes[censorState.selectedBoxIndex].box = [
                    orig[0] + dx, orig[1] + dy,
                    orig[2] + dx, orig[3] + dy
                ];
                redrawCurrentTab();
            }
            
            // 리사이즈 중 (회전 고려, Ctrl: 중심 기준 확장)
            if (censorState.isResizing && censorState.selectedBoxIndex >= 0 && censorState.resizeAnchor) {
                const det = censorState.editBoxes[censorState.selectedBoxIndex];
                const rotation = det.rotation || 0;
                const anchor = censorState.resizeAnchor;
                const handle = censorState.resizeHandle;
                const orig = censorState.dragBoxOriginal;
                const isCtrl = e.ctrlKey;
                
                // 마우스 월드 좌표
                const mwx = coords.imageX;
                const mwy = coords.imageY;
                
                let x1, y1, x2, y2;
                const cos = Math.cos(-rotation);
                const sin = Math.sin(-rotation);
                
                if (isCtrl) {
                    // Ctrl 누름: 중심 기준 대칭 확장
                    const [ox1, oy1, ox2, oy2] = orig;
                    const ocx = (ox1 + ox2) / 2;
                    const ocy = (oy1 + oy2) / 2;
                    
                    // 원래 중심의 월드 좌표 계산
                    const cosR = Math.cos(rotation);
                    const sinR = Math.sin(rotation);
                    
                    // 마우스를 원래 중심 기준으로 역회전 → 로컬 좌표
                    const mox = mwx - ocx;
                    const moy = mwy - ocy;
                    const mlx = ocx + mox * cos - moy * sin;
                    const mly = ocy + mox * sin + moy * cos;
                    
                    if (handle === 'nw' || handle === 'ne' || handle === 'sw' || handle === 'se') {
                        // 코너: 중심에서 마우스까지의 거리를 양쪽으로
                        const dx = Math.abs(mlx - ocx);
                        const dy = Math.abs(mly - ocy);
                        x1 = ocx - dx;
                        y1 = ocy - dy;
                        x2 = ocx + dx;
                        y2 = ocy + dy;
                    } else {
                        // 엣지: 해당 축만 대칭 확장
                        x1 = ox1; y1 = oy1; x2 = ox2; y2 = oy2;
                        if (handle === 'n' || handle === 's') {
                            const dy = Math.abs(mly - ocy);
                            y1 = ocy - dy;
                            y2 = ocy + dy;
                        } else {
                            const dx = Math.abs(mlx - ocx);
                            x1 = ocx - dx;
                            x2 = ocx + dx;
                        }
                    }
                } else if (handle === 'nw' || handle === 'ne' || handle === 'sw' || handle === 'se') {
                    // 코너 핸들: 앵커 월드 좌표 고정, 새 중심 기준 역회전
                    const wcx = (anchor.worldX + mwx) / 2;
                    const wcy = (anchor.worldY + mwy) / 2;
                    
                    const aox = anchor.worldX - wcx;
                    const aoy = anchor.worldY - wcy;
                    const alx = wcx + aox * cos - aoy * sin;
                    const aly = wcy + aox * sin + aoy * cos;
                    
                    const mox = mwx - wcx;
                    const moy = mwy - wcy;
                    const mlx = wcx + mox * cos - moy * sin;
                    const mly = wcy + mox * sin + moy * cos;
                    
                    x1 = Math.min(alx, mlx);
                    y1 = Math.min(aly, mly);
                    x2 = Math.max(alx, mlx);
                    y2 = Math.max(aly, mly);
                } else {
                    // 엣지 핸들: 마우스의 해당 축만 사용
                    const origWidth = orig[2] - orig[0];
                    const origHeight = orig[3] - orig[1];
                    
                    const dwx = mwx - anchor.worldX;
                    const dwy = mwy - anchor.worldY;
                    const dlx = dwx * cos - dwy * sin;
                    const dly = dwx * sin + dwy * cos;
                    
                    let effectiveDLX, effectiveDLY;
                    switch (handle) {
                        case 'n': effectiveDLX = origWidth; effectiveDLY = dly; break;
                        case 's': effectiveDLX = -origWidth; effectiveDLY = dly; break;
                        case 'w': effectiveDLX = dlx; effectiveDLY = origHeight; break;
                        case 'e': effectiveDLX = dlx; effectiveDLY = -origHeight; break;
                    }
                    
                    const cosR = Math.cos(rotation);
                    const sinR = Math.sin(rotation);
                    const effectiveDWX = effectiveDLX * cosR - effectiveDLY * sinR;
                    const effectiveDWY = effectiveDLX * sinR + effectiveDLY * cosR;
                    
                    const emwx = anchor.worldX + effectiveDWX;
                    const emwy = anchor.worldY + effectiveDWY;
                    
                    const wcx = (anchor.worldX + emwx) / 2;
                    const wcy = (anchor.worldY + emwy) / 2;
                    
                    const aox = anchor.worldX - wcx;
                    const aoy = anchor.worldY - wcy;
                    const alx = wcx + aox * cos - aoy * sin;
                    const aly = wcy + aox * sin + aoy * cos;
                    
                    const emox = emwx - wcx;
                    const emoy = emwy - wcy;
                    const emlx = wcx + emox * cos - emoy * sin;
                    const emly = wcy + emox * sin + emoy * cos;
                    
                    x1 = Math.min(alx, emlx);
                    y1 = Math.min(aly, emly);
                    x2 = Math.max(alx, emlx);
                    y2 = Math.max(aly, emly);
                }
                
                censorState.editBoxes[censorState.selectedBoxIndex].box = [x1, y1, x2, y2];
                redrawCurrentTab();
            }
            
            // 회전 중
            if (censorState.isRotating && censorState.selectedBoxIndex >= 0 && censorState.rotateCenter) {
                const cx = censorState.rotateCenter.x;
                const cy = censorState.rotateCenter.y;
                const angle = Math.atan2(coords.imageY - cy, coords.imageX - cx) + Math.PI / 2;
                censorState.editBoxes[censorState.selectedBoxIndex].rotation = angle;
                redrawCurrentTab();
            }
            
            // 새 박스 그리는 중
            if (censorState.isDrawing && censorState.newBoxStart) {
                drawEditBoxes();
                // 임시 박스 그리기
                const scale = censorState.displayScale || 1;
                const sx = censorState.newBoxStart.x * scale;
                const sy = censorState.newBoxStart.y * scale;
                const sw = (coords.imageX - censorState.newBoxStart.x) * scale;
                const sh = (coords.imageY - censorState.newBoxStart.y) * scale;
                
                censorOverlayCtx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                censorOverlayCtx.lineWidth = 2;
                censorOverlayCtx.setLineDash([5, 5]);
                censorOverlayCtx.strokeRect(sx, sy, sw, sh);
                censorOverlayCtx.setLineDash([]);
            }
        }
        
        // 마우스 업
        function handleCensorMouseUp(e) {
            // 새 박스 완성
            if (censorState.isDrawing && censorState.newBoxStart) {
                const coords = canvasToImageCoords(e);
                const x1 = Math.min(censorState.newBoxStart.x, coords.imageX);
                const y1 = Math.min(censorState.newBoxStart.y, coords.imageY);
                const x2 = Math.max(censorState.newBoxStart.x, coords.imageX);
                const y2 = Math.max(censorState.newBoxStart.y, coords.imageY);
                
                // 최소 크기 체크 (10x10 픽셀)
                if (x2 - x1 > 10 && y2 - y1 > 10) {
                    const method = document.getElementById(getCurrentMethodSelector())?.value || 'black';
                    censorState.editBoxes.push({
                        box: [x1, y1, x2, y2],
                        label: 'manual',
                        method: method
                    });
                    censorState.selectedBoxIndex = censorState.editBoxes.length - 1;
                    // 검열후 탭에서 새 박스 추가 시 dirty 표시
                    if (censorState.currentTab === 'after') {
                        markAfterEditDirty();
                    }
                }
                redrawCurrentTab();
            }
            
            // 드래그/리사이즈/회전 완료 시 결과 저장
            if (censorState.isDragging || censorState.isResizing || censorState.isRotating) {
                if (censorState.currentTab === 'processing') {
                    if (censorState.currentImage && censorState.processingResults[censorState.currentImage.path]) {
                        // 저장 전 검증
                        const validBoxes = censorState.editBoxes.filter(b => {
                            if (!b.box || !Array.isArray(b.box) || b.box.length !== 4) {
                                console.error('Invalid box detected during save:', b);
                                return false;
                            }
                            return true;
                        });
                        censorState.processingResults[censorState.currentImage.path].editBoxes = validBoxes.map(b => ({
                            ...b,
                            box: [b.box[0], b.box[1], b.box[2], b.box[3]]  // 명시적 4개 값 복사
                        }));
                    }
                } else if (censorState.currentTab === 'after') {
                    // 검열후 탭에서 편집 시 dirty 표시
                    markAfterEditDirty();
                }
            }
            
            // 상태 초기화
            censorState.isDragging = false;
            censorState.isResizing = false;
            censorState.isRotating = false;
            censorState.isDrawing = false;
            censorState.newBoxStart = null;
            censorState.resizeHandle = null;
            censorState.rotateCenter = null;
            censorState.resizeAnchor = null;
        }
        
        // 편집 박스 그리기 (선택 상태, 핸들 포함)
        function drawEditBoxes() {
            if (!censorOverlayCtx) return;

            const scale = censorState.displayScale || 1;
            const offsetY = censorState.overlayOffsetY || 0;  // 상단 여백 오프셋
            censorOverlayCtx.clearRect(0, 0, censorOverlayCanvas.width, censorOverlayCanvas.height);

            // 검열전 탭: detections 사용 (스캔 결과 표시용)
            // 검열중/검열후 탭: editBoxes 사용 (편집 가능)
            const boxes = censorState.currentTab === 'before'
                ? censorState.detections
                : censorState.editBoxes;
            
            boxes.forEach((det, index) => {
                const [x1, y1, x2, y2] = det.box;
                const sx1 = x1 * scale;
                const sy1 = y1 * scale + offsetY;  // 오프셋 적용
                const sw = (x2 - x1) * scale;
                const sh = (y2 - y1) * scale;
                
                const isSelected = index === censorState.selectedBoxIndex;
                
                // threshold 통과 여부 확인 (passes_threshold 필드 또는 현재 설정과 비교)
                let passesThreshold = det.passes_threshold;
                if (passesThreshold === undefined && det.confidence !== undefined && det.label) {
                    // 현재 설정된 threshold와 비교
                    const requiredConf = censorState.labelConf[det.label] || 0.3;
                    passesThreshold = det.confidence >= requiredConf;
                }
                if (passesThreshold === undefined) passesThreshold = true;  // 기본값
                
                // 색상 결정: 선택 = 청록, threshold 통과 = 빨강, 미통과 = 회색
                let strokeColor, fillColor;
                if (isSelected) {
                    strokeColor = 'rgba(0, 200, 255, 1)';
                    fillColor = 'rgba(0, 200, 255, 0.9)';
                } else if (passesThreshold) {
                    strokeColor = 'rgba(255, 0, 0, 0.8)';
                    fillColor = 'rgba(255, 0, 0, 0.8)';
                } else {
                    strokeColor = 'rgba(128, 128, 128, 0.4)';
                    fillColor = 'rgba(128, 128, 128, 0.5)';
                }
                
                // 박스 그리기
                censorOverlayCtx.strokeStyle = strokeColor;
                censorOverlayCtx.lineWidth = isSelected ? 3 : 2;
                censorOverlayCtx.setLineDash(isSelected ? [] : (passesThreshold ? [5, 5] : [3, 6]));
                censorOverlayCtx.strokeRect(sx1, sy1, sw, sh);
                
                // 라벨 표시
                censorOverlayCtx.setLineDash([]);
                censorOverlayCtx.fillStyle = fillColor;
                const label = det.label + (det.confidence ? ` ${(det.confidence * 100).toFixed(0)}%` : '');
                const textW = censorOverlayCtx.measureText(label).width + 8;
                censorOverlayCtx.fillRect(sx1, sy1 - 18, textW, 18);
                censorOverlayCtx.fillStyle = passesThreshold ? 'white' : 'rgba(255, 255, 255, 0.7)';
                censorOverlayCtx.font = '12px sans-serif';
                censorOverlayCtx.fillText(label, sx1 + 4, sy1 - 5);
                
                // 선택된 박스 또는 호버된 박스면 리사이즈/회전 핸들 그리기
                if (isSelected || index === censorState.hoverBoxIndex) {
                    const handleSize = 8;
                    const handleColor = isSelected ? 'rgba(0, 200, 255, 1)' : 'rgba(255, 200, 0, 0.8)';
                    censorOverlayCtx.fillStyle = handleColor;
                    // 4개 모서리
                    censorOverlayCtx.fillRect(sx1 - handleSize/2, sy1 - handleSize/2, handleSize, handleSize);
                    censorOverlayCtx.fillRect(sx1 + sw - handleSize/2, sy1 - handleSize/2, handleSize, handleSize);
                    censorOverlayCtx.fillRect(sx1 - handleSize/2, sy1 + sh - handleSize/2, handleSize, handleSize);
                    censorOverlayCtx.fillRect(sx1 + sw - handleSize/2, sy1 + sh - handleSize/2, handleSize, handleSize);
                    
                    // 회전 핸들도 그리기 (선택 또는 호버 시 모두)
                    const cx = sx1 + sw / 2;
                    const rotateHandleY = sy1 - 25;
                    // 회전 핸들 연결선
                    censorOverlayCtx.strokeStyle = handleColor;
                    censorOverlayCtx.lineWidth = 1;
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.moveTo(cx, sy1);
                    censorOverlayCtx.lineTo(cx, rotateHandleY);
                    censorOverlayCtx.stroke();
                    // 회전 핸들 (원형)
                    censorOverlayCtx.fillStyle = handleColor;
                    censorOverlayCtx.beginPath();
                    censorOverlayCtx.arc(cx, rotateHandleY, 6, 0, Math.PI * 2);
                    censorOverlayCtx.fill();
                }
            });
        }
        
    </script>
</body>
</html>
